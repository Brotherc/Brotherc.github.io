(window.webpackJsonp=window.webpackJsonp||[]).push([[17],{2364:function(t,s,a){"use strict";a.r(s);var r=a(2),e=Object(r.a)({},(function(){var t=this,s=t._self._c;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h2",{attrs:{id:"介绍-一"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#介绍-一"}},[t._v("#")]),t._v(" 介绍(一)")]),t._v(" "),s("h3",{attrs:{id:"锁的基本概念"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#锁的基本概念"}},[t._v("#")]),t._v(" 锁的基本概念")]),t._v(" "),s("h4",{attrs:{id:"超卖案例"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#超卖案例"}},[t._v("#")]),t._v(" 超卖案例")]),t._v(" "),s("p",[s("img",{attrs:{src:a(599),alt:""}}),t._v(" "),s("img",{attrs:{src:a(600),alt:""}}),t._v(" "),s("img",{attrs:{src:a(601),alt:""}}),t._v(" "),s("img",{attrs:{src:a(602),alt:""}})]),t._v(" "),s("h4",{attrs:{id:"超卖的根源"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#超卖的根源"}},[t._v("#")]),t._v(" 超卖的根源")]),t._v(" "),s("p",[s("img",{attrs:{src:a(603),alt:""}})]),t._v(" "),s("h4",{attrs:{id:"线程安全"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#线程安全"}},[t._v("#")]),t._v(" 线程安全")]),t._v(" "),s("p",[s("img",{attrs:{src:a(604),alt:""}})]),t._v(" "),s("h4",{attrs:{id:"同步"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#同步"}},[t._v("#")]),t._v(" 同步")]),t._v(" "),s("p",[s("img",{attrs:{src:a(605),alt:""}}),t._v(" "),s("img",{attrs:{src:a(606),alt:""}})]),t._v(" "),s("h4",{attrs:{id:"锁的性能优化"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#锁的性能优化"}},[t._v("#")]),t._v(" 锁的性能优化")]),t._v(" "),s("ul",[s("li",[t._v("缩短锁持有的时间")]),t._v(" "),s("li",[t._v("减小锁的粒度")]),t._v(" "),s("li",[t._v("锁分离\n"),s("img",{attrs:{src:a(607),alt:""}}),t._v(" "),s("img",{attrs:{src:a(608),alt:""}}),t._v(" "),s("img",{attrs:{src:a(609),alt:""}})])]),t._v(" "),s("h4",{attrs:{id:"锁种类"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#锁种类"}},[t._v("#")]),t._v(" 锁种类")]),t._v(" "),s("ul",[s("li",[t._v("公平锁，synchronized、ReentrantLock")]),t._v(" "),s("li",[t._v("非公平锁，ReentrantLock、CAS")]),t._v(" "),s("li",[t._v("独享锁，synchronized、ReentrantLock")]),t._v(" "),s("li",[t._v("共享锁，Semaphore")])]),t._v(" "),s("h3",{attrs:{id:"分布式锁"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#分布式锁"}},[t._v("#")]),t._v(" 分布式锁")]),t._v(" "),s("h4",{attrs:{id:"分布式环境"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#分布式环境"}},[t._v("#")]),t._v(" 分布式环境")]),t._v(" "),s("p",[s("img",{attrs:{src:a(610),alt:""}})]),t._v(" "),s("h4",{attrs:{id:"分布式锁的注意事项"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#分布式锁的注意事项"}},[t._v("#")]),t._v(" 分布式锁的注意事项")]),t._v(" "),s("ul",[s("li",[s("p",[t._v("互斥锁(独享锁)\n在任意时刻只有一个客户端可以获取锁")])]),t._v(" "),s("li",[s("p",[t._v("防死锁\n即使有一个客户端在持有锁的期间奔溃而没有主动解锁，也能保证后续其他客户端能加锁")])]),t._v(" "),s("li",[s("p",[t._v("持锁人解锁\n加锁和解锁必须是同一个客户端，客户端自己不能把别人加的锁给解了")])]),t._v(" "),s("li",[s("p",[t._v("可重入\n当一个客户端获取对象锁之后，这个客户端可以再次获取本对象上的锁")])])]),t._v(" "),s("h4",{attrs:{id:"redis分布式锁流程图"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#redis分布式锁流程图"}},[t._v("#")]),t._v(" Redis分布式锁流程图")]),t._v(" "),s("p",[s("img",{attrs:{src:a(611),alt:""}})]),t._v(" "),s("h4",{attrs:{id:"redis分布式锁算法"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#redis分布式锁算法"}},[t._v("#")]),t._v(" Redis分布式锁算法")]),t._v(" "),s("p",[t._v("redis.script：")]),t._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v('if redis.call("get", KEYS[1]) == ARGV[1] then\n    return redis.call("del", KEYS[1])\nelse\n    return 0\nend\n')])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br"),s("span",{staticClass:"line-number"},[t._v("4")]),s("br"),s("span",{staticClass:"line-number"},[t._v("5")]),s("br")])]),s("p",[s("img",{attrs:{src:a(612),alt:""}}),t._v(" "),s("img",{attrs:{src:a(613),alt:""}}),t._v(" "),s("img",{attrs:{src:a(614),alt:""}}),t._v(" "),s("img",{attrs:{src:a(615),alt:""}}),t._v(" "),s("img",{attrs:{src:a(616),alt:""}}),t._v(" "),s("img",{attrs:{src:a(617),alt:""}})]),t._v(" "),s("h4",{attrs:{id:"readlock算法"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#readlock算法"}},[t._v("#")]),t._v(" Readlock算法")]),t._v(" "),s("p",[s("img",{attrs:{src:a(618),alt:""}}),t._v(" "),s("img",{attrs:{src:a(619),alt:""}}),t._v(" "),s("img",{attrs:{src:a(620),alt:""}})]),t._v(" "),s("h4",{attrs:{id:"基于数据库的分布式锁"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#基于数据库的分布式锁"}},[t._v("#")]),t._v(" 基于数据库的分布式锁")]),t._v(" "),s("p",[t._v("实现方式：")]),t._v(" "),s("ul",[s("li",[t._v("新建一张锁表")]),t._v(" "),s("li",[t._v("获取锁时插入一条数据")]),t._v(" "),s("li",[t._v("解锁时删除数据")])]),t._v(" "),s("p",[t._v("主要问题:")]),t._v(" "),s("ul",[s("li",[t._v("可用性差，数据库挂掉会导致业务系统不可用，连接数量有限")]),t._v(" "),s("li",[t._v("锁的失效时间难以控制，容易造成死锁")])]),t._v(" "),s("h4",{attrs:{id:"基于zk的分布式锁"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#基于zk的分布式锁"}},[t._v("#")]),t._v(" 基于zk的分布式锁")]),t._v(" "),s("p",[t._v("实现方式:\n每个客户端对某个方法加锁时，在zookeeper上的与该方法对应的指定节点的目录下，生成一个唯一的临时有序节点。判断是否获取锁的方式很简单，只需要判断有序节点中序号最小的一个。\n当释放锁的时候，只需将这个临时节点删除即可。同时，其可以避免服务宕机导致的锁无法释放，而产生的死锁问题。")]),t._v(" "),s("p",[t._v("主要问题:")]),t._v(" "),s("ul",[s("li",[t._v("性能一般，加减锁时需要通过Leader创建或删除临时节点")])]),t._v(" "),s("h4",{attrs:{id:"各种分布式锁比较"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#各种分布式锁比较"}},[t._v("#")]),t._v(" 各种分布式锁比较")]),t._v(" "),s("p",[t._v("哪种方式都无法做到完美。就像CAP一样，在复杂性、可靠性、性能等方面无法同时满足，所以根据不同的应用场景选择最合适自己的方案。")]),t._v(" "),s("ul",[s("li",[s("p",[t._v("从理解的难易程度角度\n数据库 > 缓存 > Zookeeper")])]),t._v(" "),s("li",[s("p",[t._v("从实现的复杂性角度\nZookeeper > 缓存 > 数据库")])]),t._v(" "),s("li",[s("p",[t._v("从性能角度\n缓存 > Zookeeper > 数据库")])]),t._v(" "),s("li",[s("p",[t._v("从可靠性角度\nZookeeper > 缓存 > 数据库")])])])])}),[],!1,null,null,null);s.default=e.exports},599:function(t,s,a){t.exports=a.p+"assets/img/1.6c6b7398.jpg"},600:function(t,s,a){t.exports=a.p+"assets/img/2.b47ac27e.jpg"},601:function(t,s,a){t.exports=a.p+"assets/img/3.bea5fd0b.jpg"},602:function(t,s,a){t.exports=a.p+"assets/img/4.bdabeec1.jpg"},603:function(t,s,a){t.exports=a.p+"assets/img/5.2a199960.jpg"},604:function(t,s,a){t.exports=a.p+"assets/img/6.14068c84.jpg"},605:function(t,s,a){t.exports=a.p+"assets/img/7.5dec697d.jpg"},606:function(t,s,a){t.exports=a.p+"assets/img/8.0274816a.jpg"},607:function(t,s,a){t.exports=a.p+"assets/img/9.43b4e37c.jpg"},608:function(t,s,a){t.exports=a.p+"assets/img/10.59d75e53.jpg"},609:function(t,s,a){t.exports=a.p+"assets/img/11.d2fa3930.jpg"},610:function(t,s,a){t.exports=a.p+"assets/img/13.e597affa.jpg"},611:function(t,s,a){t.exports=a.p+"assets/img/14.e7f0f76c.jpg"},612:function(t,s,a){t.exports=a.p+"assets/img/15.6d115325.jpg"},613:function(t,s,a){t.exports=a.p+"assets/img/16.1c34f0d0.jpg"},614:function(t,s,a){t.exports=a.p+"assets/img/17.85e0dbc0.jpg"},615:function(t,s,a){t.exports=a.p+"assets/img/18.20ed59ee.jpg"},616:function(t,s,a){t.exports=a.p+"assets/img/19.703f5d25.jpg"},617:function(t,s,a){t.exports=a.p+"assets/img/20.ac61effc.jpg"},618:function(t,s,a){t.exports=a.p+"assets/img/21.f6e49bff.jpg"},619:function(t,s,a){t.exports=a.p+"assets/img/22.79d6c803.jpg"},620:function(t,s,a){t.exports=a.p+"assets/img/23.6adb29c9.jpg"}}]);