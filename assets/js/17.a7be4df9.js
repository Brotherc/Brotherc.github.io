(window.webpackJsonp=window.webpackJsonp||[]).push([[17],{2390:function(t,s,a){"use strict";a.r(s);var r=a(43),e=Object(r.a)({},(function(){var t=this,s=t.$createElement,r=t._self._c||s;return r("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[r("h2",{attrs:{id:"锁的基本概念"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#锁的基本概念"}},[t._v("#")]),t._v(" 锁的基本概念")]),t._v(" "),r("h3",{attrs:{id:"超卖案例"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#超卖案例"}},[t._v("#")]),t._v(" 超卖案例")]),t._v(" "),r("p",[r("img",{attrs:{src:a(390),alt:""}}),t._v(" "),r("img",{attrs:{src:a(391),alt:""}}),t._v(" "),r("img",{attrs:{src:a(392),alt:""}}),t._v(" "),r("img",{attrs:{src:a(393),alt:""}})]),t._v(" "),r("h3",{attrs:{id:"超卖的根源"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#超卖的根源"}},[t._v("#")]),t._v(" 超卖的根源")]),t._v(" "),r("p",[r("img",{attrs:{src:a(394),alt:""}})]),t._v(" "),r("h3",{attrs:{id:"线程安全"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#线程安全"}},[t._v("#")]),t._v(" 线程安全")]),t._v(" "),r("p",[r("img",{attrs:{src:a(395),alt:""}})]),t._v(" "),r("h3",{attrs:{id:"同步"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#同步"}},[t._v("#")]),t._v(" 同步")]),t._v(" "),r("p",[r("img",{attrs:{src:a(396),alt:""}}),t._v(" "),r("img",{attrs:{src:a(397),alt:""}})]),t._v(" "),r("h3",{attrs:{id:"锁的性能优化"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#锁的性能优化"}},[t._v("#")]),t._v(" 锁的性能优化")]),t._v(" "),r("ul",[r("li",[t._v("缩短锁持有的时间")]),t._v(" "),r("li",[t._v("减小锁的粒度")]),t._v(" "),r("li",[t._v("锁分离\n"),r("img",{attrs:{src:a(398),alt:""}}),t._v(" "),r("img",{attrs:{src:a(399),alt:""}}),t._v(" "),r("img",{attrs:{src:a(400),alt:""}})])]),t._v(" "),r("h3",{attrs:{id:"锁种类"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#锁种类"}},[t._v("#")]),t._v(" 锁种类")]),t._v(" "),r("ul",[r("li",[t._v("公平锁，synchronized、ReentrantLock")]),t._v(" "),r("li",[t._v("非公平锁，ReentrantLock、CAS")]),t._v(" "),r("li",[t._v("独享锁，synchronized、ReentrantLock")]),t._v(" "),r("li",[t._v("共享锁，Semaphore")])]),t._v(" "),r("h2",{attrs:{id:"分布式锁"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#分布式锁"}},[t._v("#")]),t._v(" 分布式锁")]),t._v(" "),r("h3",{attrs:{id:"分布式环境"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#分布式环境"}},[t._v("#")]),t._v(" 分布式环境")]),t._v(" "),r("p",[r("img",{attrs:{src:a(401),alt:""}})]),t._v(" "),r("h3",{attrs:{id:"分布式锁的注意事项"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#分布式锁的注意事项"}},[t._v("#")]),t._v(" 分布式锁的注意事项")]),t._v(" "),r("ul",[r("li",[r("p",[t._v("互斥锁(独享锁)\n在任意时刻只有一个客户端可以获取锁")])]),t._v(" "),r("li",[r("p",[t._v("防死锁\n即使有一个客户端在持有锁的期间奔溃而没有主动解锁，也能保证后续其他客户端能加锁")])]),t._v(" "),r("li",[r("p",[t._v("持锁人解锁\n加锁和解锁必须是同一个客户端，客户端自己不能把别人加的锁给解了")])]),t._v(" "),r("li",[r("p",[t._v("可重入\n当一个客户端获取对象锁之后，这个客户端可以再次获取本对象上的锁")])])]),t._v(" "),r("h3",{attrs:{id:"redis分布式锁流程图"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#redis分布式锁流程图"}},[t._v("#")]),t._v(" Redis分布式锁流程图")]),t._v(" "),r("p",[r("img",{attrs:{src:a(402),alt:""}})]),t._v(" "),r("h3",{attrs:{id:"redis分布式锁算法"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#redis分布式锁算法"}},[t._v("#")]),t._v(" Redis分布式锁算法")]),t._v(" "),r("p",[t._v("redis.script：")]),t._v(" "),r("div",{staticClass:"language- line-numbers-mode"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[t._v('if redis.call("get", KEYS[1]) == ARGV[1] then\n    return redis.call("del", KEYS[1])\nelse\n    return 0\nend\n')])]),t._v(" "),r("div",{staticClass:"line-numbers-wrapper"},[r("span",{staticClass:"line-number"},[t._v("1")]),r("br"),r("span",{staticClass:"line-number"},[t._v("2")]),r("br"),r("span",{staticClass:"line-number"},[t._v("3")]),r("br"),r("span",{staticClass:"line-number"},[t._v("4")]),r("br"),r("span",{staticClass:"line-number"},[t._v("5")]),r("br")])]),r("p",[r("img",{attrs:{src:a(403),alt:""}}),t._v(" "),r("img",{attrs:{src:a(404),alt:""}}),t._v(" "),r("img",{attrs:{src:a(405),alt:""}}),t._v(" "),r("img",{attrs:{src:a(406),alt:""}}),t._v(" "),r("img",{attrs:{src:a(407),alt:""}}),t._v(" "),r("img",{attrs:{src:a(408),alt:""}})]),t._v(" "),r("h3",{attrs:{id:"readlock算法"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#readlock算法"}},[t._v("#")]),t._v(" Readlock算法")]),t._v(" "),r("p",[r("img",{attrs:{src:a(409),alt:""}}),t._v(" "),r("img",{attrs:{src:a(410),alt:""}}),t._v(" "),r("img",{attrs:{src:a(411),alt:""}})]),t._v(" "),r("h3",{attrs:{id:"基于数据库的分布式锁"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#基于数据库的分布式锁"}},[t._v("#")]),t._v(" 基于数据库的分布式锁")]),t._v(" "),r("p",[t._v("实现方式：")]),t._v(" "),r("ul",[r("li",[t._v("新建一张锁表")]),t._v(" "),r("li",[t._v("获取锁时插入一条数据")]),t._v(" "),r("li",[t._v("解锁时删除数据")])]),t._v(" "),r("p",[t._v("主要问题:")]),t._v(" "),r("ul",[r("li",[t._v("可用性差，数据库挂掉会导致业务系统不可用，连接数量有限")]),t._v(" "),r("li",[t._v("锁的失效时间难以控制，容易造成死锁")])]),t._v(" "),r("h3",{attrs:{id:"基于zk的分布式锁"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#基于zk的分布式锁"}},[t._v("#")]),t._v(" 基于zk的分布式锁")]),t._v(" "),r("p",[t._v("实现方式:\n每个客户端对某个方法加锁时，在zookeeper上的与该方法对应的指定节点的目录下，生成一个唯一的临时有序节点。判断是否获取锁的方式很简单，只需要判断有序节点中序号最小的一个。\n当释放锁的时候，只需将这个临时节点删除即可。同时，其可以避免服务宕机导致的锁无法释放，而产生的死锁问题。")]),t._v(" "),r("p",[t._v("主要问题:")]),t._v(" "),r("ul",[r("li",[t._v("性能一般，加减锁时需要通过Leader创建或删除临时节点")])]),t._v(" "),r("h3",{attrs:{id:"各种分布式锁比较"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#各种分布式锁比较"}},[t._v("#")]),t._v(" 各种分布式锁比较")]),t._v(" "),r("p",[t._v("哪种方式都无法做到完美。就像CAP一样，在复杂性、可靠性、性能等方面无法同时满足，所以根据不同的应用场景选择最合适自己的方案。")]),t._v(" "),r("ul",[r("li",[r("p",[t._v("从理解的难易程度角度\n数据库 > 缓存 > Zookeeper")])]),t._v(" "),r("li",[r("p",[t._v("从实现的复杂性角度\nZookeeper > 缓存 > 数据库")])]),t._v(" "),r("li",[r("p",[t._v("从性能角度\n缓存 > Zookeeper > 数据库")])]),t._v(" "),r("li",[r("p",[t._v("从可靠性角度\nZookeeper > 缓存 > 数据库")])])])])}),[],!1,null,null,null);s.default=e.exports},390:function(t,s,a){t.exports=a.p+"assets/img/1.2b6e14ab.jpg"},391:function(t,s,a){t.exports=a.p+"assets/img/2.b47ac27e.jpg"},392:function(t,s,a){t.exports=a.p+"assets/img/3.bea5fd0b.jpg"},393:function(t,s,a){t.exports=a.p+"assets/img/4.bdabeec1.jpg"},394:function(t,s,a){t.exports=a.p+"assets/img/5.358fd029.jpg"},395:function(t,s,a){t.exports=a.p+"assets/img/6.df7dcbf5.jpg"},396:function(t,s,a){t.exports=a.p+"assets/img/7.0d9030dc.jpg"},397:function(t,s,a){t.exports=a.p+"assets/img/8.0274816a.jpg"},398:function(t,s,a){t.exports=a.p+"assets/img/9.43b4e37c.jpg"},399:function(t,s,a){t.exports=a.p+"assets/img/10.59d75e53.jpg"},400:function(t,s,a){t.exports=a.p+"assets/img/11.d2fa3930.jpg"},401:function(t,s,a){t.exports=a.p+"assets/img/13.3cd02def.jpg"},402:function(t,s,a){t.exports=a.p+"assets/img/14.6a30eded.jpg"},403:function(t,s,a){t.exports=a.p+"assets/img/15.30463574.jpg"},404:function(t,s,a){t.exports=a.p+"assets/img/16.1c34f0d0.jpg"},405:function(t,s,a){t.exports=a.p+"assets/img/17.85e0dbc0.jpg"},406:function(t,s,a){t.exports=a.p+"assets/img/18.20ed59ee.jpg"},407:function(t,s,a){t.exports=a.p+"assets/img/19.703f5d25.jpg"},408:function(t,s,a){t.exports=a.p+"assets/img/20.ac61effc.jpg"},409:function(t,s,a){t.exports=a.p+"assets/img/21.747f9617.jpg"},410:function(t,s,a){t.exports=a.p+"assets/img/22.79d6c803.jpg"},411:function(t,s,a){t.exports=a.p+"assets/img/23.6adb29c9.jpg"}}]);