(window.webpackJsonp=window.webpackJsonp||[]).push([[46],{1153:function(t,a,s){t.exports=s.p+"assets/img/3.e7c712db.jpg"},1154:function(t,a,s){t.exports=s.p+"assets/img/1.47ea1d7d.jpg"},1155:function(t,a,s){t.exports=s.p+"assets/img/2.83bc5db9.jpg"},2334:function(t,a,s){"use strict";s.r(a);var v=s(43),_=Object(v.a)({},(function(){var t=this,a=t.$createElement,v=t._self._c||a;return v("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[v("h2",{attrs:{id:"一、数据传输安全性"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#一、数据传输安全性"}},[t._v("#")]),t._v(" 一、数据传输安全性")]),t._v(" "),v("h5",{attrs:{id:"在tcp-ip层中不涉及安全"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#在tcp-ip层中不涉及安全"}},[t._v("#")]),t._v(" 在TCP/IP层中不涉及安全")]),t._v(" "),v("ul",[v("li",[t._v("机密性：明文传输（ftp,smtp,talnet）别人一拦截就能看到请求的内容。")]),t._v(" "),v("li",[t._v("完整性：10颗原子弹（被改成100）所以数据在互联网上传播的时候，不应该也不能够被其他人非法篡改掉。当收到的和发送的不一致时拒绝接受这就能保证数据的完整性。")]),t._v(" "),v("li",[t._v("身份验证：通过有效的手段保证所访问的对象就是我们所要的那个人。")])]),t._v(" "),v("h4",{attrs:{id:"保证数据的机密性"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#保证数据的机密性"}},[t._v("#")]),t._v(" 保证数据的机密性")]),t._v(" "),v("ul",[v("li",[t._v("plaintext(明文) --\x3e 加密（转换规则）--\x3e ciphertext（密文）")]),t._v(" "),v("li",[t._v("ciphertext --\x3e 转换规则 --\x3e plaintext")]),t._v(" "),v("li",[t._v("转换算法：依赖密钥（即使得到了转换规则也没用）")]),t._v(" "),v("li",[t._v("对称加密：加密和解密使用同一个密钥（有加密算法和解密算法，算法不同，但密钥相同）。\n好处是计算速度快，在一定程度上解决了机密性问题。坏处是不能解决密钥有效管理的问题。\n假如a跟b，c,d通信，如果密钥相同，则c只要用密钥就可以看到a发送给b的内容，显然密钥不能相同，\n那就得维护很多密钥。")])]),t._v(" "),v("h4",{attrs:{id:"保证数据的完整性"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#保证数据的完整性"}},[t._v("#")]),t._v(" 保证数据的完整性")]),t._v(" "),v("ul",[v("li",[t._v("A：plaintext:footprint --\x3e B\nB使用同样的加密算法去重复计算这个明文的特征码，并跟A所发过来的特征码进行比较，\n如果一样，则说明没被篡改。")]),t._v(" "),v("li",[t._v("单项加密算法：提取数据特征码，追加到数据后面。数据的输入一样：特征码必然相同。")]),t._v(" "),v("li",[t._v("特点：\n输入一样，输出必然相同\n雪崩效应（输入的微小改变，将其会引起结果的巨大改变）\n定长输出（无论原始数据是多长，结果大小都是相同的）\n不可逆（无法根据原始特征码还原原来的数据）")])]),t._v(" "),v("h4",{attrs:{id:"中间人攻击问题"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#中间人攻击问题"}},[t._v("#")]),t._v(" 中间人攻击问题")]),t._v(" "),v("ul",[v("li",[t._v("E(A)：plaintext2:footprint2 --\x3e B\nA生成一段数据，并对它计算特征码，E在中间经过的路由时拿到这个明文，并重新修改明文和再计算特征码发给B，还声称自己是A，B拿到数据之后就算使用了数据完整性的算法之后，计算特征码还是一模一样，还认为是A发过来的，所以需要借助额外的机制。")]),t._v(" "),v("li",[t._v("解决办法：A：plaintext:footprint(加密) --\x3e B B拿到特征码之后通过密钥进行解密，能解密\n说明数据没有被改过。如果E拿到plaintext并修改为plaintext2，并重新生成特征码，就没办法加密\n特征码或者加密后就不是A和B之间实现约定的密码。")])]),t._v(" "),v("h4",{attrs:{id:"a与b之间如何进行密码约定"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#a与b之间如何进行密码约定"}},[t._v("#")]),t._v(" A与B之间如何进行密码约定")]),t._v(" "),v("ul",[v("li",[t._v("假如A与B之间从未通信或从未见过面，如何进行密码约定呢？")]),t._v(" "),v("li",[t._v("协商生成密码：密码交换（Internet Key Exchange / IKE）,密码交换是不让第三方得到密钥，\n密码交换需要特殊的互联网协议支撑。比如：Dffie-Hellman协议。")]),t._v(" "),v("li",[t._v("A和B事先约定两个数p(大素数)，g(生成数)。A生成一个自己知道的x，B生成一个自己知道的y。\nA将 g^x % p 发送给B，B将g^y % p 发送给A。\nA拿到之后进行计算 （g^y % p）^x = g^xy % p，\nB拿到之后进行计算 （g^x % p）^y = g^xy % p。\n这个相同的结果就是密钥。\n在互联网上可以看到g、p、g^x % p、g^y % p，但看不到x、y。")]),t._v(" "),v("li",[t._v("A和B只需要选好几个数，让这些数的计算结果作为密钥来用，使得彼此不用计算密码，只要双方\n生成密钥的软件一样就可以随时生成密钥。")])]),t._v(" "),v("h4",{attrs:{id:"身份验证"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#身份验证"}},[t._v("#")]),t._v(" 身份验证")]),t._v(" "),v("ul",[v("li",[t._v("之前是A和B一起约定好的密码，所以身份验证没问题。但是密钥是交换生成的，事先之前谁也不知道。\nE跳出来，截取了数据并篡改，然后与B进行连接通信，还告诉它自己是A。")]),t._v(" "),v("li",[t._v("解决办法：公钥加密算法（非对称加密算法）")]),t._v(" "),v("li",[t._v("特点：拥有一对密钥对，分别是公钥（是从私钥中提取出来的）、私钥。用公钥加密的，只能用私钥\n解密，反之亦然。")])]),t._v(" "),v("h4",{attrs:{id:"结论"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#结论"}},[t._v("#")]),t._v(" 结论")]),t._v(" "),v("h2",{attrs:{id:"二、数据传输"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#二、数据传输"}},[t._v("#")]),t._v(" 二、数据传输")]),t._v(" "),v("p",[v("img",{attrs:{src:s(1153),alt:""}}),t._v("\nPKI:公钥基础设施(Public Key Infrastructure) 核心就是CA和彼此之间的信任关系\nCA:证书颁发机构(Certificate Authority)，CA中还维护了CRL\nCRL:证书撤销列表，CRL中保存了此前曾经发出去的证书，但仍未过期，只不过已经各种原因被撤销了")]),t._v(" "),v("h2",{attrs:{id:"三、tls-ssl"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#三、tls-ssl"}},[t._v("#")]),t._v(" 三、TLS/SSL")]),t._v(" "),v("p",[v("img",{attrs:{src:s(1154),alt:""}})]),t._v(" "),v("h3",{attrs:{id:"不同标准下的证书格式是不同的"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#不同标准下的证书格式是不同的"}},[t._v("#")]),t._v(" 不同标准下的证书格式是不同的")]),t._v(" "),v("p",[t._v("比如x509, pkcs12\nx509: 公钥及其有效期限，证书的合法拥有者，证书该如何被使用，CA的信息，CA签名的校验码\nTLS/SSL所使用的正是x509的证书，TLS/SSL其实就是一种PKI，PKI的第二种实现OpenGPG")]),t._v(" "),v("h3",{attrs:{id:"tls-ssl-如何实现握手认证、密钥交换"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#tls-ssl-如何实现握手认证、密钥交换"}},[t._v("#")]),t._v(" TLS/SSL 如何实现握手认证、密钥交换")]),t._v(" "),v("p",[v("img",{attrs:{src:s(1155),alt:""}})]),t._v(" "),v("h2",{attrs:{id:"四、加密"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#四、加密"}},[t._v("#")]),t._v(" 四、加密")]),t._v(" "),v("h3",{attrs:{id:"对称加密"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#对称加密"}},[t._v("#")]),t._v(" 对称加密")]),t._v(" "),v("p",[t._v("加密解密使用同一个密码")]),t._v(" "),v("ul",[v("li",[t._v("DES(Data Encrption Standard, 56bit)")]),t._v(" "),v("li",[t._v("3DES")]),t._v(" "),v("li",[t._v("AES(Advanced, AES192/AES256/AES512)")]),t._v(" "),v("li",[t._v("Blowfish")])]),t._v(" "),v("h3",{attrs:{id:"单向加密"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#单向加密"}},[t._v("#")]),t._v(" 单向加密")]),t._v(" "),v("ul",[v("li",[t._v("MD4")]),t._v(" "),v("li",[t._v("MD5")]),t._v(" "),v("li",[t._v("SHA1")]),t._v(" "),v("li",[t._v("SHA192、SHA256、SHA384")]),t._v(" "),v("li",[t._v("CRC-32")])]),t._v(" "),v("h3",{attrs:{id:"非对称加密-公钥加密"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#非对称加密-公钥加密"}},[t._v("#")]),t._v(" 非对称加密（公钥加密）")]),t._v(" "),v("p",[t._v("身份认证（数字签名）、数据加密、密钥交换")]),t._v(" "),v("ul",[v("li",[t._v("RSA(加密、签名)")]),t._v(" "),v("li",[t._v("DSA(签名)")]),t._v(" "),v("li",[t._v("ElGamal")])]),t._v(" "),v("h3",{attrs:{id:"加密实现"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#加密实现"}},[t._v("#")]),t._v(" 加密实现")]),t._v(" "),v("p",[t._v("OpenSSL: SSL的开源实现\nlibcryptc: 通用的加密库\nlibssl: TLS/SSL的实现\n基于会话的、实现了省份认证、数据机密性和会话完整性的TLS/SSL库\nopenssl: 多用途命令行工具\n实现私有证书颁发机构")])])}),[],!1,null,null,null);a.default=_.exports}}]);