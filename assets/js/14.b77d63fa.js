(window.webpackJsonp=window.webpackJsonp||[]).push([[14],{2417:function(t,s,a){"use strict";a.r(s);var r=a(2),e=Object(r.a)({},(function(){var t=this,s=t._self._c;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h2",{attrs:{id:"介绍-一"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#介绍-一"}},[t._v("#")]),t._v(" 介绍(一)")]),t._v(" "),s("h3",{attrs:{id:"锁的基本概念"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#锁的基本概念"}},[t._v("#")]),t._v(" 锁的基本概念")]),t._v(" "),s("h4",{attrs:{id:"超卖案例"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#超卖案例"}},[t._v("#")]),t._v(" 超卖案例")]),t._v(" "),s("p",[s("img",{attrs:{src:a(441),alt:""}}),t._v(" "),s("img",{attrs:{src:a(442),alt:""}}),t._v(" "),s("img",{attrs:{src:a(443),alt:""}}),t._v(" "),s("img",{attrs:{src:a(444),alt:""}})]),t._v(" "),s("h4",{attrs:{id:"超卖的根源"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#超卖的根源"}},[t._v("#")]),t._v(" 超卖的根源")]),t._v(" "),s("p",[s("img",{attrs:{src:a(445),alt:""}})]),t._v(" "),s("h4",{attrs:{id:"线程安全"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#线程安全"}},[t._v("#")]),t._v(" 线程安全")]),t._v(" "),s("p",[s("img",{attrs:{src:a(446),alt:""}})]),t._v(" "),s("h4",{attrs:{id:"同步"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#同步"}},[t._v("#")]),t._v(" 同步")]),t._v(" "),s("p",[s("img",{attrs:{src:a(447),alt:""}}),t._v(" "),s("img",{attrs:{src:a(448),alt:""}})]),t._v(" "),s("h4",{attrs:{id:"锁的性能优化"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#锁的性能优化"}},[t._v("#")]),t._v(" 锁的性能优化")]),t._v(" "),s("ul",[s("li",[t._v("缩短锁持有的时间")]),t._v(" "),s("li",[t._v("减小锁的粒度")]),t._v(" "),s("li",[t._v("锁分离\n"),s("img",{attrs:{src:a(449),alt:""}}),t._v(" "),s("img",{attrs:{src:a(450),alt:""}}),t._v(" "),s("img",{attrs:{src:a(451),alt:""}})])]),t._v(" "),s("h4",{attrs:{id:"锁种类"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#锁种类"}},[t._v("#")]),t._v(" 锁种类")]),t._v(" "),s("ul",[s("li",[t._v("公平锁，synchronized、ReentrantLock")]),t._v(" "),s("li",[t._v("非公平锁，ReentrantLock、CAS")]),t._v(" "),s("li",[t._v("独享锁，synchronized、ReentrantLock")]),t._v(" "),s("li",[t._v("共享锁，Semaphore")])]),t._v(" "),s("h3",{attrs:{id:"分布式锁"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#分布式锁"}},[t._v("#")]),t._v(" 分布式锁")]),t._v(" "),s("h4",{attrs:{id:"分布式环境"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#分布式环境"}},[t._v("#")]),t._v(" 分布式环境")]),t._v(" "),s("p",[s("img",{attrs:{src:a(452),alt:""}})]),t._v(" "),s("h4",{attrs:{id:"分布式锁的注意事项"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#分布式锁的注意事项"}},[t._v("#")]),t._v(" 分布式锁的注意事项")]),t._v(" "),s("ul",[s("li",[s("p",[t._v("互斥锁(独享锁)\n在任意时刻只有一个客户端可以获取锁")])]),t._v(" "),s("li",[s("p",[t._v("防死锁\n即使有一个客户端在持有锁的期间奔溃而没有主动解锁，也能保证后续其他客户端能加锁")])]),t._v(" "),s("li",[s("p",[t._v("持锁人解锁\n加锁和解锁必须是同一个客户端，客户端自己不能把别人加的锁给解了")])]),t._v(" "),s("li",[s("p",[t._v("可重入\n当一个客户端获取对象锁之后，这个客户端可以再次获取本对象上的锁")])])]),t._v(" "),s("h4",{attrs:{id:"redis分布式锁流程图"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#redis分布式锁流程图"}},[t._v("#")]),t._v(" Redis分布式锁流程图")]),t._v(" "),s("p",[s("img",{attrs:{src:a(453),alt:""}})]),t._v(" "),s("h4",{attrs:{id:"redis分布式锁算法"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#redis分布式锁算法"}},[t._v("#")]),t._v(" Redis分布式锁算法")]),t._v(" "),s("p",[t._v("redis.script：")]),t._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v('if redis.call("get", KEYS[1]) == ARGV[1] then\n    return redis.call("del", KEYS[1])\nelse\n    return 0\nend\n')])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br"),s("span",{staticClass:"line-number"},[t._v("4")]),s("br"),s("span",{staticClass:"line-number"},[t._v("5")]),s("br")])]),s("p",[s("img",{attrs:{src:a(454),alt:""}}),t._v(" "),s("img",{attrs:{src:a(455),alt:""}}),t._v(" "),s("img",{attrs:{src:a(456),alt:""}}),t._v(" "),s("img",{attrs:{src:a(457),alt:""}}),t._v(" "),s("img",{attrs:{src:a(458),alt:""}}),t._v(" "),s("img",{attrs:{src:a(459),alt:""}})]),t._v(" "),s("h4",{attrs:{id:"readlock算法"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#readlock算法"}},[t._v("#")]),t._v(" Readlock算法")]),t._v(" "),s("p",[s("img",{attrs:{src:a(460),alt:""}}),t._v(" "),s("img",{attrs:{src:a(461),alt:""}}),t._v(" "),s("img",{attrs:{src:a(462),alt:""}})]),t._v(" "),s("h4",{attrs:{id:"基于数据库的分布式锁"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#基于数据库的分布式锁"}},[t._v("#")]),t._v(" 基于数据库的分布式锁")]),t._v(" "),s("p",[t._v("实现方式：")]),t._v(" "),s("ul",[s("li",[t._v("新建一张锁表")]),t._v(" "),s("li",[t._v("获取锁时插入一条数据")]),t._v(" "),s("li",[t._v("解锁时删除数据")])]),t._v(" "),s("p",[t._v("主要问题:")]),t._v(" "),s("ul",[s("li",[t._v("可用性差，数据库挂掉会导致业务系统不可用，连接数量有限")]),t._v(" "),s("li",[t._v("锁的失效时间难以控制，容易造成死锁")])]),t._v(" "),s("h4",{attrs:{id:"基于zk的分布式锁"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#基于zk的分布式锁"}},[t._v("#")]),t._v(" 基于zk的分布式锁")]),t._v(" "),s("p",[t._v("实现方式:\n每个客户端对某个方法加锁时，在zookeeper上的与该方法对应的指定节点的目录下，生成一个唯一的临时有序节点。判断是否获取锁的方式很简单，只需要判断有序节点中序号最小的一个。\n当释放锁的时候，只需将这个临时节点删除即可。同时，其可以避免服务宕机导致的锁无法释放，而产生的死锁问题。")]),t._v(" "),s("p",[t._v("主要问题:")]),t._v(" "),s("ul",[s("li",[t._v("性能一般，加减锁时需要通过Leader创建或删除临时节点")])]),t._v(" "),s("h4",{attrs:{id:"各种分布式锁比较"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#各种分布式锁比较"}},[t._v("#")]),t._v(" 各种分布式锁比较")]),t._v(" "),s("p",[t._v("哪种方式都无法做到完美。就像CAP一样，在复杂性、可靠性、性能等方面无法同时满足，所以根据不同的应用场景选择最合适自己的方案。")]),t._v(" "),s("ul",[s("li",[s("p",[t._v("从理解的难易程度角度\n数据库 > 缓存 > Zookeeper")])]),t._v(" "),s("li",[s("p",[t._v("从实现的复杂性角度\nZookeeper > 缓存 > 数据库")])]),t._v(" "),s("li",[s("p",[t._v("从性能角度\n缓存 > Zookeeper > 数据库")])]),t._v(" "),s("li",[s("p",[t._v("从可靠性角度\nZookeeper > 缓存 > 数据库")])])]),t._v(" "),s("h2",{attrs:{id:"介绍-二"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#介绍-二"}},[t._v("#")]),t._v(" 介绍(二)")]),t._v(" "),s("p",[s("img",{attrs:{src:a(463),alt:""}}),t._v(" "),s("img",{attrs:{src:a(464),alt:""}}),t._v(" "),s("img",{attrs:{src:a(465),alt:""}}),t._v(" "),s("img",{attrs:{src:a(466),alt:""}}),t._v(" "),s("img",{attrs:{src:a(467),alt:""}}),t._v(" "),s("img",{attrs:{src:a(468),alt:""}}),t._v(" "),s("img",{attrs:{src:a(469),alt:""}})])])}),[],!1,null,null,null);s.default=e.exports},441:function(t,s,a){t.exports=a.p+"assets/img/1.2b6e14ab.jpg"},442:function(t,s,a){t.exports=a.p+"assets/img/2.b47ac27e.jpg"},443:function(t,s,a){t.exports=a.p+"assets/img/3.bea5fd0b.jpg"},444:function(t,s,a){t.exports=a.p+"assets/img/4.bdabeec1.jpg"},445:function(t,s,a){t.exports=a.p+"assets/img/5.358fd029.jpg"},446:function(t,s,a){t.exports=a.p+"assets/img/6.df7dcbf5.jpg"},447:function(t,s,a){t.exports=a.p+"assets/img/7.0d9030dc.jpg"},448:function(t,s,a){t.exports=a.p+"assets/img/8.0274816a.jpg"},449:function(t,s,a){t.exports=a.p+"assets/img/9.43b4e37c.jpg"},450:function(t,s,a){t.exports=a.p+"assets/img/10.59d75e53.jpg"},451:function(t,s,a){t.exports=a.p+"assets/img/11.d2fa3930.jpg"},452:function(t,s,a){t.exports=a.p+"assets/img/13.3cd02def.jpg"},453:function(t,s,a){t.exports=a.p+"assets/img/14.6a30eded.jpg"},454:function(t,s,a){t.exports=a.p+"assets/img/15.30463574.jpg"},455:function(t,s,a){t.exports=a.p+"assets/img/16.1c34f0d0.jpg"},456:function(t,s,a){t.exports=a.p+"assets/img/17.85e0dbc0.jpg"},457:function(t,s,a){t.exports=a.p+"assets/img/18.20ed59ee.jpg"},458:function(t,s,a){t.exports=a.p+"assets/img/19.703f5d25.jpg"},459:function(t,s,a){t.exports=a.p+"assets/img/20.ac61effc.jpg"},460:function(t,s,a){t.exports=a.p+"assets/img/21.747f9617.jpg"},461:function(t,s,a){t.exports=a.p+"assets/img/22.79d6c803.jpg"},462:function(t,s,a){t.exports=a.p+"assets/img/23.6adb29c9.jpg"},463:function(t,s,a){t.exports=a.p+"assets/img/1.57c93aec.jpg"},464:function(t,s,a){t.exports=a.p+"assets/img/2.3a2e90a6.jpg"},465:function(t,s,a){t.exports=a.p+"assets/img/3.97076ec1.jpg"},466:function(t,s,a){t.exports=a.p+"assets/img/4.b994a589.jpg"},467:function(t,s,a){t.exports=a.p+"assets/img/5.edf36114.jpg"},468:function(t,s,a){t.exports=a.p+"assets/img/6.afe9421f.jpg"},469:function(t,s,a){t.exports=a.p+"assets/img/7.15b271cf.jpg"}}]);