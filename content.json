{"meta":{"title":"Brotherc","subtitle":null,"description":null,"author":"Brotherc","url":"http://yoursite.com"},"pages":[{"title":"all-categories","date":"2019-01-19T03:33:53.552Z","updated":"2019-01-19T03:33:53.552Z","comments":false,"path":"all-categories/index.html","permalink":"http://yoursite.com/all-categories/index.html","excerpt":"","text":""},{"title":"all-archives","date":"2019-01-19T03:34:34.316Z","updated":"2019-01-19T03:34:34.316Z","comments":false,"path":"all-archives/index.html","permalink":"http://yoursite.com/all-archives/index.html","excerpt":"","text":""},{"title":"all-tags","date":"2019-01-19T03:34:15.573Z","updated":"2019-01-19T03:34:15.573Z","comments":false,"path":"all-tags/index.html","permalink":"http://yoursite.com/all-tags/index.html","excerpt":"","text":""}],"posts":[{"title":"位运算","slug":"位运算","date":"2019-09-03T10:35:53.851Z","updated":"2019-09-03T10:44:50.502Z","comments":true,"path":"2019/09/03/位运算/","link":"","permalink":"http://yoursite.com/2019/09/03/位运算/","excerpt":"","text":"Demo1:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859/* 位运算符： &amp;,|,^,~ &lt;&lt;,&gt;&gt;,&gt;&gt;&gt; 注意： 要做位运算，首先要把数据转换为二进制。*/class OperatorDemo &#123; public static void main(String[] args) &#123; //&amp;,|,^,~ int a = 3; int b = 4; System.out.println(3 &amp; 4); System.out.println(3 | 4); System.out.println(3 ^ 4); System.out.println(~3); &#125;&#125;/* 分析：因为是位运算，所以我们必须先把数据换算成二进制。 3的二进制：11 00000000 00000000 00000000 00000011 4的二进制：100 00000000 00000000 00000000 00000100 &amp;位与运算：有0则0。 00000000 00000000 00000000 00000011 &amp;00000000 00000000 00000000 00000100 ----------------------------------- 00000000 00000000 00000000 00000000 结果是：0 |位或运算：有1则1。 00000000 00000000 00000000 00000011 |00000000 00000000 00000000 00000100 ----------------------------------- 00000000 00000000 00000000 00000111 结果是：7 ^位异或运算：相同则0，不同则1。 00000000 00000000 00000000 00000011 &amp;00000000 00000000 00000000 00000100 ----------------------------------- 00000000 00000000 00000000 00000111 结果是：7 ~按位取反运算符：0变1，1变0 00000000 00000000 00000000 00000011 ~11111111 11111111 11111111 11111100 (补码) 补码：11111111 11111111 11111111 11111100 反码：11111111 11111111 11111111 11111011 原码：10000000 00000000 00000000 00000100 结果是：-4*/ Demo2:123456789101112/* ^的特点：一个数据对另一个数据位异或两次，该数本身不变。*/class OperatorDemo2 &#123; public static void main(String[] args) &#123; int a = 10; int b = 20; System.out.println(a ^ b ^ b); //10 System.out.println(a ^ b ^ a); //20 &#125;&#125; Demo3:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556/* &lt;&lt;:左移 左边最高位丢弃，右边补齐0 &gt;&gt;:右移 最高位是0，左边补齐0；最高为是1，左边补齐1 &gt;&gt;&gt;:无符号右移 无论最高位是0还是1，左边补齐0 面试题： 请用最有效率的方式写出计算2乘以8的结果? 2 * 8 2 &lt;&lt; 3*/class OperatorDemo3 &#123; public static void main(String[] args) &#123; //&lt;&lt; 把&lt;&lt;左边的数据乘以2的移动次幂 System.out.println(3 &lt;&lt; 2); //3*2^2 = 3*4 = 12; //&gt;&gt; 把&gt;&gt;左边的数据除以2的移动次幂 System.out.println(24 &gt;&gt; 2); //24 / 2^2 = 24 / 4 = 6 System.out.println(24 &gt;&gt;&gt; 2); System.out.println(-24 &gt;&gt; 2); System.out.println(-24 &gt;&gt;&gt; 2); &#125;&#125;/* 计算出3的二进制：11 00000000 00000000 00000000 00000011 (00)000000 00000000 00000000 0000001100 &gt;&gt;的移动： 计算出24的二进制：11000 原码：10000000 00000000 00000000 00011000 反码：11111111 11111111 11111111 11100111 补码：11111111 11111111 11111111 11101000 11111111 11111111 11111111 11101000 1111111111 11111111 11111111 111010(00) 补码 补码：1111111111 11111111 11111111 111010 反码：1111111111 11111111 11111111 111001 原码：1000000000 00000000 00000000 000110 结果：-6 &gt;&gt;&gt;的移动： 计算出24的二进制：11000 原码：10000000 00000000 00000000 00011000 反码：11111111 11111111 11111111 11100111 补码：11111111 11111111 11111111 11101000 11111111 11111111 11111111 11101000 0011111111 11111111 11111111 111010(00) 结果：*/ Demo4:123456789101112131415161718192021222324252627282930313233343536373839404142/* 实现两个整数变量的交换*/class OperatorTest &#123; public static void main(String[] args) &#123; int a = 10; int b = 20; System.out.println(&quot;a:&quot;+a+&quot;,b:&quot;+b); //方式1：使用第三方变量(开发中用的) /* int c = a; a = b; b = c; System.out.println(&quot;a:&quot;+a+&quot;,b:&quot;+b); System.out.println(&quot;------------&quot;); */ //方式2：用位异或实现 //左边：a,b,a //右边：a ^ b /* a = a ^ b; b = a ^ b; //a ^ b ^ b = a a = a ^ b; //a ^ b ^ a = b System.out.println(&quot;a:&quot;+a+&quot;,b:&quot;+b); */ //方式3：用变量相加的做法 /* a = a + b; //a=30 b = a - b; //b=10 a = a - b; //a=20 System.out.println(&quot;a:&quot;+a+&quot;,b:&quot;+b); */ //方式4：一句话搞定 b = (a+b) - (a=b); //b=30-20=10,a=20 System.out.println(&quot;a:&quot;+a+&quot;,b:&quot;+b); &#125;&#125;","categories":[],"tags":[{"name":"java基础","slug":"java基础","permalink":"http://yoursite.com/tags/java基础/"}],"keywords":[]},{"title":"高并发解决方案","slug":"高并发解决方案","date":"2019-08-25T10:31:43.530Z","updated":"2019-08-25T12:52:32.080Z","comments":true,"path":"2019/08/25/高并发解决方案/","link":"","permalink":"http://yoursite.com/2019/08/25/高并发解决方案/","excerpt":"","text":"高并发处理思路与手段扩容 123随着并发线程的增加，从几十到几百，几千，几万垂直扩展：可能就得考虑给系统增内存水平扩展：复杂一点可能要增服务器来分担压力 缓存特征、场景及组件介绍 123456789101112131415适合读多写少的场景，实时性越低越适合缓存在相同key和请求数的情况下，缓存的时间越长命中率越高。缓存的粒度越小，命中率越高。当缓存当个对象时，比如单个用户信息，只有当该对象对应的数据发生变化的时候我们才要更新缓存或者移除缓存。而当缓存一个集合时，例如我们要缓存所有用户数据，期中任何一个对象当中的数据发生变化时，我们都要更新或移除缓存。还有另一种情况，假设其他地方也要获取该对象对应的数据时，比如也要获取单个用户信息，如果缓存的是单个对象，那么就可以直接命中缓存，否则就无法直接命中。此外，缓存的更新过期策略也直接影响到缓存的命中率，当数据发生变化时，直接更新缓存的值会比移除缓存或让缓存过期的命中率更高，当然这个时候的系统复杂度也会变得更高。缓存的容量有限，就容易引起缓存失效和被淘汰，目前多数的缓存框架或中间件都采用LRU算法。同时缓存的技术选型也是至关重要的，比如采用应用内置的本地缓存，比较容易出现单机瓶颈，而采用分布式缓存则容易拓展，所以需要做好系统容量规划，并考虑是否可拓展。此外，不同的缓存框架和中间件的效率和稳定性也是存在一定的差异，还有一些会影响到缓存命中率的因素，比如当缓存节点发生故障时，需要避免缓存失效并最大化程度降低影响，业内比较典型的做法就是通过一致性哈希算法或者节点冗余的方式来避免这个问题，并发越高，缓存的收益越高，即使缓存的时间很短。需要应用尽可能的通过缓存来直接获取数据并避免缓存失效，尽可能的聚集在高频访问且时效性不高的热点业务上，通过缓存预加载，增加存储容量，调整缓存粒度，更新缓存等手段来提高命中率。对于时效性很高或缓存空间有限的情况下内容跨度越大或者访问很随机并且访问量不高的业务来说，缓存命中率可能会长期的很低，可能预热后的缓存还没来得及访问就过期了。 12345678910111213redis是远程内存数据库，非关系型数据库，性能强劲，具有复制特性，解决问题而生的独一无二的数据模型，存储键值对与5种不同类型的值之间的映射，可以将存储在内存的键值对数据持久化到硬盘，可以使用复制特性来拓展读性能，还可以使用客户端分片来拓展写性能。特点：支持数据的持久化，可以将数据保存到磁盘里，重启的时候可以再次加载进行使用，redis不仅支持简单的key,value数据，同时它还提供特殊类型的存储如：list，hash支持数据的备份，即master slave模式（主从数据备份）性能极高：读的速度 11万次/s 写的速度 81000次/s丰富的数据类型原子性支持对多个操作后的原子性执行支持publish,subscribe，key过期等等特性场景：取最新n个操作；排行榜（取top N 操作）精准设置过期的应用；应用于计数器；做唯一性检查的操作；实时系统；队列系统 高并发场景问题及实战讲解 123在高并发的场景下，如果某个key被高并发的访问，没有被命中，出于对容错性的考虑，可以尝试去后端数据库获取，从而达到了大量请求到达数据库，而当该key对应的数据本身就是空的情况下，这就导致数据库中并发的执行了很多不必要的查询操作，从而导致了巨大的冲击和压力。我们可以缓存空对象，对查询结果为空的对象也进行缓存，如果是集合的话，可以缓存一个空的集合，但不是null，如果是缓存单个对象，则可以通过字段标识来区分，避免请求穿透到后端数据库，同时也需要保证缓存数据的时效性，这种方式实现起来成本较低，比较适合命中不高，但比较频繁更新的数据。单独过滤处理，对所有可能对应数据为空的key进行统一的存放，并在请求前做拦截，这样避免请求穿透到后端的数据库，这种方式实现起来相对复杂一些，比较适合命中不高但是更新不频繁的数据。 123456由于缓存的原因导致大量的请求到达后端数据库而导致数据库奔溃整个系统奔溃发生灾难。导致的原因有很多种，比如提到的缓存并发，缓存穿透，缓存抖动，都有可能造成缓存雪崩的现象。这些问题也可能被恶意攻击者利用，还有一种情况，例如某个时间点内，系统预加载的缓存周期性的集中失效了，也有可能导致雪崩。为了避免这种周期性的失效，可以通过设置不同的过期时间来错开他们的缓存过期时间，从而避免缓存集中失效。从应用架构角度，我们可以通过限流，降级，熔断等手段来降低影响，也可以通过多级缓存来避免这种灾难。此外，从整个研发体系流程角度，应该多加强压力测试，尽量模拟真实场景，尽早暴露问题，从而进行防范。 参考:http://www.imooc.com/article/20918 消息队列 业务解耦1234所谓解耦，本质上讲的就是一个事务只关心简单的流程，而需要依赖其它的系统但不那么重要的事情，有通知即可无需等待结果。基于消息的模型关心的是通知，不是处理。如：对于订单系统，用户支付成功之后，我们可能需要给用户发送一条短信通知。但其实呢，这已经不是系统的核心流程了。如果外部系统偏慢，比如短信网关速度不好，那么主流程的时间就会加强很多，用户肯定不想点击支付之后几分钟才看到结果，那么我们只需通知短信系统我们支付成功了，去发送短信通知就好了，并不一定要等待它处理完成才结束。 最终一致性12345678910111213141516指的是两个系统的状态保持一致，要么都成功，要么都失败。当然了，有个时间限制，理论上是越快越好。但实际上各种异常的情况下，可能会有一定的延迟达到最终的一致状态。但最后两个系统的状态还是要一样的。如：转账功能，A系统扣钱成功，B系统加钱一定也要成功。反之，它们就一起回滚，像什么都没发生一样，然而这个过程中存在很多可能的意外，比如：1.A系统扣钱成功，调用B系统加钱失效2.A扣钱成功，调用B系统加钱接口虽然成功，但是获取最终结果的时候网络异常引起的超时3.A扣钱成功，但B系统加钱失效了，A系统想回滚刚才扣除的钱，但是系统宕机了，无法回滚通过这三个场景，我们看出了想把这件看似简单的事情做成真的不容易，所有跨JVM一致性的问题，从技术的角度讲，通用的解决方法包括两个：1.强一致性分布式事务，落地太难，而且成本太高，我们就不做具体介绍了。2.最终一致性也是消息队列可以使用的场景，主要是用记录和补偿的方式来处理，在做所有的不确定事情之前，先把事情记录下来，然后去做不确定的事，它的结果通常分三种：成功/失败/不确定（超时等等可以等价为失败）如果是成功的话，就可以把我们记录的东西清理掉，对于失败和不确定，我们可以依靠定时任务等方式把所有失败的事情重新做一遍，知道成功为止。系统在A扣钱成功的情况下，需要给B通知的这件事情记录在库中，为了保证最高的可靠性，也可以把通知B系统加钱和扣钱成功这两件事情维护在一个本地事务里面。通知成功，则删除这条记录，通知失败或不确定则依靠定时任务可尝试地通知我们，直到我们把状态更加为正确的为止。这时，可能会遇到重复消息的问题，需要处理消息的地方做好幂等操作。最终一致性不是消息队列必备的特性。但确实可以依靠队列来做最终一致性的事情。需要注意的是，像kafka等消息队列，它的设计层面上有丢消息的可能，比如定时刷盘，如果掉列会丢消息的可能等等。哪怕只丢千分之一的消息，业务也要通过其它手段来保证结果的正确。 广播1如果没有队列，每当一个新的业务方介入，我们都要联调一次新接口，有了消息队列，我们只需要关心消息是否达到消息队列，新接入的接口订阅相关的消息，自己去做处理就可以了。 错峰和流控1234567上下游对性能处理能力是不同的，比如：Web前端每秒承受上千万的请求并不是什么神奇的事情，只需要多加一点机器，再搭建一些LVS负载均衡设备和nginx服务器即可。但是，数据库处理却是十分有限，即使使用了SSD加上分库分表单机处理能力仍然有限，出于成本考虑，我们不能奢求数据库的机器数量追上前端。这种问题同样出现于系统和系统之间，比如短信系统可能由于短板效应，速度卡在网关上，比如每秒几百次请求，它跟前端的并发量不是一个数量级的，但是，用户晚个半分钟左右收到短信一般也不会有太大问题，如果没有消息队列，两个系统之间通过协商，滑动窗口等方案也不是不能实现。但是，系统的复杂性将会成指数性增长。势必在上游或下游做些存储，并且要处理定时、阻塞等一些列问题，而且每当处理能力有些差异的时候，都需要单独开发一套逻辑来维护这套逻辑。所以，利用中间系统，如消息队列转储两个系统的消息内容，并在下游系统有能力处理这些消息的时候再处理，是一套相对比较通用的方式。总而言之，对于需要强事务保证，而且延迟很敏感的，RPC是优于队列的，对于一些无关痛痒或者一些对于别人很重要，但对于自己不是那么关心的事情可以利用消息队列去做。支持最终一致性的消息队列能够用来处理延迟不那么敏感的分布式事务场景，而且相对于笨重的分布式事务可能是更优的处理方式。 应用拆分 应用限流 服务降级与服务熔断 12对一些服务，界面有策略地降级以此缓解保证了部分甚至大部分客户能得到正确的响应，简单来说，如果当前请求处理不了了或者出错了，我给一个默认的返回，根据不同的接口做不同的默认返回和定制 1熔断是指软件系统里由于某些原因使得服务出现了过载的现象，为了防止整个系统出现故障，从而采用的一种保护措施，所以很多地方也把熔断称为过载保护 数据库切库、分库、分表","categories":[],"tags":[{"name":"并发编程与高并发解决方案","slug":"并发编程与高并发解决方案","permalink":"http://yoursite.com/tags/并发编程与高并发解决方案/"}],"keywords":[]},{"title":"并发编程","slug":"并发编程与高并发解决方案","date":"2019-08-25T03:46:27.324Z","updated":"2019-08-25T04:12:28.561Z","comments":true,"path":"2019/08/25/并发编程与高并发解决方案/","link":"","permalink":"http://yoursite.com/2019/08/25/并发编程与高并发解决方案/","excerpt":"","text":"准备 基本概念 CPU多级缓存 JAVA内存模型 并发的优势与风险 线程安全性 原子性 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051import lombok.extern.slf4j.Slf4j;import java.util.concurrent.CountDownLatch;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;import java.util.concurrent.Semaphore;import java.util.concurrent.atomic.AtomicInteger;import java.util.concurrent.atomic.AtomicLong;import java.util.concurrent.atomic.LongAdder;@Slf4j@ThreadSafepublic class AtomicExample1 &#123; // 请求总数 public static int clientTotal = 5000; // 同时并发执行的线程数 public static int threadTotal = 200; public static AtomicInteger count = new AtomicInteger(0); // public static AtomicLong count = new AtomicLong(0); // public static LongAdder count = new LongAdder(); public static void main(String[] args) throws Exception &#123; ExecutorService executorService = Executors.newCachedThreadPool(); final Semaphore semaphore = new Semaphore(threadTotal); final CountDownLatch countDownLatch = new CountDownLatch(clientTotal); for (int i = 0; i &lt; clientTotal ; i++) &#123; executorService.execute(() -&gt; &#123; try &#123; semaphore.acquire(); add(); semaphore.release(); &#125; catch (Exception e) &#123; log.error(&quot;exception&quot;, e); &#125; countDownLatch.countDown(); &#125;); &#125; countDownLatch.await(); executorService.shutdown(); log.info(&quot;count:&#123;&#125;&quot;, count.get()); &#125; private static void add() &#123; count.incrementAndGet(); // count.getAndIncrement(); // count.increment(); &#125;&#125; 123456789101112131415161718192021222324import lombok.extern.slf4j.Slf4j;import java.util.concurrent.CountDownLatch;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;import java.util.concurrent.Semaphore;import java.util.concurrent.atomic.AtomicReference;import java.util.concurrent.atomic.LongAdder;@Slf4j@ThreadSafepublic class AtomicExample4 &#123; private static AtomicReference&lt;Integer&gt; count = new AtomicReference&lt;&gt;(0); public static void main(String[] args) &#123; count.compareAndSet(0, 2); // 2 count.compareAndSet(0, 1); // no count.compareAndSet(1, 3); // no count.compareAndSet(2, 4); // 4 count.compareAndSet(3, 5); // no log.info(&quot;count:&#123;&#125;&quot;, count.get()); &#125;&#125; 1234567891011121314151617181920212223242526272829import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;import lombok.Getter;import lombok.extern.slf4j.Slf4j;@Slf4jpublic class AtomicExample5 &#123; private static AtomicIntegerFieldUpdater&lt;AtomicExample5&gt; updater = AtomicIntegerFieldUpdater.newUpdater(AtomicExample5.class, &quot;count&quot;); @Getter public volatile int count = 100; public static void main(String[] args) &#123; AtomicExample5 example5 = new AtomicExample5(); if (updater.compareAndSet(example5, 100, 120)) &#123; log.info(&quot;update success 1, &#123;&#125;&quot;, example5.getCount()); &#125; if (updater.compareAndSet(example5, 100, 120)) &#123; log.info(&quot;update success 2, &#123;&#125;&quot;, example5.getCount()); &#125; else &#123; log.info(&quot;update failed, &#123;&#125;&quot;, example5.getCount()); &#125; &#125;&#125; 结果:1223:15:33.084 [main] INFO com.mmall.concurrency.example.atomic.AtomicExample5 - update success 1, 12023:15:33.089 [main] INFO com.mmall.concurrency.example.atomic.AtomicExample5 - update failed, 120 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647import lombok.extern.slf4j.Slf4j;import java.util.concurrent.CountDownLatch;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;import java.util.concurrent.Semaphore;import java.util.concurrent.atomic.AtomicBoolean;@Slf4j@ThreadSafepublic class AtomicExample6 &#123; private static AtomicBoolean isHappened = new AtomicBoolean(false); // 请求总数 public static int clientTotal = 5000; // 同时并发执行的线程数 public static int threadTotal = 200; public static void main(String[] args) throws Exception &#123; ExecutorService executorService = Executors.newCachedThreadPool(); final Semaphore semaphore = new Semaphore(threadTotal); final CountDownLatch countDownLatch = new CountDownLatch(clientTotal); for (int i = 0; i &lt; clientTotal ; i++) &#123; executorService.execute(() -&gt; &#123; try &#123; semaphore.acquire(); test(); semaphore.release(); &#125; catch (Exception e) &#123; log.error(&quot;exception&quot;, e); &#125; countDownLatch.countDown(); &#125;); &#125; countDownLatch.await(); executorService.shutdown(); log.info(&quot;isHappened:&#123;&#125;&quot;, isHappened.get()); &#125; private static void test() &#123; if (isHappened.compareAndSet(false, true)) &#123; log.info(&quot;execute&quot;); &#125; &#125;&#125; 结果:1223:19:09.823 [pool-1-thread-1] INFO com.mmall.concurrency.example.atomic.AtomicExample6 - execute23:19:09.840 [main] INFO com.mmall.concurrency.example.atomic.AtomicExample6 - isHappened:true 可见性 有序性 安全发布对象 123456789101112131415161718192021222324import lombok.extern.slf4j.Slf4j;@Slf4j@NotThreadSafe@NotRecommendpublic class Escape &#123; private int thisCanBeEscape = 0; public Escape () &#123; new InnerClass(); &#125; private class InnerClass &#123; public InnerClass() &#123; log.info(&quot;&#123;&#125;&quot;, Escape.this.thisCanBeEscape); &#125; &#125; public static void main(String[] args) &#123; new Escape(); &#125;&#125; 123456789101112131415161718192021import lombok.extern.slf4j.Slf4j;import java.util.Arrays;@Slf4j@NotThreadSafepublic class UnsafePublish &#123; private String[] states = &#123;&quot;a&quot;, &quot;b&quot;, &quot;c&quot;&#125;; public String[] getStates() &#123; return states; &#125; public static void main(String[] args) &#123; UnsafePublish unsafePublish = new UnsafePublish(); log.info(&quot;&#123;&#125;&quot;, Arrays.toString(unsafePublish.getStates())); unsafePublish.getStates()[0] = &quot;d&quot;; log.info(&quot;&#123;&#125;&quot;, Arrays.toString(unsafePublish.getStates())); &#125;&#125; 1234567891011121314151617181920/** * 懒汉模式 * 单例实例在第一次使用时进行创建 */@NotThreadSafepublic class SingletonExample1 &#123; // 私有构造函数 private SingletonExample1() &#123;&#125; // 单例对象 private static SingletonExample1 instance = null; // 静态的工厂方法 public static SingletonExample1 getInstance() &#123; if (instance == null) &#123; instance = new SingletonExample1(); &#125; return instance; &#125;&#125; 1234567891011121314151617/** * 饿汉模式 * 单例实例在类装载时进行创建 */@ThreadSafepublic class SingletonExample2 &#123; // 私有构造函数 private SingletonExample2() &#123;&#125; // 单例对象 private static SingletonExample2 instance = new SingletonExample2(); // 静态的工厂方法 public static SingletonExample2 getInstance() &#123; return instance; &#125;&#125; 123456789101112131415161718192021/** * 懒汉模式 * 单例实例在第一次使用时进行创建 */@ThreadSafe@NotRecommendpublic class SingletonExample3 &#123; // 私有构造函数 private SingletonExample3() &#123;&#125; // 单例对象 private static SingletonExample3 instance = null; // 静态的工厂方法 public static synchronized SingletonExample3 getInstance() &#123; if (instance == null) &#123; instance = new SingletonExample3(); &#125; return instance; &#125;&#125; 12345678910111213141516171819202122232425262728293031323334/** * 懒汉模式 -》 双重同步锁单例模式 * 单例实例在第一次使用时进行创建 */@NotThreadSafepublic class SingletonExample4 &#123; // 私有构造函数 private SingletonExample4() &#123;&#125; // 1、memory = allocate() 分配对象的内存空间 // 2、ctorInstance() 初始化对象 // 3、instance = memory 设置instance指向刚分配的内存 // JVM和cpu优化，发生了指令重排 // 1、memory = allocate() 分配对象的内存空间 // 3、instance = memory 设置instance指向刚分配的内存 // 2、ctorInstance() 初始化对象 // 单例对象 private static SingletonExample4 instance = null; // 静态的工厂方法 public static SingletonExample4 getInstance() &#123; if (instance == null) &#123; // 双重检测机制 // B synchronized (SingletonExample4.class) &#123; // 同步锁 if (instance == null) &#123; instance = new SingletonExample4(); // A - 3 &#125; &#125; &#125; return instance; &#125;&#125; 12345678910111213141516171819202122232425262728/** * 懒汉模式 -》 双重同步锁单例模式 * 单例实例在第一次使用时进行创建 */@ThreadSafepublic class SingletonExample5 &#123; // 私有构造函数 private SingletonExample5() &#123;&#125; // 1、memory = allocate() 分配对象的内存空间 // 2、ctorInstance() 初始化对象 // 3、instance = memory 设置instance指向刚分配的内存 // 单例对象 volatile + 双重检测机制 -&gt; 禁止指令重排 private volatile static SingletonExample5 instance = null; // 静态的工厂方法 public static SingletonExample5 getInstance() &#123; if (instance == null) &#123; // 双重检测机制 // B synchronized (SingletonExample5.class) &#123; // 同步锁 if (instance == null) &#123; instance = new SingletonExample5(); // A - 3 &#125; &#125; &#125; return instance; &#125;&#125; 1234567891011121314151617181920212223242526/** * 饿汉模式 * 单例实例在类装载时进行创建 */@ThreadSafepublic class SingletonExample6 &#123; // 私有构造函数 private SingletonExample6() &#123;&#125; // 单例对象 private static SingletonExample6 instance = null; static &#123; instance = new SingletonExample6(); &#125; // 静态的工厂方法 public static SingletonExample6 getInstance() &#123; return instance; &#125; public static void main(String[] args) &#123; System.out.println(getInstance().hashCode()); System.out.println(getInstance().hashCode()); &#125;&#125; 1234567891011121314151617181920212223242526272829/** * 枚举模式：最安全 */@ThreadSafe@Recommendpublic class SingletonExample7 &#123; // 私有构造函数 private SingletonExample7() &#123;&#125; public static SingletonExample7 getInstance() &#123; return Singleton.INSTANCE.getInstance(); &#125; private enum Singleton &#123; INSTANCE; private SingletonExample7 singleton; // JVM保证这个方法绝对只调用一次 Singleton() &#123; singleton = new SingletonExample7(); &#125; public SingletonExample7 getInstance() &#123; return singleton; &#125; &#125;&#125; 不可变对象 12345678910111213141516171819202122232425262728293031import com.google.common.collect.Maps;import lombok.extern.slf4j.Slf4j;import java.util.Map;@Slf4j@NotThreadSafepublic class ImmutableExample1 &#123; private final static Integer a = 1; private final static String b = &quot;2&quot;; private final static Map&lt;Integer, Integer&gt; map = Maps.newHashMap(); static &#123; map.put(1, 2); map.put(3, 4); map.put(5, 6); &#125; public static void main(String[] args) &#123;// a = 2;// b = &quot;3&quot;;// map = Maps.newHashMap(); map.put(1, 3); log.info(&quot;&#123;&#125;&quot;, map.get(1)); &#125; private void test(final int a) &#123;// a = 1; &#125;&#125; 12345678910111213141516171819202122232425import com.google.common.collect.Maps;import lombok.extern.slf4j.Slf4j;import java.util.Collections;import java.util.Map;@Slf4j@ThreadSafepublic class ImmutableExample2 &#123; private static Map&lt;Integer, Integer&gt; map = Maps.newHashMap(); static &#123; map.put(1, 2); map.put(3, 4); map.put(5, 6); map = Collections.unmodifiableMap(map); &#125; public static void main(String[] args) &#123; map.put(1, 3); log.info(&quot;&#123;&#125;&quot;, map.get(1)); &#125;&#125; 结果:12Exception in thread &quot;main&quot; java.lang.UnsupportedOperationException at java.util.Collections$UnmodifiableMap.put(Collections.java:1457) 123456789101112131415161718import com.google.common.collect.ImmutableList;import com.google.common.collect.ImmutableMap;import com.google.common.collect.ImmutableSet;@ThreadSafepublic class ImmutableExample3 &#123; private final static ImmutableList&lt;Integer&gt; list = ImmutableList.of(1, 2, 3); private final static ImmutableSet set = ImmutableSet.copyOf(list); private final static ImmutableMap&lt;Integer, Integer&gt; map = ImmutableMap.of(1, 2, 3, 4); private final static ImmutableMap&lt;Integer, Integer&gt; map2 = ImmutableMap.&lt;Integer, Integer&gt;builder() .put(1, 2).put(3, 4).put(5, 6).build(); public static void main(String[] args) &#123; System.out.println(map2.get(3)); &#125;&#125; 线程封闭 线程不安全类与写法 JodaTime:12345678910111213141516171819202122232425262728293031323334353637383940414243444546import com.mmall.concurrency.annoations.ThreadSafe;import lombok.extern.slf4j.Slf4j;import org.joda.time.DateTime;import org.joda.time.format.DateTimeFormat;import org.joda.time.format.DateTimeFormatter;import java.util.concurrent.CountDownLatch;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;import java.util.concurrent.Semaphore;@Slf4j@ThreadSafepublic class DateFormatExample3 &#123; // 请求总数 public static int clientTotal = 5000; // 同时并发执行的线程数 public static int threadTotal = 200; private static DateTimeFormatter dateTimeFormatter = DateTimeFormat.forPattern(&quot;yyyyMMdd&quot;); public static void main(String[] args) throws Exception &#123; ExecutorService executorService = Executors.newCachedThreadPool(); final Semaphore semaphore = new Semaphore(threadTotal); final CountDownLatch countDownLatch = new CountDownLatch(clientTotal); for (int i = 0; i &lt; clientTotal; i++) &#123; final int count = i; executorService.execute(() -&gt; &#123; try &#123; semaphore.acquire(); update(count); semaphore.release(); &#125; catch (Exception e) &#123; log.error(&quot;exception&quot;, e); &#125; countDownLatch.countDown(); &#125;); &#125; countDownLatch.await(); executorService.shutdown(); &#125; private static void update(int i) &#123; log.info(&quot;&#123;&#125;, &#123;&#125;&quot;, i, DateTime.parse(&quot;20180208&quot;, dateTimeFormatter).toDate()); &#125;&#125; 同步容器 Vector不是线程安全的情况:1234567891011121314151617181920212223242526272829303132333435import java.util.Vector;@NotThreadSafepublic class VectorExample2 &#123; private static Vector&lt;Integer&gt; vector = new Vector&lt;&gt;(); public static void main(String[] args) &#123; while (true) &#123; for (int i = 0; i &lt; 10; i++) &#123; vector.add(i); &#125; Thread thread1 = new Thread() &#123; public void run() &#123; for (int i = 0; i &lt; vector.size(); i++) &#123; vector.remove(i); &#125; &#125; &#125;; Thread thread2 = new Thread() &#123; public void run() &#123; for (int i = 0; i &lt; vector.size(); i++) &#123; vector.get(i); &#125; &#125; &#125;; thread1.start(); thread2.start(); &#125; &#125;&#125; ConcurrentModificationException:123456789101112131415161718192021222324252627282930313233343536373839404142import java.util.Iterator;import java.util.Vector;public class VectorExample3 &#123; // java.util.ConcurrentModificationException private static void test1(Vector&lt;Integer&gt; v1) &#123; // foreach for(Integer i : v1) &#123; if (i.equals(3)) &#123; v1.remove(i); &#125; &#125; &#125; // java.util.ConcurrentModificationException private static void test2(Vector&lt;Integer&gt; v1) &#123; // iterator Iterator&lt;Integer&gt; iterator = v1.iterator(); while (iterator.hasNext()) &#123; Integer i = iterator.next(); if (i.equals(3)) &#123; v1.remove(i); &#125; &#125; &#125; // success private static void test3(Vector&lt;Integer&gt; v1) &#123; // for for (int i = 0; i &lt; v1.size(); i++) &#123; if (v1.get(i).equals(3)) &#123; v1.remove(i); &#125; &#125; &#125; public static void main(String[] args) &#123; Vector&lt;Integer&gt; vector = new Vector&lt;&gt;(); vector.add(1); vector.add(2); vector.add(3); test1(vector); &#125;&#125; Collections.synchronizedXXX1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556import com.google.common.collect.Lists;import com.google.common.collect.Sets;import com.mmall.concurrency.annoations.ThreadSafe;import lombok.extern.slf4j.Slf4j;import java.util.Collections;import java.util.List;import java.util.Vector;import java.util.Set;import java.util.concurrent.CountDownLatch;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;import java.util.concurrent.Semaphore;@Slf4j@ThreadSafepublic class CollectionsExample1 &#123; // 请求总数 public static int clientTotal = 5000; // 同时并发执行的线程数 public static int threadTotal = 200; private static List&lt;Integer&gt; list = Collections.synchronizedList(Lists.newArrayList()); // private static Set&lt;Integer&gt; set = Collections.synchronizedSet(Sets.newHashSet()); // private static Map&lt;Integer, Integer&gt; map = Collections.synchronizedMap(new HashMap&lt;&gt;()); public static void main(String[] args) throws Exception &#123; ExecutorService executorService = Executors.newCachedThreadPool(); final Semaphore semaphore = new Semaphore(threadTotal); final CountDownLatch countDownLatch = new CountDownLatch(clientTotal); for (int i = 0; i &lt; clientTotal; i++) &#123; final int count = i; executorService.execute(() -&gt; &#123; try &#123; semaphore.acquire(); update(count); semaphore.release(); &#125; catch (Exception e) &#123; log.error(&quot;exception&quot;, e); &#125; countDownLatch.countDown(); &#125;); &#125; countDownLatch.await(); executorService.shutdown(); log.info(&quot;size:&#123;&#125;&quot;, list.size()); &#125; private static void update(int i) &#123; list.add(i); // set.add(i); // map.put(i, i); &#125;&#125; 安全共享策略 AQS Sync queue 同步队列（底层是双向链表）Condition queue 单向链表（不是必须的，需要用到的时候才会使用） aqs实现的具体大致思路:123aqs内部维护了一个clh队列来管理锁，线程会首先尝试获取锁，如果失败，就将当前线程以及等待信息包成一个node节点，加入到之前介绍的同步队列，接着会不断循环尝试获取锁，条件是，当前节点为head的直接后继才会尝试，如果失败，就会阻塞自己，直到自己被唤醒，而当持有锁的线程释放锁的时候，会唤醒队列中的后继线程，基于这些基础的设计和思路，jdk提供了很多基于aqs的子类 使用场景:123程序执行需要等待某个条件完成后才能继续执行后续的操作，典型的应用比如：并行计算当某个处理的运算量很大时，可以将该运算任务拆分成多个子任务，等待所有的子任务都完成后，父任务再拿到所有子任务的运算结果进行汇总 12345678910111213141516171819202122232425262728293031323334353637383940import lombok.extern.slf4j.Slf4j;import java.util.concurrent.CountDownLatch;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;@Slf4jpublic class CountDownLatchExample1 &#123; private final static int threadCount = 200; public static void main(String[] args) throws Exception &#123; ExecutorService exec = Executors.newCachedThreadPool(); final CountDownLatch countDownLatch = new CountDownLatch(threadCount); for (int i = 0; i &lt; threadCount; i++) &#123; final int threadNum = i; exec.execute(() -&gt; &#123; try &#123; test(threadNum); &#125; catch (Exception e) &#123; log.error(&quot;exception&quot;, e); &#125; finally &#123; countDownLatch.countDown(); &#125; &#125;); &#125; countDownLatch.await(); log.info(&quot;finish&quot;); exec.shutdown(); &#125; private static void test(int threadNum) throws Exception &#123; Thread.sleep(100); log.info(&quot;&#123;&#125;&quot;, threadNum); Thread.sleep(100); &#125;&#125; 结果:123456789101115:14:51.589 [pool-1-thread-10] INFO com.mmall.concurrency.example.aqs.CountDownLatchExample1 - 915:14:51.589 [pool-1-thread-6] INFO com.mmall.concurrency.example.aqs.CountDownLatchExample1 - 515:14:51.589 [pool-1-thread-3] INFO com.mmall.concurrency.example.aqs.CountDownLatchExample1 - 215:14:51.589 [pool-1-thread-7] INFO com.mmall.concurrency.example.aqs.CountDownLatchExample1 - 615:14:51.589 [pool-1-thread-1] INFO com.mmall.concurrency.example.aqs.CountDownLatchExample1 - 015:14:51.589 [pool-1-thread-5] INFO com.mmall.concurrency.example.aqs.CountDownLatchExample1 - 415:14:51.589 [pool-1-thread-9] INFO com.mmall.concurrency.example.aqs.CountDownLatchExample1 - 815:14:51.589 [pool-1-thread-4] INFO com.mmall.concurrency.example.aqs.CountDownLatchExample1 - 315:14:51.589 [pool-1-thread-2] INFO com.mmall.concurrency.example.aqs.CountDownLatchExample1 - 115:14:51.589 [pool-1-thread-8] INFO com.mmall.concurrency.example.aqs.CountDownLatchExample1 - 715:14:51.696 [main] INFO com.mmall.concurrency.example.aqs.CountDownLatchExample1 - finish 12345678910111213141516171819202122232425262728293031323334353637383940import java.util.concurrent.CountDownLatch;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;import java.util.concurrent.TimeUnit;import lombok.extern.slf4j.Slf4j;@Slf4jpublic class CountDownLatchExample2 &#123; private final static int threadCount = 10; public static void main(String[] args) throws Exception &#123; ExecutorService exec = Executors.newCachedThreadPool(); final CountDownLatch countDownLatch = new CountDownLatch(threadCount); for (int i = 0; i &lt; threadCount; i++) &#123; final int threadNum = i; exec.execute(() -&gt; &#123; try &#123; test(threadNum); &#125; catch (Exception e) &#123; log.error(&quot;exception&quot;, e); &#125; finally &#123; countDownLatch.countDown(); &#125; &#125;); &#125; countDownLatch.await(10, TimeUnit.MILLISECONDS); log.info(&quot;finish&quot;); exec.shutdown(); &#125; private static void test(int threadNum) throws Exception &#123; Thread.sleep(100); log.info(&quot;&#123;&#125;&quot;, threadNum); &#125;&#125; 结果:123456789101115:17:50.556 [main] INFO com.mmall.concurrency.example.aqs.CountDownLatchExample2 - finish15:17:50.644 [pool-1-thread-1] INFO com.mmall.concurrency.example.aqs.CountDownLatchExample2 - 015:17:50.644 [pool-1-thread-4] INFO com.mmall.concurrency.example.aqs.CountDownLatchExample2 - 315:17:50.644 [pool-1-thread-3] INFO com.mmall.concurrency.example.aqs.CountDownLatchExample2 - 215:17:50.644 [pool-1-thread-7] INFO com.mmall.concurrency.example.aqs.CountDownLatchExample2 - 615:17:50.644 [pool-1-thread-8] INFO com.mmall.concurrency.example.aqs.CountDownLatchExample2 - 715:17:50.644 [pool-1-thread-2] INFO com.mmall.concurrency.example.aqs.CountDownLatchExample2 - 115:17:50.645 [pool-1-thread-10] INFO com.mmall.concurrency.example.aqs.CountDownLatchExample2 - 915:17:50.644 [pool-1-thread-9] INFO com.mmall.concurrency.example.aqs.CountDownLatchExample2 - 815:17:50.644 [pool-1-thread-6] INFO com.mmall.concurrency.example.aqs.CountDownLatchExample2 - 515:17:50.644 [pool-1-thread-5] INFO com.mmall.concurrency.example.aqs.CountDownLatchExample2 - 4 使用场景:12仅能提供有限的访问资源，比如：我们项目中的数据库，数据库的最大连接数只有20，而我们的上层应用的并发数会远远大于20，如果同时对数据库进行操作，就可能会出现因为无法获取数据库连接数导致异常，这时候就可以通过信号量来做并发访问控制，当信号量semaphore把并发数控制到1时，就跟单线程运行很相似， 1234567891011121314151617181920212223242526272829303132333435363738import lombok.extern.slf4j.Slf4j;import java.util.concurrent.CountDownLatch;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;import java.util.concurrent.Semaphore;@Slf4jpublic class SemaphoreExample1 &#123; private final static int threadCount = 10; public static void main(String[] args) throws Exception &#123; ExecutorService exec = Executors.newCachedThreadPool(); final Semaphore semaphore = new Semaphore(3); for (int i = 0; i &lt; threadCount; i++) &#123; final int threadNum = i; exec.execute(() -&gt; &#123; try &#123; semaphore.acquire(); // 获取一个许可 test(threadNum); semaphore.release(); // 释放一个许可 &#125; catch (Exception e) &#123; log.error(&quot;exception&quot;, e); &#125; &#125;); &#125; exec.shutdown(); &#125; private static void test(int threadNum) throws Exception &#123; log.info(&quot;&#123;&#125;&quot;, threadNum); Thread.sleep(1000); &#125;&#125; 结果: 大概每隔1s打印3行1234567891012:14:18.188 [pool-1-thread-2] INFO com.mmall.concurrency.example.aqs.SemaphoreExample1 - 112:14:18.188 [pool-1-thread-1] INFO com.mmall.concurrency.example.aqs.SemaphoreExample1 - 012:14:18.188 [pool-1-thread-3] INFO com.mmall.concurrency.example.aqs.SemaphoreExample1 - 212:14:19.194 [pool-1-thread-4] INFO com.mmall.concurrency.example.aqs.SemaphoreExample1 - 312:14:19.194 [pool-1-thread-5] INFO com.mmall.concurrency.example.aqs.SemaphoreExample1 - 412:14:19.194 [pool-1-thread-6] INFO com.mmall.concurrency.example.aqs.SemaphoreExample1 - 512:14:20.195 [pool-1-thread-8] INFO com.mmall.concurrency.example.aqs.SemaphoreExample1 - 712:14:20.195 [pool-1-thread-9] INFO com.mmall.concurrency.example.aqs.SemaphoreExample1 - 812:14:20.195 [pool-1-thread-7] INFO com.mmall.concurrency.example.aqs.SemaphoreExample1 - 612:14:21.196 [pool-1-thread-10] INFO com.mmall.concurrency.example.aqs.SemaphoreExample1 - 9 12345678910111213141516171819202122232425262728293031323334353637import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;import java.util.concurrent.Semaphore;import lombok.extern.slf4j.Slf4j;@Slf4jpublic class SemaphoreExample2 &#123; private final static int threadCount = 10; public static void main(String[] args) throws Exception &#123; ExecutorService exec = Executors.newCachedThreadPool(); final Semaphore semaphore = new Semaphore(3); for (int i = 0; i &lt; threadCount; i++) &#123; final int threadNum = i; exec.execute(() -&gt; &#123; try &#123; semaphore.acquire(3); // 获取多个许可 test(threadNum); semaphore.release(3); // 释放多个许可 &#125; catch (Exception e) &#123; log.error(&quot;exception&quot;, e); &#125; &#125;); &#125; exec.shutdown(); &#125; private static void test(int threadNum) throws Exception &#123; log.info(&quot;&#123;&#125;&quot;, threadNum); Thread.sleep(1000); &#125;&#125; 结果: 大概每隔1s打印1行1234567891012:17:05.304 [pool-1-thread-1] INFO com.mmall.concurrency.example.aqs.SemaphoreExample2 - 012:17:06.310 [pool-1-thread-2] INFO com.mmall.concurrency.example.aqs.SemaphoreExample2 - 112:17:07.310 [pool-1-thread-3] INFO com.mmall.concurrency.example.aqs.SemaphoreExample2 - 212:17:08.310 [pool-1-thread-4] INFO com.mmall.concurrency.example.aqs.SemaphoreExample2 - 312:17:09.311 [pool-1-thread-5] INFO com.mmall.concurrency.example.aqs.SemaphoreExample2 - 412:17:10.312 [pool-1-thread-6] INFO com.mmall.concurrency.example.aqs.SemaphoreExample2 - 512:17:11.312 [pool-1-thread-7] INFO com.mmall.concurrency.example.aqs.SemaphoreExample2 - 612:17:12.313 [pool-1-thread-8] INFO com.mmall.concurrency.example.aqs.SemaphoreExample2 - 712:17:13.314 [pool-1-thread-9] INFO com.mmall.concurrency.example.aqs.SemaphoreExample2 - 812:17:14.314 [pool-1-thread-10] INFO com.mmall.concurrency.example.aqs.SemaphoreExample2 - 9 123456789101112131415161718192021222324252627282930313233343536373839import lombok.extern.slf4j.Slf4j;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;import java.util.concurrent.Semaphore;import java.util.concurrent.TimeUnit;@Slf4jpublic class SemaphoreExample3 &#123; private final static int threadCount = 20; public static void main(String[] args) throws Exception &#123; ExecutorService exec = Executors.newCachedThreadPool(); final Semaphore semaphore = new Semaphore(3); for (int i = 0; i &lt; threadCount; i++) &#123; final int threadNum = i; exec.execute(() -&gt; &#123; try &#123; if (semaphore.tryAcquire()) &#123; // 尝试获取一个许可 test(threadNum); semaphore.release(); // 释放一个许可 &#125; &#125; catch (Exception e) &#123; log.error(&quot;exception&quot;, e); &#125; &#125;); &#125; exec.shutdown(); &#125; private static void test(int threadNum) throws Exception &#123; log.info(&quot;&#123;&#125;&quot;, threadNum); Thread.sleep(1000); &#125;&#125; 结果:12312:19:05.556 [pool-1-thread-3] INFO com.mmall.concurrency.example.aqs.SemaphoreExample3 - 212:19:05.556 [pool-1-thread-1] INFO com.mmall.concurrency.example.aqs.SemaphoreExample3 - 012:19:05.556 [pool-1-thread-2] INFO com.mmall.concurrency.example.aqs.SemaphoreExample3 - 1 123456789101112131415161718192021222324252627282930313233343536373839import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;import java.util.concurrent.Semaphore;import java.util.concurrent.TimeUnit;import lombok.extern.slf4j.Slf4j;@Slf4jpublic class SemaphoreExample4 &#123; private final static int threadCount = 10; public static void main(String[] args) throws Exception &#123; ExecutorService exec = Executors.newCachedThreadPool(); final Semaphore semaphore = new Semaphore(3); for (int i = 0; i &lt; threadCount; i++) &#123; final int threadNum = i; exec.execute(() -&gt; &#123; try &#123; if (semaphore.tryAcquire(5000, TimeUnit.MILLISECONDS)) &#123; // 尝试获取一个许可 test(threadNum); semaphore.release(); // 释放一个许可 &#125; &#125; catch (Exception e) &#123; log.error(&quot;exception&quot;, e); &#125; &#125;); &#125; exec.shutdown(); &#125; private static void test(int threadNum) throws Exception &#123; log.info(&quot;&#123;&#125;&quot;, threadNum); Thread.sleep(1000); &#125;&#125; 结果: 大概每隔1s打印3行12345678910111213141512:22:58.289 [pool-1-thread-1] INFO com.mmall.concurrency.example.aqs.SemaphoreExample4 - 012:22:58.289 [pool-1-thread-3] INFO com.mmall.concurrency.example.aqs.SemaphoreExample4 - 212:22:58.289 [pool-1-thread-2] INFO com.mmall.concurrency.example.aqs.SemaphoreExample4 - 112:22:59.294 [pool-1-thread-6] INFO com.mmall.concurrency.example.aqs.SemaphoreExample4 - 512:22:59.294 [pool-1-thread-5] INFO com.mmall.concurrency.example.aqs.SemaphoreExample4 - 412:22:59.294 [pool-1-thread-4] INFO com.mmall.concurrency.example.aqs.SemaphoreExample4 - 312:23:00.294 [pool-1-thread-8] INFO com.mmall.concurrency.example.aqs.SemaphoreExample4 - 712:23:00.294 [pool-1-thread-7] INFO com.mmall.concurrency.example.aqs.SemaphoreExample4 - 612:23:00.294 [pool-1-thread-9] INFO com.mmall.concurrency.example.aqs.SemaphoreExample4 - 812:23:01.294 [pool-1-thread-11] INFO com.mmall.concurrency.example.aqs.SemaphoreExample4 - 1012:23:01.294 [pool-1-thread-10] INFO com.mmall.concurrency.example.aqs.SemaphoreExample4 - 912:23:01.294 [pool-1-thread-12] INFO com.mmall.concurrency.example.aqs.SemaphoreExample4 - 1112:23:02.295 [pool-1-thread-15] INFO com.mmall.concurrency.example.aqs.SemaphoreExample4 - 1412:23:02.295 [pool-1-thread-13] INFO com.mmall.concurrency.example.aqs.SemaphoreExample4 - 1212:23:02.295 [pool-1-thread-14] INFO com.mmall.concurrency.example.aqs.SemaphoreExample4 - 13 12345678910111213141516171819202122232425262728293031323334353637383940414243import lombok.extern.slf4j.Slf4j;import java.util.concurrent.CyclicBarrier;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;@Slf4jpublic class CyclicBarrierExample1 &#123; private static CyclicBarrier barrier = new CyclicBarrier(5); public static void main(String[] args) throws Exception &#123; ExecutorService executor = Executors.newCachedThreadPool(); for (int i = 0; i &lt; 10; i++) &#123; final int threadNum = i; Thread.sleep(1000); executor.execute(() -&gt; &#123; try &#123; race(threadNum); &#125; catch (Exception e) &#123; log.error(&quot;exception&quot;, e); &#125; &#125;); &#125; executor.shutdown(); &#125; private static void race(int threadNum) throws Exception &#123; Thread.sleep(1000); log.info(&quot;&#123;&#125; is ready&quot;, threadNum); barrier.await();/* try &#123; barrier.await(2000, TimeUnit.MILLISECONDS); &#125; catch (Exception e) &#123; log.warn(&quot;BarrierException&quot;, e); &#125;*/ log.info(&quot;&#123;&#125; continue&quot;, threadNum); &#125;&#125; 结果：123456789101112131415161718192023:57:27.925 [pool-1-thread-1] INFO com.mmall.concurrency.example.aqs.CyclicBarrierExample1 - 0 is ready23:57:28.916 [pool-1-thread-2] INFO com.mmall.concurrency.example.aqs.CyclicBarrierExample1 - 1 is ready23:57:29.917 [pool-1-thread-3] INFO com.mmall.concurrency.example.aqs.CyclicBarrierExample1 - 2 is ready23:57:30.917 [pool-1-thread-4] INFO com.mmall.concurrency.example.aqs.CyclicBarrierExample1 - 3 is ready23:57:31.918 [pool-1-thread-5] INFO com.mmall.concurrency.example.aqs.CyclicBarrierExample1 - 4 is ready23:57:31.918 [pool-1-thread-5] INFO com.mmall.concurrency.example.aqs.CyclicBarrierExample1 - 4 continue23:57:31.918 [pool-1-thread-1] INFO com.mmall.concurrency.example.aqs.CyclicBarrierExample1 - 0 continue23:57:31.918 [pool-1-thread-2] INFO com.mmall.concurrency.example.aqs.CyclicBarrierExample1 - 1 continue23:57:31.918 [pool-1-thread-3] INFO com.mmall.concurrency.example.aqs.CyclicBarrierExample1 - 2 continue23:57:31.918 [pool-1-thread-4] INFO com.mmall.concurrency.example.aqs.CyclicBarrierExample1 - 3 continue23:57:32.919 [pool-1-thread-6] INFO com.mmall.concurrency.example.aqs.CyclicBarrierExample1 - 5 is ready23:57:33.918 [pool-1-thread-4] INFO com.mmall.concurrency.example.aqs.CyclicBarrierExample1 - 6 is ready23:57:34.919 [pool-1-thread-1] INFO com.mmall.concurrency.example.aqs.CyclicBarrierExample1 - 7 is ready23:57:35.919 [pool-1-thread-2] INFO com.mmall.concurrency.example.aqs.CyclicBarrierExample1 - 8 is ready23:57:36.920 [pool-1-thread-3] INFO com.mmall.concurrency.example.aqs.CyclicBarrierExample1 - 9 is ready23:57:36.920 [pool-1-thread-3] INFO com.mmall.concurrency.example.aqs.CyclicBarrierExample1 - 9 continue23:57:36.920 [pool-1-thread-6] INFO com.mmall.concurrency.example.aqs.CyclicBarrierExample1 - 5 continue23:57:36.920 [pool-1-thread-4] INFO com.mmall.concurrency.example.aqs.CyclicBarrierExample1 - 6 continue23:57:36.920 [pool-1-thread-1] INFO com.mmall.concurrency.example.aqs.CyclicBarrierExample1 - 7 continue23:57:36.920 [pool-1-thread-2] INFO com.mmall.concurrency.example.aqs.CyclicBarrierExample1 - 8 continue 1234567891011121314151617181920212223242526272829303132333435363738import lombok.extern.slf4j.Slf4j;import java.util.concurrent.CyclicBarrier;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;@Slf4jpublic class CyclicBarrierExample3 &#123; private static CyclicBarrier barrier = new CyclicBarrier(5, () -&gt; &#123; log.info(&quot;callback is running&quot;); &#125;); public static void main(String[] args) throws Exception &#123; ExecutorService executor = Executors.newCachedThreadPool(); for (int i = 0; i &lt; 10; i++) &#123; final int threadNum = i; Thread.sleep(1000); executor.execute(() -&gt; &#123; try &#123; race(threadNum); &#125; catch (Exception e) &#123; log.error(&quot;exception&quot;, e); &#125; &#125;); &#125; executor.shutdown(); &#125; private static void race(int threadNum) throws Exception &#123; Thread.sleep(1000); log.info(&quot;&#123;&#125; is ready&quot;, threadNum); barrier.await(); log.info(&quot;&#123;&#125; continue&quot;, threadNum); &#125;&#125; 1234567891011121314151617181920212200:00:48.622 [pool-1-thread-1] INFO com.mmall.concurrency.example.aqs.CyclicBarrierExample3 - 0 is ready00:00:49.618 [pool-1-thread-2] INFO com.mmall.concurrency.example.aqs.CyclicBarrierExample3 - 1 is ready00:00:50.618 [pool-1-thread-3] INFO com.mmall.concurrency.example.aqs.CyclicBarrierExample3 - 2 is ready00:00:51.618 [pool-1-thread-4] INFO com.mmall.concurrency.example.aqs.CyclicBarrierExample3 - 3 is ready00:00:52.617 [pool-1-thread-5] INFO com.mmall.concurrency.example.aqs.CyclicBarrierExample3 - 4 is ready00:00:52.617 [pool-1-thread-5] INFO com.mmall.concurrency.example.aqs.CyclicBarrierExample3 - callback is running00:00:52.617 [pool-1-thread-5] INFO com.mmall.concurrency.example.aqs.CyclicBarrierExample3 - 4 continue00:00:52.618 [pool-1-thread-2] INFO com.mmall.concurrency.example.aqs.CyclicBarrierExample3 - 1 continue00:00:52.618 [pool-1-thread-1] INFO com.mmall.concurrency.example.aqs.CyclicBarrierExample3 - 0 continue00:00:52.618 [pool-1-thread-3] INFO com.mmall.concurrency.example.aqs.CyclicBarrierExample3 - 2 continue00:00:52.618 [pool-1-thread-4] INFO com.mmall.concurrency.example.aqs.CyclicBarrierExample3 - 3 continue00:00:53.619 [pool-1-thread-6] INFO com.mmall.concurrency.example.aqs.CyclicBarrierExample3 - 5 is ready00:00:54.618 [pool-1-thread-4] INFO com.mmall.concurrency.example.aqs.CyclicBarrierExample3 - 6 is ready00:00:55.619 [pool-1-thread-3] INFO com.mmall.concurrency.example.aqs.CyclicBarrierExample3 - 7 is ready00:00:56.619 [pool-1-thread-2] INFO com.mmall.concurrency.example.aqs.CyclicBarrierExample3 - 8 is ready00:00:57.620 [pool-1-thread-1] INFO com.mmall.concurrency.example.aqs.CyclicBarrierExample3 - 9 is ready00:00:57.620 [pool-1-thread-1] INFO com.mmall.concurrency.example.aqs.CyclicBarrierExample3 - callback is running00:00:57.620 [pool-1-thread-1] INFO com.mmall.concurrency.example.aqs.CyclicBarrierExample3 - 9 continue00:00:57.620 [pool-1-thread-6] INFO com.mmall.concurrency.example.aqs.CyclicBarrierExample3 - 5 continue00:00:57.620 [pool-1-thread-4] INFO com.mmall.concurrency.example.aqs.CyclicBarrierExample3 - 6 continue00:00:57.620 [pool-1-thread-3] INFO com.mmall.concurrency.example.aqs.CyclicBarrierExample3 - 7 continue00:00:57.620 [pool-1-thread-2] INFO com.mmall.concurrency.example.aqs.CyclicBarrierExample3 - 8 continue synchronized:12345678910111213141516171819202122232425262728293031323334353637383940414243import lombok.extern.slf4j.Slf4j;import java.util.concurrent.CountDownLatch;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;import java.util.concurrent.Semaphore;@Slf4j@ThreadSafepublic class LockExample1 &#123; // 请求总数 public static int clientTotal = 5000; // 同时并发执行的线程数 public static int threadTotal = 200; public static int count = 0; public static void main(String[] args) throws Exception &#123; ExecutorService executorService = Executors.newCachedThreadPool(); final Semaphore semaphore = new Semaphore(threadTotal); final CountDownLatch countDownLatch = new CountDownLatch(clientTotal); for (int i = 0; i &lt; clientTotal ; i++) &#123; executorService.execute(() -&gt; &#123; try &#123; semaphore.acquire(); add(); semaphore.release(); &#125; catch (Exception e) &#123; log.error(&quot;exception&quot;, e); &#125; countDownLatch.countDown(); &#125;); &#125; countDownLatch.await(); executorService.shutdown(); log.info(&quot;count:&#123;&#125;&quot;, count); &#125; private synchronized static void add() &#123; count++; &#125;&#125; ReentrantLock:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253import lombok.extern.slf4j.Slf4j;import java.util.concurrent.CountDownLatch;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;import java.util.concurrent.Semaphore;import java.util.concurrent.locks.Lock;import java.util.concurrent.locks.ReentrantLock;@Slf4j@ThreadSafepublic class LockExample2 &#123; // 请求总数 public static int clientTotal = 5000; // 同时并发执行的线程数 public static int threadTotal = 200; public static int count = 0; private final static Lock lock = new ReentrantLock(); public static void main(String[] args) throws Exception &#123; ExecutorService executorService = Executors.newCachedThreadPool(); final Semaphore semaphore = new Semaphore(threadTotal); final CountDownLatch countDownLatch = new CountDownLatch(clientTotal); for (int i = 0; i &lt; clientTotal ; i++) &#123; executorService.execute(() -&gt; &#123; try &#123; semaphore.acquire(); add(); semaphore.release(); &#125; catch (Exception e) &#123; log.error(&quot;exception&quot;, e); &#125; countDownLatch.countDown(); &#125;); &#125; countDownLatch.await(); executorService.shutdown(); log.info(&quot;count:&#123;&#125;&quot;, count); &#125; private static void add() &#123; lock.lock(); try &#123; count++; &#125; finally &#123; lock.unlock(); &#125; &#125;&#125; ReentrantReadWriteLock:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748import lombok.extern.slf4j.Slf4j;import java.util.Map;import java.util.Set;import java.util.TreeMap;import java.util.concurrent.locks.Lock;import java.util.concurrent.locks.ReentrantReadWriteLock;@Slf4jpublic class LockExample3 &#123; private final Map&lt;String, Data&gt; map = new TreeMap&lt;&gt;(); private final ReentrantReadWriteLock lock = new ReentrantReadWriteLock(); private final Lock readLock = lock.readLock(); private final Lock writeLock = lock.writeLock(); public Data get(String key) &#123; readLock.lock(); try &#123; return map.get(key); &#125; finally &#123; readLock.unlock(); &#125; &#125; public Set&lt;String&gt; getAllKeys() &#123; readLock.lock(); try &#123; return map.keySet(); &#125; finally &#123; readLock.unlock(); &#125; &#125; public Data put(String key, Data value) &#123; writeLock.lock(); try &#123; return map.put(key, value); &#125; finally &#123; readLock.unlock(); &#125; &#125; class Data &#123;&#125;&#125; StampedLock:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657import java.util.concurrent.locks.StampedLock;public class LockExample4 &#123; class Point &#123; private double x, y; private final StampedLock sl = new StampedLock(); void move(double deltaX, double deltaY) &#123; // an exclusively locked method long stamp = sl.writeLock(); try &#123; x += deltaX; y += deltaY; &#125; finally &#123; sl.unlockWrite(stamp); &#125; &#125; //下面看看乐观读锁案例 double distanceFromOrigin() &#123; // A read-only method long stamp = sl.tryOptimisticRead(); //获得一个乐观读锁 double currentX = x, currentY = y; //将两个字段读入本地局部变量 if (!sl.validate(stamp)) &#123; //检查发出乐观读锁后同时是否有其他写锁发生？ stamp = sl.readLock(); //如果没有，我们再次获得一个读悲观锁 try &#123; currentX = x; // 将两个字段读入本地局部变量 currentY = y; // 将两个字段读入本地局部变量 &#125; finally &#123; sl.unlockRead(stamp); &#125; &#125; return Math.sqrt(currentX * currentX + currentY * currentY); &#125; //下面是悲观读锁案例 void moveIfAtOrigin(double newX, double newY) &#123; // upgrade // Could instead start with optimistic, not read mode long stamp = sl.readLock(); try &#123; while (x == 0.0 &amp;&amp; y == 0.0) &#123; //循环，检查当前状态是否符合 long ws = sl.tryConvertToWriteLock(stamp); //将读锁转为写锁 if (ws != 0L) &#123; //这是确认转为写锁是否成功 stamp = ws; //如果成功 替换票据 x = newX; //进行状态改变 y = newY; //进行状态改变 break; &#125; else &#123; //如果不能成功转换为写锁 sl.unlockRead(stamp); //我们显式释放读锁 stamp = sl.writeLock(); //显式直接进行写锁 然后再通过循环再试 &#125; &#125; &#125; finally &#123; sl.unlock(stamp); //释放读锁或写锁 &#125; &#125; &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152import lombok.extern.slf4j.Slf4j;import java.util.concurrent.CountDownLatch;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;import java.util.concurrent.Semaphore;import java.util.concurrent.locks.StampedLock;@Slf4j@ThreadSafepublic class LockExample5 &#123; // 请求总数 public static int clientTotal = 5000; // 同时并发执行的线程数 public static int threadTotal = 200; public static int count = 0; private final static StampedLock lock = new StampedLock(); public static void main(String[] args) throws Exception &#123; ExecutorService executorService = Executors.newCachedThreadPool(); final Semaphore semaphore = new Semaphore(threadTotal); final CountDownLatch countDownLatch = new CountDownLatch(clientTotal); for (int i = 0; i &lt; clientTotal ; i++) &#123; executorService.execute(() -&gt; &#123; try &#123; semaphore.acquire(); add(); semaphore.release(); &#125; catch (Exception e) &#123; log.error(&quot;exception&quot;, e); &#125; countDownLatch.countDown(); &#125;); &#125; countDownLatch.await(); executorService.shutdown(); log.info(&quot;count:&#123;&#125;&quot;, count); &#125; private static void add() &#123; long stamp = lock.writeLock(); try &#123; count++; &#125; finally &#123; lock.unlock(stamp); &#125; &#125;&#125; Condition:1234567891011121314151617181920212223242526272829303132333435363738import lombok.extern.slf4j.Slf4j;import java.util.concurrent.locks.Condition;import java.util.concurrent.locks.ReentrantLock;@Slf4jpublic class LockExample6 &#123; public static void main(String[] args) &#123; ReentrantLock reentrantLock = new ReentrantLock(); Condition condition = reentrantLock.newCondition(); new Thread(() -&gt; &#123; try &#123; reentrantLock.lock(); log.info(&quot;wait signal&quot;); // 1 condition.await(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; log.info(&quot;get signal&quot;); // 4 reentrantLock.unlock(); &#125;).start(); new Thread(() -&gt; &#123; reentrantLock.lock(); log.info(&quot;get lock&quot;); // 2 try &#123; Thread.sleep(3000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; condition.signalAll(); log.info(&quot;send signal ~ &quot;); // 3 reentrantLock.unlock(); &#125;).start(); &#125;&#125; Future:1234567891011121314151617181920212223242526272829import lombok.extern.slf4j.Slf4j;import java.util.concurrent.Callable;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;import java.util.concurrent.Future;@Slf4jpublic class FutureExample &#123; static class MyCallable implements Callable&lt;String&gt; &#123; @Override public String call() throws Exception &#123; log.info(&quot;do something in callable&quot;); Thread.sleep(5000); return &quot;Done&quot;; &#125; &#125; public static void main(String[] args) throws Exception &#123; ExecutorService executorService = Executors.newCachedThreadPool(); Future&lt;String&gt; future = executorService.submit(new MyCallable()); log.info(&quot;do something in main&quot;); Thread.sleep(1000); String result = future.get(); log.info(&quot;result：&#123;&#125;&quot;, result); &#125;&#125; FutureTask:12345678910111213141516171819202122232425import lombok.extern.slf4j.Slf4j;import java.util.concurrent.Callable;import java.util.concurrent.FutureTask;@Slf4jpublic class FutureTaskExample &#123; public static void main(String[] args) throws Exception &#123; FutureTask&lt;String&gt; futureTask = new FutureTask&lt;String&gt;(new Callable&lt;String&gt;() &#123; @Override public String call() throws Exception &#123; log.info(&quot;do something in callable&quot;); Thread.sleep(5000); return &quot;Done&quot;; &#125; &#125;); new Thread(futureTask).start(); log.info(&quot;do something in main&quot;); Thread.sleep(1000); String result = futureTask.get(); log.info(&quot;result：&#123;&#125;&quot;, result); &#125;&#125; 结果:12309:06:15.160 [main] INFO com.mmall.concurrency.example.aqs.FutureTaskExample - do something in main09:06:15.160 [Thread-0] INFO com.mmall.concurrency.example.aqs.FutureTaskExample - do something in callable09:06:20.164 [main] INFO com.mmall.concurrency.example.aqs.FutureTaskExample - result：Done JUC组件拓展 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364import lombok.extern.slf4j.Slf4j;import java.util.concurrent.ForkJoinPool;import java.util.concurrent.Future;import java.util.concurrent.RecursiveTask;@Slf4jpublic class ForkJoinTaskExample extends RecursiveTask&lt;Integer&gt; &#123; public static final int threshold = 2; private int start; private int end; public ForkJoinTaskExample(int start, int end) &#123; this.start = start; this.end = end; &#125; @Override protected Integer compute() &#123; int sum = 0; //如果任务足够小就计算任务 boolean canCompute = (end - start) &lt;= threshold; if (canCompute) &#123; for (int i = start; i &lt;= end; i++) &#123; sum += i; &#125; &#125; else &#123; // 如果任务大于阈值，就分裂成两个子任务计算 int middle = (start + end) / 2; ForkJoinTaskExample leftTask = new ForkJoinTaskExample(start, middle); ForkJoinTaskExample rightTask = new ForkJoinTaskExample(middle + 1, end); // 执行子任务 leftTask.fork(); rightTask.fork(); // 等待任务执行结束合并其结果 int leftResult = leftTask.join(); int rightResult = rightTask.join(); // 合并子任务 sum = leftResult + rightResult; &#125; return sum; &#125; public static void main(String[] args) &#123; ForkJoinPool forkjoinPool = new ForkJoinPool(); //生成一个计算任务，计算1+2+3+4 ForkJoinTaskExample task = new ForkJoinTaskExample(1, 100); //执行一个任务 Future&lt;Integer&gt; result = forkjoinPool.submit(task); try &#123; log.info(&quot;result:&#123;&#125;&quot;, result.get()); &#125; catch (Exception e) &#123; log.error(&quot;exception&quot;, e); &#125; &#125;&#125; 线程调度-线程池 1234运行的线程数量 &lt; corePoolSize 直接创建新线程来处理任务即使线程池中的其他线程是空闲的corePoolSize &lt;= 线程池的线程数量 &lt; maximumPoolSize 只有当workQueue满时才会创建新的线程处理任务corePoolSize = maximumPoolSize 创建的线程池大小是固定的，这时如果有新任务提交，workQueue没满时，把请求放到workQueue里面，等待有空闲等待线程从里面取出任务进行处理运行的线程数量 &gt; maximumPoolSize 如果workQueue满了，通过指定策略来处理这个任务 1234提交一个新的任务到线程池以后，线程池会根据当前线程池中运行的线程数量来决定该任务的处理方式1.直接切换 SynchronousQueue2.使用无界队列 LnkedBlockingQueue 能创建的最大线程数就是corePoolSize3.使用有界队列 ArrayBlockQueue 将线程的最大线程数量设置为maximumPoolSize ，降低资源的消耗 12降低系统资源的消耗（cpu使用率，操作系统资源的消耗）可以设置一个较大的队列容量，较小的线程池容量，降低线程处理任务的吞吐量提交的任务经常发生阻塞，调用设置线程最大线程数方法重新设置线程的容量，如果队列容量设置较小通常需要把线程池容量设置大一点，CPU的使用率会相对高一些 1234AbortPolicy：直接抛出异常CallerRunsPolicy：用调用者使用的线程来执行任务DiscardOldestPolicy：丢弃掉阻塞队列中最靠前的任务，并执行当前任务DiscardPolicy：直接丢弃当前任务 12345678910111213141516171819202122232425import lombok.extern.slf4j.Slf4j;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;@Slf4jpublic class ThreadPoolExample1 &#123; public static void main(String[] args) &#123; ExecutorService executorService = Executors.newCachedThreadPool(); // ExecutorService executorService = Executors.newFixedThreadPool(3); // ExecutorService executorService = Executors.newSingleThreadExecutor(); for (int i = 0; i &lt; 10; i++) &#123; final int index = i; executorService.execute(new Runnable() &#123; @Override public void run() &#123; log.info(&quot;task:&#123;&#125;&quot;, index); &#125; &#125;); &#125; executorService.shutdown(); &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738import lombok.extern.slf4j.Slf4j;import java.util.Date;import java.util.Timer;import java.util.TimerTask;import java.util.concurrent.Executors;import java.util.concurrent.ScheduledExecutorService;import java.util.concurrent.TimeUnit;@Slf4jpublic class ThreadPoolExample4 &#123; public static void main(String[] args) &#123; ScheduledExecutorService executorService = Executors.newScheduledThreadPool(1);// executorService.schedule(new Runnable() &#123;// @Override// public void run() &#123;// log.warn(&quot;schedule run&quot;);// &#125;// &#125;, 3, TimeUnit.SECONDS); executorService.scheduleAtFixedRate(new Runnable() &#123; @Override public void run() &#123; log.warn(&quot;schedule run&quot;); &#125; &#125;, 1, 3, TimeUnit.SECONDS);// executorService.shutdown(); Timer timer = new Timer(); timer.schedule(new TimerTask() &#123; @Override public void run() &#123; log.warn(&quot;timer run&quot;); &#125; &#125;, new Date(), 5 * 1000); &#125;&#125; 死锁 1234567891011避免死锁1.按顺序加锁2.加锁时间（超过一定时间就放弃该锁的请求，并释放自己占有的锁）3.死锁检测（以上两种方式都无法解决）每当一个线程获取了锁，会在线程和锁的相关数据结构中记下来，除此之外，每当有线程请求锁，也需要记录在这个数据结构中，当一个线程请求锁失败的时候，这个线程可以遍历锁的关系图，看是否有死锁发生，并决定后续操作该怎么办，具体这个结构需要大家根据实际情况去设计一下，那么，当检测出死锁的时候，线程都可以做哪些是事情呢，一个可执行的做法是释放所有锁，回退，并且等待一定时间（随机）后，之后进行重试，这个和简单的加锁超时有些类似，不一样的是，只有死锁发生了才回退而不会因为加锁请求超时了，虽然有了回退和等待，但是，如果有大量线程又同时竞争同一批锁，他们还是有可能出现重复死锁，这时候有个更好的方案，给这些线程设置优先级，让一个或几个线程回退，剩下的线程就像reantran锁一样，继续保持他们，如果赋予这些线程的优先级是固定不变的，可以在死锁发生的时候设置随机的线程优先级 并发最佳实践 spring与线程安全 HashMap与ConcurrentHashMap解析","categories":[],"tags":[{"name":"并发编程与高并发解决方案","slug":"并发编程与高并发解决方案","permalink":"http://yoursite.com/tags/并发编程与高并发解决方案/"}],"keywords":[]},{"title":"docker安装Oracle 12c","slug":"docker安装Oracle 12c","date":"2019-07-10T08:35:48.819Z","updated":"2019-07-10T08:33:12.394Z","comments":true,"path":"2019/07/10/docker安装Oracle 12c/","link":"","permalink":"http://yoursite.com/2019/07/10/docker安装Oracle 12c/","excerpt":"","text":"1.配置阿里的docker源1234cat /etc/docker/daemon.json&#123;&quot;registry-mirrors&quot;: [&quot;https://pee6w651.mirror.aliyuncs.com&quot;]&#125; 2.重启docker服务1systemctl restart docker 3.拉取镜像1docker pull sath89/oracle-12c 4.运行容器1docker run -d --name oracle -p 8080:8080 -p 1521:1521 -v $PWD/data:/mnt -e TZ=Asia/Shanghai sath89/oracle-12c 5.进行容器1docker exec -it ef7e5bc1c20e /bin/bash (ef7e5bc1c20e自己容器的ID) 6.相关操作1234567891011121314#root用户切换到oracle用户su oracle#使用sysdba登陆/u01/app/oracle-product/12.1.0/xe/bin/sqlplus / as sysdba#create tablespace 表空间名称 datafile 表空间路劲 size 3000m;SQL&gt;create tablespace bspdb datafile &apos;/u01/app/oracle/oradata/xe/bspdb.dbf&apos; size 3000m;#create user 用户名 identified by 密码 default tablespace 用户默认使用哪一个表空间;SQL&gt;create user bspdb identified by 123456 default tablespace bspdb;#grant 角色1,角色2 to 用户名;SQL&gt;grant dba, connect to bspdb; 参考：https://www.cnblogs.com/Dev0ps/p/10676930.htmlhttps://blog.csdn.net/Damionew/article/details/84566718https://www.cnblogs.com/forturn/p/9371841.html","categories":[],"tags":[{"name":"oracle","slug":"oracle","permalink":"http://yoursite.com/tags/oracle/"}],"keywords":[]},{"title":"angular根据路由展开菜单","slug":"angular根据路由展开菜单","date":"2019-05-28T08:16:54.132Z","updated":"2019-05-28T08:13:13.235Z","comments":true,"path":"2019/05/28/angular根据路由展开菜单/","link":"","permalink":"http://yoursite.com/2019/05/28/angular根据路由展开菜单/","excerpt":"","text":"当路由为“/a”和“/a/b”class active都会被添加。active可以设置为展开菜单的样式html:12&lt;li [routerLink]=&quot;/a&quot; routerLinkActive=&quot;active&quot;&gt;a&lt;/li&gt;&lt;li [routerLink]=&quot;/a/b&quot; routerLinkActive=&quot;active&quot;&gt;ab&lt;/li&gt; 当路由中携带参数时（即？key=value）html:1&lt;li [routerLink]=&quot;/a&quot; [class.active]=&quot;isActive(&quot;/a&quot;)&quot;&gt;a&lt;/li&gt; component:123isActive(instruction: string): boolean &#123; return this.router.isActive(this.router.createUrlTree([instruction]), false);&#125; 参考：(https://stackoverflow.com/questions/39271654/routerlinkactive-for-routerlink-with-parameters-dynamic)[https://stackoverflow.com/questions/39271654/routerlinkactive-for-routerlink-with-parameters-dynamic](https://majing.io/posts/10000019031169)[https://majing.io/posts/10000019031169]","categories":[],"tags":[{"name":"angular","slug":"angular","permalink":"http://yoursite.com/tags/angular/"}],"keywords":[]},{"title":"oracle-monitor-toptable","slug":"oracle_table","date":"2019-05-24T09:29:25.567Z","updated":"2019-05-24T09:28:24.680Z","comments":true,"path":"2019/05/24/oracle_table/","link":"","permalink":"http://yoursite.com/2019/05/24/oracle_table/","excerpt":"","text":"1234567891011121314151617181920212223242526272829303132333435SELECT t1.*, nvl(t2.index_bytes, 0) index_bytes, nvl(t3.lob_bytes, 0) lob_bytesFROM (SELECT * FROM(SELECT tab.owner, tab.table_name, tab.tablespace_name, nvl(tab.num_rows, to_number(NULL)) num_rows, nvl(stab.bytes, to_number(NULL)) bytes FROM dba_tables tab, dba_segments stab WHERE stab.owner = tab.owner AND stab.segment_name = tab.table_name AND tab.owner NOT LIKE &apos;%SYS%&apos; ORDER BY stab.bytes DESC) WHERE rownum &lt;= 10) t1, (SELECT table_owner, table_name, SUM(nvl(bytes, to_number(NULL))) index_bytes FROM dba_indexes ind, dba_segments seg WHERE ind.owner=seg.owner AND ind.index_name=seg.segment_name AND table_owner NOT LIKE &apos;%SYS%&apos; GROUP BY table_owner,table_name) t2, (SELECT l.owner, l.table_name, SUM(nvl(bytes, to_number(NULL))) lob_bytes FROM dba_lobs l, dba_segments seg WHERE l.owner=seg.owner AND l.segment_name=seg.segment_name AND l.owner NOT LIKE &apos;%SYS%&apos; GROUP BY l.owner,l.table_name) t3WHERE t1.table_name = t2.table_name(+) AND t1.owner = t2.table_owner(+) AND t1.table_name = t3.table_name(+) AND t1.owner = t3.owner(+) 参考：(https://github.com/freenetdigital/prometheus_oracle_exporter)[https://github.com/freenetdigital/prometheus_oracle_exporter]","categories":[],"tags":[{"name":"oracle","slug":"oracle","permalink":"http://yoursite.com/tags/oracle/"}],"keywords":[]},{"title":"解决SqlPlus前台程序出现中文乱码的问题","slug":"解决SqlPlus前台程序出现中文乱码的问题","date":"2019-05-24T09:22:11.891Z","updated":"2019-04-18T13:32:34.319Z","comments":true,"path":"2019/05/24/解决SqlPlus前台程序出现中文乱码的问题/","link":"","permalink":"http://yoursite.com/2019/05/24/解决SqlPlus前台程序出现中文乱码的问题/","excerpt":"","text":"第一步：12345在sqlplus中执行 select userenv(&apos;language&apos;) from dual;查看当前数据库的字符集为：SIMPLIFIED CHINESE_CHINA.ZHS16GBK。我们只需要把客户端字符集和操作系统字符集都设置成这个就行了开始-运行-CMD：SET NLS_LANG=SIMPLIFIED CHINESE_CHINA.ZHS16GBK以上参数设置只是在当前会话生效 第二步：12在环境变量中查找一个名为“NLS_LANG”的环境变量，如果找不到，则新建一个，把变量值赋值为：“SIMPLIFIED CHINESE_CHINA.ZHS16GBK” 参考：http://blog.itpub.net/26839123/viewspace-722870/","categories":[],"tags":[{"name":"oracle","slug":"oracle","permalink":"http://yoursite.com/tags/oracle/"}],"keywords":[]},{"title":"telegraf file plugin inputs","slug":"telegraf_volume","date":"2019-05-24T09:20:36.214Z","updated":"2019-05-24T08:56:27.428Z","comments":true,"path":"2019/05/24/telegraf_volume/","link":"","permalink":"http://yoursite.com/2019/05/24/telegraf_volume/","excerpt":"","text":"需要使用新增过功能的telegraf1.telegraf.conf1234567891011121314151617181920212223242526272829303132333435363738394041[global_tags][agent] interval = &quot;1h&quot; #修改成实际的抓取间隔 round_interval = true metric_batch_size = 1000 metric_buffer_limit = 10000 collection_jitter = &quot;0s&quot; flush_interval = &quot;20s&quot; flush_jitter = &quot;0s&quot; precision = &quot;&quot; debug = false quiet = false hostname = &quot;&quot; omit_hostname = false################################################################################ OUTPUTS ################################################################################[[outputs.influxdb]] urls = [&quot;http://ip:8086&quot;] #修改成实际的influxdb地址 database = &quot;volume_monitor&quot; skip_database_creation = true username = &quot;admin&quot; #有权限验证则修改用户名，否则删除该行配置 password = &quot;admin&quot; #有权限验证则修改密码，否则删除该行配置 namepass=[&quot;volume_*&quot;]################################################################################ INPUTS ################################################################################[[inputs.filecount]] name_prefix=&quot;volume_&quot; directories = [&quot;E:\\\\volume01&quot;] #实际抓取的文件目录 name = &quot;*&quot; recursive = true regular_only = true size = 0 large_file_size = 4 mtime = &quot;0s&quot; 2.启动1telegraf --config telegraf.conf --input-filter filecount --output-filter influxdb","categories":[],"tags":[{"name":"telegraf","slug":"telegraf","permalink":"http://yoursite.com/tags/telegraf/"}],"keywords":[]},{"title":"telegraf prometheus plugin inputs","slug":"telegraf_prometheus","date":"2019-05-24T09:20:24.839Z","updated":"2019-05-24T08:51:11.426Z","comments":true,"path":"2019/05/24/telegraf_prometheus/","link":"","permalink":"http://yoursite.com/2019/05/24/telegraf_prometheus/","excerpt":"","text":"Prometheus Input plugins（需要结合修改过的oracledb_exporter）安装与启动1.启动oracledb_exporter，并访问oracledb_exporter启动时指定的ip:port，确认数据无误。加载不同配置启动oracledb_exporter：oracle.conf12345678connections: - connection: userName/userPassword@ip:1521/databaseName database: databaseName instance: ip id: customId metrics: process,top_sql,session,wait_time,activity,physical_io,cache topsql: rownum: 10 oracledb_exporter -configfile=oracle.conf -web.listen-address ip:port oracle_table.conf12345678connections: - connection: userName/userPassword@ip:1521/databaseName database: databaseName instance: ip id: customId metrics: top_table,tablespace toptable: rownum: 10 oracledb_exporter -configfile=oracle_table.conf -web.listen-address ip:port 2.配置Telegraf Prometheus输入插件（对于抓取不同metric的输agent，需要不同的telegraf配置）抓取以oracle.conf启动的oracle_exporter的telegraf.conf12345678910111213141516171819202122232425262728293031323334353637383940414243[global_tags][agent] interval = &quot;60s&quot; #修改成实际的抓取间隔 round_interval = true metric_batch_size = 1000 metric_buffer_limit = 10000 collection_jitter = &quot;0s&quot; flush_interval = &quot;10s&quot; flush_jitter = &quot;0s&quot; precision = &quot;&quot; debug = false quiet = false logfile = &quot;&quot; hostname = &quot;hostname&quot; #修改成抓取的数据库所在主机名 omit_hostname = false################################################################################ OUTPUT PLUGINS ################################################################################[[outputs.influxdb]] urls = [&quot;http://ip:8086&quot;] #修改成实际的influxdb地址 database = &quot;oracledb_monitor&quot; skip_database_creation = true username = &quot;admin&quot; #有权限验证则修改用户名，否则删除该行配置 password = &quot;admin&quot; #有权限验证则修改密码，否则删除该行配置 namepass=[&quot;oracledb_*&quot;]################################################################################ PROCESSOR PLUGINS ################################################################################[[processors.converter]] [processors.converter.tags] string = [&quot;info_version&quot;, &quot;sql_text&quot;, &quot;sql_username&quot;] boolean = [&quot;info_is_rac&quot;] float = [&quot;info_uptime&quot;, &quot;info_dbtime&quot;, &quot;sql_exec&quot;]################################################################################ INPUT PLUGINS ################################################################################[[inputs.prometheus]] urls = [&quot;http://ip:9162/metrics&quot;] #修改成实际的exporter地址 response_timeout = &quot;150s&quot; 抓取以oracle_table.conf启动的oracle_exporter的telegraf.conf1234567891011121314151617181920212223242526272829303132333435363738394041[global_tags][agent] interval = &quot;24h&quot; #修改成实际的抓取间隔 round_interval = true metric_batch_size = 1000 metric_buffer_limit = 10000 collection_jitter = &quot;0s&quot; flush_interval = &quot;10s&quot; flush_jitter = &quot;0s&quot; precision = &quot;&quot; debug = false quiet = false logfile = &quot;&quot; hostname = &quot;hostname&quot; #修改成抓取的数据库所在主机名 omit_hostname = false################################################################################ OUTPUT PLUGINS ################################################################################[[outputs.influxdb]] urls = [&quot;http://ip:8086&quot;] #修改成实际的influxdb地址 database = &quot;oracledb_monitor&quot; skip_database_creation = true username = &quot;admin&quot; #有权限验证则修改用户名，否则删除该行配置 password = &quot;admin&quot; #有权限验证则修改密码，否则删除该行配置 namepass=[&quot;oracledb_*&quot;]################################################################################ PROCESSOR PLUGINS ################################################################################[[processors.converter]] [processors.converter.tags] integer = [&quot;index_bytes&quot;, &quot;lob_bytes&quot;, &quot;num_rows&quot;]################################################################################ INPUT PLUGINS ################################################################################[[inputs.prometheus]] urls = [&quot;http://ip:9162/metrics&quot;] #修改成实际的exporter地址 response_timeout = &quot;150s&quot; 3.启动telegraf收集不同exporter启动时加载不同的配置文件12telegraf --config telegraf.conf --input-filter prometheus --processor-filter converter --output-filter influxdbtelegraf --config telegraf_table.conf --input-filter prometheus --processor-filter converter --output-filter influxdb","categories":[],"tags":[{"name":"telegraf","slug":"telegraf","permalink":"http://yoursite.com/tags/telegraf/"}],"keywords":[]},{"title":"spring常用操作","slug":"spring常用操作","date":"2019-05-24T09:18:45.228Z","updated":"2019-05-15T12:17:24.726Z","comments":true,"path":"2019/05/24/spring常用操作/","link":"","permalink":"http://yoursite.com/2019/05/24/spring常用操作/","excerpt":"","text":"初始化bean时，普通成员变量获取不到@Value注解的变量值问题：12345678public class Xxx &#123; @Value(&quot;$&#123;value&#125;&quot;) private String value; private Map&lt;String, String&gt; map = new HashMap&lt;String, String&gt;()&#123;&#123; put(&quot;key&quot;, value);// value取不到值 &#125;&#125;;&#125; 修改：123456789101112public class Xxx &#123; @Value(&quot;$&#123;value&#125;&quot;) private String value; private Map&lt;String, String&gt; map; @PostConstruct private void init()&#123; map = new HashMap&lt;String, String&gt;()&#123;&#123; put(&quot;key&quot;, value); &#125;&#125;; &#125;&#125; 参考：https://blog.csdn.net/zlp1992/article/details/78346420 springboot yaml文件数组表示1array: item1, item2, item3, item4, item5 参考：https://stackoverflow.com/questions/26699385/spring-boot-yaml-configuration-for-a-list-of-strings","categories":[],"tags":[{"name":"spring","slug":"spring","permalink":"http://yoursite.com/tags/spring/"}],"keywords":[]},{"title":"docker基础","slug":"docker","date":"2019-05-24T09:11:20.054Z","updated":"2019-05-05T16:18:45.668Z","comments":true,"path":"2019/05/24/docker/","link":"","permalink":"http://yoursite.com/2019/05/24/docker/","excerpt":"","text":"安装1234567891011121314sudo yum remove docker \\docker-common \\docker-selinux \\docker-enginesudo yum install -y yum-utils \\device-mapper-persistent-data \\lvm2sudo yum-config-manager \\--add-repo \\https://download.docker.com/linux/centos/docker-ce.reposudo yum install docker-ce 启动12sudo systemctl start dockersudo docker version helloworld1sudo docker run hello-world 镜像123456789101112// 查看进程ps -ef | grep docker// 查看镜像sudo docker image ls// 拉取镜像sudo docker pull ubuntu:14.04// 运行镜像docker run hello-worlddocker run -it centos// 删除镜像docker image rm 67759a80360c(镜像ID)docker image rmi f2a91732366c(镜像ID) 自己实现helloworld12345mkdir hello-worldcd hello-world/vim hello.c//hello.c内容忽略gcc -static hello.c -o hello 12345vim DockerfileFROM scratchADD hello /CMD [&quot;/hello&quot;] 12docker build -t brotherc/hello-world .docker run brotherc/hello-world 容器12345678910docker container lsdocker container ls -adocker container ps -adocker rm $(docker container ls -f &quot;status-exited&quot; -q)docker rm $(docker container ls -aq)docker container rm 846b5efe98d4(容器ID)docker container rm 84(容器ID前缀)// 将已有容器提交成新的镜像Usage: docker commit [OPTIONS] CONTAINER [REPOSITORY[:TAG]] [flags]docker commit xenodochial_pare(容器名称) brotherc/centos-vim DockerfileFROM尽量使用官方的image作为base image!123FROM scratch #制作base imageFROM centos #使用base imageFROM ubuntu:14.04 LABELMetadata不可少!123LABEL maintainer=&quot;brotherc@136.com&quot;LABEL version=&quot;1.0&quot;LABEL description=&quot;This is description&quot; RUN为了美观，复杂的RUN请用反斜杠换行!避免无用分层，合并多条命令成一行!12RUN yum update &amp;&amp; yum install -y vim \\ #反斜线换行 python-dev 123RUN apt-get update &amp;&amp; apt-get install -y perl \\ pwgen --no-install-recommends &amp;&amp; rm -rf \\ /var/lib/apt/lists/* #注意清理cache 1RUN /bin/bash -c&apos;source $HOME/.bashrc;echo $HOME&apos; WORKDIR用WORKDIR，不要用RUN cd!尽量使用绝对目录!1WORKDIR /root 123WORKDIR /test #如果没有会自动创建test目录WORKDIR demoRUN pwd #输出结果应该是 /test/demo ADD and COPY大部分情况，COPY优于ADD!ADD除了COPY还有额外功能(解压)!添加远程文件/目录请使用curl或者wget!1ADD hello / 1ADD test.tar.gz / #添加到根目录并解压 12WORKDIR /rootADD hello test/ # /root/test/hello 12WORKDIR /rootCOPY hello test/ ENV尽量使用ENV增加可维护性!123ENV MYSQL_VERSION 5.6 #设置常量RUN apt-get install -y mysql-server=&quot;$&#123;MYSQL_VERSION&#125;&quot; \\ &amp;&amp; rm -rf /var/lib/apt/lists/* #引用常量 RUN vs CMD vs ENTRYPOINTRUN:执行命令并创建新的image layerCMD:设置容器启动后默认执行的命令和参数ENTRYPOINT:设置容器启动时运行的命令 Shell格式123RUN apt-get install -y vimCMD echo &quot;hello docker&quot;ENTRYPOINT echo &quot;hello docker&quot; 123FROM centosENV name DockerENTRYPOINT echo &quot;hello $name&quot; Exec格式123RUN [&quot;apt-get&quot;, &quot;install&quot;, &quot;-y&quot;, &quot;vim&quot;]CMD [&quot;/bin/echo&quot;, &quot;hello docker&quot;]ENTRYPOINT [&quot;/bin/echo&quot;, &quot;hello docker&quot;] 123FROM centosENV name DockerENTRYPOINT [&quot;/bin/echo&quot;, &quot;hello docker&quot;] Dockerfile实践Dockerfile:123FROM centosENV name DockerENTRYPOINT echo &quot;hello $name&quot; 123docker build -t brotherc/centos-entrypoint-shell .docker run brotherc/centos-entrypoint-shellhello Docker Dockerfile:123FROM centosENV name DockerENTRYPOINT [&quot;/bin/bash&quot;, &quot;-c&quot;, &quot;echo hello $name&quot;] 123docker build -t brotherc/centos-entrypoint-exec .docker run brotherc/centos-entrypoint-exechello Docker CMD容器启动时默认执行的命令如果docker run指定了其它命令，CMD命令被忽略如果定义了多个CMD，只有最后一个会执行Dockerfile:123FROM centosENV name DockerCMD echo &quot;hello $name&quot; 123456docker build -t brotherc/centos-cmd-shell .docker run brotherc/centos-cmd-shellhello Dockerdocker run -it brotherc/centos-cmd-shell /bin/bash无输出 ENTRYPOINT让容器以应用程序或者服务的形式运行不会被忽略，一定会执行12345docker run brotherc/centos-entrypoint-shellhello Dockerdocker run -it brotherc/centos-entrypoint-shell /bin/bashhello Docker","categories":[],"tags":[{"name":"docker","slug":"docker","permalink":"http://yoursite.com/tags/docker/"}],"keywords":[]},{"title":"oracle-monitor-topsql","slug":"oracle_top","date":"2019-04-16T12:34:53.056Z","updated":"2019-05-24T09:15:32.329Z","comments":true,"path":"2019/04/16/oracle_top/","link":"","permalink":"http://yoursite.com/2019/04/16/oracle_top/","excerpt":"","text":"最大增量（即最大Elapsed_Time的一次sql）1234567891011121314151617181920// 最近快照select * from ( SELECT m.*, TO_CHAR(dbms_lob.substr(v.sql_text, 3900)) SQL_Text FROM ( select distinct snap_id, sql_id, EXECUTIONS_DELTA, trunc(max(ELAPSED_TIME_DELTA)OVER(PARTITION BY snap_id, sql_id),0) max_elapsed, trunc(max(cpu_time_delta)OVER(PARTITION BY snap_id, sql_id),0) max_cpu from dba_hist_sqlstat t WHERE t.snap_id IN (SELECT MAX(snap_id) FROM dba_hist_sqlstat) ) M,dba_hist_sqltext v where v.sql_id(+)=m.sql_id and v.SQL_TEXT not like &apos;%v$%&apos; order by max_elapsed desc) where rownum &lt; 10; 12345678910111213141516171819202122232425-- 不区分快照，关联sql执行用户select * from ( select sqt.sql_id, sqt.max_exec, sqt.max_elapsed, su.username, TO_CHAR(dbms_lob.substr(st.sql_text, 3900)) sql_text from (select sql_id, min(snap_id) snap_id, max(executions_delta) max_exec, max(cpu_time_delta) max_cpu, NVL((MAX(elapsed_time_delta) / 1000000), to_number(null)) max_elapsed from dba_hist_sqlstat where module = &apos;tcserver.exe&apos; -- 过滤某个程序执行的sql语句 group by sql_id) sqt, dba_hist_sqltext st, (SELECT sql_id, parsing_schema_name username FROM ( SELECT t.sql_id,t.parsing_schema_name,row_number() over(partition by t.sql_id order by t.snap_id asc) rn FROM dba_hist_sqlstat t WHERE module =&apos;tcserver.exe&apos;) -- 过滤某个程序执行的sql语句 WHERE rn = 1) su where st.sql_id(+) = sqt.sql_id and su.sql_id(+) = sqt.sql_id order by nvl(sqt.max_elapsed, -1) desc, sqt.sql_id) where rownum &lt;= 10; 总量（即某条sql的总时长）123456789101112131415161718192021222324252627select * from ( select sqt.sql_id, sqt.exec Executions, nvl((sqt.elap / 1000000), to_number(null)) Elapsed_Time_s, nvl((sqt.cput / 1000000), to_number(null)) CPU_Time_s, decode(sqt.exec, 0, to_number(null), (sqt.elap / sqt.exec / 1000000)) Elap_per_Exec_s, TO_CHAR(dbms_lob.substr(st.sql_text, 3900)) SQL_Text from (select sql_id, max(module) module, sum(elapsed_time_delta) elap, sum(cpu_time_delta) cput, sum(executions_delta) exec from dba_hist_sqlstat group by sql_id) sqt, dba_hist_sqltext st where st.sql_id(+) = sqt.sql_id and st.sql_text not like &apos;%v$%&apos; order by nvl(sqt.elap, -1) desc, sqt.sql_id) where rownum &lt; 10; 12345678910111213141516171819202122select sql_id, executions, elapsed_time, cpu_time, (elapsed_time / executions ) Elap_per_Exec, TO_CHAR(dbms_lob.substr(sql_fulltext, 3900)) SQL_Textfrom (select sql_id, child_number, sql_text, elapsed_time, cpu_time, disk_reads, sql_fulltext, executions, rank () over(order by elapsed_time desc) as sql_rank from v$sql where sql_fulltext not like &apos;%v$%&apos;)where sql_rank &lt; 10; 注意： 使用TO_CHAR(dbms_lob.substr(BLOB_FIELD, 3900))将BLOB转成VARCHAR 根据情况选择查询dba_hist_sqlstat表或v$sql表 row_number() over( partition by 分组字段 order by 排序字段 desc ) oracle按某个字段分组然后从每组取出最大的一条纪录 参考：http://www.cnblogs.com/david-zhang-index/archive/2012/03/16/2399846.htmlhttp://www.dba-oracle.com/t_sql_longest_elapsed_time.htmhttp://blog.itpub.net/12679300/viewspace-2125679/https://stackoverflow.com/questions/828650/how-do-i-get-textual-contents-from-blob-in-oracle-sqlhttps://www.cnblogs.com/ryanchancrj/p/6437288.html其他情境下的sql:https://blog.csdn.net/yingwang9/article/details/80853484https://blog.csdn.net/xwnxwn/article/details/78062433","categories":[],"tags":[{"name":"oracle","slug":"oracle","permalink":"http://yoursite.com/tags/oracle/"}],"keywords":[]},{"title":"typescript常用操作","slug":"typescript常用操作","date":"2019-04-04T06:51:07.030Z","updated":"2019-05-24T09:21:03.008Z","comments":true,"path":"2019/04/04/typescript常用操作/","link":"","permalink":"http://yoursite.com/2019/04/04/typescript常用操作/","excerpt":"","text":"保留两位小数12345Math.floor(15.7784514000 * 100) / 100 // 输出结果为 15.77parseInt(7/2) // 丢弃小数部分,保留整数部分const a = 2.461;const b = (parseInt(a * 100) / 100).toFixed(2); // 2.46 创建Map并赋值1const map = new Map([[2, &apos;foo&apos;], [1, &apos;bar&apos;]]); 判断Map类型123isMap(obj) &#123; return obj instanceof Map;&#125; 删除数组中的某个元素123const arr = [&apos;a&apos;,&apos;b&apos;,&apos;c&apos;,&apos;d&apos;];arr.splice(1,1);console.log(arr); //[&apos;a&apos;,&apos;c&apos;,&apos;d&apos;]; Object转成Map1const result = new Map(Object.entries(map)); 将Map的key、value转成数组12const values = Array.from(map.values());const keys = Array.from(map.keys()); 求数组最大值12const maxN = Math.max.apply(null,ary);const minN = Math.min.apply(null,ary); 实现Map的深克隆1234567891011121314151617181920212223export class MapUtils &#123; public static deepClone(obj) &#123; if (!obj || true === obj) &#123; // this also handles boolean as true and false return obj; &#125; const objType = typeof(obj); if (&apos;number&apos; === objType || &apos;string&apos; === objType) &#123; // add your immutables here return obj; &#125; const result = Array.isArray(obj) ? [] : !obj.constructor ? &#123;&#125; : new obj.constructor(); if (obj instanceof Map) &#123; for (const key of obj.keys()) &#123; result.set(key, this.deepClone(obj.get(key))); &#125; &#125; for (const key in obj) &#123; if (obj.hasOwnProperty(key)) &#123; result[key] = this.deepClone(obj[key]); &#125; &#125; return result; &#125;&#125; 参考：https://stackoverflow.com/questions/8206988/clone-copy-a-map-instance/39643085#39643085 请求的url后面添加时间戳参数或者随机数的参数1234// 添加时间戳...?time=new Date();// 添加随机数...?number=Math.random();","categories":[],"tags":[{"name":"js","slug":"js","permalink":"http://yoursite.com/tags/js/"}],"keywords":[]},{"title":"world目录，显示“错误！未定义书签”","slug":"world目录，显示“错误！未定义书签","date":"2019-04-04T06:40:18.116Z","updated":"2019-04-04T04:06:35.086Z","comments":true,"path":"2019/04/04/world目录，显示“错误！未定义书签/","link":"","permalink":"http://yoursite.com/2019/04/04/world目录，显示“错误！未定义书签/","excerpt":"","text":"解决方法：全选后CTRL+SHIFT+F9参考：https://zhidao.baidu.com/question/421631748.html","categories":[],"tags":[{"name":"office","slug":"office","permalink":"http://yoursite.com/tags/office/"}],"keywords":[]},{"title":"Drag And Drop In Angular 7","slug":"angularInDragAndDrop","date":"2019-04-04T06:36:53.285Z","updated":"2019-04-04T06:30:28.577Z","comments":true,"path":"2019/04/04/angularInDragAndDrop/","link":"","permalink":"http://yoursite.com/2019/04/04/angularInDragAndDrop/","excerpt":"","text":"resource-grouping-listhtml:123456789&lt;button nz-button nzType=&quot;primary&quot; (click)=&quot;showModal(0, null, &apos;新建分组&apos;)&quot;&gt;&lt;i nz-icon type=&quot;plus&quot;&gt;&lt;/i&gt;新建分组&lt;/button&gt;&lt;nz-table&gt;...&lt;a (click)=&quot;showModal(1, data._id, &apos;修改分组&apos;)&quot;&gt;&lt;i nz-icon type=&quot;form&quot;&gt;&lt;/i&gt;&lt;/a&gt;&lt;/nz-table&gt;&lt;nz-modal [(nzVisible)]=&quot;modalIsVisible&quot; [(nzTitle)]=&quot;modalTitle&quot; (nzOnCancel)=&quot;handleCancel()&quot; (nzOnOk)=&quot;handleOk()&quot; nzWidth=&quot;1200&quot;&gt; &lt;app-resource-grouping-form #form [resourceGroupId]=&quot;resourceGroupId&quot;&gt;&lt;/app-resource-grouping-form&gt;&lt;/nz-modal&gt; component:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849export class ResourceGroupingListComponent implements OnInit &#123; resourceGroupId: string; modalTitle = &apos;新增分组&apos;; modalIsVisible = false; modalType = 0; @ViewChild(&apos;form&apos;) form: ResourceGroupingFormComponent; constructor(private message: NzMessageService) &#123;&#125; showModal(type: number, id: string, modalTitle: string): void &#123; this.modalType = type; this.modalTitle = modalTitle; this.modalIsVisible = true; this.resourceGroupId = id; if (type === 1) &#123; this.form.initResourceData(id); &#125; &#125; handleCancel(): void &#123; this.modalIsVisible = false; if (this.modalType === 1) &#123; this.form.clearForm(); &#125; &#125; handleOk(): void &#123; if (this.modalType === 0) &#123; const params = this.form.submitForm(); if (params !== null) &#123; // 调用service添加 this.dealOkResp(resp, this.modalType, &apos;添加成功&apos;); &#125; &#125; else if (this.modalType === 1) &#123; const params = this.form.submitForm(); if (params !== null) &#123; // 调用service修改 this.dealOkResp(resp, this.modalType, &apos;修改成功&apos;); &#125; &#125; &#125; dealOkResp(resp: any, type: number, content: string) &#123; if (resp &amp;&amp; resp._id) &#123; this.modalIsVisible = false; this.message.create(&apos;success&apos;, content); // 刷新列表数据 this.form.clearForm(); &#125; &#125;&#125; resource-grouping-formhtml:1234567891011121314151617181920212223242526272829303132333435363738394041&lt;form nz-form [formGroup]=&quot;validateForm&quot; (ngSubmit)=&quot;submitForm()&quot;&gt; &lt;nz-form-item&gt; &lt;nz-form-control [nzSm]=&quot;5&quot; [nzXs]=&quot;24&quot; [nzOffset]=&quot;3&quot;&gt; &lt;nz-card style=&quot;width:200px;&quot; nzTitle=&quot;已选择的资源&quot;&gt; &lt;div class=&quot;example-container&quot;&gt; &lt;div cdkDropList id=&quot;selectedList&quot; [cdkDropListData]=&quot;selected&quot; [cdkDropListConnectedTo]=&quot;toList&quot; class=&quot;example-list&quot; (cdkDropListDropped)=&quot;drop($event)&quot;&gt; &lt;div class=&quot;example-box&quot; *ngFor=&quot;let item of selected&quot; cdkDrag [cdkDragData]=&quot;item&quot;&gt;&#123;&#123;item.title&#125;&#125; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/nz-card&gt; &lt;/nz-form-control&gt; &lt;ng-container *ngFor=&quot;let entity of resourceTypeMap | keyvalue&quot;&gt; &lt;nz-form-control [nzSm]=&quot;5&quot; [nzXs]=&quot;24&quot;&gt; &lt;nz-card style=&quot;width:200px; margin-bottom: 10px;&quot; [nzTitle]=&quot;entity.key.name&quot;&gt; &lt;div class=&quot;example-container&quot; style=&quot;overflow-y: auto;&quot;&gt; &lt;div cdkDropList [id]=&quot;entity.key.value&quot; [cdkDropListData]=&quot;entity.value&quot; [cdkDropListConnectedTo]=&quot;[&apos;selectedList&apos;]&quot; class=&quot;example-list&quot; [cdkDropListEnterPredicate]=&quot;evenPredicate&quot; (cdkDropListDropped)=&quot;drop($event)&quot;&gt; &lt;div class=&quot;example-box&quot; *ngFor=&quot;let item of entity.value&quot; cdkDrag [cdkDragData]=&quot;item&quot;&gt; &#123;&#123;item.title&#125;&#125; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/nz-card&gt; &lt;/nz-form-control&gt; &lt;/ng-container&gt; &lt;/nz-form-item&gt;&lt;/form&gt; css:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354.example-container &#123; width: 200px; max-width: 100%; display: inline-block; vertical-align: top; height: 164px;&#125;.example-list &#123; border: solid 1px #ccc; min-height: 33px; background: white; border-radius: 4px; overflow: hidden; display: block;&#125;.example-box &#123; padding: 6px 6px; border-bottom: solid 1px #ccc; color: rgba(0, 0, 0, 0.87); display: flex; flex-direction: row; align-items: center; justify-content: space-between; box-sizing: border-box; cursor: move; background: white; font-size: 14px;&#125;.cdk-drag-preview &#123; box-sizing: border-box; border-radius: 4px; box-shadow: 0 5px 5px -3px rgba(0, 0, 0, 0.2), 0 8px 10px 1px rgba(0, 0, 0, 0.14), 0 3px 14px 2px rgba(0, 0, 0, 0.12);&#125;.cdk-drag-placeholder &#123; opacity: 0;&#125;.cdk-drag-animating &#123; transition: transform 250ms cubic-bezier(0, 0, 0.2, 1);&#125;.example-box:last-child &#123; border: none;&#125;.example-list.cdk-drop-list-dragging .example-box:not(.cdk-drag-placeholder) &#123; transition: transform 250ms cubic-bezier(0, 0, 0.2, 1);&#125; component:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798export class ResourceGroupingFormComponent implements OnInit &#123; validateForm: FormGroup; selected = []; toList = []; resourceTypeMap: Map&lt;any, any[]&gt; = new Map(); resourceType = [&#123; name: &apos;主机&apos;, value: &apos;HOST&apos;, data: [&#123; key: &quot;192.168.174.170&quot;, title: &quot;192.168.174.170&quot;, type: &quot;HOST&quot; &#125;] &#125;, &#123; name: &apos;数据库&apos;, value: &apos;DATABASE&apos;, data: [&#123; key: &quot;orcl&quot;, title: &quot;192.168.174.154 orcl&quot;, type: &quot;DATABASE&quot; &#125;] &#125;]; @Input() resourceGroupId: string = null; evenPredicate(item: CdkDrag&lt;any&gt;, drop: CdkDropList) &#123; if (item.data.type === drop.id) &#123; return true; &#125; return false; &#125; drop(event: CdkDragDrop&lt;any[]&gt;) &#123; if (event.previousContainer === event.container) &#123; moveItemInArray(event.container.data, event.previousIndex, event.currentIndex); &#125; else &#123; transferArrayItem(event.previousContainer.data, event.container.data, event.previousIndex, event.currentIndex); &#125; &#125; constructor(private fb: FormBuilder) &#123;&#125; ngOnInit() &#123; this.initValidateForm(); &#125; initValidateForm() &#123; this.validateForm = this.fb.group(&#123; groupName: [null, [Validators.required]], &#125;); this.initFormData(); &#125; initFormData() &#123; this.selected = []; this.toList = []; this.resourceTypeMap = new Map&lt;any, any[]&gt;(); this.resourceType.forEach(item =&gt; &#123; this.resourceTypeMap.set(item, item.data); this.toList.push(item.value); &#125;); &#125; submitForm(): any &#123; if (this.validateForm.invalid) &#123; this.validAlarmForm(this.validateForm); return null; &#125; const resources = this.selected.map(item =&gt; new Resource(item.key, item.title, item.type)); this.setFormVal(this.validateForm, &apos;resources&apos;, resources); return this.validateForm.value; &#125; validForm(form: FormGroup) &#123; for (const key in form.controls) &#123; const control = form.controls[key]; if (control instanceof FormGroup) &#123; this.validForm(control); &#125; else if (control instanceof FormControl) &#123; control.markAsDirty(); control.updateValueAndValidity(); &#125; &#125; &#125; setFormVal(form: FormGroup, name: string, val: any) &#123; const formControl = new FormControl(); formControl.setValue(val); form.setControl(name, formControl); &#125; clearForm() &#123; this.validateForm.reset(); this.initFormData(); &#125;&#125; app.module.ts:12345import &#123; DragDropModule &#125; from &apos;@angular/cdk/drag-drop&apos;; imports: [ DragDropModule ], 参考:https://www.c-sharpcorner.com/article/drag-and-drop-using-angular-7/https://material.angular.io/cdk/drag-drop/overview其它插件:https://github.com/ObaidUrRehman/ng-drag-drop#readme","categories":[],"tags":[{"name":"angular","slug":"angular","permalink":"http://yoursite.com/tags/angular/"}],"keywords":[]},{"title":"angular基础-表单处理","slug":"angular基础-表单处理","date":"2019-03-31T04:34:41.855Z","updated":"2019-03-31T04:34:03.538Z","comments":true,"path":"2019/03/31/angular基础-表单处理/","link":"","permalink":"http://yoursite.com/2019/03/31/angular基础-表单处理/","excerpt":"","text":"模板式表单表单的数据模型是通过组件模板中的相关指令来定义的，因为使用这种方式定义表单的数据模型时，我们会受限于HTML的语法，所以，模板驱动方式只适合用于一些简单的场景。 需要在app.module.ts中引入：123imports: [ FormsModule] NgForm / ngNoForm:简单使用：12345&lt;div ngForm&gt;&lt;/div&gt;&lt;form ngNoForm&gt;&lt;/form&gt; 取值：123456&lt;form #myForm=&quot;ngForm&quot;&gt;&lt;/form&gt;&lt;div&gt; &#123;&#123;myForm.value | json&#125;&#125;&lt;/div&gt; 提交：123&lt;form #myForm=&quot;ngForm&quot; (onSubmit)=&quot;onSubmit(myForm.value)&quot;&gt; &lt;button type=&quot;submit&quot;&gt;注册&lt;/button&gt;&lt;/form&gt; NgModel:简单使用：1234&lt;form #myForm=&quot;ngForm&quot; (onSubmit)=&quot;onSubmit(myForm.value)&quot;&gt; &lt;div&gt;用户名：&lt;input ngModel name=&quot;username&quot; type=&quot;text&quot;&gt;&lt;/div&gt; &lt;button type=&quot;submit&quot;&gt;注册&lt;/button&gt;&lt;/form&gt; 取值：12345678&lt;form #myForm=&quot;ngForm&quot; (onSubmit)=&quot;onSubmit(myForm.value)&quot;&gt; &lt;div&gt;用户名：&lt;input #username=&quot;ngModel&quot; ngModel name=&quot;username&quot; type=&quot;text&quot;&gt;&lt;/div&gt; &lt;button type=&quot;submit&quot;&gt;注册&lt;/button&gt;&lt;/form&gt;&lt;div&gt; &#123;&#123;username.value&#125;&#125;&lt;/div&gt; NgModelGroup：简单使用：1234567&lt;div ngModelGroup=&quot;userInfo&quot;&gt; &lt;div&gt;用户名：&lt;input #username=&quot;ngModel&quot; ngModel name=&quot;username&quot; type=&quot;text&quot;&gt;&lt;/div&gt;&lt;/div&gt;&lt;div&gt; &#123;&#123;username.value&#125;&#125; &lt;!-- &#123;&quot;userInfo&quot;: &#123;&quot;username&quot;: &quot;&quot;&#125;&#125; --&gt;&lt;/div&gt; 样例：html：123456789&lt;form #myForm=&quot;ngForm&quot; (onSubmit)=&quot;onSubmit(myForm.value)&quot;&gt; &lt;div&gt;用户名：&lt;input ngModel name=&quot;username&quot; type=&quot;text&quot;&gt;&lt;/div&gt; &lt;div&gt;手机号：&lt;input ngModel name=&quot;mobile&quot; type=&quot;number&quot;&gt;&lt;/div&gt; &lt;div ngModelGroup=&quot;passwordsGroup&quot;&gt; &lt;div&gt;密码：&lt;input ngModel name=&quot;password&quot; type=&quot;password&quot;&gt;&lt;/div&gt; &lt;div&gt;确认密码：&lt;input ngModel name=&quot;pconfirm&quot; type=&quot;password&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;button type=&quot;submit&quot;&gt;注册&lt;/button&gt;&lt;/form&gt; component:123onSubmit(value: any) &#123; console.log(value);&#125; 响应式表单使用响应式表单时，那你通过编写TypeScript代码而不是Html代码来创建一个底层的数据模型，在这个模型定义好以后，你使用一些特定的指令，将模板上的html元素与底层的数据模型连接在一起。 需要在app.module.ts中引入：123imports: [ ReactiveFormsModule] FormGroup：html12345&lt;form [formGroup]=&quot;formModel&quot; (submit)=&quot;onSubmit()&quot;&gt; &lt;div&gt; &lt;button type=&quot;submit&quot;&gt;保存&lt;/button&gt; &lt;/div&gt;&lt;/form&gt; component12345formModel: FormGroup = new FormGroup (&#123;&#125;);onSubmit() &#123; console.log(this.formModel.value);&#125; FormControl：html12345678910&lt;form [formGroup]=&quot;formModel&quot; (submit)=&quot;onSubmit()&quot;&gt; &lt;input formControlName=&quot;username&quot;&gt; &lt;div formGroupName=&quot;dateRange&quot;&gt; 起始日期：&lt;input type=&quot;date&quot; formControlName=&quot;from&quot;&gt; 截止日期：&lt;input type=&quot;date&quot; formControlName=&quot;to&quot;&gt; &lt;/div&gt; &lt;div&gt; &lt;button type=&quot;submit&quot;&gt;保存&lt;/button&gt; &lt;/div&gt;&lt;/form&gt; component1234567formModel: FormGroup = new FormGroup (&#123; username: new FormControl(&apos;aaa&apos;), dateRange: new FormGroup(&#123; from: new FormControl(), to: new FormControl() &#125;)&#125;); FormArray：html1234567891011121314151617&lt;form [formGroup]=&quot;formModel&quot; (submit)=&quot;onSubmit()&quot;&gt; &lt;div formGroupName=&quot;dateRange&quot;&gt; 起始日期：&lt;input type=&quot;date&quot; formControlName=&quot;from&quot;&gt; 截止日期：&lt;input type=&quot;date&quot; formControlName=&quot;to&quot;&gt; &lt;/div&gt; &lt;div&gt; &lt;ul formArrayName=&quot;emails&quot;&gt; &lt;li *ngFor=&quot;let e of this.formModel.get(&apos;emails&apos;).controls; let i = index;&quot;&gt; &lt;input type=&quot;text&quot; [formControlName]=&quot;i&quot;&gt; &lt;/li&gt; &lt;/ul&gt; &lt;button type=&quot;button&quot; (click)=&quot;addEmail()&quot;&gt;增加Email&lt;/button&gt; &lt;/div&gt; &lt;div&gt; &lt;button type=&quot;submit&quot;&gt;保存&lt;/button&gt; &lt;/div&gt;&lt;/form&gt; component123456789101112131415formModel: FormGroup = new FormGroup (&#123; dateRange: new FormGroup(&#123; from: new FormControl(), to: new FormControl() &#125;), emails: new FormArray(&#123; new FormControl(&quot;a@a.com&quot;), new FormControl(&quot;b@b.com&quot;) &#125;)&#125;);addEmail() &#123; let emails = this.formModel.get(&apos;emails&apos;) as FormArray; emails.push(new FormControl());&#125; 样例html123456789&lt;form [FormGroup]=&quot;formModel&quot; (onSubmit)=&quot;onSubmit()&quot;&gt; &lt;div&gt;用户名：&lt;input type=&quot;text&quot; formControlName=&quot;username&quot;&gt;&lt;/div&gt; &lt;div&gt;手机号：&lt;input type=&quot;number&quot; formControlName=&quot;mobile&quot;&gt;&lt;/div&gt; &lt;div formGroupName=&quot;passwordsGroup&quot;&gt; &lt;div&gt;密码：&lt;input type=&quot;password&quot; formControlName=&quot;password&quot;&gt;&lt;/div&gt; &lt;div&gt;确认密码：&lt;input type=&quot;password&quot; formControlName=&quot;pconfirm&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;button type=&quot;submit&quot;&gt;注册&lt;/button&gt;&lt;/form&gt; component123456789101112formModel: FormGroup;constructor() &#123; this.formModel = new FormGroup (&#123; username: new FormControl(), mobile: new FormControl(), passwordsGroup: new FormGroup(&#123; password: new FormControl(), pconfirm: new FormControl() &#125;) &#125;);&#125; FromBuilder通过FromBuilder简化代码123456789101112formModel: FormGroup;constructor(fb: FormBuilder) &#123; this.formModel = fb.group (&#123; username: [&apos;&apos;], mobile: [&apos;&apos;], passwordsGroup: fb.group(&#123; password: [&apos;&apos;], pconfirm: [&apos;&apos;] &#125;) &#125;);&#125; 表单验证html123456789101112131415161718192021222324&lt;form [FormGroup]=&quot;formModel&quot; (onSubmit)=&quot;onSubmit()&quot;&gt; &lt;div&gt;用户名：&lt;input type=&quot;text&quot; formControlName=&quot;username&quot;&gt;&lt;/div&gt; &lt;div [hidden]=&quot;!formModel.hasError(&apos;required&apos;, &apos;username&apos;)&quot;&gt; 用户名是必填项 &lt;/div&gt; &lt;div [hidden]=&quot;!formModel.hasError(&apos;minLength&apos;, &apos;username&apos;)&quot;&gt; 用户名最小长度是6 &lt;/div&gt; &lt;div&gt;手机号：&lt;input type=&quot;number&quot; formControlName=&quot;mobile&quot;&gt;&lt;/div&gt; &lt;div [hidden]=&quot;!formModel.hasError(&apos;mobile&apos;, &apos;mobile&apos;)&quot;&gt; 请输入正确的手机号 &lt;/div&gt; &lt;div formGroupName=&quot;passwordsGroup&quot;&gt; &lt;div&gt;密码：&lt;input type=&quot;password&quot; formControlName=&quot;password&quot;&gt;&lt;/div&gt; &lt;div [hidden]=&quot;!formModel.hasError(&apos;minLength&apos;, [&apos;passwordsGroup&apos;, [&apos;password&apos;]])&quot;&gt; 密码最小长度是6 &lt;/div&gt; &lt;div&gt;确认密码：&lt;input type=&quot;password&quot; formControlName=&quot;pconfirm&quot;&gt;&lt;/div&gt; &lt;div [hidden]=&quot;!formModel.hasError(&apos;equal&apos;, &apos;passwordsGroup&apos;)&quot;&gt; &#123;&#123;formModel.getError(&apos;equal&apos;, &apos;passwordsGroup&apos;)?.descxxx&#125;&#125; &lt;/div&gt; &lt;/div&gt; &lt;button type=&quot;submit&quot;&gt;注册&lt;/button&gt;&lt;/form&gt; component12345678910111213141516171819202122232425262728293031323334353637383940414243444546// 可以将以下angular校验器抽取到一个ts文件中mobileValidator(control: FormControl): any &#123; const myreq = /^(((13[0-9]&#123;1&#125;)|(15[0-9]&#123;1&#125;)|(18[0-9]&#123;1&#125;))+\\d&#123;8&#125;)$/; const valid = myreq.test(control.calue); console.log(&apos;mobile的校验结果是：&apos; + valid); return valid ? null : &#123;mobile: true&#125;;&#125;mobileAsyncValidator(control: FormControl): any &#123; const myreq = /^(((13[0-9]&#123;1&#125;)|(15[0-9]&#123;1&#125;)|(18[0-9]&#123;1&#125;))+\\d&#123;8&#125;)$/; const valid = myreq.test(control.calue); console.log(&apos;mobile的校验结果是：&apos; + valid); // 模拟异步 return Observable.of(valid ? null : &#123;mobile: true&#125;).delay(5000);&#125;equalValidator(group: FormGroup): any &#123; const password: FormControl = group.get(&apos;password&apos;) as FormControl; const pconfirm: FormControl = group.get(&apos;pconfirm&apos;) as FormControl; const valid: boolean = (password.value === pconfirm.value); console.log(&apos;密码的校验结果是：&apos; + valid); return valid ? null : &#123;equal: &#123;descxxx: &apos;密码和确认密码不匹配&apos;&#125;&#125;;&#125;formModel: FormGroup;constructor(fb: FormBuilder) &#123; this.formModel = fb.group (&#123; username: [&apos;&apos;, [Vaildators.required, Validators.minLength(6)]], mobile: [&apos;&apos;, this.mobileValidator], passwordsGroup: fb.group(&#123; password: [&apos;&apos;], pconfirm: [&apos;&apos;] &#125;, &#123;validator: this.equalValidator&#125;) &#125;);&#125;onSubmit() &#123; // const isValid: boolean = this.formModel.get(&apos;username&apos;).valid; // console.log(&apos;username的校验结果：&apos; + isValid); // const errors: any = this.formModel.get(&quot;username&quot;).errors; // console.log(&apos;username的错误信息是：&apos; + JSON.stringify(errors)); if (this.formModel.valid) &#123; console.log(this.formModel.value); &#125;&#125; 状态字段touched和untouched123456789&lt;form [FormGroup]=&quot;formModel&quot; (onSubmit)=&quot;onSubmit()&quot;&gt; &lt;div&gt;用户名：&lt;input type=&quot;text&quot; formControlName=&quot;username&quot;&gt;&lt;/div&gt; &lt;div [hidden]=&quot;formModel.get(&apos;mobile&apos;).valid || formModel.get(&apos;mobile&apos;).untouched&quot;&gt; &lt;div [hidden]=&quot;!formModel.hasError(&apos;required&apos;, &apos;username&apos;)&quot;&gt; 用户名是必填项 &lt;/div&gt; &lt;/div&gt; ...&lt;/form&gt; pristine和dirty123456789&lt;form [FormGroup]=&quot;formModel&quot; (onSubmit)=&quot;onSubmit()&quot;&gt; &lt;div&gt;用户名：&lt;input type=&quot;text&quot; formControlName=&quot;username&quot;&gt;&lt;/div&gt; &lt;div [hidden]=&quot;formModel.get(&apos;mobile&apos;).valid || formModel.get(&apos;mobile&apos;).pristine&quot;&gt; &lt;div [hidden]=&quot;!formModel.hasError(&apos;required&apos;, &apos;username&apos;)&quot;&gt; 用户名是必填项 &lt;/div&gt; &lt;/div&gt; ...&lt;/form&gt; pending123456&lt;form [FormGroup]=&quot;formModel&quot; (onSubmit)=&quot;onSubmit()&quot;&gt; &lt;div [hidden]=&quot;!formModel.get(&apos;mobile&apos;).pending&quot;&gt; 正在校验手机合法性 &lt;/div&gt; ...&lt;/form&gt;","categories":[],"tags":[{"name":"angular","slug":"angular","permalink":"http://yoursite.com/tags/angular/"}],"keywords":[]},{"title":"kapacitor lambda","slug":"kapacitor_lambda","date":"2019-03-28T08:04:01.420Z","updated":"2019-05-24T09:14:23.994Z","comments":true,"path":"2019/03/28/kapacitor_lambda/","link":"","permalink":"http://yoursite.com/2019/03/28/kapacitor_lambda/","excerpt":"","text":"lambda使用简单使用：123|where(lambda: &quot;tag&quot; == &apos;v1&apos; AND &quot;field&quot; == &apos;v2&apos;)|eval(lambda: (&quot;field1&quot; - &quot;field2&quot;) / &quot;field3&quot; * 100.0)|eval(lambda: float(&quot;field1&quot;) / float(&quot;field2&quot;) * 100.0) 保留两位小数：1|eval(lambda: float(int(&quot;field&quot; * 100.0)) / 100.0) // 保留两位小数","categories":[],"tags":[{"name":"kapacitor","slug":"kapacitor","permalink":"http://yoursite.com/tags/kapacitor/"}],"keywords":[]},{"title":"influxdb query","slug":"influxdb_query","date":"2019-03-28T07:26:05.838Z","updated":"2019-03-28T07:34:31.930Z","comments":true,"path":"2019/03/28/influxdb_query/","link":"","permalink":"http://yoursite.com/2019/03/28/influxdb_query/","excerpt":"","text":"注意点 查询结果如果要显示tag，则无需指定查询tag，只需要在GROUP BY 中带上tag。 如果GROUP BY 除了time 还有其它tag，则最好不要加fill(previous)，否则数据可能会错乱。 SELECT * FROM (SELECT …) 会将值为空的数据过滤掉。 GROUP BY time() 之后要确定用FIRST() 或 LAST()。 如果查询的字段带有空格，则需要使用”字段名”查询。 demo数据以下数据来自telegraf 的[[inputs.prometheus]] 插件，每隔10秒从oracle_exporter中采集数据并写回influxdb，database为telegraf，measurement为oracledb_physical_iops，counter为field，其它为tag，部分tag省略，部分值已被修改。1234567891011121314# time counter database dbinstance host id type1 2019/3/28 6:21:20 1 orcl ip1 localhost orcl read_iops2 2019/3/28 6:21:20 2 orcl ip1 localhost orcl write_iops3 2019/3/28 6:21:20 1 orcl2 ip2 localhost orcl2 read_iops4 2019/3/28 6:21:20 2 orcl2 ip2 localhost orcl2 write_iops5 2019/3/28 6:21:30 1 orcl ip1 localhost orcl read_iops6 2019/3/28 6:21:30 2 orcl ip1 localhost orcl write_iops7 2019/3/28 6:21:30 1 orcl2 ip2 localhost orcl2 read_iops8 2019/3/28 6:21:30 2 orcl2 ip2 localhost orcl2 write_iops[...]13 2019/3/28 6:21:50 1 orcl ip1 localhost orcl read_iops14 2019/3/28 6:21:50 2 orcl ip1 localhost orcl write_iops15 2019/3/28 6:21:50 1 orcl2 ip2 localhost orcl2 read_iops16 2019/3/28 6:21:50 2 orcl2 ip2 localhost orcl2 write_iops mavenpom.xml：123456&lt;!-- https://mvnrepository.com/artifact/org.influxdb/influxdb-java --&gt;&lt;dependency&gt; &lt;groupId&gt;org.influxdb&lt;/groupId&gt; &lt;artifactId&gt;influxdb-java&lt;/artifactId&gt; &lt;version&gt;2.14&lt;/version&gt;&lt;/dependency&gt; springbootapplication.yml：123spring: influx: url: http://localhost:8086 javaconfig：12345678910111213141516171819@Componentpublic class InfluxDbHolder &#123; private final InfluxDBResultMapper mapper; private final InfluxDB db; @Autowired public InfluxDbHolder(InfluxDB db) &#123; this.db = db; this.mapper = new InfluxDBResultMapper(); &#125; public InfluxDBResultMapper getMapper() &#123; return mapper; &#125; public InfluxDB getDb() &#123; return db; &#125;&#125; entity：1234567891011121314@Data@Measurement(name = &quot;oracledb_physical_iops&quot;)public class DbIOps &#123; @Column(name = &quot;time&quot;) @JsonDeserialize(using = InstantJacksonDeserialize.class) @JsonSerialize(using = InstantJacksonSerializer.class) private Instant time; @Column(name = &quot;type&quot;, tag = true) private String type; @Column(name = &quot;counter&quot;) private Integer counter;&#125; 123456789101112131415161718@Datapublic class InfluxdbCriteria &#123; private Integer during; private Integer groupTime; private Integer offset; public void validate() &#123; if (during == null) &#123; during = 1; &#125; if (groupTime == null) &#123; groupTime = 10; &#125; if (offset == null) &#123; offset = 0; &#125; &#125;&#125; service：1234567891011121314151617181920public Map&lt;Instant, List&lt;DbIOps&gt;&gt; getDatabaseIOps(String dbId, InfluxdbCriteria databaseCriteria) &#123; databaseCriteria.validate(); Integer during = databaseCriteria.getDuring(); Integer groupTime = databaseCriteria.getGroupTime(); Integer offset = databaseCriteria.getOffset(); String sql = &quot;SELECT first(counter) as counter &quot; + &quot;FROM oracledb_physical_iops &quot; + &quot;WHERE id=&apos;&quot;+ dbId + &quot;&apos; AND time &gt; now() - &quot; + during + &quot;h &quot; + &quot;group by type, time(&quot;+ groupTime + &quot;m, &quot; + offset + &quot;s)&quot;; Query query = new Query(sql, &quot;telegraf&quot;); QueryResult result = holder.getDb().query(query); List&lt;DbIOps&gt; dbIOpsList = holder.getMapper().toPOJO(result, DbIOps.class); Map&lt;Instant, List&lt;DbIOps&gt;&gt; map = dbIOpsList.stream().collect(Collectors.groupingBy(DbIOps::getTime)); //对时间排序 Map&lt;Instant, List&lt;DbIOps&gt;&gt; sortMap = new TreeMap&lt;&gt;((Instant instant1, Instant instant2) -&gt; instant1.compareTo(instant2)); sortMap.putAll(map); return sortMap;&#125; controller：1234@GetMapping(&quot;/databaseIOps/&#123;dbId&#125;&quot;)public ResponseEntity getDatabaseIOps(@PathVariable String dbId, InfluxdbCriteria databaseCriteria) &#123; return ResponseEntity.ok(databaseService.getDatabaseIOps(dbId, databaseCriteria));&#125; angularservice：123456789101112131415161718/** * 查询数据库IOpsmetrics */getDatabaseIOps(dbId: string, during: number): Observable&lt;any&gt; &#123; // during: 最近during小时 const params = DateUtils.getInfluxdbParams(during); return this.http.get&lt;any&gt;(`databaseIOps/$&#123;dbId&#125;`, &#123; params: &#123; during: String(during), groupTime: String(params.groupTime), offset: String(params.offset) &#125; &#125;).pipe( retry(1), catchError(this.handleError.bind(this)) );&#125; utils：1234567891011121314151617export class DateUtils &#123; public static getInfluxdbParams(during: number): any &#123; let groupTime = 10; let offset = 0; if (during === 1) &#123; groupTime = 5; offset = (moment().minutes() % 5) * 60 - 30; &#125; else if (during === 3) &#123; groupTime = 15; offset = (moment().minutes() % 15) * 60 - 30; &#125; else if (during === 12) &#123; groupTime = 60; offset = (moment().minutes() % 60) * 60 - 30; &#125; return &#123;groupTime: groupTime, offset: offset&#125;; &#125;&#125;","categories":[],"tags":[{"name":"influxdb","slug":"influxdb","permalink":"http://yoursite.com/tags/influxdb/"}],"keywords":[]},{"title":"oracle账号","slug":"oracle账号","date":"2019-03-28T04:03:26.105Z","updated":"2019-03-28T03:33:24.496Z","comments":true,"path":"2019/03/28/oracle账号/","link":"","permalink":"http://yoursite.com/2019/03/28/oracle账号/","excerpt":"","text":"用户名：541509124@qq.com密码：LR4ever.1314 参考：https://blog.csdn.net/dengxt/article/details/81536099","categories":[],"tags":[{"name":"oracle","slug":"oracle","permalink":"http://yoursite.com/tags/oracle/"}],"keywords":[]},{"title":"influxdb issues","slug":"influxdb","date":"2019-03-28T04:03:05.994Z","updated":"2019-03-28T03:07:45.935Z","comments":true,"path":"2019/03/28/influxdb/","link":"","permalink":"http://yoursite.com/2019/03/28/influxdb/","excerpt":"","text":"org.influxdb.InfluxDBIOException: java.net.SocketTimeoutException: timeout使用influxdb的java客户端连接influxdb：1InfluxDB influxDB = InfluxDBFactory.connect(&quot;http://localhost:8086&quot;); 报错：123Exception in thread &quot;main&quot; org.influxdb.InfluxDBIOException: java.net.SocketTimeoutException: timeout at org.influxdb.impl.InfluxDBImpl.execute(InfluxDBImpl.java:800) at org.influxdb.impl.InfluxDBImpl.write(InfluxDBImpl.java:455) 更改OKHttpClient的默认超时：123456OkHttpClient.Builder client = new OkHttpClient.Builder() .connectTimeout(1, TimeUnit.MINUTES) .readTimeout(1, TimeUnit.MINUTES) .writeTimeout(2, TimeUnit.MINUTES) .retryOnConnectionFailure(true);InfluxDB influxDB = InfluxDBFactory.connect(&quot;http://localhost:8086&quot;, client); 参考：https://github.com/influxdata/influxdb-javahttps://stackoverflow.com/questions/50922473/influxdbioexception-java-net-sockettimeoutexception-timeout","categories":[],"tags":[{"name":"influxdb","slug":"influxdb","permalink":"http://yoursite.com/tags/influxdb/"}],"keywords":[]},{"title":"Chrome中启用Flash","slug":"Chrome中启用Flash","date":"2019-03-28T04:02:26.147Z","updated":"2019-03-27T13:26:53.572Z","comments":true,"path":"2019/03/28/Chrome中启用Flash/","link":"","permalink":"http://yoursite.com/2019/03/28/Chrome中启用Flash/","excerpt":"","text":"参考：https://support.digication.com/hc/en-us/articles/115003963468-Enabling-Flash-for-Google-Chrome-Windows-Macintosh-","categories":[],"tags":[{"name":"Chrome","slug":"Chrome","permalink":"http://yoursite.com/tags/Chrome/"}],"keywords":[]},{"title":"jdk1.8新特性","slug":"java8","date":"2019-03-28T03:44:49.456Z","updated":"2019-07-26T07:31:58.387Z","comments":true,"path":"2019/03/28/java8/","link":"","permalink":"http://yoursite.com/2019/03/28/java8/","excerpt":"","text":"HashMap结构 HashMap如果不用Hash算法、Hash表，那么每添加一个元素都要进行equals判断一次，效率很慢，HashMap默认大小为16。 jdk1.7 数组+链表 首先取对象的HashCode进行运算，生成数组的索引值，根据索引值找到位置，如果对应位置没有元素，则直接存储。如果存在元素，再通过equals比较两个对象的内容，如果内容一样，则覆盖原先的值，内容不一样，则在表头插入，形成链表。我们应该尽量减少元素的碰撞，否则效率很低，一旦出现碰撞，就得遍历整个链表的元素进行equals判断，所以HashCode和equals要尽量写得严谨些。但是，即使再严谨碰撞的情况也避免不了。所以HashMap提供了加载因子，当HashMap的大小超过75%时进行扩容，将会对元素重新运算位置，碰撞的概率也因此降低。 jdk1.8 数组+链表+红黑树 当某个链表的长度 &gt; 8 并且总元素 &gt; 64时，将会把链表转成红黑树。这样的好处是，出了添加操作，其他的操作都比链表快，而且扩容时，只需要将整棵树从新运算位置即可。同时，ConcurrentHashMap 的结构也跟着改变，也是数组+链表+红黑树的结构删除了concurrentlevel = 16,采用CAS算法，效率比锁高。 JVM内存结构 jdk1.7 存在永久区，永久区也会被垃圾回收，只是回收机制比较苛刻。 jdk1.8 没有永久区，取而代之的是MetaSpace元空间。元空间使用的是物理内存（物理内存有多大，元空间就有多大）只有当元空间的容量快满时，才会被回收。现在取决于物理内存（很大）。所以，垃圾回收机制触发的概率也低了。OOM发生的概率也低了。调优参数由以前的PremGenSize、MaxPremGenSize替换为MetaSpaceSize和MaxMetaSpaceSize 接口中的默认方法与静态方法demo1:12345public interface MyFun &#123; default String getName()&#123; return &quot;哈哈哈&quot;; &#125;&#125; 12345public class MyClass &#123; public String getName()&#123; return &quot;嘿嘿嘿&quot;; &#125;&#125; 1public class SubClass extends MyClass implements MyFun &#123;&#125; 123456public class TestDefaultInterface &#123; public static void main(String[] args) &#123; SubClass sc = new SubClass(); System.out.println(sc.getName()); //嘿嘿嘿 &#125;&#125; demo2:123456789public interface MyInterface &#123; default String getName()&#123; return &quot;呵呵呵&quot;; &#125; public static void show()&#123; System.out.println(&quot;接口中的静态方法&quot;); &#125;&#125; 123456public class SubClass /*extends MyClass*/ implements MyFun, MyInterface&#123; @Override public String getName() &#123; return MyInterface.super.getName(); &#125;&#125; 12345678public class TestDefaultInterface &#123; public static void main(String[] args) &#123; SubClass sc = new SubClass(); System.out.println(sc.getName()); //呵呵呵 MyInterface.show(); //接口中的静态方法 &#125;&#125; Stream API 的操作步骤创建 Stream：12345678910111213141516171819202122232425//创建 Stream： @Test public void test1()&#123; //1. Collection 提供了两个方法 stream() 与 parallelStream() List&lt;String&gt; list = new ArrayList&lt;&gt;(); Stream&lt;String&gt; stream = list.stream(); //获取一个顺序流 Stream&lt;String&gt; parallelStream = list.parallelStream(); //获取一个并行流 //2. 通过 Arrays 中的 stream() 获取一个数组流 Integer[] nums = new Integer[10]; Stream&lt;Integer&gt; stream1 = Arrays.stream(nums); //3. 通过 Stream 类中静态方法 of() Stream&lt;Integer&gt; stream2 = Stream.of(1,2,3,4,5,6); //4. 创建无限流 //迭代 Stream&lt;Integer&gt; stream3 = Stream.iterate(0, (x) -&gt; x + 2).limit(10); stream3.forEach(System.out::println); //生成 Stream&lt;Double&gt; stream4 = Stream.generate(Math::random).limit(2); stream4.forEach(System.out::println); &#125; 中间操作：12345678910// 初始化数据 List&lt;Employee&gt; emps = Arrays.asList( new Employee(102, &quot;李四&quot;, 59, 6666.66, Status.BUSY), new Employee(101, &quot;张三&quot;, 18, 9999.99, Status.FREE), new Employee(103, &quot;王五&quot;, 28, 3333.33, Status.VOCATION), new Employee(104, &quot;赵六&quot;, 8, 7777.77, Status.BUSY), new Employee(104, &quot;赵六&quot;, 8, 7777.77, Status.FREE), new Employee(104, &quot;赵六&quot;, 8, 7777.77, Status.FREE), new Employee(105, &quot;田七&quot;, 38, 5555.55, Status.BUSY) ); 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556/* 筛选与切片 filter——接收 Lambda ， 从流中排除某些元素。 limit——截断流，使其元素不超过给定数量。 skip(n) —— 跳过元素，返回一个扔掉了前 n 个元素的流。若流中元素不足 n 个，则返回一个空流。与 limit(n) 互补 distinct——筛选，通过流所生成元素的 hashCode() 和 equals() 去除重复元素 *///内部迭代：迭代操作 Stream API 内部完成@Testpublic void test2()&#123; //所有的中间操作不会做任何的处理 Stream&lt;Employee&gt; stream = emps.stream() .filter((e) -&gt; &#123; System.out.println(&quot;测试中间操作&quot;); return e.getAge() &lt;= 35; &#125;); //只有当做终止操作时，所有的中间操作会一次性的全部执行，称为“惰性求值” stream.forEach(System.out::println);&#125;//外部迭代@Testpublic void test3()&#123; Iterator&lt;Employee&gt; it = emps.iterator(); while(it.hasNext())&#123; System.out.println(it.next()); &#125;&#125;@Testpublic void test4()&#123; emps.stream() .filter((e) -&gt; &#123; System.out.println(&quot;短路！&quot;); // &amp;&amp; || return e.getSalary() &gt;= 5000; &#125;).limit(3) .forEach(System.out::println);&#125;@Testpublic void test5()&#123; emps.parallelStream() .filter((e) -&gt; e.getSalary() &gt;= 5000) .skip(2) .forEach(System.out::println);&#125;@Testpublic void test6()&#123; emps.stream() .distinct() .forEach(System.out::println);&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344/* 映射 map——接收 Lambda ， 将元素转换成其他形式或提取信息。接收一个函数作为参数，该函数会被应用到每个元素上，并将其映射成一个新的元素。 flatMap——接收一个函数作为参数，将流中的每个值都换成另一个流，然后把所有流连接成一个流 */@Testpublic void test1()&#123; Stream&lt;String&gt; str = emps.stream() .map((e) -&gt; e.getName()); System.out.println(&quot;-------------------------------------------&quot;); List&lt;String&gt; strList = Arrays.asList(&quot;aaa&quot;, &quot;bbb&quot;, &quot;ccc&quot;, &quot;ddd&quot;, &quot;eee&quot;); Stream&lt;String&gt; stream = strList.stream() .map(String::toUpperCase); stream.forEach(System.out::println); Stream&lt;Stream&lt;Character&gt;&gt; stream2 = strList.stream() .map(TestStreamAPI1::filterCharacter); stream2.forEach((sm) -&gt; &#123; sm.forEach(System.out::println); &#125;); System.out.println(&quot;---------------------------------------------&quot;); Stream&lt;Character&gt; stream3 = strList.stream() .flatMap(TestStreamAPI1::filterCharacter); stream3.forEach(System.out::println);&#125;public static Stream&lt;Character&gt; filterCharacter(String str)&#123; List&lt;Character&gt; list = new ArrayList&lt;&gt;(); for (Character ch : str.toCharArray()) &#123; list.add(ch); &#125; return list.stream();&#125; 12345678910111213141516171819202122/* sorted()——自然排序 sorted(Comparator com)——定制排序 */@Testpublic void test2()&#123; emps.stream() .map(Employee::getName) .sorted() .forEach(System.out::println); System.out.println(&quot;------------------------------------&quot;); emps.stream() .sorted((x, y) -&gt; &#123; if(x.getAge() == y.getAge())&#123; return x.getName().compareTo(y.getName()); &#125;else&#123; return Integer.compare(x.getAge(), y.getAge()); &#125; &#125;).forEach(System.out::println);&#125; 终止操作：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229/* allMatch——检查是否匹配所有元素 anyMatch——检查是否至少匹配一个元素 noneMatch——检查是否没有匹配的元素 findFirst——返回第一个元素 findAny——返回当前流中的任意元素 count——返回流中元素的总个数 max——返回流中最大值 min——返回流中最小值 */@Testpublic void test1()&#123; boolean bl = emps.stream() .allMatch((e) -&gt; e.getStatus().equals(Status.BUSY)); System.out.println(bl); boolean bl1 = emps.stream() .anyMatch((e) -&gt; e.getStatus().equals(Status.BUSY)); System.out.println(bl1); boolean bl2 = emps.stream() .noneMatch((e) -&gt; e.getStatus().equals(Status.BUSY)); System.out.println(bl2);&#125;@Testpublic void test2()&#123; Optional&lt;Employee&gt; op = emps.stream() .sorted((e1, e2) -&gt; Double.compare(e1.getSalary(), e2.getSalary())) .findFirst(); System.out.println(op.get()); System.out.println(&quot;--------------------------------&quot;); Optional&lt;Employee&gt; op2 = emps.parallelStream() .filter((e) -&gt; e.getStatus().equals(Status.FREE)) .findAny(); System.out.println(op2.get());&#125;@Testpublic void test3()&#123; long count = emps.stream() .filter((e) -&gt; e.getStatus().equals(Status.FREE)) .count(); System.out.println(count); Optional&lt;Double&gt; op = emps.stream() .map(Employee::getSalary) .max(Double::compare); System.out.println(op.get()); Optional&lt;Employee&gt; op2 = emps.stream() .min((e1, e2) -&gt; Double.compare(e1.getSalary(), e2.getSalary())); System.out.println(op2.get());&#125;//注意：流进行了终止操作后，不能再次使用@Testpublic void test4()&#123; Stream&lt;Employee&gt; stream = emps.stream() .filter((e) -&gt; e.getStatus().equals(Status.FREE)); long count = stream.count(); stream.map(Employee::getSalary) .max(Double::compare);&#125;/* 归约 reduce(T identity, BinaryOperator) / reduce(BinaryOperator) ——可以将流中元素反复结合起来，得到一个值。 */@Testpublic void test1()&#123; List&lt;Integer&gt; list = Arrays.asList(1,2,3,4,5,6,7,8,9,10); Integer sum = list.stream() .reduce(0, (x, y) -&gt; x + y); System.out.println(sum); System.out.println(&quot;----------------------------------------&quot;); Optional&lt;Double&gt; op = emps.stream() .map(Employee::getSalary) .reduce(Double::sum); System.out.println(op.get());&#125;//需求：搜索名字中 “六” 出现的次数@Testpublic void test2()&#123; Optional&lt;Integer&gt; sum = emps.stream() .map(Employee::getName) .flatMap(TestStreamAPI1::filterCharacter) .map((ch) -&gt; &#123; if(ch.equals(&apos;六&apos;)) return 1; else return 0; &#125;).reduce(Integer::sum); System.out.println(sum.get());&#125;//collect——将流转换为其他形式。接收一个 Collector接口的实现，用于给Stream中元素做汇总的方法@Testpublic void test3()&#123; List&lt;String&gt; list = emps.stream() .map(Employee::getName) .collect(Collectors.toList()); list.forEach(System.out::println); System.out.println(&quot;----------------------------------&quot;); Set&lt;String&gt; set = emps.stream() .map(Employee::getName) .collect(Collectors.toSet()); set.forEach(System.out::println); System.out.println(&quot;----------------------------------&quot;); HashSet&lt;String&gt; hs = emps.stream() .map(Employee::getName) .collect(Collectors.toCollection(HashSet::new)); hs.forEach(System.out::println);&#125;@Testpublic void test4()&#123; Optional&lt;Double&gt; max = emps.stream() .map(Employee::getSalary) .collect(Collectors.maxBy(Double::compare)); System.out.println(max.get()); Optional&lt;Employee&gt; op = emps.stream() .collect(Collectors.minBy((e1, e2) -&gt; Double.compare(e1.getSalary(), e2.getSalary()))); System.out.println(op.get()); Double sum = emps.stream() .collect(Collectors.summingDouble(Employee::getSalary)); System.out.println(sum); Double avg = emps.stream() .collect(Collectors.averagingDouble(Employee::getSalary)); System.out.println(avg); Long count = emps.stream() .collect(Collectors.counting()); System.out.println(count); System.out.println(&quot;--------------------------------------------&quot;); DoubleSummaryStatistics dss = emps.stream() .collect(Collectors.summarizingDouble(Employee::getSalary)); System.out.println(dss.getMax());&#125;//分组@Testpublic void test5()&#123; Map&lt;Status, List&lt;Employee&gt;&gt; map = emps.stream() .collect(Collectors.groupingBy(Employee::getStatus)); System.out.println(map);&#125;//多级分组@Testpublic void test6()&#123; Map&lt;Status, Map&lt;String, List&lt;Employee&gt;&gt;&gt; map = emps.stream() .collect(Collectors.groupingBy(Employee::getStatus, Collectors.groupingBy((e) -&gt; &#123; if(e.getAge() &gt;= 60) return &quot;老年&quot;; else if(e.getAge() &gt;= 35) return &quot;中年&quot;; else return &quot;成年&quot;; &#125;))); System.out.println(map);&#125;//分区@Testpublic void test7()&#123; Map&lt;Boolean, List&lt;Employee&gt;&gt; map = emps.stream() .collect(Collectors.partitioningBy((e) -&gt; e.getSalary() &gt;= 5000)); System.out.println(map);&#125;//@Testpublic void test8()&#123; String str = emps.stream() .map(Employee::getName) .collect(Collectors.joining(&quot;,&quot; , &quot;----&quot;, &quot;----&quot;)); System.out.println(str);&#125;@Testpublic void test9()&#123; Optional&lt;Double&gt; sum = emps.stream() .map(Employee::getSalary) .collect(Collectors.reducing(Double::sum)); System.out.println(sum.get());&#125; 时间日期操作jdk8以前时间操作线程问题：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293 class DateFormatThreadLocal &#123; private static final ThreadLocal&lt;DateFormat&gt; df = new ThreadLocal&lt;DateFormat&gt;()&#123; protected DateFormat initialValue()&#123; return new SimpleDateFormat(&quot;yyyyMMdd&quot;); &#125; &#125;; public static final Date convert(String source) throws ParseException&#123; return df.get().parse(source); &#125; &#125;public static void main(String[] args) throws Exception &#123; /*SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyyMMdd&quot;); Callable&lt;Date&gt; task = new Callable&lt;Date&gt;() &#123; @Override public Date call() throws Exception &#123; return sdf.parse(&quot;20161121&quot;); &#125; &#125;; ExecutorService pool = Executors.newFixedThreadPool(10); List&lt;Future&lt;Date&gt;&gt; results = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; 10; i++) &#123; results.add(pool.submit(task)); &#125; for (Future&lt;Date&gt; future : results) &#123; System.out.println(future.get()); &#125; pool.shutdown();*/ //解决多线程安全问题 /*Callable&lt;Date&gt; task = new Callable&lt;Date&gt;() &#123; @Override public Date call() throws Exception &#123; return DateFormatThreadLocal.convert(&quot;20161121&quot;); &#125; &#125;; ExecutorService pool = Executors.newFixedThreadPool(10); List&lt;Future&lt;Date&gt;&gt; results = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; 10; i++) &#123; results.add(pool.submit(task)); &#125; for (Future&lt;Date&gt; future : results) &#123; System.out.println(future.get()); &#125; pool.shutdown();*/ DateTimeFormatter dtf = DateTimeFormatter.ofPattern(&quot;yyyyMMdd&quot;); Callable&lt;LocalDate&gt; task = new Callable&lt;LocalDate&gt;() &#123; @Override public LocalDate call() throws Exception &#123; LocalDate ld = LocalDate.parse(&quot;20161121&quot;, dtf); return ld; &#125; &#125;; ExecutorService pool = Executors.newFixedThreadPool(10); List&lt;Future&lt;LocalDate&gt;&gt; results = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; 10; i++) &#123; results.add(pool.submit(task)); &#125; for (Future&lt;LocalDate&gt; future : results) &#123; System.out.println(future.get()); &#125; pool.shutdown();&#125; 新的时间API12345678910111213141516171819202122//1. LocalDate、LocalTime、LocalDateTime@Testpublic void test1()&#123; LocalDateTime ldt = LocalDateTime.now(); System.out.println(ldt); LocalDateTime ld2 = LocalDateTime.of(2016, 11, 21, 10, 10, 10); System.out.println(ld2); LocalDateTime ldt3 = ld2.plusYears(20); System.out.println(ldt3); LocalDateTime ldt4 = ld2.minusMonths(2); System.out.println(ldt4); System.out.println(ldt.getYear()); System.out.println(ldt.getMonthValue()); System.out.println(ldt.getDayOfMonth()); System.out.println(ldt.getHour()); System.out.println(ldt.getMinute()); System.out.println(ldt.getSecond());&#125; 1234567891011121314//2. Instant : 时间戳。 （使用 Unix 元年 1970年1月1日 00:00:00 所经历的毫秒值）@Testpublic void test2()&#123; Instant ins = Instant.now(); //默认使用 UTC 时区 System.out.println(ins); OffsetDateTime odt = ins.atOffset(ZoneOffset.ofHours(8)); System.out.println(odt); System.out.println(ins.getNano()); Instant ins2 = Instant.ofEpochSecond(5); System.out.println(ins2);&#125; 123456789101112131415161718192021222324252627//3.//Duration : 用于计算两个“时间”间隔//Period : 用于计算两个“日期”间隔@Testpublic void test3()&#123; Instant ins1 = Instant.now(); System.out.println(&quot;--------------------&quot;); try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; &#125; Instant ins2 = Instant.now(); System.out.println(&quot;所耗费时间为：&quot; + Duration.between(ins1, ins2)); System.out.println(&quot;----------------------------------&quot;); LocalDate ld1 = LocalDate.now(); LocalDate ld2 = LocalDate.of(2011, 1, 1); Period pe = Period.between(ld2, ld1); System.out.println(pe.getYears()); System.out.println(pe.getMonths()); System.out.println(pe.getDays());&#125; 123456789101112131415161718192021222324252627282930//4. TemporalAdjuster : 时间校正器@Testpublic void test4()&#123;LocalDateTime ldt = LocalDateTime.now(); System.out.println(ldt); LocalDateTime ldt2 = ldt.withDayOfMonth(10); System.out.println(ldt2); LocalDateTime ldt3 = ldt.with(TemporalAdjusters.next(DayOfWeek.SUNDAY)); System.out.println(ldt3); //自定义：下一个工作日 LocalDateTime ldt5 = ldt.with((l) -&gt; &#123; LocalDateTime ldt4 = (LocalDateTime) l; DayOfWeek dow = ldt4.getDayOfWeek(); if(dow.equals(DayOfWeek.FRIDAY))&#123; return ldt4.plusDays(3); &#125;else if(dow.equals(DayOfWeek.SATURDAY))&#123; return ldt4.plusDays(2); &#125;else&#123; return ldt4.plusDays(1); &#125; &#125;); System.out.println(ldt5);&#125; 123456789101112131415 //5. DateTimeFormatter : 解析和格式化日期或时间 @Test public void test5()&#123;// DateTimeFormatter dtf = DateTimeFormatter.ISO_LOCAL_DATE; DateTimeFormatter dtf = DateTimeFormatter.ofPattern(&quot;yyyy年MM月dd日 HH:mm:ss E&quot;); LocalDateTime ldt = LocalDateTime.now(); String strDate = ldt.format(dtf); System.out.println(strDate); LocalDateTime newLdt = ldt.parse(strDate, dtf); System.out.println(newLdt); &#125; 123456789101112131415//6.ZonedDate、ZonedTime、ZonedDateTime ： 带时区的时间或日期********@Testpublic void test7()&#123; LocalDateTime ldt = LocalDateTime.now(ZoneId.of(&quot;Asia/Shanghai&quot;)); System.out.println(ldt); ZonedDateTime zdt = ZonedDateTime.now(ZoneId.of(&quot;US/Pacific&quot;)); System.out.println(zdt);&#125;@Testpublic void test6()&#123; Set&lt;String&gt; set = ZoneId.getAvailableZoneIds(); set.forEach(System.out::println);&#125; Optional类1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889/* * 一、Optional 容器类：用于尽量避免空指针异常 * Optional.of(T t) : 创建一个 Optional 实例 * Optional.empty() : 创建一个空的 Optional 实例 * Optional.ofNullable(T t):若 t 不为 null,创建 Optional 实例,否则创建空实例 * isPresent() : 判断是否包含值 * orElse(T t) : 如果调用对象包含值，返回该值，否则返回t * orElseGet(Supplier s) :如果调用对象包含值，返回该值，否则返回 s 获取的值 * map(Function f): 如果有值对其处理，并返回处理后的Optional，否则返回 Optional.empty() * flatMap(Function mapper):与 map 类似，要求返回值必须是Optional */ @Test public void test1()&#123; Optional&lt;Employee&gt; op = Optional.of(new Employee()); Employee emp = op.get(); System.out.println(emp); &#125; @Test public void test2()&#123; /*Optional&lt;Employee&gt; op = Optional.ofNullable(null); System.out.println(op.get());*/// Optional&lt;Employee&gt; op = Optional.empty();// System.out.println(op.get()); &#125; @Test public void test3()&#123; Optional&lt;Employee&gt; op = Optional.ofNullable(new Employee()); if(op.isPresent())&#123; System.out.println(op.get()); &#125; Employee emp = op.orElse(new Employee(&quot;张三&quot;)); System.out.println(emp); Employee emp2 = op.orElseGet(() -&gt; new Employee()); System.out.println(emp2); &#125; @Test public void test4()&#123; Optional&lt;Employee&gt; op = Optional.of(new Employee(101, &quot;张三&quot;, 18, 9999.99)); Optional&lt;String&gt; op2 = op.map(Employee::getName); System.out.println(op2.get()); Optional&lt;String&gt; op3 = op.flatMap((e) -&gt; Optional.of(e.getName())); System.out.println(op3.get()); &#125; //需求：获取一个男人心中女神的名字 public String getGodnessName(Man man)&#123; if(man != null)&#123; Godness g = man.getGod(); if(g != null)&#123; return g.getName(); &#125; &#125; return &quot;苍老师&quot;; &#125; public String getGodnessName2(Optional&lt;NewMan&gt; man)&#123; return man.orElse(new NewMan()) .getGodness() .orElse(new Godness(&quot;苍老师&quot;)) .getName(); &#125; @Test public void test5()&#123; Man man = new Man(); String name = getGodnessName(man); System.out.println(name); &#125; //运用 Optional 的实体类 @Test public void test6()&#123; Optional&lt;Godness&gt; godness = Optional.ofNullable(new Godness(&quot;林志玲&quot;)); Optional&lt;NewMan&gt; op = Optional.ofNullable(new NewMan(godness)); String name = getGodnessName2(op); System.out.println(name); &#125;","categories":[],"tags":[{"name":"java8","slug":"java8","permalink":"http://yoursite.com/tags/java8/"}],"keywords":[]},{"title":"moment.js常用操作","slug":"momentJs常用操作","date":"2019-03-14T11:05:08.221Z","updated":"2019-03-07T13:17:44.737Z","comments":true,"path":"2019/03/14/momentJs常用操作/","link":"","permalink":"http://yoursite.com/2019/03/14/momentJs常用操作/","excerpt":"","text":"将String转成moment再格式化const date = ‘2019-03-07T21:16:00Z’;moment(date, ‘YYYY-MM-DDTHH:mm:ssZ’).format(‘HH:mm’)","categories":[],"tags":[{"name":"moment.js","slug":"moment-js","permalink":"http://yoursite.com/tags/moment-js/"}],"keywords":[]},{"title":"linux常用指令","slug":"linux常用指令","date":"2019-03-14T11:05:08.206Z","updated":"2019-02-19T14:08:05.230Z","comments":true,"path":"2019/03/14/linux常用指令/","link":"","permalink":"http://yoursite.com/2019/03/14/linux常用指令/","excerpt":"","text":"1.查看目录下有什么文件/目录 ls &emsp;&emsp;&emsp;&emsp;&emsp; //list 列出目录的文件信息ls -l或ll &emsp;&emsp;&ensp; //list -list 以”详细信息”查看目录文件ls -a &ensp;&emsp;&emsp; &emsp; //list -all 查看目录”全部”（包括隐藏文件）文件ls -al &ensp;&emsp;&emsp;&emsp; //list -all list 查看目录”全部”（包括隐藏文件）文件，以”详细信息”显示ls 目录 &ensp;&emsp; &emsp; //查看指定目录下有什么文件ls -i &emsp;&emsp;&emsp;&emsp; //查看文件索引号码 2.进行目录切换 cd dirname &emsp;//进行目录切换cd .. &emsp;&emsp;&emsp;&emsp;&ensp;//想上级目录切换cd ~ 或 cd &emsp;&ensp;//直接切换到当前用户 3.查看完整的操作位置 pwd 4.用户切换 su - 或 su - root &emsp;//向root用户切换exit &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&ensp; //退回到原用户su 用户名 &emsp;&emsp;&emsp;&emsp;//普通用户切换 多次使用su指令，会造成用户的”叠加”：（su和exit最好配合使用）lcs—&gt;root—&gt;lcs—&gt;root—&gt;lcs 5.查看当前用户是谁 whoami 6.图形界面与命令界面切换root用户可以切换 #init 3 #init 5 7.查看一个指令对应的执行程序文件在哪 which 指令 8.目录相关操作1）创建目录 make directory mkdir 目录名字mkdir -p newdir/newdir/newdir //递归方式创建多个连续目录，新的多级目录数目如果大于等于2个，&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp; 就要使用-p参数mkdir dir/newdir &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;//不用-p参数mkdir -p dir/newdir/newdir &emsp;&emsp;//使用-p参数 2）移动目录 move mv dir1 dir2 &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;//把dir1移动到dir2目录下mv dir1/dir2 dir3 &emsp;&emsp;&emsp;&ensp; //把dir2移动到dir3目录下mv dir1/dir2 dir3/dir4 &emsp;&ensp;//把dir2移动到dir4目录下mv dir1/dir2 ./ &emsp;&emsp;&emsp;&emsp;&emsp;//把dir2移动到当前目录下 3）改名字 mv dir1 newdir &emsp;&emsp;&emsp;&emsp;//修改dir1的名字为newdir mv是”移动”和”改名字”合并的指令mv dir1 ./newdir &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;//dir1移动到当前目录下，并改名字为newdirmv dir1/dir2 dir3 &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&ensp; //dir2移动到dir3目录下，并改名字为”原名”mv dir1/dir2 dir3/newdir &emsp;&emsp;&emsp;&emsp;//dir2移动到dir3目录下，并改名字为newdirmv dir1/dir2 dir3/dir4 &emsp;&emsp;&emsp;&emsp;&emsp; //dir2移动到dir4目录下，并改名字为”原名”mv dir1/dir2 dir3/dir4/newdir &emsp;&ensp;//dir2移动到dir4目录下，并改名字为newdir 4）复制（文件和目录）copy ①文件的复制 cp file1 dir/newfile2 &emsp;&emsp;&emsp;&emsp;//file1被复制一份到dir目录下，并改名字为newfile2cp file1 dir &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&ensp;//file1被复制一份到dir目录下，并改名字为”原名”cp dir1/filea dir2/newfile &emsp;&ensp; //filea被复制一份到dir目录下，并改名字为newfile ②目录的复制（需要设置-r[recursive递归]参数，无视目录的层次） cp -r dir1 dir2 &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;//dir1被复制到dir2目录下，并改名字为”原名”cp -r dir1/dir2 dir3/newdir &emsp;&emsp;&emsp;//dir2被复制到dir3目录下，并改名字为newdircp -r dir1/dir2 dir3/dir4 &emsp;&emsp;&emsp;&emsp; //dir2被复制到dir4目录下，并改名字为”原名”cp -r dir1/dir2 dir3/dir4/newdir &ensp;//dir2被复制到dir4目录下，并改名字为newdircp -r dir1 ../../newdir &emsp;&emsp;&emsp;&emsp;&emsp;&ensp;//dir1被复制到上两级目录下，并改名字为newdir ③删除（文件和目录）remove rm 文件rm -r 目录 &emsp;&emsp;&emsp;&emsp;&emsp;//-r[recursive递归]递归方式删除目录rm -rf 文件/目录 &emsp;&emsp; //-r force 递归强制方式删除文件，force强制，不需要额外导入提示 9.文件操作1）查看文件内容 cat filename &emsp;&emsp;&emsp;//打印文件内容到输出终端more filename &emsp;&emsp;//通过敲回车方式逐行查看文件的各个行内容，默认从第一行开始查看，&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp; //不支持回看，q退出查看less &emsp;&emsp;&emsp; &emsp;&emsp;&emsp;&emsp;//通过”上下左右”键查看文件的各个部分内容，支持回看，q退出查看head -n filename &ensp; //查看文件的前n行内容tail -n filename &emsp;&ensp; //查看文件的最末尾n行内容wc filename &emsp;&emsp;&emsp; //查看文件的行数 2）创建文件 touch dir1/filenametouch filename 3）给文件追加内容 echo 内容 &gt; 文件名称 &emsp;&emsp;&emsp;&emsp;//把”内容”以[覆盖写]方式追加给”文件”echo 内容 &gt;&gt; 文件名称 &emsp;&emsp;&emsp; //把”内容”以[追加]方式写给”文件” （如果文件不存在会创建文件） 10.用户操作配置文件：/etc/passwd1）创建用户 user add #useradd #useradd liming &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;//创建liming用户，同时会创建一个同名的组出来 #useradd -g 组别编号 username &emsp;&emsp;&ensp;//把用户的组别设置好，避免创建同名的组出来 #useradd -g 组编号 -u 用户编号 -d 家目录 username 2）修改用户 user modify #usermod -g 组编号 -u 用户编号 -d 家目录 -l 新名字 username（修改家目录时需要手动创建之） 3）删除用户 user delete #userdel username #userdel -r username //删除用户同时删除其家目录 4）给用户设置密码，使其登录系统 passwd 用户名 11.组别操作配置文件：/etc/group1）创建组 group add #groupadd music #groupadd movie #groupadd php 2）修改组 group modify #groupmod -g gid -n 新名字 groupname 3）删除组 group delete #groupdel groupname //组下边如果有用户存在，就禁止删除 12.查看指令可设置的参数 man 指令 13.给文件设置权限1）字母相对方式设置权限// 针对一个组别设置权限，其他组别权限没有变化，称为“相对方式”权限设置chmod指令chmod u+rwx filename //给filename文件的主人增加“读、写、执行”权限chmod g-rx filename //给filename文件的同组用户 删除“读、执行”权限 chmod u+/-rwx,g+/-rwx,o+/-rwx filename说明：①每个单元“+” “-”只能使用一个②可以同时给一个组或多个组设置权限，组别之间使用“，”分割③每个单元的权限可以是“rwx”中的一个或多个 chmod u+w,g-rx,o+rw filename //给filename文件主人增加写权限，同组删除读、执行权限，其他组增加读、写权限chmod u+w,u-x filename //给filename文件主人“增加写权限”同时“删除执行权限” chmod +/-rwx filename //无视具体组别，统一给全部的组设置权限 chmod +rw filename //给filename全部用户增加“读、写”权限 2）数字绝对方式设置权限r读：4 &emsp;&emsp; w写：2 &emsp;&emsp; x执行：10：没有权限1：执行2：写3：写、执行4：读5：读、执行6：读、写7：读、写、执行 chmod ABC filename //ABC分别代表主人、同组、其他组用户的数字权限 chmod 753 filename //主人读、写、执行；同组读、执行；其他组写、执行 问：字母相对 和 数字绝对 方式权限设置取舍？答：修改的权限相对“比较少”的时候使用“字母”方式，相反，权限变动“非常多”的时候就使用“数字”方式 14.在文件中查找内容grep 被搜索内容 文件 grep hello passwd //在passwd文件中搜索hello内容，会把hello所在行的内容都打印到终端显示 15.计算文件占据磁盘空间大小 du -h 文件（目录） 16.文件查找find 查找目录 选项 选项值 选项 选项值 …1）-name选项 根据名字进行查找 find / -name passwd &emsp;&emsp;&emsp;&emsp;//“递归遍历”/根目录及其内部深层目录，寻找名称等于“passwd”的文件find / -name “pas“[模糊查找] //在系统全部目录，模糊查找一个名字是“pas”开始的文件find / -name “er*” &emsp;&emsp;&emsp;&emsp;&emsp; //文件名字有出现“er”字样即可，不要位置 2）限制查找的目录层次 -maxdepth -mindepth-maxdepth 限制查找的最深目录-mindepth 限制查找的最浅目录 find / -maxdepth 4 -name passwdfind / -maxdepth 4 -mindepth 3 -name passwd 3）根据大小为条件进行文件查找-size +/-数字+号表示大小大于某个范围-号表示大小小于某个范围大小单位：-size 5 &emsp;&emsp; //单位是“512字节” 5512字节-size 10c &emsp; //单位是“字节” 10字节-size 3k &emsp;&ensp; //单位是“千字节” 31024字节-size 6M &emsp; //单位是“1024*千字节” 6M兆字节 find ./ -size 14c &emsp;&emsp;//在当前目录查找大小等于14千字节的文件find / -size +50M &emsp;//在系统全部目录里边查找大小大于50M的文件","categories":[],"tags":[{"name":"linux","slug":"linux","permalink":"http://yoursite.com/tags/linux/"}],"keywords":[]},{"title":"kapacitor issues","slug":"kapactior","date":"2019-03-14T11:05:08.203Z","updated":"2019-03-09T09:45:31.111Z","comments":true,"path":"2019/03/14/kapactior/","link":"","permalink":"http://yoursite.com/2019/03/14/kapactior/","excerpt":"","text":"kapacitor与influxdb在不同机器上通信时的配置kapacitor在启动时会向配置中的influxBD进行发现与创建订阅，这些订阅告诉InfluxDB将它收到的所有数据发送给Kapacitor。当kapacitor与influxdb不在同一台机器上时，需要在kapactior的配置中配置influxdb可以通信的IP或主机名。只要是在influxdb订阅过，influxdb之后都会像这些订阅发送数据 kapactior.conf:1hostname = &quot;localhost&quot; // 默认修改为influxdb可以ping得通的ip或主机名","categories":[],"tags":[{"name":"kapacitor","slug":"kapacitor","permalink":"http://yoursite.com/tags/kapacitor/"}],"keywords":[]},{"title":"Java常用操作","slug":"Java常用操作","date":"2019-03-14T11:05:08.200Z","updated":"2019-03-28T03:52:53.568Z","comments":true,"path":"2019/03/14/Java常用操作/","link":"","permalink":"http://yoursite.com/2019/03/14/Java常用操作/","excerpt":"","text":"java对Map进行排序根据key排序jdk8:12345// map为待排序的MapMap&lt;String, String&gt; sortMap = new TreeMap&lt;&gt;((String s1, String s2) -&gt; s1.compareTo(s2));sortMap.putAll(map);return sortMap; 参考：https://blog.csdn.net/weixin_41415986/article/details/82781618 快速生成Map1234private Map&lt;Integer, String&gt; newsEventMap = new HashMap&lt;Integer, String&gt;()&#123;&#123; put(&quot;k1&quot;, &quot;v1&quot;); put(&quot;k2&quot;, &quot;v2&quot;);&#125;&#125;; 参考：https://blog.csdn.net/molingduzun123/article/details/50634637/","categories":[],"tags":[{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"}],"keywords":[]},{"title":"pkg-config --cflags oci8, Package oci8 was not found in the pkg-config search path.","slug":"go-oracle","date":"2019-03-14T11:05:08.162Z","updated":"2019-02-01T09:56:37.529Z","comments":true,"path":"2019/03/14/go-oracle/","link":"","permalink":"http://yoursite.com/2019/03/14/go-oracle/","excerpt":"","text":"在linux下可以正常运行oracledb_exporter，在windows64下启动时报错12pkg-config --cflags oci8Package oci8 was not found in the pkg-config search path. 因为linux中已经安装了oracle客户端，所以怀疑可能是windows下没有导致的。1.go-oci8 地址：https://github.com/wendal/go-oci8 它是 https://github.com/mattn/go-oci8 的分支，增加了windows下中文的安装说明及相关文件。 从oracledb_exporter的代码中可以看到引用的是go-oci8_ &quot;github.com/mattn/go-oci8&quot;,所以需要安装windows的oracle连接。 2.安装oci 地址：https://www.oracle.com/technetwork/database/database-technologies/instant-client/downloads/index.html 我的安装目录为：F:\\instantclient_18 _3 3.安装oci-sdk 地址：同上。 我的安装目录为F:\\instantclient_18 _3\\sdk 4.安装MinGW 地址：https://sourceforge.net/projects/mingw-w64/files/ 我的安装目录为F:\\mingw-w64 配置环境变量：在系统变量path中追加 F:\\mingw-w64\\x86_64-8.1.0-posix-seh-rt_v6-rev0\\mingw64\\bin 5.下载go-oci8驱动 地址：https://github.com/wendal/go-oci8 运行命令 go get github.com/wendal/go-oci8 (报错先不管) 复制GOPATH目下的\\src\\github.com\\wendal\\go-oci8\\windows\\pkg-config.exe到到mingw的安装目录mingw64\\bin下。 复制GOPATH目下的\\src\\github.com\\wendal\\go-oci8\\windows\\oci8.pc到到mingw的安装目录mingw64\\lib\\pkg-config的下。 修改oci8.pc #Package Information for pkg-configprefix=F:/instantclient_18_3exec_prefix=F:/instantclient_18_3libdir=${exec_prefix}includedir=${prefix}/sdk/include/ Name: OCIDescription: Oracle database engineVersion: 18.3Libs: -L${libdir} -lociLibs.private:Cflags: -I${includedir} 6.环境变量配置 PATH=原有PATH;F:\\instantclient_18_3; PKG_CONFIG_PATH=F:\\mingw-w64\\x86_64-8.1.0-posix-seh-rt_v6-rev0\\mingw64\\lib\\pkg-config 启动报错1234F:\\GOENV\\src\\github.com\\wendal\\go-oci8\\oci8.go:119: cannot use (**_Ctype_struct_OCIServer)(unsafe.Pointer(&amp;conn.svc)) (type **_Ctype_struct_OCIServer) as type **_Ctype_struct_OCISvcCtx in argument to func literalF:\\GOENV\\src\\github.com\\wendal\\go-oci8\\oci8.go:136: cannot use (*_Ctype_struct_OCIServer)(c.svc) (type *_Ctype_struct_OCIServer) as type *_Ctype_struct_OCISvcCtx in argument to func literalF:\\GOENV\\src\\github.com\\wendal\\go-oci8\\oci8.go:263: cannot use (*_Ctype_struct_OCIServer)(s.c.svc) (type *_Ctype_struct_OCIServer) as type *_Ctype_struct_OCISvcCtx in argument to func literalF:\\GOENV\\src\\github.com\\wendal\\go-oci8\\oci8.go:383: cannot use (*_Ctype_struct_OCIServer)(s.c.svc) (type *_Ctype_struct_OCIServer) as type *_Ctype_struct_OCISvcCtx in argument to func literal 替换GOPATH目下的\\src\\github.com\\wendal\\go-oci8里四处OCIServer为OCISvcCtx。参考：https://www.cnblogs.com/ghj1976/p/3437250.htmlhttps://blog.csdn.net/wq57885/article/details/82841792","categories":[],"tags":[{"name":"go","slug":"go","permalink":"http://yoursite.com/tags/go/"}],"keywords":[]},{"title":"golang判断当前主机是物理机还是虚拟机","slug":"golang判断当前主机是物理机还是虚拟机","date":"2019-03-14T11:05:08.134Z","updated":"2019-03-14T10:31:59.655Z","comments":true,"path":"2019/03/14/golang判断当前主机是物理机还是虚拟机/","link":"","permalink":"http://yoursite.com/2019/03/14/golang判断当前主机是物理机还是虚拟机/","excerpt":"","text":"windows下命令行获取：1wmic path Win32_ComputerSystem get Model linux下命令行获取：1dmidecode | egrep -i &apos;system-product-name|product|domU&apos; 123456789101112131415161718192021222324func isVirtualMachine() (bool, error) &#123; model := &quot;&quot; var cmd *exec.Cmd if runtime.GOOS == &quot;windows&quot; &#123; cmd = exec.Command(&quot;cmd&quot;, &quot;/C&quot;, &quot;wmic path Win32_ComputerSystem get Model&quot;) &#125; else &#123; // linux cmd = exec.Command(&quot;/bin/bash&quot;, &quot;-c&quot;, &quot;dmidecode | egrep -i &apos;system-product-name|product|domU&apos;&quot;) &#125; stdout, err := cmd.Output() if err != nil &#123; return false, err &#125; model = string(stdout) if strings.Contains(model, &quot;VirtualBox&quot;) || strings.Contains(model, &quot;Virtual Machine&quot;) || strings.Contains(model, &quot;VMware Virtual Platform&quot;) || strings.Contains(model, &quot;KVM&quot;) || strings.Contains(model, &quot;Bochs&quot;) || strings.Contains(model, &quot;HVM domU&quot;) &#123; return true, nil &#125; return false, nil&#125; 参考：https://unix.stackexchange.com/questions/89714/easy-way-to-determine-virtualization-technologyhttps://blog.csdn.net/yangzhenping/article/details/49996765?utm_source=blogxgwz1https://blog.csdn.net/greless/article/details/71107767https://stackoverflow.com/questions/34229486/how-to-execute-a-linux-built-in-command-in-golanghttps://stackoverflow.com/questions/6182369/exec-a-shell-command-in-gohttps://stackoverflow.com/questions/13008255/how-to-execute-a-simple-windows-command-in-golang","categories":[],"tags":[{"name":"go","slug":"go","permalink":"http://yoursite.com/tags/go/"}],"keywords":[]},{"title":"centos7知识点","slug":"centos7","date":"2019-03-14T11:05:08.098Z","updated":"2019-03-09T09:08:56.389Z","comments":true,"path":"2019/03/14/centos7/","link":"","permalink":"http://yoursite.com/2019/03/14/centos7/","excerpt":"","text":"操作系统主机名修改centos6:1234#hostname //查看主机名#hostname newhostname //在当前会话修改主机名为newhostname，重启后失效#vim /etc/sysconfig/network //修改其中的HOSTNAME=newhostname，重启后依旧生效 centos7：123#hostname //查看主机名#vim /etc/hostname //直接修改其中的主机名，重启后依旧生效 时区操作centos6:123date // 查看时间date -R //查看时区cp /usr/share/zoneinfo/Asia/Tokyo /etc/localtime // 修改时区为东京时区 centos7:123timedatectl // 查看时间、时区。。。timedatectl set-timezone Asia/Tokyo // 修改时区为东京时区timedatectl set-local-rtc 1 //设置rtc时间与local时间相同 centos7 ip操作12345ip addr // 查看ip地址信息ip a add 192.168.8.149/24 dev eth0:2 // 添加网卡ipip a del 192.168.8.149/24 dev eth0:2 // 删除网卡ipip link set dev eth0 down // 将接口设备关闭ip link set dev eth0 up // 将接口设备启用","categories":[],"tags":[{"name":"centos7","slug":"centos7","permalink":"http://yoursite.com/tags/centos7/"}],"keywords":[]},{"title":"angular2中如何在发送delete请求时携带参数","slug":"angular发送带参数的delete请求","date":"2019-03-14T11:05:08.083Z","updated":"2019-02-13T15:07:03.434Z","comments":true,"path":"2019/03/14/angular发送带参数的delete请求/","link":"","permalink":"http://yoursite.com/2019/03/14/angular发送带参数的delete请求/","excerpt":"","text":"前端angular:1234567891011/** * 根据ids删除资源分组 */deleteResourceGroupByIds(ids: string[]) &#123; return this.http.request(&apos;DELETE&apos;, this.API + &apos;/resourceGroup&apos;, &#123; body: ids &#125;).pipe( retry(1), catchError(this.handleError.bind(this)) );&#125; 后台springboot:1234@DeleteMapping(&quot;/resourceGroup&quot;)public void deleteResourceGroupByIds(@RequestBody String[] ids) &#123; resourceGroupService.deleteResourceGroupByIds(ids);&#125; 参考：https://stackoverflow.com/questions/38819336/body-of-http-delete-request-in-angular2","categories":[],"tags":[{"name":"angular","slug":"angular","permalink":"http://yoursite.com/tags/angular/"}],"keywords":[]},{"title":"angular常用操作","slug":"angular常用操作","date":"2019-03-14T11:05:08.049Z","updated":"2019-05-24T09:13:35.029Z","comments":true,"path":"2019/03/14/angular常用操作/","link":"","permalink":"http://yoursite.com/2019/03/14/angular常用操作/","excerpt":"","text":"angular遍历maphtml:12345&lt;ul&gt; &lt;li *ngFor=&quot;let recipient of map | keyvalue&quot;&gt; &#123;&#123;recipient.key&#125;&#125; --&gt; &#123;&#123;recipient.value&#125;&#125; &lt;/li&gt;&lt;/ul&gt; cpmponent:12345myMap : Map&lt;string, boolean&gt;;for(let key of myMap.keys()) &#123; console.log(key); console.log(myMap.get(key));&#125; 1234Object.keys(myMap).map( key =&gt; &#123; console.log(&apos;key: &apos; + key); console.log(&apos;value: &apos; + result[key]);&#125;); 1234for (const [key, val] of map) &#123; console.log(key); console.log(val);&#125; 参考：https://stackoverflow.com/questions/48187362/how-to-iterate-using-ngfor-loop-map-containing-key-as-string-and-values-as-map-i/48187637 angular中html界面的if else 表示1234567&lt;div *ngIf=&quot;someCondition; else falsyTemplate&quot;&gt; &lt;h1&gt;Condition Passed!&lt;/h1&gt;&lt;/div&gt;&lt;ng-template #falsyTemplate&gt; &lt;h1&gt;Condition Failed!&lt;/h1&gt;&lt;/ng-template&gt; angular中http请求的option、params使用方式一：1234let option = &#123;&#125;;const params = new HttpParams().append(&apos;key&apos;, String(&apos;val&apos;));params = params.append(&apos;status&apos;, String(status)); // 注意要从新赋值给paramsoption = &#123;params&#125;; 方式二：12345678// 动态添加参数const option = &#123;&#125;;const params = &#123;&#125;;if (v != null) &#123; params[&apos;k&apos;] = v; option[&apos;params&apos;] = params;&#125; angular的html根据条件显示样式html：1&lt;div [class.hide]=&quot;someCondition&quot;&gt;&lt;/div&gt; css:123.hide &#123; display: none;&#125; 在父组件中直接调用子组件的函数父组件html：1&lt;app-child-form #childForm&gt;&lt;/app-child-form&gt; 父组件component：123456@ViewChild(&apos;childForm&apos;)childForm: ChildFormComponent;f(): void &#123; this.childForm.f();&#125; 子组件component：123f(): void &#123; console.log(&apos;child component&apos;);&#125; 日期格式转换java:1LocalDateTime time angular component：1time: Date html:1&#123;&#123;time| date:&apos;yyyy-MM-dd HH:mm:ss&apos;&#125;&#125; 在组件中使用自定义的管道pipe:12345678@Pipe(&#123; name: &apos;xxx&apos;&#125;)export class XxxPipe implements PipeTransform &#123; transform(value: AlarmRule, args?: any): any &#123; // ... &#125;&#125; Component：123456789101112131415@Component(&#123; selector: &apos;xxx&apos;, templateUrl: &apos;xxx.html&apos;, styleUrls: [&apos;xxx.css&apos;], providers: [ XxxPipe ]&#125;)export class XxxComponent &#123; constructor(private xxx: XxxPipe) &#123;&#125; // ... f(value) &#123;// 调用 this.xxx.transform(value); // ... &#125;&#125; 参考：https://alligator.io/angular/using-pipes-in-component-class/ 重置表单html:12&lt;form nz-form [formGroup]=&quot;form&quot;&gt;&lt;/form&gt; Component:1234567export class FormComponent implements OnInit &#123; form: FormGroup; clearForm() &#123; this.form.reset(); &#125;&#125; 参考：https://stackoverflow.com/questions/36655922/resetting-a-form-in-angular-2-after-submit 离开组件时销毁定时器12345678910111213export class xxxComponent implements OnInit, OnDestroy &#123; timer: any; ngOnInit() &#123; this.timer = setInterval(() =&gt; &#123; console.log(&apos;轮询&apos;); &#125;, 2000); &#125; ngOnDestroy() &#123; clearInterval(this.timer); &#125;&#125; 参考：https://stackoverflow.com/questions/35561320/end-interval-when-route-changes-in-angular-2/35561450 http请求返回非json数据返回类型：image/png1234567891011export class XxxService &#123; getRqCode() &#123; const url = &apos;&apos;; return this.http.post(url, &#123;&#125;, &#123; responseType: &apos;blob&apos; // 类型 &#125;).pipe( retry(1), catchError(this.handleError.bind(this)) ); &#125;&#125; img展示Blob类型数据component:1234567891011121314export class XxxComponent &#123; rqcode: any; getRqCode() &#123; this.xxxService.getRqCode().subscribe(resp =&gt; &#123; // blob转base64 const reader = new FileReader(); reader.readAsDataURL(resp); reader.onloadend = () =&gt; &#123; this.rqcode = reader.result; &#125;; &#125;); &#125;&#125; html:1&lt;img style=&quot;height: 200px; width: 200px;&quot; [src]=&quot;rqcode&quot;&gt; 参考：https://stackoverflow.com/questions/7650587/using-javascript-to-display-a-blob/44069294https://blog.csdn.net/fangquan1980/article/details/80675369https://stackoverflow.com/questions/18650168/convert-blob-to-base64","categories":[],"tags":[{"name":"angular","slug":"angular","permalink":"http://yoursite.com/tags/angular/"}],"keywords":[]},{"title":"通过策略模式和工厂模式减少代码中的if else","slug":"通过策略模式和工厂模式减少代码中的if else","date":"2019-03-14T11:05:08.039Z","updated":"2019-02-14T13:44:53.807Z","comments":true,"path":"2019/03/14/通过策略模式和工厂模式减少代码中的if else/","link":"","permalink":"http://yoursite.com/2019/03/14/通过策略模式和工厂模式减少代码中的if else/","excerpt":"","text":"枚举类：12345678910public enum ResourceStatus &#123; Health(1), UnHealth(0), NoAlarm(-1); @Getter private int seq; private ResourceStatus(int seq) &#123; this.seq = seq; &#125;&#125; 策略接口：12345678public interface Strategy &#123; /** *将val和状态值比较判断是否属于某种状态 * @param val 资源的健康值 * @return 是否属于某种状态 */ boolean compare(Double val);&#125; 策略具体实现类：12345678public class HealthStrategy implements Strategy&#123; private final Double healthVal = 60d; @Override public boolean compare(Double val) &#123; return val &gt;= healthVal; &#125;&#125; 12345678public class UnHealthStrategy implements Strategy&#123; private final Double healthVal = 60d; @Override public boolean compare(Double val) &#123; return val &lt; healthVal &amp;&amp; val &gt;= 0; &#125;&#125; 12345678public class NoAlarmStrategy implements Strategy&#123; private final Double healthVal = -1d; @Override public boolean compare(Double val) &#123; return val.equals(healthVal); &#125;&#125; 工厂类：1234567891011121314151617181920public class StrategyFactory &#123; private static StrategyFactory factory = new StrategyFactory(); private static Map&lt;Integer, Strategy&gt; strategyMap = new HashMap(); static&#123; strategyMap.put(ResourceStatus.Health.getSeq(), new HealthStrategy()); strategyMap.put(ResourceStatus.UnHealth.getSeq(), new UnHealthStrategy()); strategyMap.put(ResourceStatus.NoAlarm.getSeq(), new NoAlarmStrategy()); &#125; private StrategyFactory()&#123;&#125; public Strategy creator(Integer status)&#123; return strategyMap.get(status); &#125; public static StrategyFactory getInstance()&#123; return factory; &#125;&#125; 策略上下文：123456789@Datapublic class Context &#123; private Strategy strategy; public boolean compare(Double val, Integer status) &#123; strategy = StrategyFactory.getInstance().creator(status); return strategy.compare(val); &#125;&#125; 参考：https://blog.csdn.net/u011507568/article/details/70238491","categories":[],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/tags/设计模式/"}],"keywords":[]},{"title":"加密类型及其相关算法","slug":"加密类型及其相关算法","date":"2019-03-14T11:05:08.020Z","updated":"2019-02-11T16:14:23.617Z","comments":true,"path":"2019/03/14/加密类型及其相关算法/","link":"","permalink":"http://yoursite.com/2019/03/14/加密类型及其相关算法/","excerpt":"","text":"一、数据传输安全性在TCP/IP层中不涉及安全 机密性：明文传输（ftp,smtp,talnet）别人一拦截就能看到请求的内容。 完整性：10颗原子弹（被改成100）所以数据在互联网上传播的时候，不应该也不能够被其他人非法篡改掉当收到的和发送的不一致时拒绝接受这就能保证数据的完整性。 身份验证：通过有效的手段保证所访问的对象就是我们所要的那个人。 保证数据的机密性 plaintext(明文) –&gt; 加密（转换规则）–&gt; ciphertext（密文） ciphertext –&gt; 转换规则 –&gt; plaintext 转换算法：依赖密钥（即使得到了转换规则也没用） 对称加密：加密和解密使用同一个密钥（有加密算法和解密算法，算法不同，但密钥相同）。好处是计算速度快，在一定程度上解决了机密性问题。坏处是不能解决密钥有效管理的问题。假如a跟b，c,d通信，如果密钥相同，则c只要用密钥就可以看到a发送给b的内容，显然密钥不能相同，那就得维护很多密钥。 保证数据的完整性 A：plaintext:footprint –&gt; BB使用同样的加密算法去重复计算这个明文的特征码，并跟A所发过来的特征码进行比较，如果一样，则说明没被篡改。 单项加密算法：提取数据特征码，追加到数据后面。数据的输入一样：特征码必然相同。 特点：雪崩效应（输入的微小改变，将其会引起结果的巨大改变）、定长输出（无论原始数据是多长，结果大小都是相同的）、不可逆（无法根据原始特征码还原原来的数据）。 中间人攻击问题 E(A)：plaintext2:footprint2 –&gt; BA生成一段数据，并对它计算特征码，E在中间经过的路由时拿到这个明文，并重新修改明文和再计算特征码发给B，还声称自己是A，B拿到数据之后就算使用了数据完整性的算法之后，计算特征码还是一模一样，还认为是A发过来的，所以需要借助额外的机制。 解决办法：A：plaintext:footprint(加密) –&gt; B B拿到特征码之后通过密钥进行解密，能解密说明数据没有被改过。如果E拿到plaintext并修改为plaintext2，并重新生成特征码，就没办法加密特征码或者加密后就不是A和B之间实现约定的密码。 A与B之间如何进行密码约定 假如A与B之间从未通信或从未见过面，如何进行密码约定呢？ 协商生成密码：密码交换（Internet Key Exchange / IKE）,密码交换是不让第三方得到密钥，密码交换需要特殊的互联网协议支撑。比如：Dffie-Hellman协议。 A和B事先约定两个数p(大素数)，g(生成数)。A生成一个自己知道的x，B生成一个自己知道的y。A将 g^x % p 发送给B，B将g^y % p 发送给A。A拿到之后进行计算 （g^y % p）^x = g^xy % p，B拿到之后进行计算 （g^x % p）^y = g^xy % p。这个相同的结果就是密钥。在互联网上可以看到g、p、g^x % p、g^y % p，但看不到x、y。 A和B只需要选好几个数，让这些数的计算结果作为密钥来用，使得彼此不用计算密码，只要双方生成密钥的软件一样就可以随时生成密钥。 身份验证 之前是A和B一起约定好的密码，所以身份验证没问题。但是密钥是交换生成的，事先之前谁也不知道。E跳出来，截取了数据并篡改，然后与B进行连接通信，还告诉它自己是A。 解决办法：公钥加密算法（非对称加密算法） 特点：拥有一对密钥对，分别是公钥（是从私钥中提取出来的）、私钥。用公钥加密的，只能用私钥解密，反之亦然。 结论 机密性：用B的公钥加密，B的私钥解密。发送方用对方的公钥加密数据，可以保证数据机密性。 身份验证：用A的私钥加密，A的公钥加密。发送方用自己的私钥加密数据，可以实现身份验证。 公钥加密算法很少用来加密数据：速度太慢。 二、数据传输A beautiful sunrise — — — — — — —|&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;||&emsp;&emsp;&emsp;&emsp;A&emsp;&emsp;&emsp;&ensp;&ensp; ||&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;||&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;|— — — — — — —","categories":[],"tags":[{"name":"加密","slug":"加密","permalink":"http://yoursite.com/tags/加密/"}],"keywords":[]},{"title":"telegraf Jolokia2 plugin inputs","slug":"telegraf_Jolokia2_Input_Plugins","date":"2019-03-14T11:05:07.946Z","updated":"2019-05-24T09:19:32.017Z","comments":true,"path":"2019/03/14/telegraf_Jolokia2_Input_Plugins/","link":"","permalink":"http://yoursite.com/2019/03/14/telegraf_Jolokia2_Input_Plugins/","excerpt":"","text":"Jolokia2 Input PluginsJolokia Proxy: jolokia2 采集分为两种模式，一种是jvm代理，由java应用启动时修改参数引入jolokia2包-javaagent:/usr/local/jolokia-jvm-1.5.0-agent.jar=port=8778,host=0.0.0.0第二种是Proxy模式，由于第一种应用的限制，proxy模式不需要在应用端修改 在某些情况下，不可能在目标平台上部署Jolokia代理。这可能是出于政治原因，或者是仪表化服务器上已经建立的JSR-160导出。在这些环境中，Jolokia可以作为JMX代理进行操作。在此设置中，代理部署在专用代理Java EE服务器(或其他受支持的代理平台)上。代理连接Jolokia JSON请求和对目标服务器的远程JSR-160调用的响应。 Jolokia代理是通用的，与目标服务器无关，因为它通过传入请求(与HTTP代理相同)获取目标的信息。由于需要扩展信息，所以只能使用Jolokia POST请求进行代理，因为目前还没有方法将目标信息封装在GET Url中。请求的基本Jolokia URL是代理服务器的URL，而目标参数包含在请求中。在下一个示例中，一个代理Jolokia请求通过一个代理tomcat-proxy查询服务器jboss的活动线程数，该代理在Jolokia上下文中部署了一个代理。代理URL是这样的。 1http://jolokia-proxy:8080/jolokia 请求的POST参数如下： 12345678910&#123; &quot;type&quot;:&quot;READ&quot; &quot;mbean&quot;:&quot;java.lang:type=Threading&quot;, &quot;attribute&quot;:&quot;ThreadCount&quot;, &quot;target&quot;: &#123; &quot;url&quot;:&quot;service:jmx:rmi:///jndi/rmi://jboss-as:8686/jmxrmi&quot;, &quot;password&quot;:&quot;admin&quot;, &quot;user&quot;:&quot;s!cr!t&quot; &#125;,&#125; WAR Agent: WAR代理jolokia.war在Java EE服务器中部署为常规Web归档（WAR）。 此外，这是代理模式的代理，它部署在一个简单、专用的应用服务器中，比如Tomcat或Jetty。 安装与启动步骤1. 在Tomcat服务器上安装Jolokia代理1.从以下网址下载最新版本的Jolokia.war文件：https://jolokia.org/download.html2.将文件重命名jolokia-war-X.X.X.war为jolokia.war。3.将jolokia.war文件复制到${TOMCAT_HOME}/webapps。4.添加jolokia为角色tomcat-users.xml（Jolokia 1.6或更高版本强制使用）12&lt;role rolename=&quot;jolokia&quot;/&gt;&lt;user username=&quot;jolokia&quot; password=&quot;jolokia&quot; roles=&quot;jolokia&quot;/&gt; 5.启动Tomcat服务器。6.停止Tomcat服务器并修改jolokia的web.xml，添加以下内容（自版本1.5.0起，默认情况下不启用代理模式）12345678&lt;init-param&gt; &lt;description&gt; Classnames (comma separated) of RequestDispatcher used in addition to the LocalRequestDispatcher &lt;/description&gt; &lt;param-name&gt;dispatcherClasses&lt;/param-name&gt; &lt;param-value&gt;org.jolokia.jsr160.Jsr160RequestDispatcher&lt;/param-value&gt;&lt;/init-param&gt; 7.通过访问此URL验证Jolokia代理安装：http://tomcatip:8080/jolokia/version 步骤2.配置Telegraf Jolokia2输入插件1234567891011121314151617181920212223242526272829[[inputs.jolokia2_proxy]]# # default_tag_prefix = &quot;&quot;# # default_field_prefix = &quot;&quot;# # default_field_separator = &quot;.&quot;## ## Proxy agent url = &quot;http://tomcatip:8080/jolokia&quot; username = &quot;jolokia&quot; #如果是jolokia-war-unsecured-1.6.0.war则不需要username password = &quot;jolokia&quot; #如果是jolokia-war-unsecured-1.6.0.war则不需要password response_timeout = &quot;30s&quot;## ## Optional TLS config# # tls_ca = &quot;/var/private/ca.pem&quot;# # tls_cert = &quot;/var/private/client.pem&quot;# # tls_key = &quot;/var/private/client-key.pem&quot;# # insecure_skip_verify = false## ## Add proxy targets to query# # default_target_username = &quot;&quot;# # default_target_password = &quot;&quot; [[inputs.jolokia2_proxy.target]] url = &quot;service:jmx:rmi:///jndi/rmi://ip:port/jmxrmi&quot;# # username = &quot;&quot;# # password = &quot;&quot; [[inputs.jolokia2_agent.metric]] name = &quot;jvm_runtime&quot; mbean = &quot;java.lang:type=Runtime&quot; paths = [&quot;Uptime&quot;] 步骤3.配置多个targets12345678 [[inputs.jolokia2_proxy.target]] url = &quot;service:jmx:rmi:///jndi/rmi://ip:port/jmxrmi&quot;# # username = &quot;&quot;# # password = &quot;&quot; [[inputs.jolokia2_proxy.target]] url = &quot;service:jmx:rmi:///jndi/rmi://ip:port/jmxrmi&quot;# # username = &quot;&quot;# # password = &quot;&quot; 以抓取teamcenter的pool_manager为例telegraf.conf123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119[global_tags][agent] interval = &quot;60s&quot; #修改成实际的抓取间隔 round_interval = true metric_batch_size = 1000 metric_buffer_limit = 10000 collection_jitter = &quot;0s&quot; flush_interval = &quot;10s&quot; flush_jitter = &quot;0s&quot; precision = &quot;&quot; debug = false quiet = false logfile = &quot;&quot; hostname = &quot;&quot; omit_hostname = true################################################################################ OUTPUT PLUGINS ################################################################################[[outputs.influxdb]] urls = [&quot;http://ip:8086&quot;] #修改成实际的influxdb地址 database = &quot;volume_monitor&quot; skip_database_creation = true username = &quot;admin&quot; #有权限验证则修改用户名，否则删除该行配置 password = &quot;admin&quot; #有权限验证则修改密码，否则删除该行配置 namepass=[&quot;volume_*&quot;][[outputs.influxdb]] urls = [&quot;http://ip:8086&quot;] #修改成实际的influxdb地址 database = &quot;pool_monitor&quot; skip_database_creation = true username = &quot;admin&quot; #有权限验证则修改用户名，否则删除该行配置 password = &quot;admin&quot; #有权限验证则修改密码，否则删除该行配置 namepass=[&quot;pool_*&quot;]################################################################################ PROCESSOR PLUGINS ################################################################################[[processors.converter]] [processors.converter.fields] tag = [&quot;Assigned User&quot;][[processors.strings]] [[processors.strings.trim_prefix]] tag = &quot;jolokia_agent_url&quot; prefix = &quot;service:jmx:rmi:///jndi/rmi://&quot; [[processors.strings.trim_suffix]] tag = &quot;jolokia_agent_url&quot; suffix = &quot;/jmxrmi&quot;################################################################################ INPUT PLUGINS ################################################################################[[inputs.jolokia2_proxy]] name_prefix=&quot;volume_&quot; url = &quot;http://localhost:8181/jolokia&quot; #代理的tomcat地址 username = &quot;jolokia&quot; #代理的tomcat 用户名 password = &quot;jolokia&quot; #代理的tomcat 密码 response_timeout = &quot;60s&quot; [[inputs.jolokia2_proxy.target]] url = &quot;service:jmx:rmi:///jndi/rmi://ip:8999/jmxrmi&quot; #ip必须设置为主机名，即使是加了host映射 username = &quot;username&quot; #jmx有权限验证则修改用户名，否则删除该行配置 password = &quot;password&quot; #jmx有权限验证则修改密码，否则删除该行配置 [[inputs.jolokia2_proxy.metric]] name = &quot;fsc_local_read_write&quot; mbean = &quot;com.teamcenter.mld:units=mSec,name=LocalReadWholeFile-FMSWebHandlerRoot,type=*,SRC=*&quot; paths = [&quot;Active&quot;, &quot;ActiveSpan&quot;, &quot;AdHocValues&quot;, &quot;Age&quot;, &quot;CurrentFilter&quot;, &quot;FilterAlgorithm&quot;, &quot;FilterMovingAvgTime&quot;, &quot;FilterNum&quot;, &quot;FilterNumLastMax&quot;, &quot;FilterSpan&quot;, &quot;FilterTimeAvg&quot;, &quot;FilterTimeMax&quot;, &quot;FilterTimeMin&quot;, &quot;FilterTimeStdv&quot;, &quot;Histogram&quot;, &quot;KBytes&quot;, &quot;MeasureBytes&quot;, &quot;Name&quot;, &quot;NumFailures&quot;, &quot;NumSuccesses&quot;, &quot;TimeAvg&quot;, &quot;TimeMax&quot;, &quot;TimeMin&quot;, &quot;TimeNum&quot;, &quot;TimeStdv&quot;, &quot;Trace&quot;, &quot;TraceAboveMsec&quot;, &quot;TraceOneShot&quot;, &quot;TracePattern&quot;] tag_keys = [&quot;name&quot;] [[inputs.jolokia2_proxy.metric]] name = &quot;fsc_local_read_write&quot; mbean = &quot;com.teamcenter.mld:units=mSec,name=LocalWrite-FMSWebHandlerRoot,type=*,SRC=*&quot; paths = [&quot;Active&quot;, &quot;ActiveSpan&quot;, &quot;AdHocValues&quot;, &quot;Age&quot;, &quot;CurrentFilter&quot;, &quot;FilterAlgorithm&quot;, &quot;FilterMovingAvgTime&quot;, &quot;FilterNum&quot;, &quot;FilterNumLastMax&quot;, &quot;FilterSpan&quot;, &quot;FilterTimeAvg&quot;, &quot;FilterTimeMax&quot;, &quot;FilterTimeMin&quot;, &quot;FilterTimeStdv&quot;, &quot;Histogram&quot;, &quot;KBytes&quot;, &quot;MeasureBytes&quot;, &quot;Name&quot;, &quot;NumFailures&quot;, &quot;NumSuccesses&quot;, &quot;TimeAvg&quot;, &quot;TimeMax&quot;, &quot;TimeMin&quot;, &quot;TimeNum&quot;, &quot;TimeStdv&quot;, &quot;Trace&quot;, &quot;TraceAboveMsec&quot;, &quot;TraceOneShot&quot;, &quot;TracePattern&quot;] tag_keys = [&quot;name&quot;][[inputs.jolokia2_proxy]] name_prefix=&quot;pool_&quot; url = &quot;http://localhost:8181/jolokia&quot; #代理的tomcat地址 username = &quot;jolokia&quot; #代理的tomcat 用户名 password = &quot;jolokia&quot; #代理的tomcat 密码 response_timeout = &quot;60s&quot; [[inputs.jolokia2_proxy.target]] url = &quot;service:jmx:rmi:///jndi/rmi://ip:8088/jmxrmi&quot; #ip必须设置为主机名，即使是加了host映射 username = &quot;username&quot; #jmx有权限验证则修改用户名，否则删除该行配置 password = &quot;password&quot; #jmx有权限验证则修改密码，否则删除该行配置 [[inputs.jolokia2_proxy.metric]] name = &quot;administer_pool_manager&quot; mbean = &quot;Administer PoolA manager :id=*&quot; paths = [&quot;Assignment Service&quot;, &quot;Host&quot;, &quot;Mux&quot;, &quot;Number of Assigned Servers&quot;, &quot;Number of Cold Servers&quot;, &quot;Number of Servers&quot;, &quot;Number of Servers Terminated Before Normal Timeout&quot;, &quot;Number of Warm Servers&quot;, &quot;Number of Warming Up Servers&quot;, &quot;Pool ID&quot;, &quot;Servers in Edit Mode&quot;, &quot;Servers in Read Mode&quot;, &quot;Servers in Stateless Mode&quot;] tag_keys = [&quot;id&quot;] [[inputs.jolokia2_proxy.metric]] name = &quot;administer_pool_servers&quot; mbean = &quot;Administer PoolA servers :id=*&quot; paths = [&quot;Abandoned&quot;, &quot;Active&quot;, &quot;Assigned&quot;, &quot;Assigned User&quot;, &quot;Health Monitoring&quot;, &quot;Last Message Number&quot;,&quot;Last Message Time&quot;, &quot;Management Pipe Name&quot;, &quot;Process ID&quot;, &quot;Provisional&quot;, &quot;Ready&quot;, &quot;Remove&quot;, &quot;Request Pipe Name&quot;, &quot;Server ID&quot;, &quot;State&quot;] tag_keys = [&quot;id&quot;] 参考：https://github.com/influxdata/telegraf/tree/master/plugins/inputs/jolokia2https://jolokia.org/features/proxy.htmlhttps://jolokia.org/agent.htmlhttps://jolokia.org/tutorial.htmlhttps://jolokia.org/agent/war.htmlhttp://repo1.maven.org/maven2/org/jolokia/jolokia-war-unsecured/1.6.0/https://jolokia.org/reference/html/proxy.htmlhttps://jolokia.org/reference/html/proxy.htmlhttps://www.bountysource.com/issues/41049672-redesign-the-jolokia-input-plugin-as-jolokia2http://zhoujinl.github.io/2018/05/16/compared/","categories":[],"tags":[{"name":"telegraf","slug":"telegraf","permalink":"http://yoursite.com/tags/telegraf/"}],"keywords":[]},{"title":"Oracle报错，ORA-28001:口令已经失效","slug":"Oracle报错ORA-28001","date":"2019-03-14T11:05:07.935Z","updated":"2019-02-13T14:12:20.345Z","comments":true,"path":"2019/03/14/Oracle报错ORA-28001/","link":"","permalink":"http://yoursite.com/2019/03/14/Oracle报错ORA-28001/","excerpt":"","text":"WINDOWS下使用DOS命令行连接oracle数据库sqlplus userName/userPassword@netServiceName 1Oracle报错，ORA-28001: 口令已经失效 cmd命令行输入：12345678910sqlplus / as sysdbaSQL*Plus: Release 11.2.0.1.0 Production on 星期二 10月 17 15:42:58 2017Copyright (c) 1982, 2010, Oracle. All rights reserved.连接到:Oracle Database 11g Enterprise Edition Release 11.2.0.1.0 - ProductionWith the Partitioning, OLAP, Data Mining and Real Application Testing optionsSQL&gt; ALTER PROFILE DEFAULT LIMIT PASSWORD_LIFE_TIME UNLIMITED;配置文件已更改SQL&gt; alter user 用户名 dentified by 密码 account unlock;用户已更改。 再次测试登录即可","categories":[],"tags":[{"name":"oracle","slug":"oracle","permalink":"http://yoursite.com/tags/oracle/"}],"keywords":[]},{"title":"OCP-Oracle体系结构","slug":"OCP-Oracle体系结构","date":"2019-03-14T11:05:07.904Z","updated":"2019-07-26T08:19:11.574Z","comments":true,"path":"2019/03/14/OCP-Oracle体系结构/","link":"","permalink":"http://yoursite.com/2019/03/14/OCP-Oracle体系结构/","excerpt":"","text":"工具使用 sqlplus pl/sql develop sqldevelop toad …… 访问数据库的方式 本机直接通过sock方式访问（IPC） 1sqlplus / as sysdba 通过TCP建立连接到Oracle服务器&amp;Oracle网络配置 方式一： 123// ora10g --&gt;必须在 $ORACLE_HOME/network/admin/tnsnames.ora配置出如何访问到远程数据库服务器tnsping ora10gsqlplus sys/oracle@ora10g as sysdba 方式二： 12// 不需要任何配置，但oracle服务器必须在listener.ora定义被远程访问的方式sqlplus sys/oracle@ip:1521/ora10g as sysdba 数据库模型1.专用型一个进程一个会话2.共享型 执行sql流程 能执行sql语句的程序或进程就是用户进程 用户进程 执行一个查询语句，比如select * from emp where empno=7839; 用户进程已经跟服务进程建立链接,服务器进程会响应用户进程,一些会话信息就会存储在内存（PGA）中,把该用户进程的信息存储到PGA的UGA中。 语句经过PGA处理后传递给实例 实例中的共享池负责处理这条语句 库缓存区去判断语句如何分析–软分析或硬分析(以前是否执行过) sql语句操作的表在哪，表里面的行放在哪个block里面，所以需要数据字典 根据cbo得到的执行计划准备去执行语句，查询语句中的对象存放在哪个表空间的指定的行放在哪个块里面，数据字典缓存区得到这些信息 开始执行 判断在数据缓存区data buffer cache中是否缓存需要的块 如果是，在内存读取数据得到所需行的结果返回给用户，用户看到这行的结果如果没有，则服务器进程读取data file文件中对应的block到data buffer cache中，data buffer cache中的undo块用来做镜像，undo缓存块会对该块做镜像，然后读该镜像中的数据得到行的结果，用户看到执行的结果， redo log buffer记录数据库中块的更改，修改前后的块（提交和未提交）都在undo块中做了镜像，意味着可以写入磁盘与不可写入磁盘 oracle做这么多就是为了尽可能用内存去操作，关系型数据库最重要的就是内存和磁盘 语句执行性能的高低，从shared pool中的library cache和data dict cache的命中率进行判断 database buffer cache 命中率 关系到逻辑读（内存取数据）或物理读（磁盘取数据） redo log buffer 记录块的变化 DBWR进程会将已提交的数据写到物理磁盘data file，只有当redo log buffer 将所有块的变更信息记录下来之后才会开始写 内存中的redo log 日志会定时通过LGWR写到磁盘Redo Log file(主要用于恢复) CKPT保证数据同步，一旦触发，DBWR就开始写数据，接着LGWR也开始写数据（比如手动commit） rdbms的实现的一套完整的解决方案 一个实例（内存结构和后台进程）和数据库（物理文件和文件的逻辑结构）构成了oracle服务器 用户进程产生的日志文件12show parameter user_desc v$session v$process v$sql v$sqltext 1select username,sid from v$session;","categories":[],"tags":[{"name":"oracle","slug":"oracle","permalink":"http://yoursite.com/tags/oracle/"}],"keywords":[]}]}