{"meta":{"title":"Brotherc","subtitle":null,"description":null,"author":"Brotherc","url":"http://yoursite.com"},"pages":[{"title":"all-archives","date":"2019-01-19T03:34:34.316Z","updated":"2019-01-19T03:34:34.316Z","comments":false,"path":"all-archives/index.html","permalink":"http://yoursite.com/all-archives/index.html","excerpt":"","text":""},{"title":"all-tags","date":"2019-01-19T03:34:15.573Z","updated":"2019-01-19T03:34:15.573Z","comments":false,"path":"all-tags/index.html","permalink":"http://yoursite.com/all-tags/index.html","excerpt":"","text":""},{"title":"all-categories","date":"2019-01-19T03:33:53.552Z","updated":"2019-01-19T03:33:53.552Z","comments":false,"path":"all-categories/index.html","permalink":"http://yoursite.com/all-categories/index.html","excerpt":"","text":""}],"posts":[{"title":"加密类型及其相关算法","slug":"加密类型及其相关算法","date":"2019-02-11T16:14:46.590Z","updated":"2019-02-11T16:14:23.617Z","comments":true,"path":"2019/02/12/加密类型及其相关算法/","link":"","permalink":"http://yoursite.com/2019/02/12/加密类型及其相关算法/","excerpt":"","text":"一、数据传输安全性在TCP/IP层中不涉及安全 机密性：明文传输（ftp,smtp,talnet）别人一拦截就能看到请求的内容。 完整性：10颗原子弹（被改成100）所以数据在互联网上传播的时候，不应该也不能够被其他人非法篡改掉当收到的和发送的不一致时拒绝接受这就能保证数据的完整性。 身份验证：通过有效的手段保证所访问的对象就是我们所要的那个人。 保证数据的机密性 plaintext(明文) –&gt; 加密（转换规则）–&gt; ciphertext（密文） ciphertext –&gt; 转换规则 –&gt; plaintext 转换算法：依赖密钥（即使得到了转换规则也没用） 对称加密：加密和解密使用同一个密钥（有加密算法和解密算法，算法不同，但密钥相同）。好处是计算速度快，在一定程度上解决了机密性问题。坏处是不能解决密钥有效管理的问题。假如a跟b，c,d通信，如果密钥相同，则c只要用密钥就可以看到a发送给b的内容，显然密钥不能相同，那就得维护很多密钥。 保证数据的完整性 A：plaintext:footprint –&gt; BB使用同样的加密算法去重复计算这个明文的特征码，并跟A所发过来的特征码进行比较，如果一样，则说明没被篡改。 单项加密算法：提取数据特征码，追加到数据后面。数据的输入一样：特征码必然相同。 特点：雪崩效应（输入的微小改变，将其会引起结果的巨大改变）、定长输出（无论原始数据是多长，结果大小都是相同的）、不可逆（无法根据原始特征码还原原来的数据）。 中间人攻击问题 E(A)：plaintext2:footprint2 –&gt; BA生成一段数据，并对它计算特征码，E在中间经过的路由时拿到这个明文，并重新修改明文和再计算特征码发给B，还声称自己是A，B拿到数据之后就算使用了数据完整性的算法之后，计算特征码还是一模一样，还认为是A发过来的，所以需要借助额外的机制。 解决办法：A：plaintext:footprint(加密) –&gt; B B拿到特征码之后通过密钥进行解密，能解密说明数据没有被改过。如果E拿到plaintext并修改为plaintext2，并重新生成特征码，就没办法加密特征码或者加密后就不是A和B之间实现约定的密码。 A与B之间如何进行密码约定 假如A与B之间从未通信或从未见过面，如何进行密码约定呢？ 协商生成密码：密码交换（Internet Key Exchange / IKE）,密码交换是不让第三方得到密钥，密码交换需要特殊的互联网协议支撑。比如：Dffie-Hellman协议。 A和B事先约定两个数p(大素数)，g(生成数)。A生成一个自己知道的x，B生成一个自己知道的y。A将 g^x % p 发送给B，B将g^y % p 发送给A。A拿到之后进行计算 （g^y % p）^x = g^xy % p，B拿到之后进行计算 （g^x % p）^y = g^xy % p。这个相同的结果就是密钥。在互联网上可以看到g、p、g^x % p、g^y % p，但看不到x、y。 A和B只需要选好几个数，让这些数的计算结果作为密钥来用，使得彼此不用计算密码，只要双方生成密钥的软件一样就可以随时生成密钥。 身份验证 之前是A和B一起约定好的密码，所以身份验证没问题。但是密钥是交换生成的，事先之前谁也不知道。E跳出来，截取了数据并篡改，然后与B进行连接通信，还告诉它自己是A。 解决办法：公钥加密算法（非对称加密算法） 特点：拥有一对密钥对，分别是公钥（是从私钥中提取出来的）、私钥。用公钥加密的，只能用私钥解密，反之亦然。 结论 机密性：用B的公钥加密，B的私钥解密。发送方用对方的公钥加密数据，可以保证数据机密性。 身份验证：用A的私钥加密，A的公钥加密。发送方用自己的私钥加密数据，可以实现身份验证。 公钥加密算法很少用来加密数据：速度太慢。 二、数据传输A beautiful sunrise — — — — — — —|&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;||&emsp;&emsp;&emsp;&emsp;A&emsp;&emsp;&emsp;&ensp;&ensp; ||&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;||&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;|— — — — — — —","categories":[],"tags":[{"name":"加密","slug":"加密","permalink":"http://yoursite.com/tags/加密/"}],"keywords":[]},{"title":"pkg-config --cflags oci8, Package oci8 was not found in the pkg-config search path.","slug":"go-oracle","date":"2019-02-01T09:56:58.386Z","updated":"2019-02-01T09:56:37.529Z","comments":true,"path":"2019/02/01/go-oracle/","link":"","permalink":"http://yoursite.com/2019/02/01/go-oracle/","excerpt":"","text":"在linux下可以正常运行oracledb_exporter，在windows64下启动时报错12pkg-config --cflags oci8Package oci8 was not found in the pkg-config search path. 因为linux中已经安装了oracle客户端，所以怀疑可能是windows下没有导致的。1.go-oci8 地址：https://github.com/wendal/go-oci8 它是 https://github.com/mattn/go-oci8 的分支，增加了windows下中文的安装说明及相关文件。 从oracledb_exporter的代码中可以看到引用的是go-oci8_ &quot;github.com/mattn/go-oci8&quot;,所以需要安装windows的oracle连接。 2.安装oci 地址：https://www.oracle.com/technetwork/database/database-technologies/instant-client/downloads/index.html 我的安装目录为：F:\\instantclient_18 _3 3.安装oci-sdk 地址：同上。 我的安装目录为F:\\instantclient_18 _3\\sdk 4.安装MinGW 地址：https://sourceforge.net/projects/mingw-w64/files/ 我的安装目录为F:\\mingw-w64 配置环境变量：在系统变量path中追加 F:\\mingw-w64\\x86_64-8.1.0-posix-seh-rt_v6-rev0\\mingw64\\bin 5.下载go-oci8驱动 地址：https://github.com/wendal/go-oci8 运行命令 go get github.com/wendal/go-oci8 (报错先不管) 复制GOPATH目下的\\src\\github.com\\wendal\\go-oci8\\windows\\pkg-config.exe到到mingw的安装目录mingw64\\bin下。 复制GOPATH目下的\\src\\github.com\\wendal\\go-oci8\\windows\\oci8.pc到到mingw的安装目录mingw64\\lib\\pkg-config的下。 修改oci8.pc #Package Information for pkg-configprefix=F:/instantclient_18_3exec_prefix=F:/instantclient_18_3libdir=${exec_prefix}includedir=${prefix}/sdk/include/ Name: OCIDescription: Oracle database engineVersion: 18.3Libs: -L${libdir} -lociLibs.private:Cflags: -I${includedir} 6.环境变量配置 PATH=原有PATH;F:\\instantclient_18_3; PKG_CONFIG_PATH=F:\\mingw-w64\\x86_64-8.1.0-posix-seh-rt_v6-rev0\\mingw64\\lib\\pkg-config 启动报错1234F:\\GOENV\\src\\github.com\\wendal\\go-oci8\\oci8.go:119: cannot use (**_Ctype_struct_OCIServer)(unsafe.Pointer(&amp;conn.svc)) (type **_Ctype_struct_OCIServer) as type **_Ctype_struct_OCISvcCtx in argument to func literalF:\\GOENV\\src\\github.com\\wendal\\go-oci8\\oci8.go:136: cannot use (*_Ctype_struct_OCIServer)(c.svc) (type *_Ctype_struct_OCIServer) as type *_Ctype_struct_OCISvcCtx in argument to func literalF:\\GOENV\\src\\github.com\\wendal\\go-oci8\\oci8.go:263: cannot use (*_Ctype_struct_OCIServer)(s.c.svc) (type *_Ctype_struct_OCIServer) as type *_Ctype_struct_OCISvcCtx in argument to func literalF:\\GOENV\\src\\github.com\\wendal\\go-oci8\\oci8.go:383: cannot use (*_Ctype_struct_OCIServer)(s.c.svc) (type *_Ctype_struct_OCIServer) as type *_Ctype_struct_OCISvcCtx in argument to func literal 替换GOPATH目下的\\src\\github.com\\wendal\\go-oci8里四处OCIServer为OCISvcCtx。参考：https://www.cnblogs.com/ghj1976/p/3437250.htmlhttps://blog.csdn.net/wq57885/article/details/82841792","categories":[],"tags":[{"name":"go","slug":"go","permalink":"http://yoursite.com/tags/go/"}],"keywords":[]}]}