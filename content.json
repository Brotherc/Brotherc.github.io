{"meta":{"title":"Brotherc","subtitle":null,"description":null,"author":"Brotherc","url":"http://yoursite.com"},"pages":[{"title":"all-archives","date":"2019-01-19T03:34:34.316Z","updated":"2019-01-19T03:34:34.316Z","comments":false,"path":"all-archives/index.html","permalink":"http://yoursite.com/all-archives/index.html","excerpt":"","text":""},{"title":"all-categories","date":"2019-01-19T03:33:53.552Z","updated":"2019-01-19T03:33:53.552Z","comments":false,"path":"all-categories/index.html","permalink":"http://yoursite.com/all-categories/index.html","excerpt":"","text":""},{"title":"all-tags","date":"2019-01-19T03:34:15.573Z","updated":"2019-01-19T03:34:15.573Z","comments":false,"path":"all-tags/index.html","permalink":"http://yoursite.com/all-tags/index.html","excerpt":"","text":""}],"posts":[{"title":"JAVA实现对称加密","slug":"JAVA实现对称加密","date":"2020-08-19T03:57:40.620Z","updated":"2020-08-19T03:57:01.499Z","comments":true,"path":"2020/08/19/JAVA实现对称加密/","link":"","permalink":"http://yoursite.com/2020/08/19/JAVA实现对称加密/","excerpt":"","text":"Java实现Base64加密 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960import org.apache.commons.codec.binary.Base64;import sun.misc.BASE64Decoder;import sun.misc.BASE64Encoder;public class Base64Test &#123; public static final String src = \"base64 test\"; public static void main(String[] args) &#123; jdkBase64(); commonsCodesBase64(); bouncyCastleBase64(); &#125; // 用jdk实现 public static void jdkBase64() &#123; try &#123; BASE64Encoder encoder = new BASE64Encoder(); String encode = encoder.encode(src.getBytes()); System.out.println(\"encode:\" + encode); BASE64Decoder decoder = new BASE64Decoder(); System.out.println(\"decode:\" + new String(decoder.decodeBuffer(encode))); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; // 用Apache的common codes实现 public static void commonsCodesBase64() &#123; byte[] encodeBytes = Base64.encodeBase64(src.getBytes()); System.out.println(\"common codes encode:\" + new String(encodeBytes)); byte[] dencodeBytes = Base64.decodeBase64(encodeBytes); System.out.println(\"common codes decode:\" + new String(dencodeBytes)); &#125; // 用bouncy castle实现 public static void bouncyCastleBase64() &#123; byte[] encodeBytes = org.bouncycastle.util.encoders.Base64.encode(src.getBytes()); System.out.println(\"bouncy castle encode:\" + new String(encodeBytes)); byte[] dencodeBytes = org.bouncycastle.util.encoders.Base64.decode(encodeBytes); System.out.println(\"bouncy castle decode:\" + new String(dencodeBytes)); &#125;&#125; Java实现消息摘要算法加密 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104import java.security.MessageDigest;import java.security.Security;import org.apache.commons.codec.binary.Hex;import org.apache.commons.codec.digest.DigestUtils;import org.bouncycastle.crypto.digests.MD4Digest;import org.bouncycastle.crypto.digests.MD5Digest;import org.bouncycastle.jce.provider.BouncyCastleProvider;public class MD5Test &#123; public static final String src = \"md5 test\"; public static void main(String[] args) &#123; jdkMD5(); jdkMD2(); bcMD4(); bcMD5(); bc2jdkMD4(); ccMD5(); ccMD2(); &#125; // 用jdk实现:MD5 public static void jdkMD5() &#123; try &#123; MessageDigest md = MessageDigest.getInstance(\"MD5\"); byte[] md5Bytes = md.digest(src.getBytes()); System.out.println(\"JDK MD5:\" + Hex.encodeHexString(md5Bytes)); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; // 用jdk实现:MD2 public static void jdkMD2() &#123; try &#123; MessageDigest md = MessageDigest.getInstance(\"MD2\"); byte[] md2Bytes = md.digest(src.getBytes()); System.out.println(\"JDK MD2:\" + Hex.encodeHexString(md2Bytes)); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; // 用bouncy castle实现:MD5 public static void bcMD5() &#123; MD5Digest digest = new MD5Digest(); digest.update(src.getBytes(),0,src.getBytes().length); byte[] md5Bytes = new byte[digest.getDigestSize()]; digest.doFinal(md5Bytes, 0); System.out.println(\"bouncy castle MD5:\" + org.bouncycastle.util.encoders.Hex.toHexString(md5Bytes)); &#125; // 用bouncy castle实现:MD4 public static void bcMD4() &#123; MD4Digest digest = new MD4Digest(); digest.update(src.getBytes(),0,src.getBytes().length); byte[] md4Bytes = new byte[digest.getDigestSize()]; digest.doFinal(md4Bytes, 0); System.out.println(\"bouncy castle MD4:\" + org.bouncycastle.util.encoders.Hex.toHexString(md4Bytes)); &#125; // 用bouncy castle与jdk结合实现:MD4 public static void bc2jdkMD4() &#123; try &#123; Security.addProvider(new BouncyCastleProvider()); MessageDigest md = MessageDigest.getInstance(\"MD4\"); byte[] md4Bytes = md.digest(src.getBytes()); System.out.println(\"bc and JDK MD4:\" + Hex.encodeHexString(md4Bytes)); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; // 用common codes实现实现:MD5 public static void ccMD5() &#123; System.out.println(\"common codes MD5:\" + DigestUtils.md5Hex(src.getBytes())); &#125; // 用common codes实现实现:MD2 public static void ccMD2() &#123; System.out.println(\"common codes MD2:\" + DigestUtils.md2Hex(src.getBytes())); &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596import java.security.MessageDigest;import java.security.Security;import org.apache.commons.codec.binary.Hex;import org.apache.commons.codec.digest.DigestUtils;import org.bouncycastle.crypto.Digest;import org.bouncycastle.crypto.digests.SHA1Digest;import org.bouncycastle.crypto.digests.SHA224Digest;import org.bouncycastle.jce.provider.BouncyCastleProvider;import java.math.BigInteger;public class SHATest &#123; public static final String src = \"sha test\"; public static void main(String[] args) &#123; jdkSHA1(); bcSHA1(); bcSHA224(); bcSHA224b(); generateSha256(); ccSHA1(); &#125; // 用jdk实现:SHA1 public static void jdkSHA1() &#123; try &#123; MessageDigest md = MessageDigest.getInstance(\"SHA\"); md.update(src.getBytes()); System.out.println(\"jdk sha-1:\" + Hex.encodeHexString(md.digest())); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; // 用bouncy castle实现:SHA1 public static void bcSHA1() &#123; Digest digest = new SHA1Digest(); digest.update(src.getBytes(), 0, src.getBytes().length ); byte[] sha1Bytes = new byte[digest.getDigestSize()]; digest.doFinal(sha1Bytes, 0); System.out.println(\"bc sha-1:\" + org.bouncycastle.util.encoders.Hex.toHexString(sha1Bytes)); &#125; // 用bouncy castle实现:SHA224 public static void bcSHA224() &#123; Digest digest = new SHA224Digest(); digest.update(src.getBytes(), 0, src.getBytes().length ); byte[] sha224Bytes = new byte[digest.getDigestSize()]; digest.doFinal(sha224Bytes, 0); System.out.println(\"bc sha-224:\" + org.bouncycastle.util.encoders.Hex.toHexString(sha224Bytes)); &#125; // 用bouncy castle与jdk结合实现:SHA224 public static void bcSHA224b() &#123; try &#123; Security.addProvider(new BouncyCastleProvider()); MessageDigest md = MessageDigest.getInstance(\"SHA224\"); md.update(src.getBytes()); System.out.println(\"bc and JDK sha-224:\" + Hex.encodeHexString(md.digest())); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; public static void generateSha256() &#123; MessageDigest md = MessageDigest.getInstance(\"SHA-256\"); md.update(src.getBytes(\"UTF-8\")); // Change this to \"UTF-16\" if needed byte[] digest = md.digest(); BigInteger bigInt = new BigInteger(1, digest); System.out.println(\"Sha256 hash: \" + bigInt.toString(16)); &#125; // 用common codes实现实现:SHA1 public static void ccSHA1() &#123; System.out.println(\"common codes SHA1 - 1 :\" + DigestUtils.sha1Hex(src.getBytes())); System.out.println(\"common codes SHA1 - 2 :\" + DigestUtils.sha1Hex(src)); &#125; &#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465import javax.crypto.KeyGenerator;import javax.crypto.Mac;import javax.crypto.SecretKey;import javax.crypto.spec.SecretKeySpec;import org.apache.commons.codec.binary.Hex;import org.bouncycastle.crypto.digests.MD5Digest;import org.bouncycastle.crypto.macs.HMac;import org.bouncycastle.crypto.params.KeyParameter;public class HMACTest &#123; public static final String src = \"hmac test\"; public static void main(String[] args) &#123; jdkHmacMD5(); bcHmacMD5(); &#125; // 用jdk实现: public static void jdkHmacMD5() &#123; try &#123; // 初始化KeyGenerator KeyGenerator keyGenerator = KeyGenerator.getInstance(\"HmacMD5\"); // 产生密钥 SecretKey secretKey = keyGenerator.generateKey(); // 获取密钥// byte[] key = secretKey.getEncoded(); byte[] key = Hex.decodeHex(new char[]&#123;'1','2','3','4','5','6','7','8','9','a','b','c','d','e' &#125;); // 还原密钥 SecretKey restoreSecretKey = new SecretKeySpec(key, \"HmacMD5\"); // 实例化MAC Mac mac = Mac.getInstance(restoreSecretKey.getAlgorithm()); // 初始化MAC mac.init(restoreSecretKey); // 执行摘要 byte[] hmacMD5Bytes = mac.doFinal(src.getBytes()); System.out.println(\"jdk hmacMD5:\" + Hex.encodeHexString(hmacMD5Bytes)); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; // 用bouncy castle实现: public static void bcHmacMD5() &#123; HMac hmac = new HMac(new MD5Digest()); // 必须是16进制的字符，长度必须是2的倍数 hmac.init(new KeyParameter(org.bouncycastle.util.encoders.Hex.decode(\"123456789abcde\"))); hmac.update(src.getBytes(), 0, src.getBytes().length); // 执行摘要 byte[] hmacMD5Bytes = new byte[hmac.getMacSize()]; hmac.doFinal(hmacMD5Bytes, 0); System.out.println(\"bc hmacMD5:\" + org.bouncycastle.util.encoders.Hex.toHexString(hmacMD5Bytes)); &#125;&#125; Java实现对称加密 软件、硬件 加密密钥=解密密钥 初等、DES(3DES)、AES、PBE、IDEA 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798import java.security.Key;import java.security.Security;import javax.crypto.Cipher;import javax.crypto.KeyGenerator;import javax.crypto.SecretKey;import javax.crypto.SecretKeyFactory;import javax.crypto.spec.DESKeySpec;import org.apache.commons.codec.binary.Hex;import org.bouncycastle.jce.provider.BouncyCastleProvider;public class DESTest &#123; public static final String src = \"des test\"; public static void main(String[] args) &#123; jdkDES(); bcDES(); &#125; // 用jdk实现: public static void jdkDES() &#123; try &#123; // 生成KEY KeyGenerator keyGenerator = KeyGenerator.getInstance(\"DES\"); keyGenerator.init(56); // 产生密钥 SecretKey secretKey = keyGenerator.generateKey(); // 获取密钥 byte[] bytesKey = secretKey.getEncoded(); // KEY转换 DESKeySpec desKeySpec = new DESKeySpec(bytesKey); SecretKeyFactory factory = SecretKeyFactory.getInstance(\"DES\"); Key convertSecretKey = factory.generateSecret(desKeySpec); // 加密 Cipher cipher = Cipher.getInstance(\"DES/ECB/PKCS5Padding\"); cipher.init(Cipher.ENCRYPT_MODE, convertSecretKey); byte[] result = cipher.doFinal(src.getBytes()); System.out.println(\"jdk des encrypt:\" + Hex.encodeHexString(result)); // 解密 cipher.init(Cipher.DECRYPT_MODE, convertSecretKey); result = cipher.doFinal(result); System.out.println(\"jdk des decrypt:\" + new String(result)); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; // 用bouncy castle实现: public static void bcDES() &#123; try &#123; Security.addProvider(new BouncyCastleProvider()); // 生成KEY KeyGenerator keyGenerator = KeyGenerator.getInstance(\"DES\", \"BC\"); keyGenerator.getProvider(); keyGenerator.init(56); // 产生密钥 SecretKey secretKey = keyGenerator.generateKey(); // 获取密钥 byte[] bytesKey = secretKey.getEncoded(); // KEY转换 DESKeySpec desKeySpec = new DESKeySpec(bytesKey); SecretKeyFactory factory = SecretKeyFactory.getInstance(\"DES\"); Key convertSecretKey = factory.generateSecret(desKeySpec); // 加密 Cipher cipher = Cipher.getInstance(\"DES/ECB/PKCS5Padding\"); cipher.init(Cipher.ENCRYPT_MODE, convertSecretKey); byte[] result = cipher.doFinal(src.getBytes()); System.out.println(\"bc des encrypt:\" + Hex.encodeHexString(result)); // 解密 cipher.init(Cipher.DECRYPT_MODE, convertSecretKey); result = cipher.doFinal(result); System.out.println(\"bc des decrypt:\" + new String(result)); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102import java.security.Key;import java.security.SecureRandom;import java.security.Security;import javax.crypto.Cipher;import javax.crypto.KeyGenerator;import javax.crypto.SecretKey;import javax.crypto.SecretKeyFactory;import javax.crypto.spec.DESKeySpec;import javax.crypto.spec.DESedeKeySpec;import org.apache.commons.codec.binary.Hex;import org.bouncycastle.jce.provider.BouncyCastleProvider;public class DES3Test &#123; public static final String src = \"3des test\"; public static void main(String[] args) &#123; jdk3DES(); bc3DES(); &#125; // 用jdk实现: public static void jdk3DES() &#123; try &#123; // 生成KEY KeyGenerator keyGenerator = KeyGenerator.getInstance(\"DESede\"); // 必须长度是：112或168// keyGenerator.init(168); keyGenerator.init(new SecureRandom()); // 产生密钥 SecretKey secretKey = keyGenerator.generateKey(); // 获取密钥 byte[] bytesKey = secretKey.getEncoded(); // KEY转换 DESedeKeySpec desKeySpec = new DESedeKeySpec(bytesKey); SecretKeyFactory factory = SecretKeyFactory.getInstance(\"DESede\"); Key convertSecretKey = factory.generateSecret(desKeySpec); // 加密 Cipher cipher = Cipher.getInstance(\"DESede/ECB/PKCS5Padding\"); cipher.init(Cipher.ENCRYPT_MODE, convertSecretKey); byte[] result = cipher.doFinal(src.getBytes()); System.out.println(\"jdk 3des encrypt:\" + Hex.encodeHexString(result)); // 解密 cipher.init(Cipher.DECRYPT_MODE, convertSecretKey); result = cipher.doFinal(result); System.out.println(\"jdk 3des decrypt:\" + new String(result)); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; // 用bouncy castle实现: public static void bc3DES() &#123; try &#123; Security.addProvider(new BouncyCastleProvider()); // 生成KEY KeyGenerator keyGenerator = KeyGenerator.getInstance(\"DESede\", \"BC\"); keyGenerator.getProvider(); keyGenerator.init(168); // 产生密钥 SecretKey secretKey = keyGenerator.generateKey(); // 获取密钥 byte[] bytesKey = secretKey.getEncoded(); // KEY转换 DESedeKeySpec desKeySpec = new DESedeKeySpec(bytesKey); SecretKeyFactory factory = SecretKeyFactory.getInstance(\"DESede\"); Key convertSecretKey = factory.generateSecret(desKeySpec); // 加密 Cipher cipher = Cipher.getInstance(\"DESede/ECB/PKCS5Padding\"); cipher.init(Cipher.ENCRYPT_MODE, convertSecretKey); byte[] result = cipher.doFinal(src.getBytes()); System.out.println(\"bc 3des encrypt:\" + Hex.encodeHexString(result)); // 解密 cipher.init(Cipher.DECRYPT_MODE, convertSecretKey); result = cipher.doFinal(result); System.out.println(\"bc 3des decrypt:\" + new String(result)); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; AES是目前使用最多的对称加密算法 AES的优势之一是至今尚未被破解 AES通常用于移动通信系统加密以及基于SSH协议的软件(SSH Client、secureCRT) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293import java.security.Key;import java.security.Security;import javax.crypto.Cipher;import javax.crypto.KeyGenerator;import javax.crypto.SecretKey;import javax.crypto.spec.SecretKeySpec;import org.apache.commons.codec.binary.Hex;import org.bouncycastle.jce.provider.BouncyCastleProvider;public class AESTest &#123; public static final String src = \"aes test\"; public static void main(String[] args) &#123; jdkAES(); bcAES(); &#125; // 用jdk实现: public static void jdkAES() &#123; try &#123; // 生成KEY KeyGenerator keyGenerator = KeyGenerator.getInstance(\"AES\"); keyGenerator.init(128); // 产生密钥 SecretKey secretKey = keyGenerator.generateKey(); // 获取密钥 byte[] keyBytes = secretKey.getEncoded(); // KEY转换 Key key = new SecretKeySpec(keyBytes, \"AES\"); // 加密 Cipher cipher = Cipher.getInstance(\"AES/ECB/PKCS5Padding\"); cipher.init(Cipher.ENCRYPT_MODE, key); byte[] result = cipher.doFinal(src.getBytes()); System.out.println(\"jdk aes encrypt:\" + Hex.encodeHexString(result)); // 解密 cipher.init(Cipher.DECRYPT_MODE, key); result = cipher.doFinal(result); System.out.println(\"jdk aes decrypt:\" + new String(result)); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; // 用bouncy castle实现: public static void bcAES() &#123; try &#123; Security.addProvider(new BouncyCastleProvider()); // 生成KEY KeyGenerator keyGenerator = KeyGenerator.getInstance(\"AES\", \"BC\"); keyGenerator.getProvider(); keyGenerator.init(128); // 产生密钥 SecretKey secretKey = keyGenerator.generateKey(); // 获取密钥 byte[] keyBytes = secretKey.getEncoded(); // KEY转换 Key key = new SecretKeySpec(keyBytes, \"AES\"); // 加密 Cipher cipher = Cipher.getInstance(\"AES/ECB/PKCS5Padding\"); cipher.init(Cipher.ENCRYPT_MODE, key); byte[] result = cipher.doFinal(src.getBytes()); System.out.println(\"bc aes encrypt:\" + Hex.encodeHexString(result)); // 解密 cipher.init(Cipher.DECRYPT_MODE, key); result = cipher.doFinal(result); System.out.println(\"bc aes decrypt:\" + new String(result)); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152import java.security.Key;import java.security.SecureRandom;import javax.crypto.Cipher;import javax.crypto.SecretKeyFactory;import javax.crypto.spec.PBEKeySpec;import javax.crypto.spec.PBEParameterSpec;import org.apache.commons.codec.binary.Hex;public class PBETest &#123; public static final String src = \"pbe test\"; public static void main(String[] args) &#123; jdkPBE(); &#125; // 用jdk实现: public static void jdkPBE() &#123; try &#123; // 初始化盐 SecureRandom random = new SecureRandom(); byte[] salt = random.generateSeed(8); // 口令与密钥 String password = \"timliu\"; PBEKeySpec pbeKeySpec = new PBEKeySpec(password.toCharArray()); SecretKeyFactory factory = SecretKeyFactory.getInstance(\"PBEWITHMD5andDES\"); Key key = factory.generateSecret(pbeKeySpec); // 加密 PBEParameterSpec pbeParameterSpac = new PBEParameterSpec(salt, 100); Cipher cipher = Cipher.getInstance(\"PBEWITHMD5andDES\"); cipher.init(Cipher.ENCRYPT_MODE, key, pbeParameterSpac); byte[] result = cipher.doFinal(src.getBytes()); System.out.println(\"jdk pbe encrypt:\" + Hex.encodeHexString(result)); // 解密 cipher.init(Cipher.DECRYPT_MODE, key, pbeParameterSpac); result = cipher.doFinal(result); System.out.println(\"jdk pbe decrypt:\" + new String(result)); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; &#125; Java实现非对称加密 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485import java.security.KeyFactory;import java.security.KeyPair;import java.security.KeyPairGenerator;import java.security.PrivateKey;import java.security.PublicKey;import java.security.spec.X509EncodedKeySpec;import javax.crypto.Cipher;import javax.crypto.KeyAgreement;import javax.crypto.SecretKey;import javax.crypto.interfaces.DHPublicKey;import javax.crypto.spec.DHParameterSpec;import org.apache.commons.codec.binary.Base64;import com.sun.org.apache.xalan.internal.utils.Objects;public class DHTest &#123; public static final String src = \"dh test\"; public static void main(String[] args) &#123; jdkDH(); &#125; // jdk实现： public static void jdkDH() &#123; try &#123; // 1.初始化发送方密钥 KeyPairGenerator senderKeyPairGenerator = KeyPairGenerator.getInstance(\"DH\"); senderKeyPairGenerator.initialize(512); KeyPair senderKeyPair = senderKeyPairGenerator.generateKeyPair(); // 发送方公钥，发送给接收方（网络、文件。。。） byte[] senderPublicKeyEnc = senderKeyPair.getPublic().getEncoded(); // 2.初始化接收方密钥 KeyFactory receiverKeyFactory = KeyFactory.getInstance(\"DH\"); X509EncodedKeySpec x509EncodedKeySpec = new X509EncodedKeySpec(senderPublicKeyEnc); PublicKey receiverPublicKey = receiverKeyFactory.generatePublic(x509EncodedKeySpec); DHParameterSpec dhParameterSpec = ((DHPublicKey) receiverPublicKey).getParams(); KeyPairGenerator receiverKeyPairGenerator = KeyPairGenerator.getInstance(\"DH\"); receiverKeyPairGenerator.initialize(dhParameterSpec); KeyPair receiverKeypair = receiverKeyPairGenerator.generateKeyPair(); PrivateKey receiverPrivateKey = receiverKeypair.getPrivate(); byte[] receiverPublicKeyEnc = receiverKeypair.getPublic().getEncoded(); // 3.密钥构建 KeyAgreement receiverKeyAgreement = KeyAgreement.getInstance(\"DH\"); receiverKeyAgreement.init(receiverPrivateKey); receiverKeyAgreement.doPhase(receiverPublicKey, true); SecretKey receiverDesKey = receiverKeyAgreement.generateSecret(\"DES\"); KeyFactory senderKeyFactory = KeyFactory.getInstance(\"DH\"); x509EncodedKeySpec = new X509EncodedKeySpec(receiverPublicKeyEnc); PublicKey senderPublicKey = senderKeyFactory.generatePublic(x509EncodedKeySpec); KeyAgreement senderKeyAgreement = KeyAgreement.getInstance(\"DH\"); senderKeyAgreement.init(senderKeyPair.getPrivate()); senderKeyAgreement.doPhase(senderPublicKey, true); SecretKey senderDesKey = senderKeyAgreement.generateSecret(\"DES\"); if(Objects.equals(receiverDesKey, senderDesKey)) &#123; System.out.println(\"双方密钥相同。\"); &#125; // 4.加密 Cipher cipher = Cipher.getInstance(\"DES\"); cipher.init(Cipher.ENCRYPT_MODE, senderDesKey); byte[] result = cipher.doFinal(src.getBytes()); System.out.println(\"bc dh encrypt:\" + Base64.encodeBase64String(result)); // 5.解密 cipher.init(Cipher.DECRYPT_MODE, receiverDesKey); result = cipher.doFinal(result); System.out.println(\"bc dh decrypt:\" + new String(result)); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788import java.security.KeyFactory;import java.security.KeyPair;import java.security.KeyPairGenerator;import java.security.PrivateKey;import java.security.PublicKey;import java.security.interfaces.RSAPrivateKey;import java.security.interfaces.RSAPublicKey;import java.security.spec.PKCS8EncodedKeySpec;import java.security.spec.X509EncodedKeySpec;import javax.crypto.Cipher;import javax.crypto.KeyAgreement;import javax.crypto.SecretKey;import javax.crypto.interfaces.DHPublicKey;import javax.crypto.spec.DHParameterSpec;import org.apache.commons.codec.binary.Base64;import com.sun.org.apache.xalan.internal.utils.Objects;public class RSATest &#123; public static final String src = \"rsa test\"; public static void main(String[] args) &#123; jdkRSA(); &#125; // jdk实现： public static void jdkRSA() &#123; try &#123; // 1.初始化发送方密钥 KeyPairGenerator keyPairGenerator = KeyPairGenerator.getInstance(\"RSA\"); keyPairGenerator.initialize(512); KeyPair keyPair = keyPairGenerator.generateKeyPair(); RSAPublicKey rsaPublicKey = (RSAPublicKey) keyPair.getPublic(); RSAPrivateKey rsaPrivateKey = (RSAPrivateKey) keyPair.getPrivate(); System.out.println(\"Public Key:\" + Base64.encodeBase64String(rsaPublicKey.getEncoded())); System.out.println(\"Private Key:\" + Base64.encodeBase64String(rsaPrivateKey.getEncoded())); // 2.私钥加密、公钥解密 ---- 加密 PKCS8EncodedKeySpec pkcs8EncodedKeySpec = new PKCS8EncodedKeySpec(rsaPrivateKey.getEncoded()); KeyFactory keyFactory = KeyFactory.getInstance(\"RSA\"); PrivateKey privateKey = keyFactory.generatePrivate(pkcs8EncodedKeySpec); Cipher cipher = Cipher.getInstance(\"RSA\"); cipher.init(Cipher.ENCRYPT_MODE, privateKey); byte[] result = cipher.doFinal(src.getBytes()); System.out.println(\"私钥加密、公钥解密 ---- 加密:\" + Base64.encodeBase64String(result)); // 3.私钥加密、公钥解密 ---- 解密 X509EncodedKeySpec x509EncodedKeySpec = new X509EncodedKeySpec(rsaPublicKey.getEncoded()); keyFactory = KeyFactory.getInstance(\"RSA\"); PublicKey publicKey = keyFactory.generatePublic(x509EncodedKeySpec); cipher = Cipher.getInstance(\"RSA\"); cipher.init(Cipher.DECRYPT_MODE, publicKey); result = cipher.doFinal(result); System.out.println(\"私钥加密、公钥解密 ---- 解密:\" + new String(result)); // 4.公钥加密、私钥解密 ---- 加密 X509EncodedKeySpec x509EncodedKeySpec2 = new X509EncodedKeySpec(rsaPublicKey.getEncoded()); KeyFactory keyFactory2 = KeyFactory.getInstance(\"RSA\"); PublicKey publicKey2 = keyFactory2.generatePublic(x509EncodedKeySpec2); Cipher cipher2 = Cipher.getInstance(\"RSA\"); cipher2.init(Cipher.ENCRYPT_MODE, publicKey2); byte[] result2 = cipher2.doFinal(src.getBytes()); System.out.println(\"公钥加密、私钥解密 ---- 加密:\" + Base64.encodeBase64String(result2)); // 5.私钥解密、公钥加密 ---- 解密 PKCS8EncodedKeySpec pkcs8EncodedKeySpec5 = new PKCS8EncodedKeySpec(rsaPrivateKey.getEncoded()); KeyFactory keyFactory5 = KeyFactory.getInstance(\"RSA\"); PrivateKey privateKey5 = keyFactory5.generatePrivate(pkcs8EncodedKeySpec5); Cipher cipher5 = Cipher.getInstance(\"RSA\"); cipher5.init(Cipher.DECRYPT_MODE, privateKey5); byte[] result5 = cipher5.doFinal(result2); System.out.println(\"公钥加密、私钥解密 ---- 解密:\" + new String(result5)); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 参考：https://github.com/Tim9Liu9/java_security","categories":[],"tags":[{"name":"加密","slug":"加密","permalink":"http://yoursite.com/tags/加密/"}],"keywords":[]},{"title":"原生JDK线程扩展-Guava","slug":"云析学院-原生JDK线程扩展-Guava","date":"2020-08-12T15:03:41.460Z","updated":"2020-08-12T15:03:11.059Z","comments":true,"path":"2020/08/12/云析学院-原生JDK线程扩展-Guava/","link":"","permalink":"http://yoursite.com/2020/08/12/云析学院-原生JDK线程扩展-Guava/","excerpt":"","text":"JDK线程 针对以上串行场景，有什么优化方案 谈谈你对Java线程池的理解 以上方式就是最优解吗？ 95线 95%请求 300ms Guava对JDK扩展 Guava实战模拟外部服务1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071/** * @Description: 模拟一个耗时的服务 如：RPC或者HTTP请求 */@Servicepublic class OuterService &#123; /** * 用户服务 */ public long userService() &#123; System.out.println(\"用户服务开始执行\"); try &#123; //模拟耗时1000ms的用户服务 Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(\"用户服务执行结束\"); //假设用户服务返回值=1 return 1; &#125; /** * 订单服务 */ public long orderService() &#123; System.out.println(\"订单服务开始执行\"); try &#123; //模拟耗时2000ms的订单服务 Thread.sleep(2000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(\"订单服务执行结束\"); //假设订单服务返回值=3 return 3; &#125; /** * 商品服务 */ public long itemService() &#123; System.out.println(\"商品服务开始执行\"); try &#123; //模拟耗时3000ms的商品服务 Thread.sleep(3000); //模拟调用超时或者服务异常 // throw new RuntimeException(\"Oh My God, OrderService Exception!!!\"); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(\"商品服务执行结束\"); //假设商品服务返回值=5 return 5; &#125; /** * 地址服务 */ public long addressService() &#123; System.out.println(\"地址服务开始执行\"); try &#123; //模拟耗时5000ms的地址服务 Thread.sleep(5000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(\"地址服务执行结束\"); //假设地址服务返回值=7 return 7; &#125;&#125; 单线程演示12345678910111213141516171819202122232425262728293031323334/** * @Description: 单线程操作演示 */@RestControllerpublic class SingleThreadDemo &#123; @Resource private OuterService outerService; /** * 测试代码 */ @RequestMapping(\"/test/single\") public Map&lt;String, Object&gt; test () &#123; //开始调用的时间 long start = System.currentTimeMillis(); //同步调用用户服务 long userServiceResult = outerService.userService(); //同步调用订单服务 long orderServiceResult = outerService.orderService(); //同步调用商品服务 long itemServiceResult = outerService.itemService(); //结束调用的时间 long end = System.currentTimeMillis(); String time = \"总调用时间是：\" + (end - start) + \"毫秒\"; //计算结果 long result = userServiceResult + orderServiceResult + itemServiceResult; //为什么要初始化4个容量的Map Map&lt;String, Object&gt; resultMap = new HashMap&lt;&gt;(4); resultMap.put(\"time\", time); resultMap.put(\"result\", result); //结果 return resultMap; &#125;&#125; JDK多线程演示123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354/** * @Description: JDK多线程操作演示 */@RestControllerpublic class JdkThreadController &#123; @Resource private OuterService outerService; @RequestMapping(\"/test/jdk\") public Map&lt;String, Object&gt; execute() throws ExecutionException, InterruptedException &#123; // 固定大小的线程池 核心线程数和最大线程数=10 ExecutorService executorService = Executors.newFixedThreadPool(10); // 记录开始时间 Long start = System.currentTimeMillis(); // 异步调用用户服务 Future&lt;Long&gt; userServiceFuture = executorService.submit(new Callable&lt;Long&gt;() &#123; @Override public Long call() throws Exception &#123; return outerService.userService(); &#125; &#125;); // 异步调用订单服务 Future&lt;Long&gt; orderServiceFuture = executorService.submit(new Callable&lt;Long&gt;() &#123; @Override public Long call() throws Exception &#123; return outerService.orderService(); &#125; &#125;); // 异步调用商品服务 Future&lt;Long&gt; itemServiceFuture = executorService.submit(new Callable&lt;Long&gt;() &#123; @Override public Long call() throws Exception &#123; return outerService.itemService(); &#125; &#125;); // 阻塞 等待执行结果 long userServiceResult = userServiceFuture.get(); long orderServiceResult = orderServiceFuture.get(); long itemServiceResult = itemServiceFuture.get(); //结束调用的时间 long end = System.currentTimeMillis(); //计算结果 long result = userServiceResult + orderServiceResult + itemServiceResult; String time = \"总调用时间是：\" + (end - start) + \"毫秒\"; //为什么要初始化4个容量的Map Map&lt;String, Object&gt; resultMap = new HashMap&lt;&gt;(4); resultMap.put(\"time\", time); resultMap.put(\"result\", result); //结果 return resultMap; &#125;&#125; Guava特性演示12345678910111213141516171819import com.google.common.util.concurrent.ListeningExecutorService;import com.google.common.util.concurrent.MoreExecutors;import org.springframework.context.annotation.Bean;import org.springframework.stereotype.Component;import java.util.concurrent.Executors;/** * @Description: 公用的线程池 */@Componentpublic class ListeningExecutors &#123; @Bean public ListeningExecutorService createListeningExecutorService() &#123; // 创建线程池 return MoreExecutors.listeningDecorator(Executors.newFixedThreadPool(10)); &#125;&#125; 1234567891011121314151617181920212223242526272829import com.google.common.util.concurrent.FutureCallback;/** * @Description: ListenableFuture回调任务 */public class FutureCallBackTask implements FutureCallback&lt;Object&gt; &#123; /** * 成功的回调 * @param result */ @Override public void onSuccess(Object result) &#123; //执行回调函数 System.out.println(\"进入正确的回调函数\"); //得到任务执行的结果 System.out.printf(\"任务执行的结果是：%s%n\", result); &#125; /** * 失败的回调 * @param thrown */ @Override public void onFailure(Throwable thrown) &#123; System.out.println(\"进入错误的回调函数\"); System.out.printf(\"系统出错了，错误原因是：%s%n\", thrown.getMessage()); &#125;&#125; 123456789101112131415161718192021222324252627/** * @Description: Guava 线程简单测试 */@RestControllerpublic class GuavaThreadController &#123; @Autowired private ListeningExecutorService listeningExecutorService; @RequestMapping(\"/test/guava\") public void execute() &#123; // 记录开始时间 Long start = System.currentTimeMillis(); // 一个耗时的任务 ListenableFuture&lt;Boolean&gt; listenableFuture = listeningExecutorService.submit(() -&gt; &#123; Thread.sleep(5000); return true; &#125;); // 注册回调事件 Futures.addCallback(listenableFuture, new FutureCallBackTask(), listeningExecutorService); // 记录结束时间 Long end = System.currentTimeMillis(); // 执行时间 System.out.println(\"execute()方法执行结束了，耗时=\" + (end - start) + \"毫秒\"); System.out.println(\"-----------------------华丽的分割线-----------------------\"); &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145/** * @Description: 高级特性介绍 * &lt;p&gt; * transform：对于ListenableFuture的返回值进行转换。 * &lt;p&gt; * allAsList：对多个ListenableFuture的合并，返回一个当所有Future成功时返回多个Future返回值组成的List对象。 * 注：当其中一个Future失败或者取消的时候，将会进入失败或者取消。 * &lt;p&gt; * successfulAsList：和allAsList相似，唯一差别是对于失败或取消的Future返回值用null代替。不会进入失败或者取消流程。 * &lt;p&gt; * immediateFuture/immediateCancelledFuture： 立即返回一个待返回值的ListenableFuture。 * &lt;p&gt; * makeChecked: 将ListenableFuture 转换成CheckedFuture。CheckedFuture 是一个ListenableFuture 。 * 其中包含了多个版本的get 方法，方法声明抛出检查异常.这样使得创建一个在执行逻辑中可以抛出异常的Future更加容易 * &lt;p&gt; * JdkFutureAdapters.listenInPoolThread(jdkthread): guava同时提供了将JDK Future转换为ListenableFuture的接口函数。 */@RestControllerpublic class SeniorListenableFutureController &#123; @Autowired private ListeningExecutorService listeningExecutorService; @Autowired private OuterService outerService; @RequestMapping(\"/test/senior\") public Map&lt;String, Object&gt; execute() throws ExecutionException, InterruptedException &#123; long start = System.currentTimeMillis(); // 异步调用用户服务 ListenableFuture&lt;Long&gt; userServiceFuture = listeningExecutorService.submit(new Callable&lt;Long&gt;() &#123; @Override public Long call() throws Exception &#123; return outerService.userService(); &#125; &#125;); // 异步调用订单服务 ListenableFuture&lt;Long&gt; orderServiceFuture = listeningExecutorService.submit(new Callable&lt;Long&gt;() &#123; @Override public Long call() throws Exception &#123; return outerService.orderService(); &#125; &#125;); // 异步调用商品服务 ListenableFuture&lt;Long&gt; itemServiceFuture = listeningExecutorService.submit(new Callable&lt;Long&gt;() &#123; @Override public Long call() throws Exception &#123; return outerService.itemService(); &#125; &#125;); //注册商品服务回调 addCallBack(itemServiceFuture); // ....... // 对多个ListenableFuture的合并，返回一个当所有Future成功时返回多个Future返回值组成的List对象。 // 注：当其中一个Future失败或者取消的时候，会怎样？ final ListenableFuture&lt;List&lt;Long&gt;&gt; threeServicesFutures = Futures.successfulAsList(userServiceFuture, orderServiceFuture, itemServiceFuture); //对于多个ListenableFuture的进行转换，返回一个新的ListenableFuture final ListenableFuture&lt;Long&gt; transform = Futures.transformAsync(threeServicesFutures, new AsyncFunction&lt;List&lt;Long&gt;, Long&gt;() &#123; /** * 用给定的输入封装一个特定的ListenableFuture作为输出 * * @param input 输入的ListenableFuture对象 */ @Override public ListenableFuture&lt;Long&gt; apply(@Nullable List&lt;Long&gt; input) &#123; if (input == null || input.isEmpty()) &#123; return null; &#125; // 这里可以对input进行复杂的处理，返回最终的一个结果 // 比如：对用户服务，订单服务，商品服务的远程调用结果进行封装 long result = 0; for (Long serviceResult : input) &#123; if (serviceResult != null) &#123; result += serviceResult; &#125; &#125; // 立即返回一个带返回值的ListenableFuture return Futures.immediateFuture(result); &#125; &#125;, listeningExecutorService); // 异步调用地址服务 ListenableFuture&lt;Long&gt; addressServiceFuture = listeningExecutorService.submit(new Callable&lt;Long&gt;() &#123; @Override public Long call() throws Exception &#123; return outerService.addressService(); &#125; &#125;); final ListenableFuture&lt;List&lt;Long&gt;&gt; finalFutures = Futures.successfulAsList(transform, addressServiceFuture); ListenableFuture&lt;Long&gt; finalResult = Futures.transformAsync(finalFutures, new AsyncFunction&lt;List&lt;Long&gt;, Long&gt;() &#123; @Override public ListenableFuture&lt;Long&gt; apply(@Nullable List&lt;Long&gt; input) throws Exception &#123; if (CollectionUtils.isEmpty(input)) &#123; return null; &#125; // 这里可以对input进行复杂的处理，返回最终的一个结果 long result = 0; // 比如：对上面的用户服务，订单服务，商品服务的总结果和地址服务再封装 for (Long serviceResult : input) &#123; if (serviceResult != null) &#123; result += serviceResult; &#125; &#125; // 立即返回一个带返回值的ListenableFuture return Futures.immediateFuture(result); &#125; &#125;, listeningExecutorService); // 注册回调事件 addCallBack(finalResult); long end = System.currentTimeMillis(); String time = \"总调用时间是：\" + (end - start) + \"毫秒\"; //为什么要初始化4个容量的Map Map&lt;String, Object&gt; resultMap = new HashMap&lt;&gt;(3); resultMap.put(\"time\", time); //结果 return resultMap; &#125; /** * 添加回调 * @param listenableFuture */ private void addCallBack(ListenableFuture&lt;Long&gt; listenableFuture) &#123; Futures.addCallback(listenableFuture, new FutureCallback&lt;Long&gt;() &#123; @Override public void onSuccess(@Nullable Long result) &#123; System.out.printf(\"服务调用成功,执行结果是%s%n\",result); &#125; @Override public void onFailure(Throwable t) &#123; System.out.printf(\"服务调用异常%s%n\", t); &#125; &#125;, listeningExecutorService); &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041/** * @Description: JdkFutureAdapters.listenInPoolThread(jdkthread) * * guava同时提供了将JDK Future转换为ListenableFuture的接口函数。 */@RestControllerpublic class JdkFutureAdaptersController &#123; @Autowired private ListeningExecutorService listeningExecutorService; @RequestMapping(\"/test/adapter\") public void execute() &#123; // 固定大小的线程池 核心线程数和最大线程数=10 ExecutorService executorService = Executors.newFixedThreadPool(10); // 记录开始时间 Long start = System.currentTimeMillis(); // 一个耗时的任务 Future&lt;Boolean&gt; future = executorService.submit(new Callable&lt;Boolean&gt;() &#123; /** * Computes a result, or throws an exception if unable to do so. * * @return computed result * @throws Exception if unable to compute a result */ @Override public Boolean call() throws Exception &#123; //模拟耗时5s Thread.sleep(5000); return true; &#125; &#125;); ListenableFuture listenableFuture = JdkFutureAdapters.listenInPoolThread(future); Futures.addCallback(listenableFuture, new FutureCallBackTask(), listeningExecutorService); // 记录结束时间 Long end = System.currentTimeMillis(); // 执行时间 System.out.println(\"线程执行结束了，耗时=\" + (end - start) + \"毫秒\"); System.out.println(\"-----------------------华丽的分割线-----------------------\"); &#125;&#125; 参考：https://github.com/online-demo/yunxi-guava-thread","categories":[],"tags":[{"name":"云析学院","slug":"云析学院","permalink":"http://yoursite.com/tags/云析学院/"}],"keywords":[]},{"title":"集群无忧-SpringSession原理与坑","slug":"集群无忧-SpringSession原理与坑","date":"2020-07-01T14:13:23.606Z","updated":"2020-07-01T14:13:04.980Z","comments":true,"path":"2020/07/01/集群无忧-SpringSession原理与坑/","link":"","permalink":"http://yoursite.com/2020/07/01/集群无忧-SpringSession原理与坑/","excerpt":"","text":"nginx 80 高并发负载均衡、高可用 session 跟踪会话信息 电商网站不登录加入购物车 登录 — 标志 — session会话 属于哪个用户 ip_hash负载算法缺点 单点故障 IP – 真的能够不变？ 移动、联通、— 宽带 移动互联网 — 不同区域ip变化 redis 理解为一个JVM外置的Map 12345&lt;dependency&gt; &lt;groupId&gt;org.springframework.session&lt;/groupId&gt; &lt;artifactId&gt;spring-session-data-redis&lt;/artifactId&gt; &lt;version&gt;$&#123;spring-session-data-redis.version&#125;&lt;/version&gt;&lt;/dependency&gt; 12345678@EnableRedisHttpSession // 启用redis存储session功能public class Config &#123; @Bean public LettuceConnectionFactory connectionFactory() &#123; // 1.配置一个redis客户端 -- 默认连接 127.0.0.1:6379 return new LettuceConnectionFactory(); &#125;&#125; 12345public class Initializer extends AbstractHttpSessionApplicationInitializer &#123; public Initializer() &#123; super(Config.class); &#125;&#125;","categories":[],"tags":[{"name":"网易云课堂公开课","slug":"网易云课堂公开课","permalink":"http://yoursite.com/tags/网易云课堂公开课/"}],"keywords":[]},{"title":"typescript常用操作","slug":"typescript常用操作","date":"2020-05-09T14:57:45.933Z","updated":"2020-05-09T14:57:32.511Z","comments":true,"path":"2020/05/09/typescript常用操作/","link":"","permalink":"http://yoursite.com/2020/05/09/typescript常用操作/","excerpt":"","text":"保留两位小数12345Math.floor(15.7784514000 * 100) / 100 // 输出结果为 15.77parseInt(7/2) // 丢弃小数部分,保留整数部分const a = 2.461;const b = (parseInt(a * 100) / 100).toFixed(2); // 2.46 创建Map并赋值1const map = new Map([[2, &apos;foo&apos;], [1, &apos;bar&apos;]]); 判断Map类型123isMap(obj) &#123; return obj instanceof Map;&#125; 删除数组中的某个元素123const arr = [&apos;a&apos;,&apos;b&apos;,&apos;c&apos;,&apos;d&apos;];arr.splice(1,1);console.log(arr); //[&apos;a&apos;,&apos;c&apos;,&apos;d&apos;]; Object转成Map1const result = new Map(Object.entries(map)); 将Map的key、value转成数组12const values = Array.from(map.values());const keys = Array.from(map.keys()); 求数组最大值12const maxN = Math.max.apply(null,ary);const minN = Math.min.apply(null,ary); 实现Map的深克隆1234567891011121314151617181920212223export class MapUtils &#123; public static deepClone(obj) &#123; if (!obj || true === obj) &#123; // this also handles boolean as true and false return obj; &#125; const objType = typeof(obj); if (&apos;number&apos; === objType || &apos;string&apos; === objType) &#123; // add your immutables here return obj; &#125; const result = Array.isArray(obj) ? [] : !obj.constructor ? &#123;&#125; : new obj.constructor(); if (obj instanceof Map) &#123; for (const key of obj.keys()) &#123; result.set(key, this.deepClone(obj.get(key))); &#125; &#125; for (const key in obj) &#123; if (obj.hasOwnProperty(key)) &#123; result[key] = this.deepClone(obj[key]); &#125; &#125; return result; &#125;&#125; 参考：https://stackoverflow.com/questions/8206988/clone-copy-a-map-instance/39643085#39643085 请求的url后面添加时间戳参数或者随机数的参数123456// 添加时间戳...?time=new Date();// 添加随机数...?number=Math.random();//&quot;...?&quot; + Math.floor(Math.random() * 100)","categories":[],"tags":[{"name":"js","slug":"js","permalink":"http://yoursite.com/tags/js/"}],"keywords":[]},{"title":"feign接口调用如何获取请求头","slug":"feign","date":"2020-05-05T12:29:00.011Z","updated":"2020-05-05T12:28:29.501Z","comments":true,"path":"2020/05/05/feign/","link":"","permalink":"http://yoursite.com/2020/05/05/feign/","excerpt":"","text":"1234567891011@RestControllerpublic class TestController &#123; @Autowired private ReciveClient reciveClient; @GetMapping(&quot;/request&quot;) public void request() &#123; Response response = reciveClient.recive(); System.out.println(response.headers()); &#125;&#125; 1234567@RestControllerpublic class ReciveController &#123; @GetMapping(&quot;/recive&quot;) public String recive() &#123; return &quot;hello world&quot;; &#125;&#125; 12345@FeignClientpublic interface ReciveClient &#123; @GetMapping(&quot;/recive&quot;) public Response recive();&#125; 参考：https://stackoverflow.com/questions/38742191/get-headers-feign-netflix","categories":[],"tags":[{"name":"spring cloud","slug":"spring-cloud","permalink":"http://yoursite.com/tags/spring-cloud/"}],"keywords":[]},{"title":"Logback日志配置","slug":"logback","date":"2020-05-05T08:52:54.957Z","updated":"2020-05-05T08:52:09.666Z","comments":true,"path":"2020/05/05/logback/","link":"","permalink":"http://yoursite.com/2020/05/05/logback/","excerpt":"","text":"Logback的主要模块logback-access与server容器集成，提供通过http来访问日志的功能，我们的第三方软件可以通过logback-access来访问到logback里面记录的日志，例如kibanner等都会用到这个模块。 logback-classiclog4j的改良版本，同时完整的实现了slef4j api，使你可以很方便的更换成其他的日志系统，比如log4j等。 logback-core为我们前两个模块提供了基础的服务。 Logback的主要标签logger作为日志的记录器，主要用于存放日志对象，也可以定义日志的类型还有级别等。 appender用于指定日志输出的目的地，可以是控制台、文件、远程套接字服务器等。 layout用于格式化日志信息输出的。 Logback的加载顺序程序在运行的时候会按照一定的顺序去加载我们logback相关的配置文件 1.如果我们在配置里面指定了logback.configurationFile这个属性那我们将使用这个属性的的地址去寻找相关的配置文件1java -Dlogback.configurationFile=xxxxxx/xxx.xml 2.如果没有配置这个属性他将会加载我们classpath下的logback.groovy文件3.如果也找不到这个文件，才会加载同级目录下的logback-test.xml文件4.如果也没有，它就会加载logback.xml文件5.如果都没找到上述的配置文件，jdk1.6以上就会调用service-provider loading facility去查找com.qos.logback.classic.spi.Configurator这个接口的第一个实现类6.如果上面的都没有，则会使用ch.qos.logback.classic.BasicConfigurator这个实现类，就是直接在控制台输出1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; standalone=&quot;no&quot;?&gt;&lt;!-- scan=&quot;true&quot; 如果配置文件被改变，将会重新去加载 --&gt;&lt;!-- scanPeriod 设置监测我们的配置文件是否有修改时间的时间间隔，默认单位是毫秒，当scan为true时生效，每分钟扫一下配置文件看有没有发生变化如果有变化就会重新去加载配置，这样就不需要重启服务器 --&gt;&lt;!-- debug 打印出logback的内部信息 实时查看logback的运行状态 --&gt;&lt;configuration scan=&quot;true&quot; scanPeriod=&quot;60 seconds&quot; debug=&quot;false&quot;&gt; &lt;!-- 定义参数常量 --&gt; &lt;!-- TRACE&lt;DEBUG&lt;INFO&lt;WARN&lt;ERROR &gt;以上的级别才会显示--&gt; &lt;property name=&quot;log.level&quot; value=&quot;debug&quot; /&gt; &lt;!-- 文件保留的时长 --&gt; &lt;property name=&quot;log.maxHistory&quot; value=&quot;30&quot; /&gt; &lt;!-- 日志存储的根路径 --&gt; &lt;property name=&quot;log.filePath&quot; value=&quot;$&#123;catalina.base&#125;/logs/webapps&quot; /&gt; &lt;!-- 日志展示的格式 --&gt; &lt;property name=&quot;log.pattern&quot; value=&quot;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;50&#125; - %msg%n&quot; /&gt; &lt;!-- 控制台设置 --&gt; &lt;appender name=&quot;consoleAppender&quot; class=&quot;ch.qos.logback.core.ConsoleAppender&quot;&gt; &lt;!-- 将一个event事件转化为一组byte数组，还会将转化后的数据输出到文件中 --&gt; &lt;encoder&gt; &lt;pattern&gt;$&#123;log.pattern&#125;&lt;/pattern&gt; &lt;/encoder&gt; &lt;/appender&gt; &lt;!-- DEBUG --&gt; &lt;!-- 随着大小或时间滚动日志 --&gt; &lt;appender name=&quot;debugAppender&quot; class=&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;&gt; &lt;!-- 文件路径 --&gt; &lt;file&gt;$&#123;log.filePath&#125;/debug.log&lt;/file&gt; &lt;rollingPolicy class=&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;&gt; &lt;!-- 文件名称 --&gt; &lt;fileNamePattern&gt;$&#123;log.filePath&#125;/debug/debug.%d&#123;yyyy-MM-dd&#125;.%i.log.gz&lt;/fileNamePattern&gt; &lt;!-- 文件最大保存历史数量 --&gt; &lt;maxHistory&gt;$&#123;log.maxHistory&#125;&lt;/maxHistory&gt; &lt;/rollingPolicy&gt; &lt;encoder&gt; &lt;pattern&gt;$&#123;log.pattern&#125;&lt;/pattern&gt; &lt;/encoder&gt; &lt;filter class=&quot;ch.qos.logback.classic.filter.LevelFilter&quot;&gt; &lt;level&gt;DEBUG&lt;/level&gt; &lt;onMatch&gt;ACCEPT&lt;/onMatch&gt; &lt;onMismatch&gt;DENY&lt;/onMismatch&gt; &lt;/filter&gt; &lt;/appender&gt; &lt;!-- INFO --&gt; &lt;appender name=&quot;infoAppender&quot; class=&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;&gt; &lt;!-- 文件路径 --&gt; &lt;file&gt;$&#123;log.filePath&#125;/info.log&lt;/file&gt; &lt;rollingPolicy class=&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;&gt; &lt;!-- 文件名称 --&gt; &lt;fileNamePattern&gt;$&#123;log.filePath&#125;/info/info.%d&#123;yyyy-MM-dd&#125;.%i.log.gz&lt;/fileNamePattern&gt; &lt;!-- 文件最大保存历史数量 --&gt; &lt;maxHistory&gt;$&#123;log.maxHistory&#125;&lt;/maxHistory&gt; &lt;/rollingPolicy&gt; &lt;encoder&gt; &lt;pattern&gt;$&#123;log.pattern&#125;&lt;/pattern&gt; &lt;/encoder&gt; &lt;filter class=&quot;ch.qos.logback.classic.filter.LevelFilter&quot;&gt; &lt;level&gt;INFO&lt;/level&gt; &lt;onMatch&gt;ACCEPT&lt;/onMatch&gt; &lt;onMismatch&gt;DENY&lt;/onMismatch&gt; &lt;/filter&gt; &lt;/appender&gt; &lt;!-- ERROR --&gt; &lt;appender name=&quot;errorAppender&quot; class=&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;&gt; &lt;!-- 文件路径 --&gt; &lt;file&gt;$&#123;log.filePath&#125;/error.log&lt;/file&gt; &lt;rollingPolicy class=&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;&gt; &lt;!-- 文件名称 --&gt; &lt;fileNamePattern&gt;$&#123;log.filePath&#125;/error/error.%d&#123;yyyy-MM-dd&#125;.%i.log.gz&lt;/fileNamePattern&gt; &lt;!-- 文件最大保存历史数量 --&gt; &lt;maxHistory&gt;$&#123;log.maxHistory&#125;&lt;/maxHistory&gt; &lt;/rollingPolicy&gt; &lt;encoder&gt; &lt;pattern&gt;$&#123;log.pattern&#125;&lt;/pattern&gt; &lt;/encoder&gt; &lt;filter class=&quot;ch.qos.logback.classic.filter.LevelFilter&quot;&gt; &lt;level&gt;ERROR&lt;/level&gt; &lt;onMatch&gt;ACCEPT&lt;/onMatch&gt; &lt;onMismatch&gt;DENY&lt;/onMismatch&gt; &lt;/filter&gt; &lt;/appender&gt; &lt;!-- logger 存放日志对象，同时告诉我们logback我们需要关注哪个package下的信息 --&gt; &lt;!-- additivity 如果additivity为true那么root下面的appender也会想到logger下面 --&gt; &lt;logger name=&quot;com.brotherc.demo&quot; level=&quot;$&#123;log.level&#125;&quot; additivity=&quot;true&quot;&gt; &lt;appender-ref ref=&quot;debugAppender&quot; /&gt; &lt;appender-ref ref=&quot;infoAppender&quot; /&gt; &lt;appender-ref ref=&quot;errorAppender&quot; /&gt; &lt;/logger&gt; &lt;!--root 就是特殊的logger，根logger。如果logger没有指定level，默认继承root --&gt; &lt;root level=&quot;info&quot;&gt; &lt;appender-ref ref=&quot;consoleAppender&quot; /&gt; &lt;/root&gt;&lt;/configuration&gt;","categories":[],"tags":[{"name":"Logback","slug":"Logback","permalink":"http://yoursite.com/tags/Logback/"}],"keywords":[]},{"title":"分布式事务","slug":"分布式事务","date":"2020-05-04T11:43:32.967Z","updated":"2020-05-04T11:41:01.076Z","comments":true,"path":"2020/05/04/分布式事务/","link":"","permalink":"http://yoursite.com/2020/05/04/分布式事务/","excerpt":"","text":"两段式：2PC三段式：3PC 1.需要提供分布式事务支持的接口上添加@Compensable2.在对应的接口实现上添加@Compensable3.在接口上添加confirmMethod、cancelMethod、transactionContextEditor4.实现对应的confirmMethod、cancelMethod（注意：confirm方法和cancel方法必须与try方法在同一个类中）5.主事务的业务都已经实现的差不多的时候才调用子事务注意：1.分布式事务里，不要轻易在业务层捕获所有异常2.使用TCC-Transaction时，confirm和cancel的幂等性需要自己代码支持幂等性：使用相同参数对同一资源重复调用某个接口的结果与调用一次的结果相同参考：https://github.com/changmingxie/tcc-transaction","categories":[],"tags":[{"name":"分布式事务","slug":"分布式事务","permalink":"http://yoursite.com/tags/分布式事务/"}],"keywords":[]},{"title":"加密类型及其相关算法","slug":"加密类型及其相关算法","date":"2020-04-18T06:50:24.203Z","updated":"2020-04-18T06:49:48.043Z","comments":true,"path":"2020/04/18/加密类型及其相关算法/","link":"","permalink":"http://yoursite.com/2020/04/18/加密类型及其相关算法/","excerpt":"","text":"一、数据传输安全性在TCP/IP层中不涉及安全 机密性：明文传输（ftp,smtp,talnet）别人一拦截就能看到请求的内容。 完整性：10颗原子弹（被改成100）所以数据在互联网上传播的时候，不应该也不能够被其他人非法篡改掉。当收到的和发送的不一致时拒绝接受这就能保证数据的完整性。 身份验证：通过有效的手段保证所访问的对象就是我们所要的那个人。 保证数据的机密性 plaintext(明文) –&gt; 加密（转换规则）–&gt; ciphertext（密文） ciphertext –&gt; 转换规则 –&gt; plaintext 转换算法：依赖密钥（即使得到了转换规则也没用） 对称加密：加密和解密使用同一个密钥（有加密算法和解密算法，算法不同，但密钥相同）。好处是计算速度快，在一定程度上解决了机密性问题。坏处是不能解决密钥有效管理的问题。假如a跟b，c,d通信，如果密钥相同，则c只要用密钥就可以看到a发送给b的内容，显然密钥不能相同，那就得维护很多密钥。 保证数据的完整性 A：plaintext:footprint –&gt; BB使用同样的加密算法去重复计算这个明文的特征码，并跟A所发过来的特征码进行比较，如果一样，则说明没被篡改。 单项加密算法：提取数据特征码，追加到数据后面。数据的输入一样：特征码必然相同。 特点：输入一样，输出必然相同雪崩效应（输入的微小改变，将其会引起结果的巨大改变）定长输出（无论原始数据是多长，结果大小都是相同的）不可逆（无法根据原始特征码还原原来的数据） 中间人攻击问题 E(A)：plaintext2:footprint2 –&gt; BA生成一段数据，并对它计算特征码，E在中间经过的路由时拿到这个明文，并重新修改明文和再计算特征码发给B，还声称自己是A，B拿到数据之后就算使用了数据完整性的算法之后，计算特征码还是一模一样，还认为是A发过来的，所以需要借助额外的机制。 解决办法：A：plaintext:footprint(加密) –&gt; B B拿到特征码之后通过密钥进行解密，能解密说明数据没有被改过。如果E拿到plaintext并修改为plaintext2，并重新生成特征码，就没办法加密特征码或者加密后就不是A和B之间实现约定的密码。 A与B之间如何进行密码约定 假如A与B之间从未通信或从未见过面，如何进行密码约定呢？ 协商生成密码：密码交换（Internet Key Exchange / IKE）,密码交换是不让第三方得到密钥，密码交换需要特殊的互联网协议支撑。比如：Dffie-Hellman协议。 A和B事先约定两个数p(大素数)，g(生成数)。A生成一个自己知道的x，B生成一个自己知道的y。A将 g^x % p 发送给B，B将g^y % p 发送给A。A拿到之后进行计算 （g^y % p）^x = g^xy % p，B拿到之后进行计算 （g^x % p）^y = g^xy % p。这个相同的结果就是密钥。在互联网上可以看到g、p、g^x % p、g^y % p，但看不到x、y。 A和B只需要选好几个数，让这些数的计算结果作为密钥来用，使得彼此不用计算密码，只要双方生成密钥的软件一样就可以随时生成密钥。 身份验证 之前是A和B一起约定好的密码，所以身份验证没问题。但是密钥是交换生成的，事先之前谁也不知道。E跳出来，截取了数据并篡改，然后与B进行连接通信，还告诉它自己是A。 解决办法：公钥加密算法（非对称加密算法） 特点：拥有一对密钥对，分别是公钥（是从私钥中提取出来的）、私钥。用公钥加密的，只能用私钥解密，反之亦然。 结论 机密性：用B的公钥加密，B的私钥解密。发送方用对方的公钥加密数据，可以保证数据机密性。 身份验证：用A的私钥加密，A的公钥解密。发送方用自己的私钥加密数据，可以实现身份验证。 公钥加密算法很少用来加密数据：速度太慢。非对称加密的主要作用也就是身份验证。 二、数据传输 PKI:公钥基础设施(Public Key Infrastructure) 核心就是CA和彼此之间的信任关系CA:证书颁发机构(Certificate Authority)，CA中还维护了CRLCRL:证书撤销列表，CRL中保存了此前曾经发出去的证书，但仍未过期，只不过已经各种原因被撤销了 三、TLS/SSL 不同标准下的证书格式是不同的比如x509, pkcs12x509: 公钥及其有效期限，证书的合法拥有者，证书该如何被使用，CA的信息，CA签名的校验码TLS/SSL所使用的正是x509的证书，TLS/SSL其实就是一种PKI，PKI的第二种实现OpenGPG TLS/SSL 如何实现握手认证、密钥交换 四、加密对称加密加密解密使用同一个密码 DES(Data Encrption Standard, 56bit) 3DES AES(Advanced, AES192/AES256/AES512) Blowfish 单向加密 MD4 MD5 SHA1 SHA192、SHA256、SHA384 CRC-32 非对称加密（公钥加密）身份认证（数字签名）、数据加密、密钥交换 RSA(加密、签名) DSA(签名) ElGamal 加密实现OpenSSL: SSL的开源实现 libcryptc: 通用的加密库 libssl: TLS/SSL的实现 基于会话的、实现了省份认证、数据机密性和会话完整性的TLS/SSL库 openssl: 多用途命令行工具 实现私有证书颁发机构","categories":[],"tags":[{"name":"加密","slug":"加密","permalink":"http://yoursite.com/tags/加密/"}],"keywords":[]},{"title":"docker基础","slug":"docker","date":"2020-04-12T04:05:46.535Z","updated":"2020-04-12T04:01:02.754Z","comments":true,"path":"2020/04/12/docker/","link":"","permalink":"http://yoursite.com/2020/04/12/docker/","excerpt":"","text":"安装1234567891011121314sudo yum remove docker \\docker-common \\docker-selinux \\docker-enginesudo yum install -y yum-utils \\device-mapper-persistent-data \\lvm2sudo yum-config-manager \\--add-repo \\https://download.docker.com/linux/centos/docker-ce.reposudo yum install docker-ce 启动12sudo systemctl start dockersudo docker version helloworld1sudo docker run hello-world 镜像 123456789101112// 查看进程ps -ef | grep docker// 查看镜像sudo docker image ls// 拉取镜像sudo docker pull ubuntu:14.04// 运行镜像docker run hello-worlddocker run -it centos// 删除镜像docker image rm 67759a80360c(镜像ID)docker image rmi f2a91732366c(镜像ID) 自己实现helloworld123456789101112mkdir hello-worldcd hello-world/vim hello.c// 内容#include&lt;stdio.h&gt;int main() &#123; printf(&quot;hello docker\\n&quot;);&#125;gcc -static hello.c -o hello 123456vim Dockerfile// 内容FROM scratchADD hello /CMD [&quot;/hello&quot;] 12docker build -t brotherc/hello-world .docker run brotherc/hello-world 容器 1234567891011121314docker container lsdocker container ls -adocker container ps -adocker rm $(docker container ls -f &quot;status-exited&quot; -q)docker rm $(docker container ls -aq)docker container rm 846b5efe98d4(容器ID)docker container rm 84(容器ID前缀)// 将已有容器提交成新的镜像Usage: docker commit [OPTIONS] CONTAINER [REPOSITORY[:TAG]] [flags]docker commit xenodochial_pare(容器名称) brotherc/centos-vimdocker stop 容器id或名称docker start 容器id或名称docker inspect 容器id或名称docker logs 容器id或名称 基于已经存在的container创建一个image1234// 运行一个已安装好vim的centos容器docker run -it centosyum install -y vimexit 12// 容器名：xenodochial_paredocker commit xenodochial_pare brotherc/centos-vim 基于Dockerfile创建一个image12345678mkdir docker-centos-vimcd docker-centos-vim/vim DockerfileFROM centosRUN yum install -y vimdocker build -t brotherc/centos-vim-new . DockerfileFROM尽量使用官方的image作为base image!123FROM scratch #制作base imageFROM centos #使用base imageFROM ubuntu:14.04 LABELMetadata不可少!123LABEL maintainer=&quot;brotherc@136.com&quot;LABEL version=&quot;1.0&quot;LABEL description=&quot;This is description&quot; RUN为了美观，复杂的RUN请用反斜杠换行!避免无用分层，合并多条命令成一行!12RUN yum update &amp;&amp; yum install -y vim \\ #反斜线换行 python-dev 123RUN apt-get update &amp;&amp; apt-get install -y perl \\ pwgen --no-install-recommends &amp;&amp; rm -rf \\ /var/lib/apt/lists/* #注意清理cache 1RUN /bin/bash -c&apos;source $HOME/.bashrc;echo $HOME&apos; WORKDIR设定当前工作目录，类似cd用WORKDIR，不要用RUN cd!尽量使用绝对目录!1WORKDIR /root 123WORKDIR /test #如果没有会自动创建test目录WORKDIR demoRUN pwd #输出结果应该是 /test/demo ADD and COPY将本地文件添加到image里面大部分情况，COPY优于ADD!ADD除了COPY还有额外功能(解压)!添加远程文件/目录请使用curl或者wget!1ADD hello / 1ADD test.tar.gz / #添加到根目录并解压 12WORKDIR /rootADD hello test/ # /root/test/hello 12WORKDIR /rootCOPY hello test/ ENV尽量使用ENV增加可维护性!123ENV MYSQL_VERSION 5.6 #设置常量RUN apt-get install -y mysql-server=&quot;$&#123;MYSQL_VERSION&#125;&quot; \\ &amp;&amp; rm -rf /var/lib/apt/lists/* #引用常量 RUN vs CMD vs ENTRYPOINTRUN:执行命令并创建新的image layerCMD:设置容器启动后默认执行的命令和参数ENTRYPOINT:设置容器启动时运行的命令 Shell格式123RUN apt-get install -y vimCMD echo &quot;hello docker&quot;ENTRYPOINT echo &quot;hello docker&quot; 123FROM centosENV name DockerENTRYPOINT echo &quot;hello $name&quot; Exec格式123RUN [&quot;apt-get&quot;, &quot;install&quot;, &quot;-y&quot;, &quot;vim&quot;]CMD [&quot;/bin/echo&quot;, &quot;hello docker&quot;]ENTRYPOINT [&quot;/bin/echo&quot;, &quot;hello docker&quot;] 123FROM centosENV name DockerENTRYPOINT [&quot;/bin/echo&quot;, &quot;hello docker&quot;] Dockerfile实践Dockerfile:123FROM centosENV name DockerENTRYPOINT echo &quot;hello $name&quot; 123docker build -t brotherc/centos-entrypoint-shell .docker run brotherc/centos-entrypoint-shellhello Docker Dockerfile:123FROM centosENV name DockerENTRYPOINT [&quot;/bin/bash&quot;, &quot;-c&quot;, &quot;echo hello $name&quot;] 123docker build -t brotherc/centos-entrypoint-exec .docker run brotherc/centos-entrypoint-exechello Docker CMD容器启动时默认执行的命令如果docker run指定了其它命令，CMD命令被忽略如果定义了多个CMD，只有最后一个会执行Dockerfile:123FROM centosENV name DockerCMD echo &quot;hello $name&quot; 123456docker build -t brotherc/centos-cmd-shell .docker run brotherc/centos-cmd-shellhello Dockerdocker run -it brotherc/centos-cmd-shell /bin/bash无输出 ENTRYPOINT让容器以应用程序或者服务的形式运行不会被忽略，一定会执行12345docker run brotherc/centos-entrypoint-shellhello Dockerdocker run -it brotherc/centos-entrypoint-shell /bin/bashhello Docker 镜像的发布123docker logindocker push DockerId/镜像名称docker pull DockerId/镜像名称 分享产生image把我们的账户link到github或bitbucket，在github上面创建一个代码仓库，把我们的dockerfile push上去，这样就做了一个关联。只要我们这个仓库里面有dockerfile，就会自动去克隆获取到这个dockerfile然后dockerhub后台服务器会帮我们去build。这样我们既提供了dockerfile，docker image又是dockerhub后台服务器帮我们build的，这个安全性会有很大的提升。 私有的registry12docker run -d -p 5000:5000 --restart always --name registry// 访问ip:5000 /etc/docker/daemon.json:1&#123;&quot;insecure-registries&quot;:[&quot;ip:5000&quot;]&#125; /lib/systemd/system/docker.service:1sudo service docker restart 1234telnet ip:5000docker push ip:5000/镜像名称docker pull ip:5000/镜像名称 Docker Network基础网络概念 1234sudo docker run -d --name test1 busybox /bin/sh -c &quot;while true; do sleep 3600; done&quot;sudo docker exec -it test1 /bin/ship a 12sudo docker run -d --name test2 busybox /bin/sh -c &quot;while true; do sleep 3600; done&quot;sudo docker exec test2 ip a Docker的持久化存储和数据共享 数据持久化：Data Volume 12//mysql镜像会默认将数据挂载到本地sudo docker run -d --name mysql1 -e MYSQL_ALLOW_EMPTY_PASSWORD=true mysql 123456sudo docker volume lsDRIVER VOLUME NAMElocal e6ee5901156...sudo docker volume inspect e6ee5901156... 123456sudo docker stop mysql1sudo docker rm mysql1sudo docker volume lsDRIVER VOLUME NAMElocal e6ee5901156... 123456//给volume指定名字sudo docker run -d -v mysql:/var/lib/mysql --name mysql1 -e MYSQL_ALLOW_EMPTY_PASSWORD=true mysqlsudo docker volume lsDRIVER VOLUME NAMElocal mysql 123//让mysql容器使用已存在的volumesudo docker rm -rf mysql1sudo docker run -d -v mysql:/var/lib/mysql --name mysql2 -e MYSQL_ALLOW_EMPTY_PASSWORD=true mysql 数据持久化：Bind Mouting Dockerfile:123FROM nginx:latestWORKDIR /usr/share/nginx/htmlCOPY index.html index.html 12docker build -t brotherc/my-nginx .docker run -d -p 80:80 --name web brotherc/my-nginx 12345678docker rm -f webdocker run -d -v $(pwd):/usr/share/nginx/html -p 80:80 --name web brotherc/my-nginxdocker exec -it web /bin/bash//在容器中cd /usr/share/nginx/htmltouch test.txtexit//在linux中看到刚刚创建的test.txt文件","categories":[],"tags":[{"name":"docker","slug":"docker","permalink":"http://yoursite.com/tags/docker/"}],"keywords":[]},{"title":"网站","slug":"网站","date":"2020-04-09T12:46:59.230Z","updated":"2020-04-09T12:46:08.476Z","comments":true,"path":"2020/04/09/网站/","link":"","permalink":"http://yoursite.com/2020/04/09/网站/","excerpt":"","text":"参考：https://www.wireshark.orghttps://www.processon.com/ http://xinjipin.com/list.asp?id=26https://www.yunpanjingling.com/","categories":[],"tags":[{"name":"网站","slug":"网站","permalink":"http://yoursite.com/tags/网站/"}],"keywords":[]},{"title":"Spring Security技术栈开发企业级认证与授权-Spring Security 开发基于表单的认证","slug":"Spring Security技术栈开发企业级认证与授权-Spring Security 开发基于表单的认证","date":"2020-04-09T12:29:14.421Z","updated":"2020-04-09T12:28:54.104Z","comments":true,"path":"2020/04/09/Spring Security技术栈开发企业级认证与授权-Spring Security 开发基于表单的认证/","link":"","permalink":"http://yoursite.com/2020/04/09/Spring Security技术栈开发企业级认证与授权-Spring Security 开发基于表单的认证/","excerpt":"","text":"1.Spring Security 原理介绍如果在classpath下有spring security相关jar包，springboot会替我们做安全配置。 12用户名：（固定）user 1密码：（看启动日志，默认安全密码） 默认不做任何配置的时候，spring security做了两件事。把访问的所有服务都保护起来，访问任何一个restful服务，都要先进行身份认证，认证方式是http.base方式。 配置security-browser:123456789101112@Configurationpublic class BrowserSecurityConfig extends AbstractChannelSecurityConfig &#123; @Override protected void configure(HttpSecurity http) throws Exception &#123;// http.formLogin() //formLogin表单登录 http.httpBasic() //http.base登录 .and() .authorizeRequests() .anyRequest() //任何请求都要身份认证 .authenticated(); &#125;&#125; 123绿色过滤器：认证用户的身份，每一个过滤器处理一种认证方式。橙色过滤器：最终到这里，决定当前请求能不能去访问后面的服务，依据代码里的配置，判断是不是经过了前面的认证配置，根据代码中的规则判断过还是不过，不过会根据不用的原因抛出异常。蓝色过滤器：捕获后面这个过滤器抛出的异常，根据抛出的异常做出相应的处理。 2.基于Spring Security的默认实现开发“用户名 + 密码” 认证自定义用户认证逻辑处理用户信息获取逻辑 UserDetailsService &amp; 处理用户校验逻辑 UserDetailssecurity-demo:12345678910111213141516@Componentpublic class MyUserDetailsService implements UserDetailsService &#123; private Logger logger = LoggerFactory.getLogger(getClass()); @Override public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException &#123; logger.info(&quot;表单登录用户名:&quot; + username); // 根据用户名查找用户信息 // 根据查找到的用户信息判断用户是否被冻结 // User =&gt; isAccountNonExpired() // User =&gt; isAccountNonLocked() // User =&gt; isCredentialsNonExpired() // User =&gt; isEnabled() return new User(username, &quot;123456&quot;, true, true, true, true, AuthorityUtils.commaSeparatedStringToAuthorityList(&quot;admin&quot;)); &#125;&#125; 处理密码加密解密 PasswordEncoder12345678@Configurationpublic class BrowserSecurityConfig extends AbstractChannelSecurityConfig &#123; @Bean public PasswordEncoder passwordEncoder() &#123; return new BCryptPasswordEncoder(); &#125; ...&#125; 1234567891011121314@Componentpublic class MyUserDetailsService implements UserDetailsService &#123; private Logger logger = LoggerFactory.getLogger(getClass()); @Autowired private PasswordEncoder passwordEncoder; @Override public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException &#123; ... String password = passwordEncoder.encode(&quot;123456&quot;); logger.info(&quot;数据库密码是:&quot;+password); return new User(username, password, true, true, true, true, AuthorityUtils.commaSeparatedStringToAuthorityList(&quot;admin&quot;)); &#125;&#125; 个性化用户认证流程自定义登录页面123456789101112131415161718@Configurationpublic class BrowserSecurityConfig extends AbstractChannelSecurityConfig &#123; ... @Override protected void configure(HttpSecurity http) throws Exception &#123; http.formLogin() .loginPage(&quot;/login.html&quot;) .loginProcessingUrl(&quot;/authentication/form&quot;) .and() .authorizeRequests() .antMatchers(&quot;login.html&quot;).permitAll() .anyRequest() .authenticated() .and() .csrf().disable(); &#125;&#125; security-browser \\src\\main\\resources\\resources\\login.html123456789101112131415161718192021222324252627&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;UTF-8&quot;&gt;&lt;title&gt;登录&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h2&gt;标准登录页面&lt;/h2&gt; &lt;h3&gt;表单登录&lt;/h3&gt; &lt;form action=&quot;/authentication/form&quot; method=&quot;post&quot;&gt; &lt;table&gt; &lt;tr&gt; &lt;td&gt;用户名:&lt;/td&gt; &lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;username&quot;&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;密码:&lt;/td&gt; &lt;td&gt;&lt;input type=&quot;password&quot; name=&quot;password&quot;&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td colspan=&quot;2&quot;&gt;&lt;button type=&quot;submit&quot;&gt;登录&lt;/button&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/form&gt; &lt;br&gt;&lt;/body&gt;&lt;/html&gt; security-core:1234@Datapublic class BrowserProperties &#123; private String loginPage = &quot;login.html&quot;;&#125; 12345@Data@ConfigurationProperties(prefix = &quot;demo.security&quot;)public class SecurityProperties &#123; private BrowserProperties browser = new BrowserProperties();&#125; 1234@Configuration@EnableConfigurationProperties(SecurityProperties.class)public class SecurityCoreConfig &#123;&#125; security-browser1234567891011121314151617181920212223242526272829@RestControllerpublic class BrowserSecurityController &#123; private Logger logger = LoggerFactory.getLogger(getClass()); private RequestCache requestCache = new HttpSessionRequestCache(); private RedirectStrategy redirectStrategy = new DefaultRedirectStrategy(); @Autowired private SecurityProperties securityProperties; /** * 当需要身份认证时，跳转到这里 */ @RequestMapping(&quot;/authentication/require&quot;) @ResponseStatus(code = HttpStatus.UNAUTHORIZED) public SimpleResponse requireAuthentication(HttpServletRequest request, HttpServletResponse response) throws IOException &#123; SavedRequest savedRequest = requestCache.getRequest(request, response); if (savedRequest != null) &#123; String targetUrl = savedRequest.getRedirectUrl(); logger.info(&quot;引发跳转的请求是:&quot; + targetUrl); if (StringUtils.endsWithIgnoreCase(targetUrl, &quot;.html&quot;)) &#123; redirectStrategy.sendRedirect(request, response, securityProperties.getBrowser().getLoginPage()); &#125; &#125; return new SimpleResponse(&quot;访问的服务需要身份认证，请引导用户到登录页&quot;); &#125;&#125; 12345@Data@AllArgsConstructorpublic class SimpleResponse &#123; private Object content;&#125; 1234567891011121314151617181920@Configurationpublic class BrowserSecurityConfig extends AbstractChannelSecurityConfig &#123; ... @Autowired private SecurityProperties securityProperties; @Override protected void configure(HttpSecurity http) throws Exception &#123; http.formLogin() .loginPage(&quot;/authentication/require&quot;) .loginProcessingUrl(&quot;/authentication/form&quot;) .and() .authorizeRequests() .antMatchers(&quot;/authentication/require&quot;, securityProperties.getBrowser().getLoginPage()).permitAll() .anyRequest() .authenticated() .and() .csrf().disable(); &#125;&#125; security-demo \\src\\main\\resources\\resources\\demo-login.html12345678910&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;UTF-8&quot;&gt;&lt;title&gt;登录&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h2&gt;Demo登录页&lt;/h2&gt;&lt;/body&gt;&lt;/html&gt; security-demo application.properties1demo.security.browser.loginPage = /demo-login.html 自定义登录成功处理security-browser:1234567891011121314151617181920212223@Component(&quot;myAuthenticationSuccessHandler&quot;)public class MyAuthenticationSuccessHandler extends SavedRequestAwareAuthenticationSuccessHandler &#123; private Logger logger = LoggerFactory.getLogger(getClass()); @Autowired private ObjectMapper objectMapper; @Autowired private SecurityProperties securityProperties; @Override public void onAuthenticationSuccess(HttpServletRequest request, HttpServletResponse response, Authentication authentication) throws IOException, ServletException &#123; logger.info(&quot;登录成功&quot;); if (LoginResponseType.JSON.equals(securityProperties.getBrowser().getLoginType())) &#123; response.setContentType(&quot;application/json;charset=UTF-8&quot;); response.getWriter().write(objectMapper.writeValueAsString(authentication)); &#125; else &#123; super.onAuthenticationSuccess(request, response, authentication); &#125; &#125;&#125; 自定义登录失败处理security-browser:12345678910111213141516171819202122232425@Component(&quot;myAuthenctiationFailureHandler&quot;)public class MyAuthenctiationFailureHandler extends SimpleUrlAuthenticationFailureHandler &#123; private Logger logger = LoggerFactory.getLogger(getClass()); @Autowired private ObjectMapper objectMapper; @Autowired private SecurityProperties securityProperties; @Override public void onAuthenticationFailure(HttpServletRequest request, HttpServletResponse response, AuthenticationException exception) throws IOException, ServletException &#123; logger.info(&quot;登录失败&quot;); if (LoginResponseType.JSON.equals(securityProperties.getBrowser().getLoginType())) &#123; response.setStatus(HttpStatus.INTERNAL_SERVER_ERROR.value()); response.setContentType(&quot;application/json;charset=UTF-8&quot;); response.getWriter().write(objectMapper.writeValueAsString(new SimpleResponse(exception.getMessage()))); &#125;else&#123; super.onAuthenticationFailure(request, response, exception); &#125; &#125;&#125; 12345@Datapublic class BrowserProperties &#123; ... private LoginResponseType loginType = LoginResponseType.JSON;&#125; 1234567891011public enum LoginResponseType &#123; /** * 跳转 */ REDIRECT, /** * 返回json */ JSON&#125; 12345678910111213141516171819202122232425262728@Configurationpublic class BrowserSecurityConfig extends AbstractChannelSecurityConfig &#123; ... @Autowired private SecurityProperties securityProperties; @Autowired private AuthenticationSuccessHandler myAuthenticationSuccessHandler; @Autowired private AuthenctiationFailureHandler myAuthenctiationFailureHandler; @Override protected void configure(HttpSecurity http) throws Exception &#123; http.formLogin() .loginPage(&quot;/authentication/require&quot;) .loginProcessingUrl(&quot;/authentication/form&quot;) .successHandler(myAuthenticationSuccessHandler) .failureHandler(myAuthenctiationFailureHandler) .and() .authorizeRequests() .antMatchers(&quot;/authentication/require&quot;, securityProperties.getBrowser().getLoginPage()).permitAll() .anyRequest() .authenticated() .and() .csrf().disable(); &#125;&#125; security-demo application.properties1demo.security.browser.loginType = REDIRECT 实现图形验证码功能开发生成图形验证码接口security-core123456789101112131415161718192021@Datapublic class ImageCode &#123; private BufferedImage image; private String code; private LocalDateTime expireTime; public ImageCode(String code, int expireIn)&#123; this.code = code; this.expireTime = LocalDateTime.now().plusSeconds(expireIn); &#125; public ImageCode(String code, LocalDateTime expireTime)&#123; this.code = code; this.expireTime = expireTime; &#125; public boolean isExpried() &#123; return LocalDateTime.now().isAfter(expireTime); &#125;&#125; 123456789101112131415@RestControllerpublic class ValidateCodeController &#123; public static final String SESSION_KEY = &quot;SESSION_KEY_IMAGE_CODE&quot;; private SessionStrategy sessionStrategy = new HttpSessionSessionStrategy(); @Autowired private ValidateCodeGenerator imageCodeGenerator; @GetMapping(&quot;/code/image&quot;) public void createCode(HttpServletRequest request, HttpServletResponse response) throws Exception &#123; ImageCode imageCode = imageCodeGenerator.generate(new ServletWebRequest(request)); sessionStrategy.setAttribute(new ServletWebRequest(request), SESSION_KEY, imageCode); ImageIO.write(imageCode.getImage(), &quot;JPEG&quot;, request.getResponse().getOutputStream()); &#125;&#125; 验证码的生成逻辑可配置12345678910111213@Configurationpublic class ValidateCodeBeanConfig &#123; @Autowired private SecurityProperties securityProperties; @Bean @ConditionalOnMissingBean(name = &quot;imageValidateCodeGenerator&quot;) public ValidateCodeGenerator imageValidateCodeGenerator() &#123; ImageCodeGenerator codeGenerator = new ImageCodeGenerator(); codeGenerator.setSecurityProperties(securityProperties); return codeGenerator; &#125;&#125; 123public interface ValidateCodeGenerator &#123; ValidateCode generate(ServletWebRequest request);&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273public class ImageCodeGenerator implements ValidateCodeGenerator &#123; /** * 系统配置 */ @Autowired private SecurityProperties securityProperties; @Override public ImageCode generate(ServletWebRequest request) &#123; int width = ServletRequestUtils.getIntParameter(request.getRequest(), &quot;width&quot;, securityProperties.getCode().getImage().getWidth()); int height = ServletRequestUtils.getIntParameter(request.getRequest(), &quot;height&quot;, securityProperties.getCode().getImage().getHeight()); BufferedImage image = new BufferedImage(width, height, BufferedImage.TYPE_INT_RGB); Graphics g = image.getGraphics(); Random random = new Random(); g.setColor(getRandColor(200, 250)); g.fillRect(0, 0, width, height); g.setFont(new Font(&quot;Times New Roman&quot;, Font.ITALIC, 20)); g.setColor(getRandColor(160, 200)); for (int i = 0; i &lt; 155; i++) &#123; int x = random.nextInt(width); int y = random.nextInt(height); int xl = random.nextInt(12); int yl = random.nextInt(12); g.drawLine(x, y, x + xl, y + yl); &#125; String sRand = &quot;&quot;; for (int i = 0; i &lt; securityProperties.getCode().getImage().getLength(); i++) &#123; String rand = String.valueOf(random.nextInt(10)); sRand += rand; g.setColor(new Color(20 + random.nextInt(110), 20 + random.nextInt(110), 20 + random.nextInt(110))); g.drawString(rand, 13 * i + 6, 16); &#125; g.dispose(); return new ImageCode(image, sRand, securityProperties.getCode().getImage().getExpireIn()); &#125; /** * 生成随机背景条纹 * * @param fc * @param bc * @return */ private Color getRandColor(int fc, int bc) &#123; Random random = new Random(); if (fc &gt; 255) &#123; fc = 255; &#125; if (bc &gt; 255) &#123; bc = 255; &#125; int r = fc + random.nextInt(bc - fc); int g = fc + random.nextInt(bc - fc); int b = fc + random.nextInt(bc - fc); return new Color(r, g, b); &#125; public SecurityProperties getSecurityProperties() &#123; return securityProperties; &#125; public void setSecurityProperties(SecurityProperties securityProperties) &#123; this.securityProperties = securityProperties; &#125;&#125; 验证码基本参数可配置12345@ConfigurationProperties(prefix = &quot;demo.security&quot;)public class SecurityProperties &#123; ... private ValidateCodeProperties code = new ValidateCodeProperties();&#125; 1234@Datapublic class ValidateCodeProperties &#123; private ImageCodeProperties image = new ImageCodeProperties();&#125; 123456789@Datapublic class ImageCodeProperties &#123; private int length = 4; private int width = 67; private int height = 23; private int expireIn = 60; private String url;&#125; 1234567891011121314151617181920@Configurationpublic class BrowserSecurityConfig extends AbstractChannelSecurityConfig &#123; ... @Override protected void configure(HttpSecurity http) throws Exception &#123; http.formLogin() .loginPage(&quot;/authentication/require&quot;) .loginProcessingUrl(&quot;/authentication/form&quot;) .successHandler(myAuthenticationSuccessHandler) .failureHandler(myAuthenctiationFailureHandler) .and() .authorizeRequests() .antMatchers(&quot;/authentication/require&quot;, securityProperties.getBrowser().getLoginPage(), &quot;/code/image&quot;).permitAll() .anyRequest() .authenticated() .and() .csrf().disable(); &#125;&#125; 123456789... &lt;tr&gt; &lt;td&gt;图形验证码:&lt;/td&gt; &lt;td&gt; &lt;input type=&quot;text&quot; name=&quot;imageCode&quot;&gt; &lt;img src=&quot;/code/image?width=200&quot;&gt; &lt;/td&gt; &lt;/tr&gt;... 在认证流程中加入图形验证码校验 &amp; 验证码拦截的接口可配置 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667public class ValidateCodeFilter extends OncePerRequestFilter implements InitializingBean &#123; private AuthenticationFailureHandler authenticationFailureHandler; private SessionStrategy sessionStrategy = new HttpSessionSessionStrategy(); private Set&lt;String&gt; urls = new HashSet&lt;&gt;(); private SecurityProperties securityProperties; private AntPathMatcher pathMatcher = new AntPathMatcher(); @Override public void afterPropertiesSet() throws ServletException &#123; super.afterPropertiesSet(); String[] urls = StringUtils.splitByWholeSeparatorPreserveAllTokens(securityProperties.getCode().getImage().getUrl(), &quot;,&quot;); for (String url : urls) &#123; urls.put(url); &#125; urls.add(&quot;/authentication/form&quot;); &#125; @Override protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain chain) throws ServletException, IOException &#123; boolean action = false; for (String url : urls) &#123; if (pathMatcher.match(url, request.getRequestURI())) &#123; action = true; &#125; &#125; if (action) &#123; try &#123; validate(new ServletWebRequest(request, response)); &#125; catch (ValidateCodeException exception) &#123; authenticationFailureHandler.onAuthenticationFailure(request, response, exception); return; &#125; &#125; chain.doFilter(request, response); &#125; public void validate(ServletWebRequest request) &#123; String sessionKey = ValidateCodeController.SESSION_KEY; ImageCode codeInSession = (ImageCode)sessionStrategy.getAttribute(request, sessionKey); String codeInRequest; try &#123; codeInRequest = ServletRequestUtils.getStringParameter(request.getRequest(), &quot;imageCode&quot;); &#125; catch (ServletRequestBindingException e) &#123; throw new ValidateCodeException(&quot;获取验证码的值失败&quot;); &#125; if (StringUtils.isBlank(codeInRequest)) &#123; throw new ValidateCodeException(processorType + &quot;验证码的值不能为空&quot;); &#125; if (codeInSession == null) &#123; throw new ValidateCodeException(processorType + &quot;验证码不存在&quot;); &#125; if (codeInSession.isExpried()) &#123; sessionStrategy.removeAttribute(request, sessionKey); throw new ValidateCodeException(processorType + &quot;验证码已过期&quot;); &#125; if (!StringUtils.equals(codeInSession.getCode(), codeInRequest)) &#123; throw new ValidateCodeException(processorType + &quot;验证码不匹配&quot;); &#125; sessionStrategy.removeAttribute(request, sessionKey); &#125;&#125; 1234567public class ValidateCodeException extends AuthenticationException &#123; private static final long serialVersionUID = -7285211528095468156L; public ValidateCodeException(String msg) &#123; super(msg); &#125;&#125; 1234567891011121314151617181920212223242526@Configurationpublic class BrowserSecurityConfig extends AbstractChannelSecurityConfig &#123; ... @Override protected void configure(HttpSecurity http) throws Exception &#123; ValidateCodeFilter validateCodeFilter = new ValidateCodeFilter(); validateCodeFilter.setAuthenticationFailureHandler(myAuthenticationFailureHandler); validateCodeFilter.setSecurityProperties(securityProperties); validateCodeFilter.afterPropertiesSet(); http.addFilterBefore(validateCodeFilter, UsernamePasswordAuthenticationFilter.class) .formLogin() .loginPage(&quot;/authentication/require&quot;) .loginProcessingUrl(&quot;/authentication/form&quot;) .successHandler(myAuthenticationSuccessHandler) .failureHandler(myAuthenctiationFailureHandler) .and() .authorizeRequests() .antMatchers(&quot;/authentication/require&quot;, securityProperties.getBrowser().getLoginPage(), &quot;/code/image&quot;).permitAll() .anyRequest() .authenticated() .and() .csrf().disable(); &#125;&#125; security-demo application.properties123demo.security.code.image.length = 6demo.security.code.image.width = 100demo.security.code.image.url = /user,/user/* 12345678@Component(&quot;imageCodeGenerator&quot;)public class DemoImageCodeGenerator implements ValidateCodeGenerator &#123; @Override public ImageCode generate(ServletWebRequest request) &#123; System.out.println(&quot;更高级的图形验证码生成代码&quot;); return null; &#125;&#125; 实现 “记住我” 功能 security-browser:123&lt;tr&gt; &lt;td colspan=&apos;2&apos;&gt;&lt;input name=&quot;remember-me&quot; type=&quot;checkbox&quot; value=&quot;true&quot; /&gt;记住我&lt;/td&gt;&lt;/tr&gt; 1234public class BrowserProperties &#123; ... private int rememberMeSeconds = 3600;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344@Configurationpublic class BrowserSecurityConfig extends AbstractChannelSecurityConfig &#123; ... @Autowired private DataSource dataSource; @Autowired private UserDetailsService userDetailsService; @Override protected void configure(HttpSecurity http) throws Exception &#123; ValidateCodeFilter validateCodeFilter = new ValidateCodeFilter(); validateCodeFilter.setAuthenticationFailureHandler(myAuthenticationFailureHandler); validateCodeFilter.setSecurityProperties(securityProperties); validateCodeFilter.afterPropertiesSet(); http.addFilterBefore(validateCodeFilter, UsernamePasswordAuthenticationFilter.class) .formLogin() .loginPage(&quot;/authentication/require&quot;) .loginProcessingUrl(&quot;/authentication/form&quot;) .successHandler(myAuthenticationSuccessHandler) .failureHandler(myAuthenctiationFailureHandler) .and() .rememberMe() .tokenRepository(persistentTokenRepository()) .tokenValiditySeconds(securityProperties.getBrowser().getRememberMeSeconds()) .userDetailsService(userDetailsService) .and() .authorizeRequests() .antMatchers(&quot;/authentication/require&quot;, securityProperties.getBrowser().getLoginPage(), &quot;/code/image&quot;).permitAll() .anyRequest() .authenticated() .and() .csrf().disable(); &#125; ... @Bean public PersistentTokenRepository persistentTokenRepository() &#123; JdbcTokenRepositoryImpl tokenRepository = new JdbcTokenRepositoryImpl(); tokenRepository.setDataSource(dataSource);// tokenRepository.setCreateTableOnStartup(true); return tokenRepository; &#125;&#125; 3.开发 “手机号 + 短信” 认证实现短信验证码登录开发短信验证码接口123456789101112131415161718public class ValidateCode &#123; private String code; private LocalDateTime expireTime; public ValidateCode(String code, int expireIn)&#123; this.code = code; this.expireTime = LocalDateTime.now().plusSeconds(expireIn); &#125; public ValidateCode(String code, LocalDateTime expireTime)&#123; this.code = code; this.expireTime = expireTime; &#125; public boolean isExpried() &#123; return LocalDateTime.now().isAfter(expireTime); &#125;&#125; 修改ValidateCodeGenerator返回值123public interface ValidateCodeGenerator &#123; ValidateCode generate(ServletWebRequest request);&#125; 123456@Datapublic class SmsCodeProperties &#123; private int length = 6; private int expireIn = 60; private String url;&#125; 12345@Datapublic class ValidateCodeProperties &#123; ... private SmsCodeProperties sms = new SmsCodeProperties();&#125; 1234567891011@Data@Component(&quot;smsValidateCodeGenerator&quot;)public class SmsCodeGenerator implements ValidateCodeGenerator &#123; ... @Override public ValidateCode generate(ServletWebRequest request) &#123; String code = RandomStringUtils.randomNumeric(securityProperties.getCode().getSms().getLength()); return new ValidateCode(code, securityProperties.getCode().getSms().getExpireIn()); &#125;&#125; 123public interface SmsCodeSender &#123; void send(String mobile, String code);&#125; 123456789@Configurationpublic class ValidateCodeBeanConfig &#123; ... @Bean @ConditionalOnMissingBean(SmsCodeSender.class) public SmsCodeSender smsCodeSender() &#123; return new DefaultSmsCodeSender(); &#125;&#125; 123456public class DefaultSmsCodeSender implements SmsCodeSender &#123; @Override public void send(String mobile, String code) &#123; System.out.println(&quot;向手机&quot;+mobile+&quot;发送短信验证码&quot;+code); &#125;&#125; 123456789101112131415161718@RestControllerpublic class ValidateCodeController &#123; ... @Autowired private SmsCodeSender smsCodeSender; @Autowired private SmsCodeGenerator smsCodeGenerator; @GetMapping(&quot;/code/sms&quot;) public void createSmsCode(HttpServletRequest request, HttpServletResponse response) throws Exception &#123; ValidateCode smsCode = smsCodeGenerator.generate(new ServletWebRequest(request)); sessionStrategy.setAttribute(new ServletWebRequest(request), SESSION_KEY, smsCode); String mobile = ServletRequestUtils.getRequiredStringParameter(request.getRequest(), &quot;mobile&quot;); smsCodeSender.send(mobile, validateCode.getCode()); &#125;&#125; 123456789101112131415161718192021...&lt;h3&gt;短信登录&lt;/h3&gt;&lt;form action=&quot;/authentication/mobile&quot; method=&quot;post&quot;&gt; &lt;table&gt; &lt;tr&gt; &lt;td&gt;手机号:&lt;/td&gt; &lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;mobile&quot; value=&quot;13012345678&quot;&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;短信验证码:&lt;/td&gt; &lt;td&gt; &lt;input type=&quot;text&quot; name=&quot;smsCode&quot;&gt; &lt;a href=&quot;/code/sms?mobile=13012345678&quot;&gt;发送验证码&lt;/a&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td colspan=&quot;2&quot;&gt;&lt;button type=&quot;submit&quot;&gt;登录&lt;/button&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt;&lt;/form&gt;... 校验短信验证码并登录 12345678910111213141516171819202122232425262728293031323334353637383940public class SmsCodeAuthenticationToken extends AbstractAuthenticationToken &#123; private static final long serialVersionUID = SpringSecurityCoreVersion.SERIAL_VERSION_UID; private final Object principal; public SmsCodeAuthenticationToken(String mobile) &#123; super(null); this.principal = mobile; setAuthenticated(false); &#125; public SmsCodeAuthenticationToken(Object principal, Collection&lt;? extends GrantedAuthority&gt; authorities) &#123; super(authorities); this.principal = principal; super.setAuthenticated(true); // must use super, as we override &#125; public Object getCredentials() &#123; return null; &#125; public Object getPrincipal() &#123; return this.principal; &#125; public void setAuthenticated(boolean isAuthenticated) throws IllegalArgumentException &#123; if (isAuthenticated) &#123; throw new IllegalArgumentException( &quot;Cannot set this token to trusted - use constructor which takes a GrantedAuthority list instead&quot;); &#125; super.setAuthenticated(false); &#125; @Override public void eraseCredentials() &#123; super.eraseCredentials(); &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455public class SmsCodeAuthenticationFilter extends AbstractAuthenticationProcessingFilter &#123; private String mobileParameter = SecurityConstants.DEFAULT_PARAMETER_NAME_MOBILE; private boolean postOnly = true; public SmsCodeAuthenticationFilter() &#123; super(new AntPathRequestMatcher(SecurityConstants.DEFAULT_LOGIN_PROCESSING_URL_MOBILE, &quot;POST&quot;)); &#125; public Authentication attemptAuthentication(HttpServletRequest request, HttpServletResponse response) throws AuthenticationException &#123; if (postOnly &amp;&amp; !request.getMethod().equals(&quot;POST&quot;)) &#123; throw new AuthenticationServiceException(&quot;Authentication method not supported: &quot; + request.getMethod()); &#125; String mobile = obtainMobile(request); if (mobile == null) &#123; mobile = &quot;&quot;; &#125; mobile = mobile.trim(); SmsCodeAuthenticationToken authRequest = new SmsCodeAuthenticationToken(mobile); // Allow subclasses to set the &quot;details&quot; property setDetails(request, authRequest); return this.getAuthenticationManager().authenticate(authRequest); &#125; /** * 获取手机号 */ protected String obtainMobile(HttpServletRequest request) &#123; return request.getParameter(mobileParameter); &#125; protected void setDetails(HttpServletRequest request, SmsCodeAuthenticationToken authRequest) &#123; authRequest.setDetails(authenticationDetailsSource.buildDetails(request)); &#125; public void setMobileParameter(String usernameParameter) &#123; Assert.hasText(usernameParameter, &quot;Username parameter must not be empty or null&quot;); this.mobileParameter = usernameParameter; &#125; public void setPostOnly(boolean postOnly) &#123; this.postOnly = postOnly; &#125; public final String getMobileParameter() &#123; return mobileParameter; &#125;&#125; 12345678910111213141516171819202122232425262728293031323334public class SmsCodeAuthenticationProvider implements AuthenticationProvider &#123; private UserDetailsService userDetailsService; @Override public Authentication authenticate(Authentication authentication) throws AuthenticationException &#123; SmsCodeAuthenticationToken authenticationToken = (SmsCodeAuthenticationToken) authentication; UserDetails user = userDetailsService.loadUserByUsername((String) authenticationToken.getPrincipal()); if (user == null) &#123; throw new InternalAuthenticationServiceException(&quot;无法获取用户信息&quot;); &#125; SmsCodeAuthenticationToken authenticationResult = new SmsCodeAuthenticationToken(user, user.getAuthorities()); authenticationResult.setDetails(authenticationToken.getDetails()); return authenticationResult; &#125; @Override public boolean supports(Class&lt;?&gt; authentication) &#123; return SmsCodeAuthenticationToken.class.isAssignableFrom(authentication); &#125; public UserDetailsService getUserDetailsService() &#123; return userDetailsService; &#125; public void setUserDetailsService(UserDetailsService userDetailsService) &#123; this.userDetailsService = userDetailsService; &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667public class SmsCodeFilter extends OncePerRequestFilter implements InitializingBean &#123; private AuthenticationFailureHandler authenticationFailureHandler; private SessionStrategy sessionStrategy = new HttpSessionSessionStrategy(); private Set&lt;String&gt; urls = new HashSet&lt;&gt;(); private SecurityProperties securityProperties; private AntPathMatcher pathMatcher = new AntPathMatcher(); @Override public void afterPropertiesSet() throws ServletException &#123; super.afterPropertiesSet(); String[] urls = StringUtils.splitByWholeSeparatorPreserveAllTokens(securityProperties.getCode().getImage().getUrl(), &quot;,&quot;); for (String url : urls) &#123; urls.put(url); &#125; urls.add(&quot;/authentication/mobile&quot;); &#125; @Override protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain chain) throws ServletException, IOException &#123; boolean action = false; for (String url : urls) &#123; if (pathMatcher.match(url, request.getRequestURI())) &#123; action = true; &#125; &#125; if (action) &#123; try &#123; validate(new ServletWebRequest(request, response)); &#125; catch (ValidateCodeException exception) &#123; authenticationFailureHandler.onAuthenticationFailure(request, response, exception); return; &#125; &#125; chain.doFilter(request, response); &#125; public void validate(ServletWebRequest request) &#123; String sessionKey = ValidateCodeController.SESSION_KEY; ValidateCode codeInSession = (ValidateCode)sessionStrategy.getAttribute(request, sessionKey); String codeInRequest; try &#123; codeInRequest = ServletRequestUtils.getStringParameter(request.getRequest(), &quot;smsCode&quot;); &#125; catch (ServletRequestBindingException e) &#123; throw new ValidateCodeException(&quot;获取验证码的值失败&quot;); &#125; if (StringUtils.isBlank(codeInRequest)) &#123; throw new ValidateCodeException(processorType + &quot;验证码的值不能为空&quot;); &#125; if (codeInSession == null) &#123; throw new ValidateCodeException(processorType + &quot;验证码不存在&quot;); &#125; if (codeInSession.isExpried()) &#123; sessionStrategy.removeAttribute(request, sessionKey); throw new ValidateCodeException(processorType + &quot;验证码已过期&quot;); &#125; if (!StringUtils.equals(codeInSession.getCode(), codeInRequest)) &#123; throw new ValidateCodeException(processorType + &quot;验证码不匹配&quot;); &#125; sessionStrategy.removeAttribute(request, sessionKey); &#125;&#125; 12345678910111213141516171819202122232425@Componentpublic class SmsCodeAuthenticationSecurityConfig extends SecurityConfigurerAdapter&lt;DefaultSecurityFilterChain, HttpSecurity&gt; &#123; @Autowired private AuthenticationSuccessHandler myAuthenticationSuccessHandler; @Autowired private AuthenticationFailureHandler myAuthenticationFailureHandler; @Autowired private UserDetailsService userDetailsService; @Override public void configure(HttpSecurity http) throws Exception &#123; SmsCodeAuthenticationFilter smsCodeAuthenticationFilter = new SmsCodeAuthenticationFilter(); smsCodeAuthenticationFilter.setAuthenticationManager(http.getSharedObject(AuthenticationManager.class)); smsCodeAuthenticationFilter.setAuthenticationSuccessHandler(myAuthenticationSuccessHandler); smsCodeAuthenticationFilter.setAuthenticationFailureHandler(myAuthenticationFailureHandler); SmsCodeAuthenticationProvider smsCodeAuthenticationProvider = new SmsCodeAuthenticationProvider(); smsCodeAuthenticationProvider.setUserDetailsService(userDetailsService); http.authenticationProvider(smsCodeAuthenticationProvider) .addFilterAfter(smsCodeAuthenticationFilter, UsernamePasswordAuthenticationFilter.class); &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940@Configurationpublic class BrowserSecurityConfig extends AbstractChannelSecurityConfig &#123; ... @Override protected void configure(HttpSecurity http) throws Exception &#123; ValidateCodeFilter validateCodeFilter = new ValidateCodeFilter(); validateCodeFilter.setAuthenticationFailureHandler(myAuthenticationFailureHandler); validateCodeFilter.setSecurityProperties(securityProperties); validateCodeFilter.afterPropertiesSet(); SmsCodeFilter smsCodeFilter = new SmsCodeFilter(); smsCodeFilter.setAuthenticationFailureHandler(myAuthenticationFailureHandler); smsCodeFilter.setSecurityProperties(securityProperties); smsCodeFilter.afterPropertiesSet(); http.addFilterBefore(smsCodeFilter, UsernamePasswordAuthenticationFilter.class) .addFilterBefore(validateCodeFilter, UsernamePasswordAuthenticationFilter.class) .formLogin() .loginPage(&quot;/authentication/require&quot;) .loginProcessingUrl(&quot;/authentication/form&quot;) .successHandler(myAuthenticationSuccessHandler) .failureHandler(myAuthenctiationFailureHandler) .and() .rememberMe() .tokenRepository(persistentTokenRepository()) .tokenValiditySeconds(securityProperties.getBrowser().getRememberMeSeconds()) .userDetailsService(userDetailsService) .and() .authorizeRequests() .antMatchers(&quot;/authentication/require&quot;, securityProperties.getBrowser().getLoginPage(), &quot;/code/image&quot;).permitAll() .anyRequest() .authenticated() .and() .csrf().disable() // 相当于把smsCodeAuthenticationSecurityConfig这个类中的配置加到了后面，等于接着往后写 .apply(smsCodeAuthenticationSecurityConfig); &#125; ...&#125; 重构代码","categories":[],"tags":[{"name":"Spring Security","slug":"Spring-Security","permalink":"http://yoursite.com/tags/Spring-Security/"}],"keywords":[]},{"title":"Spring Social开发第三方认证","slug":"Spring Social开发第三方认证","date":"2020-04-09T12:12:09.261Z","updated":"2020-04-09T12:11:54.234Z","comments":true,"path":"2020/04/09/Spring Social开发第三方认证/","link":"","permalink":"http://yoursite.com/2020/04/09/Spring Social开发第三方认证/","excerpt":"","text":"1.OAuth协议以及Spring Social原理简介OAuth协议简介OAuth协议要解决的问题 应用可以访问用户在微信上的所有数据 用户只有修改密码，才能收回授权 密码泄露的可能性大大提高 OAuth协议中的各种角色 &amp;&amp; 运行流程 Spring Social原理简介 2.实现QQ认证和微信认证QQ认证参考：https://wiki.connect.qq.com/spring-core:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879@Datapublic class QQUserInfo &#123; /** * 返回码 */ private String ret; /** * 如果ret&lt;0，会有相应的错误信息提示，返回数据全部用UTF-8编码。 */ private String msg; /** * */ private String openId; /** * 不知道什么东西，文档上没写，但是实际api返回里有。 */ private String is_lost; /** * 省(直辖市) */ private String province; /** * 市(直辖市区) */ private String city; /** * 出生年月 */ private String year; /** * 用户在QQ空间的昵称。 */ private String nickname; /** * 大小为30×30像素的QQ空间头像URL。 */ private String figureurl; /** * 大小为50×50像素的QQ空间头像URL。 */ private String figureurl_1; /** * 大小为100×100像素的QQ空间头像URL。 */ private String figureurl_2; /** * 大小为40×40像素的QQ头像URL。 */ private String figureurl_qq_1; /** * 大小为100×100像素的QQ头像URL。需要注意，不是所有的用户都拥有QQ的100×100的头像，但40×40像素则是一定会有。 */ private String figureurl_qq_2; /** * 性别。 如果获取不到则默认返回”男” */ private String gender; /** * 标识用户是否为黄钻用户（0：不是；1：是）。 */ private String is_yellow_vip; /** * 标识用户是否为黄钻用户（0：不是；1：是） */ private String vip; /** * 黄钻等级 */ private String yellow_vip_level; /** * 黄钻等级 */ private String level; /** * 标识是否为年费黄钻用户（0：不是； 1：是） */ private String is_yellow_year_vip;&#125; 123public interface QQ &#123; QQUserInfo getUserInfo();&#125; 1234567891011121314151617181920212223242526272829303132333435363738public class QQImpl extends AbstractOAuth2ApiBinding implements QQ &#123; private static final String URL_GET_OPENID = &quot;https://graph.qq.com/oauth2.0/me?access_token=%s&quot;; private static final String URL_GET_USERINFO = &quot;https://graph.qq.com/user/get_user_info?oauth_consumer_key=%s&amp;openid=%s&quot;; private String appId; private String openId; private ObjectMapper objectMapper = new ObjectMapper(); public QQImpl(String accessToken, String appId) &#123; super(accessToken, TokenStrategy.ACCESS_TOKEN_PARAMETER); this.appId = appId; String url = String.format(URL_GET_OPENID, accessToken); String result = getRestTemplate().getForObject(url, String.class); this.openId = StringUtils.substringBetween(result, &quot;\\&quot;openid\\&quot;:\\&quot;&quot;, &quot;\\&quot;&#125;&quot;); &#125; @Override public QQUserInfo getUserInfo() &#123; String url = String.format(URL_GET_USERINFO, appId, openId); String result = getRestTemplate().getForObject(url, String.class); QQUserInfo userInfo = null; try &#123; userInfo = objectMapper.readValue(result, QQUserInfo.class); userInfo.setOpenId(openId); return userInfo; &#125; catch (Exception e) &#123; throw new RuntimeException(&quot;获取用户信息失败&quot;, e); &#125; &#125;&#125; 123456789101112131415161718192021222324252627282930public class QQOAuth2Template extends OAuth2Template &#123; private Logger logger = LoggerFactory.getLogger(getClass()); public QQOAuth2Template(String clientId, String clientSecret, String authorizeUrl, String accessTokenUrl) &#123; super(clientId, clientSecret, authorizeUrl, accessTokenUrl); setUseParametersForClientAuthentication(true); &#125; @Override protected AccessGrant postForAccessGrant(String accessTokenUrl, MultiValueMap&lt;String, String&gt; parameters) &#123; String responseStr = getRestTemplate().postForObject(accessTokenUrl, parameters, String.class); logger.info(&quot;获取accessToke的响应：&quot;+responseStr); String[] items = StringUtils.splitByWholeSeparatorPreserveAllTokens(responseStr, &quot;&amp;&quot;); String accessToken = StringUtils.substringAfterLast(items[0], &quot;=&quot;); Long expiresIn = new Long(StringUtils.substringAfterLast(items[1], &quot;=&quot;)); String refreshToken = StringUtils.substringAfterLast(items[2], &quot;=&quot;); return new AccessGrant(accessToken, null, refreshToken, expiresIn); &#125; @Override protected RestTemplate createRestTemplate() &#123; RestTemplate restTemplate = super.createRestTemplate(); restTemplate.getMessageConverters().add(new StringHttpMessageConverter(Charset.forName(&quot;UTF-8&quot;))); return restTemplate; &#125;&#125; 1234567891011121314151617public class QQServiceProvider extends AbstractOAuth2ServiceProvider&lt;QQ&gt; &#123; private String appId; private static final String URL_AUTHORIZE = &quot;https://graph.qq.com/oauth2.0/authorize&quot;; private static final String URL_ACCESS_TOKEN = &quot;https://graph.qq.com/oauth2.0/token&quot;; public QQServiceProvider(String appId, String appSecret) &#123; super(new QQOAuth2Template(appId, appSecret, URL_AUTHORIZE, URL_ACCESS_TOKEN)); this.appId = appId; &#125; @Override public QQ getApi(String accessToken) &#123; return new QQImpl(accessToken, appId); &#125;&#125; 123456789101112131415161718192021222324252627public class QQAdapter implements ApiAdapter&lt;QQ&gt; &#123; @Override public boolean test(QQ api) &#123; return true; &#125; @Override public void setConnectionValues(QQ api, ConnectionValues values) &#123; QQUserInfo userInfo = api.getUserInfo(); values.setDisplayName(userInfo.getNickname()); values.setImageUrl(userInfo.getFigureurl_qq_1()); values.setProfileUrl(null); values.setProviderUserId(userInfo.getOpenId()); &#125; @Override public UserProfile fetchUserProfile(QQ api) &#123; // TODO Auto-generated method stub return null; &#125; @Override public void updateStatus(QQ api, String message) &#123; //do noting &#125;&#125; 12345public class QQConnectionFactory extends OAuth2ConnectionFactory&lt;QQ&gt; &#123; public QQConnectionFactory(String providerId, String appId, String appSecret) &#123; super(providerId, new QQServiceProvider(appId, appSecret), new QQAdapter()); &#125;&#125; 123public class QQProperties extends SocialProperties &#123; private String providerId = &quot;qq&quot;;&#125; 123456@Datapublic class SocialProperties &#123; private String filterProcessesUrl = &quot;/auth&quot;; private QQProperties qq = new QQProperties();&#125; 12345@Datapublic class BrowserProperties &#123; ... private String signUpUrl = &quot;/my-signUp.html&quot;;&#125; 1234567@Data@ConfigurationProperties(prefix = &quot;security&quot;)public class SecurityProperties &#123; ... private SocialProperties social = new SocialProperties(); private BrowserProperties browser = new BrowserProperties();&#125; 123456789101112131415public class MySpringSocialConfigurer extends SpringSocialConfigurer &#123; private String filterProcessesUrl; public MySpringSocialConfigurer(String filterProcessesUrl) &#123; this.filterProcessesUrl = filterProcessesUrl; &#125; @SuppressWarnings(&quot;unchecked&quot;) @Override protected &lt;T&gt; T postProcess(T object) &#123; SocialAuthenticationFilter filter = (SocialAuthenticationFilter) super.postProcess(object); filter.setFilterProcessesUrl(filterProcessesUrl); return (T) filter; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839@Configuration@EnableSocialpublic class SocialConfig extends SocialConfigurerAdapter &#123; @Autowired private DataSource dataSource; @Autowired private SecurityProperties securityProperties; @Autowired(required = false) private ConnectionSignUp connectionSignUp; @Override public UsersConnectionRepository getUsersConnectionRepository(ConnectionFactoryLocator connectionFactoryLocator) &#123; JdbcUsersConnectionRepository repository = new JdbcUsersConnectionRepository(dataSource, connectionFactoryLocator, Encryptors.noOpText()); repository.setTablePrefix(&quot;my_&quot;); if(connectionSignUp != null) &#123; repository.setConnectionSignUp(connectionSignUp); &#125; return repository; &#125; @Bean public SpringSocialConfigurer mySocialSecurityConfig() &#123; String filterProcessesUrl = securityProperties.getSocial().getFilterProcessesUrl(); MySpringSocialConfigurer configurer = new MySpringSocialConfigurer(filterProcessesUrl); configurer.signupUrl(securityProperties.getBrowser().getSignUpUrl()); return configurer; &#125; @Bean public ProviderSignInUtils providerSignInUtils(ConnectionFactoryLocator connectionFactoryLocator) &#123; return new ProviderSignInUtils(connectionFactoryLocator, getUsersConnectionRepository(connectionFactoryLocator)) &#123; &#125;; &#125;&#125; org/springframework/social/spring-social-core/1.1.4.RELEASE/spring-social-core-1.1.4.RELEASE.jar!/org/springframework/social/connect/jdbc/JdbcUsersConnectionRepository.sql:12345678910111213create table UserConnection (userId varchar(255) not null, providerId varchar(255) not null, providerUserId varchar(255), rank int not null, displayName varchar(255), profileUrl varchar(512), imageUrl varchar(512), accessToken varchar(512) not null, secret varchar(512), refreshToken varchar(512), expireTime bigint, primary key (userId, providerId, providerUserId));create unique index UserConnectionRank on UserConnection(userId, providerId, rank); 123456789101112@Configuration@ConditionalOnProperty(prefix = &quot;security.social.qq&quot;, name = &quot;app-id&quot;)public class QQAutoConfig extends SocialAutoConfigurerAdapter &#123; @Autowired private SecurityProperties securityProperties; @Override protected ConnectionFactory&lt;?&gt; createConnectionFactory() &#123; QQProperties qqConfig = securityProperties.getSocial().getQq(); return new QQConnectionFactory(qqConfig.getProviderId(), qqConfig.getAppId(), qqConfig.getAppSecret()); &#125;&#125; spring-browser:1234567891011121314151617181920@Configurationpublic class BrowserSecurityConfig extends AbstractChannelSecurityConfig &#123; ... @Autowired private SpringSocialConfigurer mySocialSecurityConfig; @Override protected void configure(HttpSecurity http) throws Exception &#123; http.apply(mySocialSecurityConfig) .and() .authorizeRequests() .antMatchers( securityProperties.getBrowser().getSignUpUrl(), &quot;/user/regist&quot; ) .permitAll() ... &#125;&#125; 12345678910@Datapublic class SocialUserInfo &#123; private String providerId; private String providerUserId; private String nickname; private String headimg;&#125; 12345678910111213141516@RestControllerpublic class BrowserSecurityController &#123; @Autowired private ProviderSignInUtils providerSignInUtils; @GetMapping(&quot;/social/user&quot;) public SocialUserInfo getSocialUserInfo(HttpServletRequest request) &#123; SocialUserInfo userInfo = new SocialUserInfo(); Connection&lt;?&gt; connection = providerSignInUtils.getConnectionFromSession(new ServletWebRequest(request)); userInfo.setProviderId(connection.getKey().getProviderId()); userInfo.setProviderUserId(connection.getKey().getProviderUserId()); userInfo.setNickname(connection.getDisplayName()); userInfo.setHeadimg(connection.getImageUrl()); return userInfo; &#125;&#125; my-signIn.html1234567891011&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;UTF-8&quot;&gt;&lt;title&gt;登录&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h3&gt;社交登录&lt;/h3&gt; &lt;a href=&quot;/qqLogin/callback.do&quot;&gt;QQ登录&lt;/a&gt;&lt;/body&gt;&lt;/html&gt; spring-demo:12345678@Componentpublic class DemoConnectionSignUp implements ConnectionSignUp &#123; @Override public String execute(Connection&lt;?&gt; connection) &#123; //根据社交用户信息默认创建用户并返回用户唯一标识 return connection.getDisplayName(); &#125;&#125; 1234567891011121314151617181920212223242526272829@Componentpublic class MyUserDetailsService implements UserDetailsService, SocialUserDetailsService &#123; private Logger logger = LoggerFactory.getLogger(getClass()); @Autowired private PasswordEncoder passwordEncoder; @Override public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException &#123; logger.info(&quot;表单登录用户名:&quot; + username); return buildUser(username); &#125; @Override public SocialUserDetails loadUserByUserId(String userId) throws UsernameNotFoundException &#123; logger.info(&quot;设计登录用户Id:&quot; + userId); return buildUser(userId); &#125; private SocialUserDetails buildUser(String userId) &#123; // 根据用户名查找用户信息 //根据查找到的用户信息判断用户是否被冻结 String password = passwordEncoder.encode(&quot;123456&quot;); logger.info(&quot;数据库密码是:&quot;+password); return new SocialUser(userId, password, true, true, true, true, AuthorityUtils.commaSeparatedStringToAuthorityList(&quot;admin&quot;)); &#125;&#125; 1234567891011121314@RestController@RequestMapping(&quot;/user&quot;)public class UserController &#123; @Autowired private ProviderSignInUtils providerSignInUtils; @PostMapping(&quot;/regist&quot;) public void regist(User user, HttpServletRequest request) &#123; //不管是注册用户还是绑定用户，都会拿到一个用户唯一标识。 String userId = user.getUsername(); providerSignInUtils.doPostSignUp(userId, new ServletWebRequest(request)); &#125;&#125; application.properties:12345678...security.social.qq.app-id =security.social.qq.app-secret =security.social.qq.providerId = callback.dosecurity.browser.signUpUrl = /demo-signUp.htmlsecurity.social.filterProcessesUrl = /qqLogin demo-signUp.html:1234567891011121314151617181920212223242526272829&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;UTF-8&quot;&gt;&lt;title&gt;登录&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h2&gt;Demo注册页&lt;/h2&gt; &lt;form action=&quot;/user/regist&quot; method=&quot;post&quot;&gt; &lt;table&gt; &lt;tr&gt; &lt;td&gt;用户名:&lt;/td&gt; &lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;username&quot;&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;密码:&lt;/td&gt; &lt;td&gt;&lt;input type=&quot;password&quot; name=&quot;password&quot;&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td colspan=&quot;2&quot;&gt; &lt;button type=&quot;submit&quot; name=&quot;type&quot; value=&quot;regist&quot;&gt;注册&lt;/button&gt; &lt;button type=&quot;submit&quot; name=&quot;type&quot; value=&quot;binding&quot;&gt;绑定&lt;/button&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 微信认证spring-core:1234567891011121314151617181920212223242526272829303132333435363738394041424344@Datapublic class WeixinUserInfo &#123; /** * 普通用户的标识，对当前开发者帐号唯一 */ private String openid; /** * 普通用户昵称 */ private String nickname; /** * 语言 */ private String language; /** * 普通用户性别，1为男性，2为女性 */ private String sex; /** * 普通用户个人资料填写的省份 */ private String province; /** * 普通用户个人资料填写的城市 */ private String city; /** * 国家，如中国为CN */ private String country; /** * 用户头像，最后一个数值代表正方形头像大小（有0、46、64、96、132数值可选，0代表640*640正方形头像），用户没有头像时该项为空 */ private String headimgurl; /** * 用户特权信息，json数组，如微信沃卡用户为（chinaunicom） */ private String[] privilege; /** * 用户统一标识。针对一个微信开放平台帐号下的应用，同一用户的unionid是唯一的。 */ private String unionid;&#125; 123public interface Weixin &#123; WeixinUserInfo getUserInfo(String openId);&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950/** * Weixin API调用模板， scope为Request的Spring bean, 根据当前用户的accessToken创建。 */public class WeixinImpl extends AbstractOAuth2ApiBinding implements Weixin &#123; /** * */ private ObjectMapper objectMapper = new ObjectMapper(); /** * 获取用户信息的url */ private static final String URL_GET_USER_INFO = &quot;https://api.weixin.qq.com/sns/userinfo?openid=&quot;; /** * @param accessToken */ public WeixinImpl(String accessToken) &#123; super(accessToken, TokenStrategy.ACCESS_TOKEN_PARAMETER); &#125; /** * 默认注册的StringHttpMessageConverter字符集为ISO-8859-1，而微信返回的是UTF-8的，所以覆盖了原来的方法。 */ protected List&lt;HttpMessageConverter&lt;?&gt;&gt; getMessageConverters() &#123; List&lt;HttpMessageConverter&lt;?&gt;&gt; messageConverters = super.getMessageConverters(); messageConverters.remove(0); messageConverters.add(new StringHttpMessageConverter(Charset.forName(&quot;UTF-8&quot;))); return messageConverters; &#125; /** * 获取微信用户信息。 */ @Override public WeixinUserInfo getUserInfo(String openId) &#123; String url = URL_GET_USER_INFO + openId; String response = getRestTemplate().getForObject(url, String.class); if(StringUtils.contains(response, &quot;errcode&quot;)) &#123; return null; &#125; WeixinUserInfo profile = null; try &#123; profile = objectMapper.readValue(response, WeixinUserInfo.class); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return profile; &#125;&#125; 1234567@Datapublic class WeixinProperties extends SocialProperties &#123; /** * 第三方id，用来决定发起第三方登录的url，默认是 weixin。 */ private String providerId = &quot;weixin&quot;;&#125; 123456@Datapublic class SocialProperties &#123; private String filterProcessesUrl = &quot;/auth&quot;; ... private WeixinProperties weixin = new WeixinProperties();&#125; 12345678910111213141516171819/** * 微信的access_token信息。与标准OAuth2协议不同，微信在获取access_token时会同时返回openId,并没有单独的通过accessToke换取openId的服务 * * 所以在这里继承了标准AccessGrant，添加了openId字段，作为对微信access_token信息的封装。 */@Datapublic class WeixinAccessGrant extends AccessGrant &#123; private static final long serialVersionUID = -7243374526633186782L; private String openId; public WeixinAccessGrant() &#123; super(&quot;&quot;); &#125; public WeixinAccessGrant(String accessToken, String scope, String refreshToken, Long expiresIn) &#123; super(accessToken, scope, refreshToken, expiresIn); &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104/** * 完成微信的OAuth2认证流程的模板类。国内厂商实现的OAuth2每个都不同, spring默认提供的OAuth2Template适应不了，只能针对每个厂商自己微调。 */public class WeixinOAuth2Template extends OAuth2Template &#123; private String clientId; private String clientSecret; private String accessTokenUrl; private static final String REFRESH_TOKEN_URL = &quot;https://api.weixin.qq.com/sns/oauth2/refresh_token&quot;; private Logger logger = LoggerFactory.getLogger(getClass()); public WeixinOAuth2Template(String clientId, String clientSecret, String authorizeUrl, String accessTokenUrl) &#123; super(clientId, clientSecret, authorizeUrl, accessTokenUrl); setUseParametersForClientAuthentication(true); this.clientId = clientId; this.clientSecret = clientSecret; this.accessTokenUrl = accessTokenUrl; &#125; @Override public AccessGrant exchangeForAccess(String authorizationCode, String redirectUri, MultiValueMap&lt;String, String&gt; parameters) &#123; StringBuilder accessTokenRequestUrl = new StringBuilder(accessTokenUrl); accessTokenRequestUrl.append(&quot;?appid=&quot;+clientId); accessTokenRequestUrl.append(&quot;&amp;secret=&quot;+clientSecret); accessTokenRequestUrl.append(&quot;&amp;code=&quot;+authorizationCode); accessTokenRequestUrl.append(&quot;&amp;grant_type=authorization_code&quot;); accessTokenRequestUrl.append(&quot;&amp;redirect_uri=&quot;+redirectUri); return getAccessToken(accessTokenRequestUrl); &#125; public AccessGrant refreshAccess(String refreshToken, MultiValueMap&lt;String, String&gt; additionalParameters) &#123; StringBuilder refreshTokenUrl = new StringBuilder(REFRESH_TOKEN_URL); refreshTokenUrl.append(&quot;?appid=&quot;+clientId); refreshTokenUrl.append(&quot;&amp;grant_type=refresh_token&quot;); refreshTokenUrl.append(&quot;&amp;refresh_token=&quot;+refreshToken); return getAccessToken(refreshTokenUrl); &#125; @SuppressWarnings(&quot;unchecked&quot;) private AccessGrant getAccessToken(StringBuilder accessTokenRequestUrl) &#123; logger.info(&quot;获取access_token, 请求URL: &quot;+accessTokenRequestUrl.toString()); String response = getRestTemplate().getForObject(accessTokenRequestUrl.toString(), String.class); logger.info(&quot;获取access_token, 响应内容: &quot;+response); Map&lt;String, Object&gt; result = null; try &#123; result = new ObjectMapper().readValue(response, Map.class); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; //返回错误码时直接返回空 if(StringUtils.isNotBlank(MapUtils.getString(result, &quot;errcode&quot;)))&#123; String errcode = MapUtils.getString(result, &quot;errcode&quot;); String errmsg = MapUtils.getString(result, &quot;errmsg&quot;); throw new RuntimeException(&quot;获取access token失败, errcode:&quot;+errcode+&quot;, errmsg:&quot;+errmsg); &#125; WeixinAccessGrant accessToken = new WeixinAccessGrant( MapUtils.getString(result, &quot;access_token&quot;), MapUtils.getString(result, &quot;scope&quot;), MapUtils.getString(result, &quot;refresh_token&quot;), MapUtils.getLong(result, &quot;expires_in&quot;)); accessToken.setOpenId(MapUtils.getString(result, &quot;openid&quot;)); return accessToken; &#125; /** * 构建获取授权码的请求。也就是引导用户跳转到微信的地址。 */ public String buildAuthenticateUrl(OAuth2Parameters parameters) &#123; String url = super.buildAuthenticateUrl(parameters); url = url + &quot;&amp;appid=&quot;+clientId+&quot;&amp;scope=snsapi_login&quot;; return url; &#125; public String buildAuthorizeUrl(OAuth2Parameters parameters) &#123; return buildAuthenticateUrl(parameters); &#125; /** * 微信返回的contentType是html/text，添加相应的HttpMessageConverter来处理。 */ protected RestTemplate createRestTemplate() &#123; RestTemplate restTemplate = super.createRestTemplate(); restTemplate.getMessageConverters().add(new StringHttpMessageConverter(Charset.forName(&quot;UTF-8&quot;))); return restTemplate; &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435/** * 微信 api适配器，将微信 api的数据模型转为spring social的标准模型。 */public class WeixinAdapter implements ApiAdapter&lt;Weixin&gt; &#123; private String openId; public WeixinAdapter() &#123;&#125; public WeixinAdapter(String openId)&#123; this.openId = openId; &#125; @Override public boolean test(Weixin api) &#123; return true; &#125; @Override public void setConnectionValues(Weixin api, ConnectionValues values) &#123; WeixinUserInfo profile = api.getUserInfo(openId); values.setProviderUserId(profile.getOpenid()); values.setDisplayName(profile.getNickname()); values.setImageUrl(profile.getHeadimgurl()); &#125; @Override public UserProfile fetchUserProfile(Weixin api) &#123; return null; &#125; @Override public void updateStatus(Weixin api, String message) &#123; //do nothing &#125;&#125; 12345678910111213141516171819202122/** * 微信的OAuth2流程处理器的提供器，供spring social的connect体系调用 */public class WeixinServiceProvider extends AbstractOAuth2ServiceProvider&lt;Weixin&gt; &#123; /** * 微信获取授权码的url */ private static final String URL_AUTHORIZE = &quot;https://open.weixin.qq.com/connect/qrconnect&quot;; /** * 微信获取accessToken的url */ private static final String URL_ACCESS_TOKEN = &quot;https://api.weixin.qq.com/sns/oauth2/access_token&quot;; public WeixinServiceProvider(String appId, String appSecret) &#123; super(new WeixinOAuth2Template(appId, appSecret,URL_AUTHORIZE,URL_ACCESS_TOKEN)); &#125; @Override public Weixin getApi(String accessToken) &#123; return new WeixinImpl(accessToken); &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637/** * 微信连接工厂 */public class WeixinConnectionFactory extends OAuth2ConnectionFactory&lt;Weixin&gt; &#123; public WeixinConnectionFactory(String providerId, String appId, String appSecret) &#123; super(providerId, new WeixinServiceProvider(appId, appSecret), new WeixinAdapter()); &#125; /** * 由于微信的openId是和accessToken一起返回的，所以在这里直接根据accessToken设置providerUserId即可，不用像QQ那样通过QQAdapter来获取 */ @Override protected String extractProviderUserId(AccessGrant accessGrant) &#123; if(accessGrant instanceof WeixinAccessGrant) &#123; return ((WeixinAccessGrant)accessGrant).getOpenId(); &#125; return null; &#125; public Connection&lt;Weixin&gt; createConnection(AccessGrant accessGrant) &#123; return new OAuth2Connection&lt;Weixin&gt;(getProviderId(), extractProviderUserId(accessGrant), accessGrant.getAccessToken(), accessGrant.getRefreshToken(), accessGrant.getExpireTime(), getOAuth2ServiceProvider(), getApiAdapter(extractProviderUserId(accessGrant))); &#125; public Connection&lt;Weixin&gt; createConnection(ConnectionData data) &#123; return new OAuth2Connection&lt;Weixin&gt;(data, getOAuth2ServiceProvider(), getApiAdapter(data.getProviderUserId())); &#125; private ApiAdapter&lt;Weixin&gt; getApiAdapter(String providerUserId) &#123; return new WeixinAdapter(providerUserId); &#125; private OAuth2ServiceProvider&lt;Weixin&gt; getOAuth2ServiceProvider() &#123; return (OAuth2ServiceProvider&lt;Weixin&gt;) getServiceProvider(); &#125;&#125; 12345678910111213141516171819202122/** * 微信登录配置 */@Configuration@ConditionalOnProperty(prefix = &quot;security.social.weixin&quot;, name = &quot;app-id&quot;)public class WeixinAutoConfiguration extends SocialAutoConfigurerAdapter &#123; @Autowired private SecurityProperties securityProperties; @Override protected ConnectionFactory&lt;?&gt; createConnectionFactory() &#123; WeixinProperties weixinConfig = securityProperties.getSocial().getWeixin(); return new WeixinConnectionFactory(weixinConfig.getProviderId(), weixinConfig.getAppId(), weixinConfig.getAppSecret()); &#125; @Bean(&#123;&quot;connect/weixinConnect&quot;, &quot;connect/weixinConnected&quot;&#125;) @ConditionalOnMissingBean(name = &quot;weixinConnectedView&quot;) public View weixinConnectedView() &#123; return new MyConnectView(); &#125;&#125; 1234567891011121314public class MyConnectView extends AbstractView &#123; @Override protected void renderMergedOutputModel(Map&lt;String, Object&gt; model, HttpServletRequest request, HttpServletResponse response) throws Exception &#123; response.setContentType(&quot;text/html;charset=UTF-8&quot;); if (model.get(&quot;connection&quot;) == null) &#123; response.getWriter().write(&quot;&lt;h3&gt;解绑成功&lt;/h3&gt;&quot;); &#125; else &#123; response.getWriter().write(&quot;&lt;h3&gt;绑定成功&lt;/h3&gt;&quot;); &#125; &#125;&#125; 123456789101112131415161718192021@Component(&quot;connect/status&quot;)public class MyConnectionStatusView extends AbstractView &#123; @Autowired private ObjectMapper objectMapper; @SuppressWarnings(&quot;unchecked&quot;) @Override protected void renderMergedOutputModel(Map&lt;String, Object&gt; model, HttpServletRequest request, HttpServletResponse response) throws Exception &#123; Map&lt;String, List&lt;Connection&lt;?&gt;&gt;&gt; connections = (Map&lt;String, List&lt;Connection&lt;?&gt;&gt;&gt;) model.get(&quot;connectionMap&quot;); Map&lt;String, Boolean&gt; result = new HashMap&lt;&gt;(); for (String key : connections.keySet()) &#123; result.put(key, CollectionUtils.isNotEmpty(connections.get(key))); &#125; response.setContentType(&quot;application/json;charset=UTF-8&quot;); response.getWriter().write(objectMapper.writeValueAsString(result)); &#125;&#125; spring-browser:my-signIn.html:1234567891011&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;UTF-8&quot;&gt;&lt;title&gt;登录&lt;/title&gt;&lt;/head&gt;&lt;body&gt;...&lt;a href=&quot;/qqLogin/weixin&quot;&gt;微信登录&lt;/a&gt;&lt;/body&gt;&lt;/html&gt; my-banding.html:12345678910111213&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;UTF-8&quot;&gt;&lt;title&gt;登录&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h2&gt;标准绑定页面&lt;/h2&gt; &lt;form action=&quot;/connect/weixin&quot; method=&quot;post&quot;&gt; &lt;button type=&quot;submit&quot;&gt;绑定微信&lt;/button&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; spring-demo:application.properties:12security.social.weixin.app-id = wxd99431bbff8305a0security.social.weixin.app-secret = 60f78681d063590a469f1b297feff3c4 3.SESSION管理及退出Session超时处理Session并发控制集群Session管理","categories":[],"tags":[{"name":"Spring Security","slug":"Spring-Security","permalink":"http://yoursite.com/tags/Spring-Security/"}],"keywords":[]},{"title":"SpringSecurity技术栈开发企业级认证与授权-使用Spring MVC开发 RESTful API","slug":"Spring Security技术栈开发企业级认证与授权-使用Spring MVC开发 RESTful API","date":"2020-04-07T13:37:40.912Z","updated":"2020-04-04T14:54:31.399Z","comments":true,"path":"2020/04/07/Spring Security技术栈开发企业级认证与授权-使用Spring MVC开发 RESTful API/","link":"","permalink":"http://yoursite.com/2020/04/07/Spring Security技术栈开发企业级认证与授权-使用Spring MVC开发 RESTful API/","excerpt":"","text":"1.开发基本的增删改查接口使用Spring MVC编写Restful API 编写针对RestfulAPI的测试用例security-demo：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596@RunWith(SpringRunner.class)@SpringBootTestpublic class UserControllerTest &#123; @Autowired private WebApplicationContext wac; private MockMvc mockMvc; @Before public void setup() &#123; mockMvc = MockMvcBuilders.webAppContextSetup(wac).build(); &#125; @Test public void whenQuerySuccess() throws Exception &#123; String result = mockMvc.perform( get(&quot;/user&quot;).param(&quot;username&quot;, &quot;jojo&quot;).param(&quot;age&quot;, &quot;18&quot;).param(&quot;ageTo&quot;, &quot;60&quot;).param(&quot;xxx&quot;, &quot;yyy&quot;) // .param(&quot;size&quot;, &quot;15&quot;) // .param(&quot;page&quot;, &quot;3&quot;) // .param(&quot;sort&quot;, &quot;age,desc&quot;) .contentType(MediaType.APPLICATION_JSON_UTF8)) .andExpect(status().isOk()).andExpect(jsonPath(&quot;$.length()&quot;).value(3)) .andReturn().getResponse().getContentAsString(); System.out.println(result); &#125; @Test public void whenGetInfoSuccess() throws Exception &#123; String result = mockMvc.perform(get(&quot;/user/1&quot;) .contentType(MediaType.APPLICATION_JSON_UTF8)) .andExpect(status().isOk()) .andExpect(jsonPath(&quot;$.username&quot;).value(&quot;tom&quot;)) .andReturn().getResponse().getContentAsString(); System.out.println(result); &#125; @Test public void whenGetInfoFail() throws Exception &#123; mockMvc.perform(get(&quot;/user/a&quot;) .contentType(MediaType.APPLICATION_JSON_UTF8)) .andExpect(status().is4xxClientError()); &#125; @Test public void whenCreateSuccess() throws Exception &#123; Date date = new Date(); System.out.println(date.getTime()); String content = &quot;&#123;\\&quot;username\\&quot;:\\&quot;tom\\&quot;,\\&quot;password\\&quot;:null,\\&quot;birthday\\&quot;:&quot;+date.getTime()+&quot;&#125;&quot;; String reuslt = mockMvc.perform(post(&quot;/user&quot;).contentType(MediaType.APPLICATION_JSON_UTF8) .content(content)) .andExpect(status().isOk()) .andExpect(jsonPath(&quot;$.id&quot;).value(&quot;1&quot;)) .andReturn().getResponse().getContentAsString(); System.out.println(reuslt); &#125; @Test public void whenCreateFail() throws Exception &#123; Date date = new Date(); System.out.println(date.getTime()); String content = &quot;&#123;\\&quot;username\\&quot;:\\&quot;tom\\&quot;,\\&quot;password\\&quot;:null,\\&quot;birthday\\&quot;:&quot;+date.getTime()+&quot;&#125;&quot;; String reuslt = mockMvc.perform(post(&quot;/user&quot;).contentType(MediaType.APPLICATION_JSON_UTF8) .content(content))// .andExpect(status().isOk())// .andExpect(jsonPath(&quot;$.id&quot;).value(&quot;1&quot;)) .andReturn().getResponse().getContentAsString(); System.out.println(reuslt); &#125; @Test public void whenUpdateSuccess() throws Exception &#123; Date date = new Date(LocalDateTime.now().plusYears(1).atZone(ZoneId.systemDefault()).toInstant().toEpochMilli()); System.out.println(date.getTime()); String content = &quot;&#123;\\&quot;id\\&quot;:\\&quot;1\\&quot;, \\&quot;username\\&quot;:\\&quot;tom\\&quot;,\\&quot;password\\&quot;:null,\\&quot;birthday\\&quot;:&quot;+date.getTime()+&quot;&#125;&quot;; String reuslt = mockMvc.perform(put(&quot;/user/1&quot;).contentType(MediaType.APPLICATION_JSON_UTF8) .content(content)) .andExpect(status().isOk()) .andExpect(jsonPath(&quot;$.id&quot;).value(&quot;1&quot;)) .andReturn().getResponse().getContentAsString(); System.out.println(reuslt); &#125; @Test public void whenDeleteSuccess() throws Exception &#123; mockMvc.perform(delete(&quot;/user/1&quot;) .contentType(MediaType.APPLICATION_JSON_UTF8)) .andExpect(status().isOk()); &#125;&#125; 123456@Datapublic class User &#123; private String id; private String username; private String password;&#125; 在url声明中使用正则表达式 &amp; @PageableDefault指定分页参数默认值security-demo：12345678910111213141516171819202122@RestController@RequestMapping(&quot;/user&quot;)public class UserController &#123; @GetMapping @JsonView(User.UserSimpleView.class) public List&lt;User&gt; query( @PageableDefault(page = 2, size = 17, sort = &quot;username,asc&quot;) Pageable pageable) &#123; List&lt;User&gt; users = new ArrayList&lt;&gt;(); users.add(new User()); users.add(new User()); users.add(new User()); return users; &#125; @GetMapping(&quot;/&#123;id:\\\\d+&#125;&quot;) @JsonView(User.UserDetailView.class) public User getInfo(@PathVariable String id) &#123; User user = new User(); user.setUsername(&quot;tom&quot;); return user; &#125;&#125; @JsonView控制json输出内容1.使用接口来声明多个视图2.在值对象的get方法上指定视图3.在Controller方法上指定视图123456789101112131415161718192021222324@Setterpublic class User &#123; public interface UserSimpleView &#123;&#125;; public interface UserDetailView extends UserSimpleView &#123;&#125;; private String id; private String username; private String password; @JsonView(UserSimpleView.class) public String getUsername() &#123; return username; &#125; @JsonView(UserDetailView.class) public String getPassword() &#123; return password; &#125; @JsonView(UserSimpleView.class) public String getId() &#123; return id; &#125;&#125; 1234567@GetMapping(&quot;/&#123;id:\\\\d+&#125;&quot;)@JsonView(User.UserDetailView.class)public User getInfo(@PathVariable String id) &#123; User user = new User(); user.setUsername(&quot;tom&quot;); return user;&#125; @Valid注解和BindingResult验证请求参数的合法性并处理校验结果 12345678910111213141516@PostMappingpublic User create(@Valid @RequestBody User user) &#123; user.setId(&quot;1&quot;); return user;&#125;@PutMapping(&quot;/&#123;id:\\\\d+&#125;&quot;)public User update(@Valid @RequestBody User user, BindingResult errors) &#123; user.setId(&quot;1&quot;); return user;&#125;@DeleteMapping(&quot;/&#123;id:\\\\d+&#125;&quot;)public void delete(@PathVariable String id) &#123; System.out.println(id);&#125; 1234567891011121314151617181920212223242526@Setterpublic class User &#123; public interface UserSimpleView &#123;&#125;; public interface UserDetailView extends UserSimpleView &#123;&#125;; private String id; private String username; @NotBlank(message = &quot;密码不能为空&quot;) private String password; @JsonView(UserSimpleView.class) public String getUsername() &#123; return username; &#125; @JsonView(UserDetailView.class) public String getPassword() &#123; return password; &#125; @JsonView(UserSimpleView.class) public String getId() &#123; return id; &#125;&#125; 自定义Validator12345678@Target(&#123;ElementType.METHOD, ElementType.FIELD&#125;)@Retention(RetentionPolicy.RUNTIME)@Constraint(validatedBy = MyConstraintValidator.class)public @interface MyConstraint &#123; String message(); Class&lt;?&gt;[] groups() default &#123; &#125;; Class&lt;? extends Payload&gt;[] payload() default &#123; &#125;;&#125; 12345678910111213public class MyConstraintValidator implements ConstraintValidator&lt;MyConstraint, Object&gt; &#123; @Override public void initialize(MyConstraint constraintAnnotation) &#123; System.out.println(&quot;my validator init&quot;); &#125; @Override public boolean isValid(Object value, ConstraintValidatorContext context) &#123; System.out.println(&quot;my validator valid&quot;); System.out.println(value); return true; &#125;&#125; 12345public class User &#123; @MyConstraint(message = &quot;这是一个测试&quot;) private String username; ...&#125; 文件上传下载12345678@Testpublic void whenUploadSuccess() throws Exception &#123; String result = mockMvc.perform(fileUpload(&quot;/file&quot;) .file(new MockMultipartFile(&quot;file&quot;, &quot;test.txt&quot;, &quot;multipart/form-data&quot;, &quot;hello upload&quot;.getBytes(&quot;UTF-8&quot;)))) .andExpect(status().isOk()) .andReturn().getResponse().getContentAsString(); System.out.println(result);&#125; 1234567891011121314151617181920212223242526272829303132@RestController@RequestMapping(&quot;/file&quot;)public class FileController &#123; private String folder = &quot;/Users/path&quot;; @PostMapping public FileInfo upload(MultipartFile file) throws Exception &#123; System.out.println(file.getName()); System.out.println(file.getOriginalFilename()); System.out.println(file.getSize()); File localFile = new File(folder, new Date().getTime() + &quot;.txt&quot;); file.transferTo(localFile); return new FileInfo(localFile.getAbsolutePath()); &#125; @GetMapping(&quot;/&#123;id&#125;&quot;) public void download(@PathVariable String id, HttpServletRequest request, HttpServletResponse response) throws Exception &#123; try (InputStream inputStream = new FileInputStream(new File(folder, id + &quot;.txt&quot;)); OutputStream outputStream = response.getOutputStream();) &#123; response.setContentType(&quot;application/x-download&quot;); response.addHeader(&quot;Content-Disposition&quot;, &quot;attachment;filename=test.txt&quot;); IOUtils.copy(inputStream, outputStream); outputStream.flush(); &#125; &#125;&#125; 12345@Data@AllArgsConstructorpublic class FileInfo &#123; private String path;&#125; 异步处理REST服务使用Runnable异步处理：1234567891011121314151617@RestControllerpublic class AsyncController &#123; @RequestMapping(&quot;/order&quot;) public void order() throws Exception &#123; logger.info(&quot;主线程开始&quot;); Callable&lt;String&gt; result = new Callable&lt;String&gt;() &#123; @Override public String call() throws Exception &#123; logger.info(&quot;副线程开始&quot;); Thread.sleep(1000); logger.info(&quot;副线程返回&quot;); return &quot;success&quot;; &#125; &#125;; &#125;&#125; 使用DeferredResult异步处理REST服务：1234567891011121314151617181920212223@RestControllerpublic class AsyncController &#123; @Autowired private MockQueue mockQueue; @Autowired private DeferredResultHolder deferredResultHolder; private Logger logger = LoggerFactory.getLogger(getClass()); @RequestMapping(&quot;/order&quot;) public DeferredResult&lt;String&gt; order() throws Exception &#123; logger.info(&quot;主线程开始&quot;); String orderNumber = RandomStringUtils.randomNumeric(8); mockQueue.setPlaceOrder(orderNumber); DeferredResult&lt;String&gt; result = new DeferredResult&lt;&gt;(); deferredResultHolder.getMap().put(orderNumber, result); return result; &#125;&#125; 123456789101112@Componentpublic class DeferredResultHolder &#123; private Map&lt;String, DeferredResult&lt;String&gt;&gt; map = new HashMap&lt;String, DeferredResult&lt;String&gt;&gt;(); public Map&lt;String, DeferredResult&lt;String&gt;&gt; getMap() &#123; return map; &#125; public void setMap(Map&lt;String, DeferredResult&lt;String&gt;&gt; map) &#123; this.map = map; &#125;&#125; 12345678910111213141516171819202122232425262728293031@Componentpublic class MockQueue &#123; private String placeOrder; private String completeOrder; private Logger logger = LoggerFactory.getLogger(getClass()); public String getPlaceOrder() &#123; return placeOrder; &#125; public void setPlaceOrder(String placeOrder) throws Exception &#123; new Thread(() -&gt; &#123; logger.info(&quot;接到下单请求, &quot; + placeOrder); try &#123; Thread.sleep(1000); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; this.completeOrder = placeOrder; logger.info(&quot;下单请求处理完毕,&quot; + placeOrder); &#125;).start(); &#125; public String getCompleteOrder() &#123; return completeOrder; &#125; public void setCompleteOrder(String completeOrder) &#123; this.completeOrder = completeOrder; &#125;&#125; 2.Spring MVC 高级特性 3.REST服务开发常用工具使用swagger自动生成html文档12345678910&lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt; &lt;version&gt;2.7.0&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt; &lt;version&gt;2.7.0&lt;/version&gt;&lt;/dependency&gt; 1234@EnableSwagger2@ApiModelProperty@ApiOperation@ApiParam 使用WireMock快速伪造RESTful服务 1java -jar wiremock-standalone-2.7.1.jar --port 8062 1234&lt;dependency&gt; &lt;groupId&gt;com.github.tomakehurst&lt;/groupId&gt; &lt;artifactId&gt;wiremock&lt;/artifactId&gt;&lt;/dependency&gt; 123456789101112131415public class MockServer &#123; public static void main(String[] args) throws IOException &#123; configureFor(8062); removeAllMappings(); mock(&quot;/order/1&quot;, &quot;01&quot;); mock(&quot;/order/2&quot;, &quot;02&quot;); &#125; private static void mock(String url, String file) throws IOException &#123; ClassPathResource resource = new ClassPathResource(&quot;mock/response/&quot; + file + &quot;.txt&quot;); String content = StringUtils.join(FileUtils.readLines(resource.getFile(), &quot;UTF-8&quot;).toArray(), &quot;\\n&quot;); stubFor(get(urlPathEqualTo(url)).willReturn(aResponse().withBody(content).withStatus(200))); &#125;&#125;","categories":[],"tags":[{"name":"Spring Security","slug":"Spring-Security","permalink":"http://yoursite.com/tags/Spring-Security/"}],"keywords":[]},{"title":"SpringSecurity技术栈开发企业级认证与授权-认证流程源码级详解","slug":"Spring Security技术栈开发企业级认证与授权-认证流程源码级详解","date":"2020-04-07T13:37:40.814Z","updated":"2020-04-04T14:53:52.873Z","comments":true,"path":"2020/04/07/Spring Security技术栈开发企业级认证与授权-认证流程源码级详解/","link":"","permalink":"http://yoursite.com/2020/04/07/Spring Security技术栈开发企业级认证与授权-认证流程源码级详解/","excerpt":"","text":"1.认证处理流程说明 1UsernamePasswordAuthenticationToken authRequest = new UsernamePasswordAuthenticationToken(username, password); 获取请求中携带的用户名和密码，然后拿用户名和密码构建了一个UsernamePasswordAuthenticationToken这样一个对象。 该对象是Authentication接口的实现，该接口实际上封装了我们的认证信息。通过该类构造函数发现，会先调用父类的构造函数设置空的权限，设置用户名和密码到本地变量上。设置当前传进去的身份信息还没经过认证。 1this.setDetails(request, authRequest); 会把请求的一些信息设到authRequest中，包括当前发请求的机器的ip，session等。 123456789101112131415161718192021222324252627282930Class&lt;? extends Authentication&gt; toTest = authentication.getClass();AuthenticationException lastException = null;Authentication result = null;boolean debug = logger.isDebugEnabled();Iterator var6 = this.getProviders().iterator();while(var6.hasNext()) &#123; AuthenticationProvider provider = (AuthenticationProvider)var6.next(); if (provider.supports(toTest)) &#123; if (debug) &#123; logger.debug(&quot;Authentication attempt using &quot; + provider.getClass().getName()); &#125; try &#123; result = provider.authenticate(authentication); if (result != null) &#123; this.copyDetails(authentication, result); break; &#125; &#125; catch (AccountStatusException var11) &#123; this.prepareException(var11, authentication); throw var11; &#125; catch (InternalAuthenticationServiceException var12) &#123; this.prepareException(var12, authentication); throw var12; &#125; catch (AuthenticationException var13) &#123; lastException = var13; &#125; &#125;&#125; AuthenticationManager用来管理下面的AuthenticationProvider。真正的检验逻辑是写在AuthenticationProvider中，不同的登录方式的认证逻辑是不一样的。用户名密码登录，校验的是用户名密码。如果是第三方登录，这时候是不用验密码的。spring提供了两个provider，AuthenticationManager负责把所有的provider收集起来，然后收到请求的时候去循环它们，挨个去问你当前这个provider支不支持我这种登录方式。即调用supports方法，判断支不支持我传进来的这个Authentication类型。比如当前拿到的是UsernamePasswordAuthenticationToken，比如第三方的登录传的就是SocialAuthenticationToken。根据传进来的Authentication类型会挑出其中一个provider来进行校验处理。 1result = provider.authenticate(authentication); 如果支持的话，往下走，真正去执行校验逻辑。 Authentication的主要校验逻辑是写在抽象类里面的，首先调用retrieveUser，获取到UserDetails对象。DaoAuthenticationProvider中实现了retrieveUser接口，在实现方法里，调用了我们提供的UserDetailsService实现。通过loadUserByUsername查到我们的用户信息，并包装成UserDetails。如果拿不到，则抛出异常。1this.preAuthenticationChecks.check(user); 如果拿到了用户信息，会做预检查。UserDetalis这个接口有4个方法来判断用户是否可用。锁定，过期等校验。1this.additionalAuthenticationChecks(user, (UsernamePasswordAuthenticationToken)authentication); 做完预检查后，会做附加检查。在DaoAuthenticationProvider中有具体实现。用passwordEncoder校验当前的密码是否匹配。1this.postAuthenticationChecks.check(user); 做完前面两步检查之后，还有一个后检查。也是UserDetails中的校验。 1return this.createSuccessAuthentication(principalToReturn, authentication, user); 所有的这些检查都通过之后，那么认为用户认证是成功的，拿获取到的用户信息、Authentication传进来的认证请求信息来创建SuccessAuthentication。 设置权限和认证通过。 1this.successfulAuthentication(request, response, chain, authResult); 会调我们自己写的成功处理器。123456789101112131415try &#123; authResult = this.attemptAuthentication(request, response); if (authResult == null) &#123; return; &#125; this.sessionStrategy.onAuthentication(authResult, request, response);&#125; catch (InternalAuthenticationServiceException var8) &#123; this.logger.error(&quot;An internal error occurred while trying to authenticate the user.&quot;, var8); this.unsuccessfulAuthentication(request, response, var8); return;&#125; catch (AuthenticationException var9) &#123; this.unsuccessfulAuthentication(request, response, var9); return;&#125; 如果在认证过程中任何一处出了异常，会调用unsuccessfulAuthentication方法，其中会调用我们自己写的失败处理器。 2.认证结果如何在多个请求之间共享 在调成功处理器之前，将我们认证成功的Authentication放到SecurityContext，然后放到SecurityContextHolder里面，SecurityContextHolder实际上是ThreadLocal的封装。 当请求进来的时候，检查sessionl里是否有SecurityContext。如果有，把SecurityContext从session中拿出来放到线程里，如果没有，则为空，放过。当整个请求响应回来以后，过它的时候，它检查线程，如果线程里面有SecurityContext,就拿出来放到session里，这样不用的请求就可以在session中拿到相同的认证信息。 3.获取认证用户信息12345678910111213@RestController@RequestMapping(&quot;/user&quot;)public class UserController &#123; @GetMapping(&quot;/me&quot;) public Object getCurrentUser(@AuthenticationPrincipal UserDetails user) &#123; return user; &#125; @GetMapping(&quot;/me2&quot;) public Object getCurrentUser2(Authentication authentication) &#123; return authentication; &#125;&#125;","categories":[],"tags":[{"name":"Spring Security","slug":"Spring-Security","permalink":"http://yoursite.com/tags/Spring-Security/"}],"keywords":[]},{"title":"angular根据路由展开菜单","slug":"angular根据路由展开菜单","date":"2020-04-04T07:50:56.693Z","updated":"2020-04-04T06:41:50.570Z","comments":true,"path":"2020/04/04/angular根据路由展开菜单/","link":"","permalink":"http://yoursite.com/2020/04/04/angular根据路由展开菜单/","excerpt":"","text":"当路由为“/a”和“/a/b”class active都会被添加。active可以设置为展开菜单的样式html:12&lt;li [routerLink]=&quot;/a&quot; routerLinkActive=&quot;active&quot;&gt;a&lt;/li&gt;&lt;li [routerLink]=&quot;/a/b&quot; routerLinkActive=&quot;active&quot;&gt;ab&lt;/li&gt; 当路由中携带参数时（即？key=value）html:1&lt;li [routerLink]=&quot;/a&quot; [class.active]=&quot;isActive(&quot;/a&quot;)&quot;&gt;a&lt;/li&gt; component:123isActive(instruction: string): boolean &#123; return this.router.isActive(this.router.createUrlTree([instruction]), false);&#125; 参考：https://stackoverflow.com/questions/39271654/routerlinkactive-for-routerlink-with-parameters-dynamichttps://majing.io/posts/10000019031169","categories":[],"tags":[{"name":"angular","slug":"angular","permalink":"http://yoursite.com/tags/angular/"}],"keywords":[]},{"title":"Java常用操作","slug":"Java常用操作","date":"2020-04-04T07:50:56.663Z","updated":"2020-04-04T06:53:34.326Z","comments":true,"path":"2020/04/04/Java常用操作/","link":"","permalink":"http://yoursite.com/2020/04/04/Java常用操作/","excerpt":"","text":"java对Map进行排序根据key排序jdk8:12345// map为待排序的MapMap&lt;String, String&gt; sortMap = new TreeMap&lt;&gt;((String s1, String s2) -&gt; s1.compareTo(s2));sortMap.putAll(map);return sortMap; 参考：https://blog.csdn.net/weixin_41415986/article/details/82781618 快速生成Map1234private Map&lt;Integer, String&gt; newsEventMap = new HashMap&lt;Integer, String&gt;()&#123;&#123; put(&quot;k1&quot;, &quot;v1&quot;); put(&quot;k2&quot;, &quot;v2&quot;);&#125;&#125;; 参考：https://blog.csdn.net/molingduzun123/article/details/50634637/ 获取hashmap的第一个元素1map.entrySet().stream().findFirst(); 参考：https://stackoverflow.com/questions/35658606/how-to-get-the-first-key-of-a-hashmap/35658690","categories":[],"tags":[{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"}],"keywords":[]},{"title":"多线程1","slug":"多线程","date":"2020-04-04T07:50:56.615Z","updated":"2020-04-04T06:59:41.571Z","comments":true,"path":"2020/04/04/多线程/","link":"","permalink":"http://yoursite.com/2020/04/04/多线程/","excerpt":"","text":"java多线程基本知识进程介绍123不管是我们开发的应用程序，还是我们运行的其他的应用程序，都需要先把程序安装在本地的硬盘上。然后找到这个程序的启动文件，启动程序的时候，其实是电脑把当前的这个程序加载到内存中，在内存中需要给当前的程序分配一段独立的运行空间。这片空间就专门负责当前这个程序的运行。不同的应用程序运行的过程中都需要在内存中分配自己独立的运行空间，彼此之间不会相互的影响。我们把每个独立应用程序在内存的独立空间称为当前应用程序运行的一个进程。进程：它是内存中的一段独立的空间，可以负责当前应用程序的运行。当前这个进程负责调度当前程序中的所有运行细节。 线程介绍1234启动的QQ聊天软件，需要和多个人进行聊天。这时多个人之间是不能相互影响，但是它们都位于当前QQ这个软件运行时所分配的内容的独立空间中。 在一个进程中，每个独立的功能都需要独立的去运行，这时又需要把当前这个进程划分成多个运行区域，每个独立的小区域（小单元）称为一个线程。线程：它是位于进程中，负责当前进程中的某个具备独立运行资格的空间。进程是负责整个程序的运行，而线程是程序中具体的某个独立功能的运行。一个进程中至少应该有一个线程。 多线程介绍1234现在的操作系统基本都是多用户，多任务的操作系统。每个任务就是一个进程。而在这个进程中就会有线程。真正可以完成程序运行和功能的实现靠的是进程中的线程。多线程：在一个进程中，我们同时开启多个线程，让多个线程同时去完成某些任务（功能）。多线程的目的：提高程序的运行效率。 多线程运行的原理1234cpu在线程中做时间片的切换。其实真正电脑中的程序的运行不是同时在运行的。CPU负责程序的运行，而CPU在运行程序的过程中某个时刻点上，它其实只能运行一个程序。而不是多个程序。而CPU它可以在多个程序之间进行高速的切换。而切换频率和速度太快，导致人的肉看看不到。每个程序就是进程， 而每个进程中会有多个线程，而CPU是在这些线程之间进行切换。了解了CPU对一个任务的执行过程，我们就必须知道，多线程可以提高程序的运行效率，但不能无限制的开线程。 12345678多进程的意义? 提高CPU的使用率多线程的意义? 提高应用程序的使用率Java程序的运行原理及JVM的启动是多线程的吗? A:Java命令去启动JVM，JVM会启动一个进程，该进程会启动一个主线程。 B:JVM的启动是多线程的，因为它最低有两个线程启动了，主线程和垃圾回收线程。 实现线程的两种方式1、继承Thread的原理123456789101112131415161718192021222324252627282930313233343536import java.util.Random;public class MyThreadWithExtends extends Thread &#123; String flag; public MyThreadWithExtends(String flag)&#123; this.flag = flag; &#125; @Override public void run() &#123; String tname = Thread.currentThread().getName(); System.out.println(tname+&quot;线程的run方法被调用……&quot;); Random random = new Random(); for(int i=0;i&lt;20;i++)&#123; try &#123; Thread.sleep(random.nextInt(10)*100); System.out.println(tname+ &quot;....&quot;+ flag); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; public static void main(String[] args) &#123; Thread thread1 = new MyThreadWithExtends(&quot;a&quot;); Thread thread2 = new MyThreadWithExtends(&quot;b&quot;); thread1.start(); thread2.start(); /** * 如果是调用thread的run方法，则只是一个普通的方法调用，不会开启新的线程 */// thread1.run();// thread2.run(); &#125;&#125; 2、声明实现 Runnable 接口的类1234567891011121314151617181920212223242526272829303132public class MyThreadWithImpliment implements Runnable &#123; int x; public MyThreadWithImpliment(int x) &#123; this.x = x; &#125; @Override public void run() &#123; String name = Thread.currentThread().getName(); System.out.println(&quot;线程&quot; + name + &quot;的run方法被调用……&quot;); for (int i = 0; i &lt; 10; i++) &#123; System.out.println(x); try &#123; Thread.sleep(100); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; public static void main(String[] args) &#123; Thread thread1 = new Thread(new MyThreadWithImpliment(1), &quot;thread-1&quot;); Thread thread2 = new Thread(new MyThreadWithImpliment(2), &quot;thread-2&quot;); thread1.start(); thread2.start(); // 注意调用run和调用start的区别,直接调用run，则都运行在main线程中// thread1.run();// thread2.run(); &#125;&#125; synchronized12345678910111213141516171819202122232425262728293031public class MySynchronized &#123; public static void main(String[] args) &#123; final MySynchronized mySynchronized = new MySynchronized(); final MySynchronized mySynchronized2 = new MySynchronized(); new Thread(&quot;thread1&quot;) &#123; public void run() &#123; synchronized (mySynchronized) &#123; try &#123; System.out.println(this.getName()+&quot; start&quot;); int i =1/0; //如果发生异常，jvm会将锁释放 Thread.sleep(5000); System.out.println(this.getName()+&quot;醒了&quot;); System.out.println(this.getName()+&quot; end&quot;); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;.start(); new Thread(&quot;thread2&quot;) &#123; public void run() &#123; synchronized (mySynchronized) &#123; //争抢同一把锁时，线程1没释放之前，线程2只能等待// synchronized (mySynchronized2) &#123; //如果不是一把锁，可以看到两句话同时打印 System.out.println(this.getName()+&quot; start&quot;); System.out.println(this.getName()+&quot; end&quot;); &#125; &#125; &#125;.start(); &#125;&#125; 线程的调度和优先级问题12345678A:线程的调度 a:分时调度 b:抢占式调度 (Java采用的是该调度方式)B:获取和设置线程优先级public final int getPriority():返回线程对象的优先级public final void setPriority(int newPriority)：更改线程的优先级。 a:默认是5 b:范围是1-10 线程的控制(常见方法)1234567891011121314151617public final String getName():获取线程的名称。public final void setName(String name):设置线程的名称public static Thread currentThread():返回当前正在执行的线程对象Thread.currentThread().getName()A:休眠线程 public static void sleep(long millis) 在run方法中调用Thread.sleep()B:加入线程 public final void join():等待该线程终止。C:礼让线程 public static void yield():暂停当前正在执行的线程对象，并执行其他线程。在run方法中调用Thread.yield()D:后台线程 public final void setDaemon(boolean on):将该线程标记为守护线程或用户线程。当正在运行的线程都是守护线程时，Java虚拟机退出。该方法必须在启动线程前调用。E:终止线程(掌握)public final void stop():让线程停止，太暴力，过时了，但是还可以使用。public void interrupt():中断线程。 把线程的状态终止，并抛出一个InterruptedException。 线程组123456789101112把多个线程组合到一起。它可以对一批线程进行分类管理，Java允许程序直接对线程组进行控制。线程默认情况下属于main线程组线程类里面的方法：public final ThreadGroup getThreadGroup() Thread(ThreadGroup group, Runnable target, String name)线程组里面的方法：public final String getName()线程组的构造方法：ThreadGroup(String name) ThreadGroup tg = new ThreadGroup(&quot;这是一个新的组&quot;);//通过组名称设置后台线程，表示该组的线程都是后台线程tg.setDaemon(true); 线程安全1234567891011121314151617181920212223242526272829303132333435363738import java.util.concurrent.atomic.AtomicInteger;/** * 线程安全概念：当多个线程访问某一个类（对象或方法）时，这个对象始终都能表现出正确的行为，那么这个类（对象或方法）就是线程安全的。 * synchronized：可以在任意对象及方法上加锁，而加锁的这段代码称为&quot;互斥区&quot;或&quot;临界区&quot; * */public class MyThread extends Thread&#123; private int count = 5 ; //synchronized加锁 public void run()&#123; count--; System.out.println(this.currentThread().getName() + &quot; count = &quot;+ count); &#125; public static void main(String[] args) &#123; /** * 分析：当多个线程访问myThread的run方法时，以排队的方式进行处理（这里排对是按照CPU分配的先后顺序而定的）， * 一个线程想要执行synchronized修饰的方法里的代码： * 1 尝试获得锁 * 2 如果拿到锁，执行synchronized代码体内容；拿不到锁，这个线程就会不断的尝试获得这把锁，直到拿到为止， * 而且是多个线程同时去竞争这把锁。（也就是会有锁竞争的问题） */ MyThread myThread = new MyThread(); Thread t1 = new Thread(myThread,&quot;t1&quot;); Thread t2 = new Thread(myThread,&quot;t2&quot;); Thread t3 = new Thread(myThread,&quot;t3&quot;); Thread t4 = new Thread(myThread,&quot;t4&quot;); Thread t5 = new Thread(myThread,&quot;t5&quot;); t1.start(); t2.start(); t3.start(); t4.start(); t5.start(); &#125;&#125; 12345t1 count = 2t5 count = 0t4 count = 1t3 count = 2t2 count = 2 多个线程多个锁多个线程多个锁，多个线程，每个线程都可以拿到自己指定的锁，分别获得锁之后，执行synchronized方法体的内容。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657/** * 关键字synchronized取得的锁都是对象锁，而不是把一段代码（方法）当做锁， * 所以代码中哪个线程先执行synchronized关键字的方法，哪个线程就持有该方法所属对象的锁（Lock）， * 两个对象，线程获得的就是两个不同的锁，他们互不影响。 * * 在静态方法上加synchronized关键字，表示锁定.class类，类一级别的锁（独占.class类）。 * */public class MultiThread &#123; private int num = 0; /** static */ public synchronized void printNum(String tag)&#123; try &#123; if(tag.equals(&quot;a&quot;))&#123; num = 100; System.out.println(&quot;tag a, set num over!&quot;); Thread.sleep(1000); &#125; else &#123; num = 200; System.out.println(&quot;tag b, set num over!&quot;); &#125; System.out.println(&quot;tag &quot; + tag + &quot;, num = &quot; + num); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; //注意观察run方法输出顺序 public static void main(String[] args) &#123; //俩个不同的对象 final MultiThread m1 = new MultiThread(); final MultiThread m2 = new MultiThread(); Thread t1 = new Thread(new Runnable() &#123; @Override public void run() &#123; m1.printNum(&quot;a&quot;); &#125; &#125;); Thread t2 = new Thread(new Runnable() &#123; @Override public void run() &#123; m2.printNum(&quot;b&quot;); &#125; &#125;); t1.start(); t2.start(); &#125;&#125; 1234tag a, set num over!tag b, set num over!tag b, num = 200tag a, num = 100 对象锁的同步和异步同步：synchronized同步的概念就是共享，我们要牢牢记住“共享”这两个字，如果不是共享的资源，就没有必要进行同步。异步：asynchronized异步的概念就是独立，相互之间不受任何制约。就好像我们学习http的时候，在页面发起的ajax请求，我们还可以继续浏览或操作页面的内容，二者之间没有任何关系。同步的目的就是为了线程安全，其实对于线程安全来说，需要猫满足两个特性。原子性（同步）可见性123456789101112131415161718192021222324252627282930313233343536373839404142434445/** * 对象锁的同步和异步问题 * */public class MyObject &#123; public synchronized void method1()&#123; try &#123; System.out.println(Thread.currentThread().getName()); Thread.sleep(4000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; /** synchronized */ public void method2()&#123; System.out.println(Thread.currentThread().getName()); &#125; public static void main(String[] args) &#123; final MyObject mo = new MyObject(); /** * 分析： * t1线程先持有object对象的Lock锁，t2线程可以以异步的方式调用对象中的非synchronized修饰的方法 * t1线程先持有object对象的Lock锁，t2线程如果在这个时候调用对象中的同步（synchronized）方法则需等待，也就是同步 */ Thread t1 = new Thread(new Runnable() &#123; @Override public void run() &#123; mo.method1(); &#125; &#125;,&quot;t1&quot;); Thread t2 = new Thread(new Runnable() &#123; @Override public void run() &#123; mo.method2(); &#125; &#125;,&quot;t2&quot;); t1.start(); t2.start(); &#125;&#125; 12t1t2 （立即打印） 脏读对于对象的同步和异步的方法,我们在设计自己的程序的时候,一定要考虑问题的整体,不然就会出现数据不一致的错误,很经典的错误藏是讲读(dirtyread)123456789101112131415161718192021222324252627282930313233343536373839/** * 在我们对一个对象的方法加锁的时候,需要考虑业务的整体性,即为setValueigetvalue方法同时加链synchronized同步关键字, * 保证业务(service)的原子性,不然会出现业务错误(也从侧面保证业务的一致性) . */public class DirtyRead &#123; private String username = &quot;bjsxt&quot;; private String password = &quot;123&quot;; public synchronized void setValue(String username, String password)&#123; this.username = username; try &#123; Thread.sleep(2000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; this.password = password; System.out.println(&quot;setValue最终结果：username = &quot; + username + &quot; , password = &quot; + password); &#125; public void getValue()&#123; System.out.println(&quot;getValue方法得到：username = &quot; + this.username + &quot; , password = &quot; + this.password); &#125; public static void main(String[] args) throws Exception&#123; final DirtyRead dr = new DirtyRead(); Thread t1 = new Thread(new Runnable() &#123; @Override public void run() &#123; dr.setValue(&quot;z3&quot;, &quot;456&quot;); &#125; &#125;); t1.start(); Thread.sleep(1000); dr.getValue(); &#125;&#125; 12getValue方法得到：username = z3 , password = 123setValue最终结果：username = z3 , password = 456 synchronized锁重入:关键字synchronized拥有锁重入的功能,也就是在使用synchronized时,当一个线程得到了一个对象的锁后,再次请求此对象时是可以再次得到该对象的锁。12345678910111213141516171819202122232425262728/** * synchronized的重入 * */public class SyncDubbo1 &#123; public synchronized void method1()&#123; System.out.println(&quot;method1..&quot;); method2(); &#125; public synchronized void method2()&#123; System.out.println(&quot;method2..&quot;); method3(); &#125; public synchronized void method3()&#123; System.out.println(&quot;method3..&quot;); &#125; public static void main(String[] args) &#123; final SyncDubbo1 sd = new SyncDubbo1(); Thread t1 = new Thread(new Runnable() &#123; @Override public void run() &#123; sd.method1(); &#125; &#125;); t1.start(); &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344/** * synchronized的重入 * */public class SyncDubbo2 &#123; static class Main &#123; public int i = 10; public synchronized void operationSup()&#123; try &#123; i--; System.out.println(&quot;Main print i = &quot; + i); Thread.sleep(100); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; static class Sub extends Main &#123; public synchronized void operationSub()&#123; try &#123; while(i &gt; 0) &#123; i--; System.out.println(&quot;Sub print i = &quot; + i); Thread.sleep(100); this.operationSup(); &#125; &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; public static void main(String[] args) &#123; Thread t1 = new Thread(new Runnable() &#123; @Override public void run() &#123; Sub sub = new Sub(); sub.operationSub(); &#125; &#125;); t1.start(); &#125;&#125; 对于web应用程序,异常释放锁的情况,如果不及时处理,很可能对你的应用程序业务逻辑产生严重的错误,比如你现在执行一个队列任务,很多对象都去在等特第一个对象正确执行完毕再去释放锁,但是第一个对象由于异常的出现,导致业务逻辑没有正常执行完毕,就释放了锁,那么可把而知后续的对象执行的都是错误的逻钱.所以这一点一定要引起注意,在编写代码的时候,一定要考虑剧全.123456789101112131415161718192021222324252627282930313233/** * synchronized异常 * */public class SyncException &#123; private int i = 0; public synchronized void operation()&#123; while(true)&#123; try &#123; i++; Thread.sleep(100); System.out.println(Thread.currentThread().getName() + &quot; , i = &quot; + i); if(i == 20)&#123; //Integer.parseInt(&quot;a&quot;); throw new RuntimeException(); &#125; &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; public static void main(String[] args) &#123; final SyncException se = new SyncException(); Thread t1 = new Thread(new Runnable() &#123; @Override public void run() &#123; se.operation(); &#125; &#125;,&quot;t1&quot;); t1.start(); &#125;&#125; synchronized代码块使用syhchronized声明的方法在某些情况下是有弊端的,比如A线程调用同步的方法执行一个很长时间的任务,那么B找程就必须等待比较长的时间才能执行,这样的情况下可以使用synchronized代码块去优化代码执行时间,也就是通常所说的减小锁的粒度。12345678910111213141516171819202122232425262728293031323334353637383940414243/** * 使用synchronized代码块减小锁的粒度，提高性能 * */public class Optimize &#123; public void doLongTimeTask()&#123; try &#123; System.out.println(&quot;当前线程开始：&quot; + Thread.currentThread().getName() + &quot;, 正在执行一个较长时间的业务操作，其内容不需要同步&quot;); Thread.sleep(2000); synchronized(this)&#123; System.out.println(&quot;当前线程：&quot; + Thread.currentThread().getName() + &quot;, 执行同步代码块，对其同步变量进行操作&quot;); Thread.sleep(1000); &#125; System.out.println(&quot;当前线程结束：&quot; + Thread.currentThread().getName() + &quot;, 执行完毕&quot;); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; public static void main(String[] args) &#123; final Optimize otz = new Optimize(); Thread t1 = new Thread(new Runnable() &#123; @Override public void run() &#123; otz.doLongTimeTask(); &#125; &#125;,&quot;t1&quot;); Thread t2 = new Thread(new Runnable() &#123; @Override public void run() &#123; otz.doLongTimeTask(); &#125; &#125;,&quot;t2&quot;); t1.start(); t2.start(); &#125;&#125; synchronized可以使用任意的Object进行加锁,用法比较灵活.1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465/** * 使用synchronized代码块加锁,比较灵活 * */public class ObjectLock &#123; public void method1()&#123; synchronized (this) &#123; //对象锁 try &#123; System.out.println(&quot;do method1..&quot;); Thread.sleep(2000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; public void method2()&#123; //类锁 synchronized (ObjectLock.class) &#123; try &#123; System.out.println(&quot;do method2..&quot;); Thread.sleep(2000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; private Object lock = new Object(); public void method3()&#123; //任何对象锁 synchronized (lock) &#123; try &#123; System.out.println(&quot;do method3..&quot;); Thread.sleep(2000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; public static void main(String[] args) &#123; final ObjectLock objLock = new ObjectLock(); Thread t1 = new Thread(new Runnable() &#123; @Override public void run() &#123; objLock.method1(); &#125; &#125;); Thread t2 = new Thread(new Runnable() &#123; @Override public void run() &#123; objLock.method2(); &#125; &#125;); Thread t3 = new Thread(new Runnable() &#123; @Override public void run() &#123; objLock.method3(); &#125; &#125;); t1.start(); t2.start(); t3.start(); &#125;&#125; 另外特别注意一个问题,就是不要使用String的常量加锁,会出现死循环问题因为在JVM中具有String常量池(如果两个String具有相同的值，那么他们的地址是相同的，都保存在这个常量池中)。当以String作为锁的时候，如果值相同则，那么线程持有相同的锁。这样就造成了另外一个线程不能执行 锁对象的改变问题,当使用一个对象进行加锁的时候,要注意对象本身发生改变的时候那么持有的镜就不同,如果对象本身不发生改变,那么依然是同步的,即使是对象的属性发生了改变。 死锁问题12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061/** * 死锁问题，在设计程序时就应该避免双方相互持有对方的锁的情况 * */public class DeadLock implements Runnable&#123; private String tag; private static Object lock1 = new Object(); private static Object lock2 = new Object(); public void setTag(String tag)&#123; this.tag = tag; &#125; @Override public void run() &#123; if(tag.equals(&quot;a&quot;))&#123; synchronized (lock1) &#123; try &#123; System.out.println(&quot;当前线程 : &quot; + Thread.currentThread().getName() + &quot; 进入lock1执行&quot;); Thread.sleep(2000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; synchronized (lock2) &#123; System.out.println(&quot;当前线程 : &quot; + Thread.currentThread().getName() + &quot; 进入lock2执行&quot;); &#125; &#125; &#125; if(tag.equals(&quot;b&quot;))&#123; synchronized (lock2) &#123; try &#123; System.out.println(&quot;当前线程 : &quot; + Thread.currentThread().getName() + &quot; 进入lock2执行&quot;); Thread.sleep(2000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; synchronized (lock1) &#123; System.out.println(&quot;当前线程 : &quot; + Thread.currentThread().getName() + &quot; 进入lock1执行&quot;); &#125; &#125; &#125; &#125; public static void main(String[] args) &#123; DeadLock d1 = new DeadLock(); d1.setTag(&quot;a&quot;); DeadLock d2 = new DeadLock(); d2.setTag(&quot;b&quot;); Thread t1 = new Thread(d1, &quot;t1&quot;); Thread t2 = new Thread(d2, &quot;t2&quot;); t1.start(); try &#123; Thread.sleep(500); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; t2.start(); &#125;&#125; synchronized的缺陷12345678910111213141516synchronized是java中的一个关键字，也就是说是Java语言内置的特性。如果一个代码块被synchronized修饰了，当一个线程获取了对应的锁，并执行该代码块时，其他线程便只能一直等待，等待获取锁的线程释放锁，而这里获取锁的线程释放锁只会有两种情况：1）获取锁的线程执行完了该代码块，然后线程释放对锁的占有；2）线程执行发生异常，此时JVM会让线程自动释放锁。例子1： 如果这个获取锁的线程由于要等待IO或者其他原因（比如调用sleep方法）被阻塞了，但是又没有释放锁，其他线程便只能干巴巴地等待，试想一下，这多么影响程序执行效率。 因此就需要有一种机制可以不让等待的线程一直无期限地等待下去（比如只等待一定的时间或者能够响应中断），通过Lock就可以办到。例子2：当有多个线程读写文件时，读操作和写操作会发生冲突现象，写操作和写操作会发生冲突现象，但是读操作和读操作不会发生冲突现象。 但是采用synchronized关键字来实现同步的话，就会导致一个问题：如果多个线程都只是进行读操作，当一个线程在进行读操作时，其他线程只能等待无法进行读操作。因此就需要一种机制来使得多个线程都只是进行读操作时，线程之间不会发生冲突，通过Lock就可以办到。另外，通过Lock可以知道线程有没有成功获取到锁。这个是synchronized无法办到的。总的来说，也就是说Lock提供了比synchronized更多的功能。 locklock和synchronized的区别121）Lock不是Java语言内置的，synchronized是Java语言的关键字，因此是内置特性。Lock是一个类，通过这个类可以实现同步访问；2）Lock和synchronized有一点非常大的不同，采用synchronized不需要用户去手动释放锁，当synchronized方法或者synchronized代码块执行完之后，系统会自动让线程释放对锁的占用；而Lock则必须要用户去手动释放锁，如果没有主动释放锁，就有可能导致出现死锁现象。 lock1234567public interface Lock &#123; void lock(); void lockInterruptibly() throws InterruptedException; boolean tryLock(); boolean tryLock(long time, TimeUnit unit) throws InterruptedException; void unlock();&#125; Lock接口中每个方法的使用：lock()、tryLock()、tryLock(long time, TimeUnit unit)、lockInterruptibly()是用来获取锁的。unLock()方法是用来释放锁的。四个获取锁方法的区别：lock()方法是平常使用得最多的一个方法，就是用来获取锁。如果锁已被其他线程获取，则进行等待。由于在前面讲到如果采用Lock，必须主动去释放锁，并且在发生异常时，不会自动释放锁。因此一般来说，使用Lock必须在try{}catch{}块中进行，并且将释放锁的操作放在finally块中进行，以保证锁一定被被释放，防止死锁的发生。tryLock()方法是有返回值的，它表示用来尝试获取锁，如果获取成功，则返回true，如果获取失败（即锁已被其他线程获取），则返回false，也就说这个方法无论如何都会立即返回。在拿不到锁时不会一直在那等待。tryLock(long time, TimeUnit unit)方法和tryLock()方法是类似的，只不过区别在于这个方法在拿不到锁时会等待一定的时间，在时间期限之内如果还拿不到锁，就返回false。如果如果一开始拿到锁或者在等待期间内拿到了锁，则返回true。lockInterruptibly()方法比较特殊，当通过这个方法去获取锁时，如果线程正在等待获取锁，则这个线程能够响应中断，即中断线程的等待状态。也就使说，当两个线程同时通过lock.lockInterruptibly()想获取某个锁时，假若此时线程A获取到了锁，而线程B只有在等待，那么对线程B调用threadB.interrupt()方法能够中断线程B的等待过程。注意，当一个线程获取了锁之后，是不会被interrupt()方法中断的。因此当通过lockInterruptibly()方法获取某个锁时，如果不能获取到，只有进行等待的情况下，是可以响应中断的。而用synchronized修饰的话，当一个线程处于等待某个锁的状态，是无法被中断的，只有一直等待下去。 ReentrantLock直接使用lock接口的话，我们需要实现很多方法，不太方便，ReentrantLock是唯一实现了Lock接口的类，并且ReentrantLock提供了更多的方法，ReentrantLock，意思是“可重入锁”。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748import java.util.ArrayList;import java.util.concurrent.locks.Lock;import java.util.concurrent.locks.ReentrantLock;public class MyLockTest &#123; private static ArrayList&lt;Integer&gt; arrayList = new ArrayList&lt;Integer&gt;(); static Lock lock = new ReentrantLock(); // 注意这个地方 public static &lt;E&gt; void main(String[] args) &#123; new Thread() &#123; public void run() &#123; Thread thread = Thread.currentThread(); lock.lock(); try &#123; System.out.println(thread.getName() + &quot;得到了锁&quot;); for (int i = 0; i &lt; 5; i++) &#123; arrayList.add(i); &#125; &#125; catch (Exception e) &#123; // TODO: handle exception &#125; finally &#123; System.out.println(thread.getName() + &quot;释放了锁&quot;); lock.unlock(); &#125; &#125;; &#125;.start(); new Thread() &#123; public void run() &#123; Thread thread = Thread.currentThread(); lock.lock(); try &#123; System.out.println(thread.getName() + &quot;得到了锁&quot;); for (int i = 0; i &lt; 5; i++) &#123; arrayList.add(i); &#125; &#125; catch (Exception e) &#123; // TODO: handle exception &#125; finally &#123; System.out.println(thread.getName() + &quot;释放了锁&quot;); lock.unlock(); &#125; &#125;; &#125;.start(); &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657import java.util.ArrayList;import java.util.concurrent.locks.Lock;import java.util.concurrent.locks.ReentrantLock;/** * 观察现象：一个线程获得锁后，另一个线程取不到锁，不会一直等待 * */public class MyTryLock &#123; private static ArrayList&lt;Integer&gt; arrayList = new ArrayList&lt;Integer&gt;(); static Lock lock = new ReentrantLock(); // 注意这个地方 public static void main(String[] args) &#123; new Thread() &#123; public void run() &#123; Thread thread = Thread.currentThread(); boolean tryLock = lock.tryLock(); System.out.println(thread.getName()+&quot; &quot;+tryLock); if (tryLock) &#123; try &#123; System.out.println(thread.getName() + &quot;得到了锁&quot;); for (int i = 0; i &lt; 5; i++) &#123; arrayList.add(i); &#125; &#125; catch (Exception e) &#123; // TODO: handle exception &#125; finally &#123; System.out.println(thread.getName() + &quot;释放了锁&quot;); lock.unlock(); &#125; &#125; &#125;; &#125;.start(); new Thread() &#123; public void run() &#123; Thread thread = Thread.currentThread(); boolean tryLock = lock.tryLock(); System.out.println(thread.getName()+&quot; &quot;+tryLock); if (tryLock) &#123; try &#123; System.out.println(thread.getName() + &quot;得到了锁&quot;); for (int i = 0; i &lt; 5; i++) &#123; arrayList.add(i); &#125; &#125; catch (Exception e) &#123; // TODO: handle exception &#125; finally &#123; System.out.println(thread.getName() + &quot;释放了锁&quot;); lock.unlock(); &#125; &#125; &#125;; &#125;.start(); &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859import java.util.concurrent.locks.Lock;import java.util.concurrent.locks.ReentrantLock;/** * 观察现象：如果thread-0得到了锁，阻塞。。。thread-1尝试获取锁，如果拿不到，则可以被中断等待 * */public class MyInterruptibly &#123; private Lock lock = new ReentrantLock(); public static void main(String[] args) &#123; MyInterruptibly test = new MyInterruptibly(); MyThread thread0 = new MyThread(test); MyThread thread1 = new MyThread(test); thread0.start(); thread1.start(); try &#123; Thread.sleep(2000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; thread1.interrupt(); System.out.println(&quot;=====================&quot;); &#125; public void insert(Thread thread) throws InterruptedException&#123; lock.lockInterruptibly(); //注意，如果需要正确中断等待锁的线程，必须将获取锁放在外面，然后将InterruptedException抛出 try &#123; System.out.println(thread.getName()+&quot;得到了锁&quot;); long startTime = System.currentTimeMillis(); for( ; ;) &#123; if(System.currentTimeMillis() - startTime &gt;= Integer.MAX_VALUE) break; //插入数据 &#125; &#125; finally &#123; System.out.println(Thread.currentThread().getName()+&quot;执行finally&quot;); lock.unlock(); System.out.println(thread.getName()+&quot;释放了锁&quot;); &#125; &#125; &#125; class MyThread extends Thread &#123; private MyInterruptibly test = null; public MyThread(MyInterruptibly test) &#123; this.test = test; &#125; @Override public void run() &#123; try &#123; test.insert(Thread.currentThread()); &#125; catch (Exception e) &#123; System.out.println(Thread.currentThread().getName()+&quot;被中断&quot;); &#125; &#125;&#125; ReadWriteLock123456789101112131415public interface ReadWriteLock &#123; /** * Returns the lock used for reading. * * @return the lock used for reading. */ Lock readLock(); /** * Returns the lock used for writing. * * @return the lock used for writing. */ Lock writeLock();&#125; 一个用来获取读锁，一个用来获取写锁。也就是说将文件的读写操作分开，分成2个锁来分配给线程，从而使得多个线程可以同时进行读操作。下面的ReentrantReadWriteLock实现了ReadWriteLock接口。123456789101112131415161718192021222324252627282930313233343536/** * 一个线程又要读又要写，用synchronize来实现的话，读写操作都只能锁住后一个线程一个线程地进行 * */public class MySynchronizedReadWrite &#123; public static void main(String[] args) &#123; final MySynchronizedReadWrite test = new MySynchronizedReadWrite(); new Thread()&#123; public void run() &#123; test.get(Thread.currentThread()); &#125;; &#125;.start(); new Thread()&#123; public void run() &#123; test.get(Thread.currentThread()); &#125;; &#125;.start(); &#125; public synchronized void get(Thread thread) &#123; long start = System.currentTimeMillis(); int i=0; while(System.currentTimeMillis() - start &lt;= 1) &#123; i++; if(i%4==0)&#123; System.out.println(thread.getName()+&quot;正在进行写操作&quot;); &#125;else &#123; System.out.println(thread.getName()+&quot;正在进行读操作&quot;); &#125; &#125; System.out.println(thread.getName()+&quot;读写操作完毕&quot;); &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667import java.util.concurrent.locks.ReentrantReadWriteLock;/** * 使用读写锁，可以实现读写分离锁定，读操作并发进行，写操作锁定单个线程 * * 如果有一个线程已经占用了读锁，则此时其他线程如果要申请写锁，则申请写锁的线程会一直等待释放读锁。 * 如果有一个线程已经占用了写锁，则此时其他线程如果申请写锁或者读锁，则申请的线程会一直等待释放写锁。 * */public class MyReentrantReadWriteLock &#123; private ReentrantReadWriteLock rwl = new ReentrantReadWriteLock(); public static void main(String[] args) &#123; final MyReentrantReadWriteLock test = new MyReentrantReadWriteLock(); new Thread()&#123; public void run() &#123; test.get(Thread.currentThread()); test.write(Thread.currentThread()); &#125;; &#125;.start(); new Thread()&#123; public void run() &#123; test.get(Thread.currentThread()); test.write(Thread.currentThread()); &#125;; &#125;.start(); &#125; /** * 读操作,用读锁来锁定 * @param thread */ public void get(Thread thread) &#123; rwl.readLock().lock(); try &#123; long start = System.currentTimeMillis(); while(System.currentTimeMillis() - start &lt;= 1) &#123; System.out.println(thread.getName()+&quot;正在进行读操作&quot;); &#125; System.out.println(thread.getName()+&quot;读操作完毕&quot;); &#125; finally &#123; rwl.readLock().unlock(); &#125; &#125; /** * 写操作，用写锁来锁定 * @param thread */ public void write(Thread thread) &#123; rwl.writeLock().lock();; try &#123; long start = System.currentTimeMillis(); while(System.currentTimeMillis() - start &lt;= 1) &#123; System.out.println(thread.getName()+&quot;正在进行写操作&quot;); &#125; System.out.println(thread.getName()+&quot;写操作完毕&quot;); &#125; finally &#123; rwl.writeLock().unlock(); &#125; &#125;&#125; 注意：不过要注意的是，如果有一个线程已经占用了读锁，则此时其他线程如果要申请写锁，则申请写锁的线程会一直等待释放读锁。如果有一个线程已经占用了写锁，则此时其他线程如果申请写锁或者读锁，则申请的线程会一直等待释放写锁。 Lock和synchronized的选择1234561）Lock是一个接口，而synchronized是Java中的关键字，synchronized是内置的语言实现；2）synchronized在发生异常时，会自动释放线程占有的锁，因此不会导致死锁现象发生；而Lock在发生异常时，如果没有主动通过unLock()去释放锁，则很可能造成死锁现象，因此使用Lock时需要在finally块中释放锁；3）Lock可以让等待锁的线程响应中断，而synchronized却不行，使用synchronized时，等待的线程会一直等待下去，不能够响应中断；4）通过Lock可以知道有没有成功获取锁，而synchronized却无法办到。5）Lock可以提高多个线程进行读操作的效率。在性能上来说，如果竞争资源不激烈，两者的性能是差不多的，而当竞争资源非常激烈时（即有大量线程同时竞争），此时Lock的性能要远远优于synchronized。所以说，在具体使用时要根据适当情况选择。 volatile关键字的概念volatile 概念: atile关键字的主要作用是使变量在多个线程同可见.在java中,每一个线程都会有一块工作内存区,其中存放着所有线程共享的主内存中的变量值的拷贝。当线程执行时,他在自己的工作内存区中操作这些变量,为了存取一个共享的变量,一个线程通常先获取镇定并去清除它的内存工作区,把这些共享变量从所有线程的共享内存区中正确的装入到他自己所在的工作内存区中,当线程解锁时保证该工作内存区中变量的值写回到共享内存中.一个线程可以执行的操作有使用(use) 、赋值(assign) 、装载(load)、存储(store) 、锁定(lock) 、解镇(unlock) .而主内存可以执行的操作有读(read)、写(wrte) 、锁定(lock)、解镇(unlock) ,每个操作都是原子的。volatile作用就是强制线程到主内存(共享内存)里去读取变量,而不去线程工作内存区里去读取,从而实现了多个线程间的变量可见。也就是满足线程安全的可见性。1234567891011121314151617181920212223public class RunThread extends Thread&#123; private volatile boolean isRunning = true; private void setRunning(boolean isRunning)&#123; this.isRunning = isRunning; &#125; public void run()&#123; System.out.println(&quot;进入run方法..&quot;); int i = 0; while(isRunning == true)&#123; //.. &#125; System.out.println(&quot;线程停止&quot;); &#125; public static void main(String[] args) throws InterruptedException &#123; RunThread rt = new RunThread(); rt.start(); Thread.sleep(1000); rt.setRunning(false); System.out.println(&quot;isRunning的值已经被设置了false&quot;); &#125;&#125; 123进入run方法..isRunning的值已经被设置了false线程停止 不加volatile12进入run方法..isRunning的值已经被设置了false volatile关键字的非原子性volatile关键字虽然拥有多个线程之间的可见性,但是却不具备同步性(也就是原子性) ,可以算上是一个轻量级的synchronized,性能要比synchronized强很多,不会造成阻塞(在很多开源的架构里,比如netty的底层代码就大量使用volatile, 可见netty性能一定是非常不错的。)这里需要注意:一般volatile用于只针对于多个线程可见的变量操作,并不能代替synchronized的同步功能.123456789101112131415161718192021222324252627282930313233import java.util.concurrent.atomic.AtomicInteger;/** * volatile关键字不具备synchronized关键字的原子性（同步） * */public class VolatileNoAtomic extends Thread&#123; private static volatile int count; //private static AtomicInteger count = new AtomicInteger(0); private static void addCount()&#123; for (int i = 0; i &lt; 1000; i++) &#123; count++ ; // count.incrementAndGet(); &#125; System.out.println(count); &#125; public void run()&#123; addCount(); &#125; public static void main(String[] args) &#123; VolatileNoAtomic[] arr = new VolatileNoAtomic[100]; for (int i = 0; i &lt; 10; i++) &#123; arr[i] = new VolatileNoAtomic(); &#125; for (int i = 0; i &lt; 10; i++) &#123; arr[i].start(); &#125; &#125;&#125; 123456789101948394829481948531560396401740184019401 AtomicInteger1234567891020002000341946725000600070009000800010000 volatie关键字只具有可见性,没有原子性,要实现原子性建议使用atomic类的系列对象,支持原子性操作(注童atomic类只保证本身方法原子性,并不保证多次操作的原子性)12345678910111213141516171819202122232425262728293031323334353637383940import java.util.ArrayList;import java.util.List;import java.util.concurrent.atomic.AtomicInteger;public class AtomicUse &#123; private static AtomicInteger count = new AtomicInteger(0); //多个addAndGet在一个方法内是非原子性的，需要加synchronized进行修饰，保证4个addAndGet整体原子性 /**synchronized*/ public synchronized int multiAdd()&#123; try &#123; Thread.sleep(100); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; count.addAndGet(1); count.addAndGet(2); count.addAndGet(3); count.addAndGet(4); //+10 return count.get(); &#125; public static void main(String[] args) &#123; final AtomicUse au = new AtomicUse(); List&lt;Thread&gt; ts = new ArrayList&lt;Thread&gt;(); for (int i = 0; i &lt; 100; i++) &#123; ts.add(new Thread(new Runnable() &#123; @Override public void run() &#123; System.out.println(au.multiAdd()); &#125; &#125;)); &#125; for(Thread t : ts)&#123; t.start(); &#125; &#125;&#125;","categories":[],"tags":[{"name":"java基础","slug":"java基础","permalink":"http://yoursite.com/tags/java基础/"}],"keywords":[]},{"title":"oracle-monitor-toptable","slug":"oracle_table","date":"2020-04-04T07:50:56.600Z","updated":"2020-04-04T07:04:47.331Z","comments":true,"path":"2020/04/04/oracle_table/","link":"","permalink":"http://yoursite.com/2020/04/04/oracle_table/","excerpt":"","text":"1234567891011121314151617181920212223242526272829303132333435SELECT t1.*, nvl(t2.index_bytes, 0) index_bytes, nvl(t3.lob_bytes, 0) lob_bytesFROM (SELECT * FROM(SELECT tab.owner, tab.table_name, tab.tablespace_name, nvl(tab.num_rows, to_number(NULL)) num_rows, nvl(stab.bytes, to_number(NULL)) bytes FROM dba_tables tab, dba_segments stab WHERE stab.owner = tab.owner AND stab.segment_name = tab.table_name AND tab.owner NOT LIKE &apos;%SYS%&apos; ORDER BY stab.bytes DESC) WHERE rownum &lt;= 10) t1, (SELECT table_owner, table_name, SUM(nvl(bytes, to_number(NULL))) index_bytes FROM dba_indexes ind, dba_segments seg WHERE ind.owner=seg.owner AND ind.index_name=seg.segment_name AND table_owner NOT LIKE &apos;%SYS%&apos; GROUP BY table_owner,table_name) t2, (SELECT l.owner, l.table_name, SUM(nvl(bytes, to_number(NULL))) lob_bytes FROM dba_lobs l, dba_segments seg WHERE l.owner=seg.owner AND l.segment_name=seg.segment_name AND l.owner NOT LIKE &apos;%SYS%&apos; GROUP BY l.owner,l.table_name) t3WHERE t1.table_name = t2.table_name(+) AND t1.owner = t2.table_owner(+) AND t1.table_name = t3.table_name(+) AND t1.owner = t3.owner(+) 参考：https://github.com/freenetdigital/prometheus_oracle_exporter","categories":[],"tags":[{"name":"oracle","slug":"oracle","permalink":"http://yoursite.com/tags/oracle/"}],"keywords":[]},{"title":"观察者模式","slug":"观察者模式","date":"2020-04-04T07:50:56.576Z","updated":"2020-04-04T07:12:25.476Z","comments":true,"path":"2020/04/04/观察者模式/","link":"","permalink":"http://yoursite.com/2020/04/04/观察者模式/","excerpt":"","text":"123public interface Observer &#123; void update(Subject subject);&#125; 123456789101112131415public class ObserverA implements Observer &#123; private int myState; //myState需要跟目标对象的state值保持一致！ @Override public void update(Subject subject) &#123; myState = ((ConcreteSubject)subject).getState(); &#125; public int getMyState() &#123; return myState; &#125; public void setMyState(int myState) &#123; this.myState = myState; &#125;&#125; 1234567891011121314151617public class Subject &#123; protected List&lt;Observer&gt; list = new ArrayList&lt;Observer&gt;(); public void registerObserver(Observer obs)&#123; list.add(obs); &#125; public void removeObserver(Observer obs)&#123; list.add(obs); &#125; //通知所有的观察者更新状态 public void notifyAllObservers()&#123; for (Observer obs : list) &#123; obs.update(this); &#125; &#125;&#125; 12345678910111213public class ConcreteSubject extends Subject &#123; private int state; public int getState() &#123; return state; &#125; public void setState(int state) &#123; this.state = state; //主题对象(目标对象)值发生了变化，请通知所有的观察者 this.notifyAllObservers(); &#125;&#125; 123456789101112131415161718192021222324252627282930313233public class Client &#123; public static void main(String[] args) &#123; //目标对象 ConcreteSubject subject = new ConcreteSubject(); //创建多个观察者 ObserverA obs1 = new ObserverA(); ObserverA obs2 = new ObserverA(); ObserverA obs3 = new ObserverA(); //将这三个观察者添加到subject对象的观察者队伍中 subject.registerObserver(obs1); subject.registerObserver(obs2); subject.registerObserver(obs3); //改变subject的状态 subject.setState(3000); System.out.println(&quot;########################&quot;); //我们看看，观察者的状态是不是也发生了变化 System.out.println(obs1.getMyState()); System.out.println(obs2.getMyState()); System.out.println(obs3.getMyState()); //改变subject的状态 subject.setState(30); System.out.println(&quot;########################&quot;); //我们看看，观察者的状态是不是也发生了变化 System.out.println(obs1.getMyState()); System.out.println(obs2.getMyState()); System.out.println(obs3.getMyState()); &#125;&#125; 12345678910111213141516171819import java.util.Observable;import java.util.Observer;public class ObserverA implements Observer &#123; private int myState; @Override public void update(Observable o, Object arg) &#123; myState = ((ConcreteSubject)o).getState(); &#125; public int getMyState() &#123; return myState; &#125; public void setMyState(int myState) &#123; this.myState = myState; &#125;&#125; 12345678910111213141516171819202122import java.util.Observable;//目标对象public class ConcreteSubject extends Observable &#123; private int state; public void set(int s)&#123; state = s; //目标对象的状态发生了改变 setChanged(); //表示目标对象已经做了更改 notifyObservers(state); //通知所有的观察者 &#125; public int getState() &#123; return state; &#125; public void setState(int state) &#123; this.state = state; &#125;&#125; 12345678910111213141516171819202122232425262728293031public class Client &#123; public static void main(String[] args) &#123; //创建目标对象Obserable ConcreteSubject subject = new ConcreteSubject(); //创建观察者 ObserverA obs1 = new ObserverA(); ObserverA obs2 = new ObserverA(); ObserverA obs3 = new ObserverA(); //将上面三个观察者对象添加到目标对象subject的观察者容器中 subject.addObserver(obs1); subject.addObserver(obs2); subject.addObserver(obs3); //改变subject对象的状态 subject.set(3000); System.out.println(&quot;===============状态修改了！&quot;); //观察者的状态发生了变化 System.out.println(obs1.getMyState()); System.out.println(obs2.getMyState()); System.out.println(obs3.getMyState()); subject.set(600); System.out.println(&quot;===============状态修改了！&quot;); //观察者的状态发生了变化 System.out.println(obs1.getMyState()); System.out.println(obs2.getMyState()); System.out.println(obs3.getMyState()); &#125;&#125;","categories":[],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/tags/设计模式/"}],"keywords":[]},{"title":"备忘录模式","slug":"备忘录模式","date":"2020-04-04T07:50:56.562Z","updated":"2020-04-04T07:13:29.324Z","comments":true,"path":"2020/04/04/备忘录模式/","link":"","permalink":"http://yoursite.com/2020/04/04/备忘录模式/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445/** * 源发器类 */public class Emp &#123; private String ename; private int age; private double salary; //进行备忘操作，并返回备忘录对象 public EmpMemento memento()&#123; return new EmpMemento(this); &#125; //进行数据恢复，恢复成制定备忘录对象的值 public void recovery(EmpMemento mmt)&#123; this.ename = mmt.getEname(); this.age = mmt.getAge(); this.salary = mmt.getSalary(); &#125; public Emp(String ename, int age, double salary) &#123; super(); this.ename = ename; this.age = age; this.salary = salary; &#125; public String getEname() &#123; return ename; &#125; public void setEname(String ename) &#123; this.ename = ename; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; public double getSalary() &#123; return salary; &#125; public void setSalary(double salary) &#123; this.salary = salary; &#125;&#125; 123456789101112131415161718192021222324252627282930313233/** * 备忘录类 */public class EmpMemento &#123; private String ename; private int age; private double salary; public EmpMemento(Emp e) &#123; this.ename = e.getEname(); this.age = e.getAge(); this.salary = e.getSalary(); &#125; public String getEname() &#123; return ename; &#125; public void setEname(String ename) &#123; this.ename = ename; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; public double getSalary() &#123; return salary; &#125; public void setSalary(double salary) &#123; this.salary = salary; &#125;&#125; 12345678910111213141516/** * 负责人类 * 负责管理备忘录对象 */public class CareTaker &#123; private EmpMemento memento;// private List&lt;EmpMemento&gt; list = new ArrayList&lt;EmpMemento&gt;(); public EmpMemento getMemento() &#123; return memento; &#125; public void setMemento(EmpMemento memento) &#123; this.memento = memento; &#125;&#125; 12345678910111213141516171819public class Client &#123; public static void main(String[] args) &#123; CareTaker taker = new CareTaker(); Emp emp = new Emp(&quot;高淇&quot;, 18, 900); System.out.println(&quot;第一次打印对象：&quot;+emp.getEname()+&quot;---&quot;+emp.getAge()+&quot;---&quot;+emp.getSalary()); taker.setMemento(emp.memento()); //备忘一次 emp.setAge(38); emp.setEname(&quot;搞起&quot;); emp.setSalary(9000); System.out.println(&quot;第二次打印对象：&quot;+emp.getEname()+&quot;---&quot;+emp.getAge()+&quot;---&quot;+emp.getSalary()); emp.recovery(taker.getMemento()); //恢复到备忘录对象保存的状态 System.out.println(&quot;第三次打印对象：&quot;+emp.getEname()+&quot;---&quot;+emp.getAge()+&quot;---&quot;+emp.getSalary()); &#125;&#125;","categories":[],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/tags/设计模式/"}],"keywords":[]},{"title":"状态模式","slug":"状态模式","date":"2020-04-04T07:50:56.558Z","updated":"2020-04-04T07:14:16.647Z","comments":true,"path":"2020/04/04/状态模式/","link":"","permalink":"http://yoursite.com/2020/04/04/状态模式/","excerpt":"","text":"123public interface State &#123; void handle();&#125; 123456789/** * 已预订状态 */public class BookedState implements State &#123; @Override public void handle() &#123; System.out.println(&quot;房间已预订！别人不能定！&quot;); &#125;&#125; 123456789/** * 已入住状态 */public class CheckedInState implements State &#123; @Override public void handle() &#123; System.out.println(&quot;房间已入住！请勿打扰！&quot;); &#125;&#125; 123456789/** * 空闲状态 */public class FreeState implements State &#123; @Override public void handle() &#123; System.out.println(&quot;房间空闲！！！没人住！&quot;); &#125;&#125; 12345678910111213/** * 房间对象 */public class HomeContext &#123; //如果是银行系统，这个Context类就是账号。根据金额不同，切换不同的状态！ private State state; public void setState(State s)&#123; System.out.println(&quot;修改状态！&quot;); state = s; state.handle(); &#125;&#125; 123456789public class Client &#123; public static void main(String[] args) &#123; HomeContext ctx = new HomeContext(); ctx.setState(new FreeState()); ctx.setState(new BookedState()); &#125;&#125;","categories":[],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/tags/设计模式/"}],"keywords":[]},{"title":"模板方法模式","slug":"模板方法模式","date":"2020-04-04T07:50:56.547Z","updated":"2020-04-04T07:15:49.326Z","comments":true,"path":"2020/04/04/模板方法模式/","link":"","permalink":"http://yoursite.com/2020/04/04/模板方法模式/","excerpt":"","text":"123456789101112131415161718192021public abstract class BankTemplateMethod &#123; //具体方法 public void takeNumber()&#123; System.out.println(&quot;取号排队&quot;); &#125; public abstract void transact(); //办理具体的业务 //钩子方法 public void evaluate()&#123; System.out.println(&quot;反馈评分&quot;); &#125; public final void process()&#123; //模板方法！！！ this.takeNumber(); this.transact(); this.evaluate(); &#125;&#125; 123456class DrawMoney extends BankTemplateMethod &#123; @Override public void transact() &#123; System.out.println(&quot;我要取款！！！&quot;); &#125;&#125; 1234567891011121314151617181920212223242526public class Client &#123; public static void main(String[] args) &#123; BankTemplateMethod btm = new DrawMoney(); btm.process(); //采用匿名内部类 BankTemplateMethod btm2 = new BankTemplateMethod() &#123; @Override public void transact() &#123; System.out.println(&quot;我要存钱！&quot;); &#125; &#125;; btm2.process(); BankTemplateMethod btm3 = new BankTemplateMethod() &#123; @Override public void transact() &#123; System.out.println(&quot;我要理财！我这里有2000万韩币&quot;); &#125; &#125;; btm3.process(); &#125;&#125;","categories":[],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/tags/设计模式/"}],"keywords":[]},{"title":"策略模式","slug":"策略模式","date":"2020-04-04T07:50:56.535Z","updated":"2020-04-04T07:16:33.975Z","comments":true,"path":"2020/04/04/策略模式/","link":"","permalink":"http://yoursite.com/2020/04/04/策略模式/","excerpt":"","text":"12345678910111213141516171819202122232425/** * 实现起来比较容易，符合一般开发人员的思路 * 假如，类型特别多，算法比较复杂时，整个条件语句的代码就变得很长，难于维护。 * 如果有新增类型，就需要频繁的修改此处的代码！ * 不符合开闭原则！ * */public class TestStrategy &#123; public double getPrice(String type, double price) &#123; if (type.equals(&quot;普通客户小批量&quot;)) &#123; System.out.println(&quot;不打折,原价&quot;); return price; &#125; else if (type.equals(&quot;普通客户大批量&quot;)) &#123; System.out.println(&quot;打九折&quot;); return price * 0.9; &#125; else if (type.equals(&quot;老客户小批量&quot;)) &#123; System.out.println(&quot;打八五折&quot;); return price * 0.85; &#125; else if (type.equals(&quot;老客户大批量&quot;)) &#123; System.out.println(&quot;打八折&quot;); return price * 0.8; &#125; return price; &#125;&#125; 123public interface Strategy &#123; public double getPrice(double standardPrice);&#125; 1234567public class OldCustomerFewStrategy implements Strategy &#123; @Override public double getPrice(double standardPrice) &#123; System.out.println(&quot;打八五折&quot;); return standardPrice*0.85; &#125;&#125; 1234567public class OldCustomerManyStrategy implements Strategy &#123; @Override public double getPrice(double standardPrice) &#123; System.out.println(&quot;打八折&quot;); return standardPrice*0.8; &#125;&#125; 1234567public class NewCustomerFewStrategy implements Strategy &#123; @Override public double getPrice(double standardPrice) &#123; System.out.println(&quot;不打折，原价&quot;); return standardPrice; &#125;&#125; 1234567public class NewCustomerManyStrategy implements Strategy &#123; @Override public double getPrice(double standardPrice) &#123; System.out.println(&quot;打九折&quot;); return standardPrice*0.9; &#125;&#125; 1234567891011121314151617181920212223/** * 负责和具体的策略类交互 * 这样的话，具体的算法和直接的客户端调用分离了，使得算法可以独立于客户端独立的变化。 * 如果使用spring的依赖注入功能，还可以通过配置文件，动态的注入不同策略对象，动态的切换不同的算法. * */public class Context &#123; private Strategy strategy; //当前采用的算法对象 //可以通过构造器来注入 public Context(Strategy strategy) &#123; super(); this.strategy = strategy; &#125; //可以通过set方法来注入 public void setStrategy(Strategy strategy) &#123; this.strategy = strategy; &#125; public void pringPrice(double s)&#123; System.out.println(&quot;您该报价：&quot;+strategy.getPrice(s)); &#125;&#125; 1234567public class Client &#123; public static void main(String[] args) &#123; Strategy s1 = new OldCustomerManyStrategy(); Context ctx = new Context(s1); ctx.pringPrice(998); &#125;&#125;","categories":[],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/tags/设计模式/"}],"keywords":[]},{"title":"访问者模式","slug":"访问者模式","date":"2020-04-04T07:50:56.533Z","updated":"2020-04-04T07:17:08.492Z","comments":true,"path":"2020/04/04/访问者模式/","link":"","permalink":"http://yoursite.com/2020/04/04/访问者模式/","excerpt":"","text":"","categories":[],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/tags/设计模式/"}],"keywords":[]},{"title":"解释器模式","slug":"解释器模式","date":"2020-04-04T07:50:56.528Z","updated":"2020-04-04T07:17:43.158Z","comments":true,"path":"2020/04/04/解释器模式/","link":"","permalink":"http://yoursite.com/2020/04/04/解释器模式/","excerpt":"","text":"","categories":[],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/tags/设计模式/"}],"keywords":[]},{"title":"命令模式","slug":"命令模式","date":"2020-04-04T07:50:56.514Z","updated":"2020-04-04T07:18:21.380Z","comments":true,"path":"2020/04/04/命令模式/","link":"","permalink":"http://yoursite.com/2020/04/04/命令模式/","excerpt":"","text":"12345678/** * 真正的命令的执行者 */public class Receiver &#123; public void action()&#123; System.out.println(&quot;Receiver.action()&quot;); &#125;&#125; 12345678910111213141516171819202122public interface Command &#123; /** * 这个方法是一个返回结果为空的方法。 * 实际项目中，可以根据需求设计多个不同的方法 */ void execute();&#125;class ConcreteCommand implements Command &#123; private Receiver receiver; //命令的真正的执行者 public ConcreteCommand(Receiver receiver) &#123; super(); this.receiver = receiver; &#125; @Override public void execute() &#123; //命令真正执行前或后，执行相关的处理！ receiver.action(); &#125;&#125; 1234567891011121314//调用者/发起者public class Invoke &#123; private Command command; //也可以通过容器List&lt;Command&gt;容纳很多命令对象，进行批处理。数据库底层的事务管理就是类似的结构！ public Invoke(Command command) &#123; super(); this.command = command; &#125; //业务方法 ，用于调用命令类的方法 public void call()&#123; command.execute(); &#125;&#125; 1234567public class Client &#123; public static void main(String[] args) &#123; Command c = new ConcreteCommand(new Receiver()); Invoke i = new Invoke(c); i.call(); &#125;&#125;","categories":[],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/tags/设计模式/"}],"keywords":[]},{"title":"代理模式","slug":"代理模式","date":"2020-04-04T07:50:56.493Z","updated":"2020-04-04T07:19:25.944Z","comments":true,"path":"2020/04/04/代理模式/","link":"","permalink":"http://yoursite.com/2020/04/04/代理模式/","excerpt":"","text":"12345678910111213141516171819202122public interface Star &#123; /** * 面谈 */ void confer(); /** * 签合同 */ void signContract(); /** * 订票 */ void bookTicket(); /** * 唱歌 */ void sing(); /** * 收钱 */ void collectMoney();&#125; 1234567891011121314151617181920212223242526public class RealStar implements Star &#123; @Override public void bookTicket() &#123; System.out.println(&quot;RealStar.bookTicket()&quot;); &#125; @Override public void collectMoney() &#123; System.out.println(&quot;RealStar.collectMoney()&quot;); &#125; @Override public void confer() &#123; System.out.println(&quot;RealStar.confer()&quot;); &#125; @Override public void signContract() &#123; System.out.println(&quot;RealStar.signContract()&quot;); &#125; @Override public void sing() &#123; System.out.println(&quot;RealStar(周杰伦本人).sing()&quot;); &#125;&#125; 123456789101112131415161718192021222324252627282930313233public class ProxyStar implements Star &#123; private Star star; public ProxyStar(Star star) &#123; super(); this.star = star; &#125; @Override public void bookTicket() &#123; System.out.println(&quot;ProxyStar.bookTicket()&quot;); &#125; @Override public void collectMoney() &#123; System.out.println(&quot;ProxyStar.collectMoney()&quot;); &#125; @Override public void confer() &#123; System.out.println(&quot;ProxyStar.confer()&quot;); &#125; @Override public void signContract() &#123; System.out.println(&quot;ProxyStar.signContract()&quot;); &#125; @Override public void sing() &#123; star.sing(); &#125;&#125; 12345678910111213public class Client &#123; public static void main(String[] args) &#123; Star real = new RealStar(); Star proxy = new ProxyStar(real); proxy.confer(); proxy.signContract(); proxy.bookTicket(); proxy.sing(); proxy.collectMoney(); &#125;&#125; 12345678910111213141516171819202122public interface Star &#123; /** * 面谈 */ void confer(); /** * 签合同 */ void signContract(); /** * 订票 */ void bookTicket(); /** * 唱歌 */ void sing(); /** * 收钱 */ void collectMoney();&#125; 1234567891011121314151617181920212223242526public class RealStar implements Star &#123; @Override public void bookTicket() &#123; System.out.println(&quot;RealStar.bookTicket()&quot;); &#125; @Override public void collectMoney() &#123; System.out.println(&quot;RealStar.collectMoney()&quot;); &#125; @Override public void confer() &#123; System.out.println(&quot;RealStar.confer()&quot;); &#125; @Override public void signContract() &#123; System.out.println(&quot;RealStar.signContract()&quot;); &#125; @Override public void sing() &#123; System.out.println(&quot;RealStar(周杰伦本人).sing()&quot;); &#125;&#125; 1234567891011121314151617181920212223242526public class StarHandler implements InvocationHandler &#123; Star realStar; public StarHandler(Star realStar) &#123; super(); this.realStar = realStar; &#125; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; Object object = null; System.out.println(&quot;真正的方法执行前！&quot;); System.out.println(&quot;面谈，签合同，预付款，订机票&quot;); if(method.getName().equals(&quot;sing&quot;))&#123; object = method.invoke(realStar, args); &#125; System.out.println(&quot;真正的方法执行后！&quot;); System.out.println(&quot;收尾款&quot;); return object; &#125;&#125; 1234567891011121314151617181920212223242526272829303132/** * 模拟动态生成的代理的结构 */public class ProxyStar implements Star &#123; StarHandler handler; public ProxyStar(StarHandler handler) &#123; super(); this.handler = handler; &#125; public void bookTicket() &#123;// handler.invoke(this,当前方法 , args); &#125; public void collectMoney() &#123;// handler.invoke(this,当前方法 , args); &#125; public void confer() &#123;// handler.invoke(this,当前方法 , args); &#125; public void signContract() &#123;// handler.invoke(this,当前方法 , args); &#125; public void sing() &#123;// handler.invoke(this,当前方法 , args); &#125;&#125; 12345678910111213public class Client &#123; public static void main(String[] args) &#123; Star realStar = new RealStar(); StarHandler handler = new StarHandler(realStar); Star proxy = (Star) Proxy.newProxyInstance(ClassLoader.getSystemClassLoader(), new Class[]&#123;Star.class&#125;, handler); proxy.sing(); &#125;&#125;","categories":[],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/tags/设计模式/"}],"keywords":[]},{"title":"单例模式","slug":"单例模式","date":"2020-04-04T07:50:56.484Z","updated":"2020-04-04T07:20:30.259Z","comments":true,"path":"2020/04/04/单例模式/","link":"","permalink":"http://yoursite.com/2020/04/04/单例模式/","excerpt":"","text":"","categories":[],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/tags/设计模式/"}],"keywords":[]},{"title":"工厂模式","slug":"工厂模式","date":"2020-04-04T07:50:56.458Z","updated":"2020-04-04T07:21:57.819Z","comments":true,"path":"2020/04/04/工厂模式/","link":"","permalink":"http://yoursite.com/2020/04/04/工厂模式/","excerpt":"","text":"123public interface Car &#123; void run();&#125; 123456public class Audi implements Car &#123; @Override public void run() &#123; System.out.println(&quot;奥迪再跑！&quot;); &#125;&#125; 123456public class Byd implements Car &#123; @Override public void run() &#123; System.out.println(&quot;比亚迪再跑！&quot;); &#125;&#125; 1234567891011public class CarFactory &#123; public static Car createCar(String type)&#123; if(&quot;奥迪&quot;.equals(type))&#123; return new Audi(); &#125;else if(&quot;比亚迪&quot;.equals(type))&#123; return new Byd(); &#125;else&#123; return null; &#125; &#125;&#125; 12345678public class CarFactory2 &#123; public static Car createAudi()&#123; return new Audi(); &#125; public static Car createByd()&#123; return new Byd(); &#125;&#125; 12345678910public class Client &#123; //调用者 public static void main(String[] args) &#123; Car c1 =CarFactory.createCar(&quot;奥迪&quot;); Car c2 = CarFactory.createCar(&quot;比亚迪&quot;); c1.run(); c2.run(); &#125;&#125; 123public interface CarFactory &#123; Car createCar();&#125; 123456public class AudiFactory implements CarFactory &#123; @Override public Car createCar() &#123; return new Audi(); &#125;&#125; 123456public class BydFactory implements CarFactory &#123; @Override public Car createCar() &#123; return new Byd(); &#125;&#125; 123456789public class Client &#123; public static void main(String[] args) &#123; Car c1 = new AudiFactory().createCar(); Car c2 = new BydFactory().createCar(); c1.run(); c2.run(); &#125;&#125; 123456789101112131415161718192021222324252627282930313233public interface Engine &#123; void run(); void start();&#125;class LuxuryEngine implements Engine&#123; @Override public void run() &#123; System.out.println(&quot;转的快！&quot;); &#125; @Override public void start() &#123; System.out.println(&quot;启动快!可以自动启停！&quot;); &#125;&#125;class LowEngine implements Engine&#123; @Override public void run() &#123; System.out.println(&quot;转的慢！&quot;); &#125; @Override public void start() &#123; System.out.println(&quot;启动慢!&quot;); &#125;&#125; 1234567891011121314151617181920public interface Seat &#123; void massage();&#125;class LuxurySeat implements Seat &#123; @Override public void massage() &#123; System.out.println(&quot;可以自动按摩！&quot;); &#125;&#125;class LowSeat implements Seat &#123; @Override public void massage() &#123; System.out.println(&quot;不能按摩！&quot;); &#125;&#125; 123456789101112131415161718192021public interface Tyre &#123; void revolve();&#125;class LuxuryTyre implements Tyre &#123; @Override public void revolve() &#123; System.out.println(&quot;旋转不磨损！&quot;); &#125;&#125;class LowTyre implements Tyre &#123; @Override public void revolve() &#123; System.out.println(&quot;旋转磨损快！&quot;); &#125;&#125; 12345public interface CarFactory &#123; Engine createEngine(); Seat createSeat(); Tyre createTyre();&#125; 1234567891011121314151617public class LowCarFactory implements CarFactory &#123; @Override public Engine createEngine() &#123; return new LowEngine(); &#125; @Override public Seat createSeat() &#123; return new LowSeat(); &#125; @Override public Tyre createTyre() &#123; return new LowTyre(); &#125;&#125; 1234567891011121314151617public class LuxuryCarFactory implements CarFactory &#123; @Override public Engine createEngine() &#123; return new LuxuryEngine(); &#125; @Override public Seat createSeat() &#123; return new LuxurySeat(); &#125; @Override public Tyre createTyre() &#123; return new LuxuryTyre(); &#125;&#125; 1234567891011public class Client &#123; public static void main(String[] args) &#123; CarFactory factory = new LuxuryCarFactory(); Engine e = factory.createEngine(); e.run(); e.start(); &#125;&#125;","categories":[],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/tags/设计模式/"}],"keywords":[]},{"title":"建造者模式","slug":"建造者模式","date":"2020-04-04T07:50:56.450Z","updated":"2020-04-04T07:22:53.546Z","comments":true,"path":"2020/04/04/建造者模式/","link":"","permalink":"http://yoursite.com/2020/04/04/建造者模式/","excerpt":"","text":"1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677public class AirShip &#123; private OrbitalModule orbitalModule; //轨道舱 private Engine engine; //发动机 private EscapeTower escapeTower; //逃逸塔 public void launch()&#123; System.out.println(&quot;发射！&quot;); &#125; public OrbitalModule getOrbitalModule() &#123; return orbitalModule; &#125; public void setOrbitalModule(OrbitalModule orbitalModule) &#123; this.orbitalModule = orbitalModule; &#125; public Engine getEngine() &#123; return engine; &#125; public void setEngine(Engine engine) &#123; this.engine = engine; &#125; public EscapeTower getEscapeTower() &#123; return escapeTower; &#125; public void setEscapeTower(EscapeTower escapeTower) &#123; this.escapeTower = escapeTower; &#125;&#125;class OrbitalModule&#123; private String name; public OrbitalModule(String name) &#123; this.name = name; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125;&#125;class Engine &#123; private String name; public Engine(String name) &#123; this.name = name; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125;&#125;class EscapeTower&#123; private String name; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public EscapeTower(String name) &#123; super(); this.name = name; &#125;&#125; 12345public interface AirShipBuilder &#123; Engine builderEngine(); OrbitalModule builderOrbitalModule(); EscapeTower builderEscapeTower();&#125; 1234567891011121314151617public class SxtAirShipBuilder implements AirShipBuilder &#123; //StringBuilder, 以后学习XML解析中，JDOM库中的类：DomBuilder,SaxBuilder @Override public Engine builderEngine() &#123; return new Engine(&quot;构建尚学堂牌发动机！&quot;); &#125; @Override public EscapeTower builderEscapeTower() &#123; return new EscapeTower(&quot;构建逃逸塔&quot;); &#125; @Override public OrbitalModule builderOrbitalModule() &#123; return new OrbitalModule(&quot;构建轨道舱&quot;); &#125;&#125; 123456789public interface AirShipDirector &#123; /** * 组装飞船对象 * @return */ AirShip directAirShip();&#125; 12345678910111213141516171819202122public class SxtAirshipDirector implements AirShipDirector &#123; private AirShipBuilder builder; public SxtAirshipDirector(AirShipBuilder builder) &#123; this.builder = builder; &#125; @Override public AirShip directAirShip() &#123; Engine e = builder.builderEngine(); OrbitalModule o = builder.builderOrbitalModule(); EscapeTower et = builder.builderEscapeTower(); //装配成飞船对象 AirShip ship = new AirShip(); ship.setEngine(e); ship.setEscapeTower(et); ship.setOrbitalModule(o); return ship; &#125;&#125; 12345678910111213public class Client &#123; public static void main(String[] args) &#123; AirShipDirector director = new SxtAirshipDirector(new SxtAirShipBuilder()); AirShip ship = director.directAirShip(); System.out.println(ship.getEngine().getName()); ship.launch(); &#125;&#125;","categories":[],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/tags/设计模式/"}],"keywords":[]},{"title":"适配器模式","slug":"适配器模式","date":"2020-04-04T07:50:56.425Z","updated":"2020-04-04T07:23:52.338Z","comments":true,"path":"2020/04/04/适配器模式/","link":"","permalink":"http://yoursite.com/2020/04/04/适配器模式/","excerpt":"","text":"12345678/** * 被适配的类 */public class Adaptee &#123; public void request()&#123; System.out.println(&quot;可以完成客户请求的需要的功能！&quot;); &#125;&#125; 123public interface Target &#123; void handleReq();&#125; 123456789/** * 适配器 (类适配器方式) */public class Adapter extends Adaptee implements Target &#123; @Override public void handleReq() &#123; super.request(); &#125;&#125; 12345678910111213141516/** * 适配器 (对象适配器方式,使用了组合的方式跟被适配对象整合) */public class Adapter2 implements Target &#123; private Adaptee adaptee; @Override public void handleReq() &#123; adaptee.request(); &#125; public Adapter2(Adaptee adaptee) &#123; super(); this.adaptee = adaptee; &#125;&#125; 123456789101112131415161718192021/** * 客户端类 */public class Client &#123; public void test1(Target t)&#123; t.handleReq(); &#125; public static void main(String[] args) &#123; Client c = new Client(); Adaptee a = new Adaptee();// Target t = new Adapter(); Target t = new Adapter2(a); c.test1(t); &#125;&#125;","categories":[],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/tags/设计模式/"}],"keywords":[]},{"title":"外观模式","slug":"外观模式","date":"2020-04-04T07:50:56.389Z","updated":"2020-04-04T07:26:44.894Z","comments":true,"path":"2020/04/04/外观模式/","link":"","permalink":"http://yoursite.com/2020/04/04/外观模式/","excerpt":"","text":"123456789101112public interface 工商局 &#123; void checkName(); //核名&#125;class 海淀区工商局 implements 工商局 &#123; @Override public void checkName() &#123; System.out.println(&quot;检查名字是否有冲突！&quot;); &#125;&#125; 1234567891011121314public interface 质检局 &#123; void orgCodeCertificate(); //办理组织机构代码证&#125;class 海淀质检局 implements 质检局 &#123; @Override public void orgCodeCertificate() &#123; System.out.println(&quot;在海淀区质检局办理组织机构代码证！&quot;); &#125;&#125; 12345678910111213public interface 银行 &#123; void openAccount(); //开户&#125;class 中国工商银行 implements 银行 &#123; @Override public void openAccount() &#123; System.out.println(&quot;在中国工商银行开户！&quot;); &#125;&#125; 12345678910111213public interface 税务局 &#123; void taxCertificate(); //办理税务登记证&#125;class 海淀税务局 implements 税务局 &#123; @Override public void taxCertificate() &#123; System.out.println(&quot;在海淀税务局办理税务登记证！&quot;); &#125;&#125; 1234567891011121314151617/** * 办理注册公司流程的门面对象 * @author Administrator * */public class RegisterFacade &#123; public void register()&#123; 工商局 a = new 海淀区工商局(); a.checkName(); 质检局 b = new 海淀质检局(); b.orgCodeCertificate(); 税务局 c = new 海淀税务局(); c.taxCertificate(); 银行 d = new 中国工商银行(); d.openAccount(); &#125;&#125; 123456789101112131415public class Client1 &#123; public static void main(String[] args) &#123;// 工商局 a = new 海淀区工商局();// a.checkName();// 质检局 b = new 海淀质检局();// b.orgCodeCertificate();// 税务局 c = new 海淀税务局();// c.taxCertificate();// 银行 d = new 中国工商银行();// d.openAccount(); new RegisterFacade().register(); &#125;&#125;","categories":[],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/tags/设计模式/"}],"keywords":[]},{"title":"享元模式","slug":"享元模式","date":"2020-04-04T07:50:56.364Z","updated":"2020-04-04T07:28:14.597Z","comments":true,"path":"2020/04/04/享元模式/","link":"","permalink":"http://yoursite.com/2020/04/04/享元模式/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536/** * 享元类 */public interface ChessFlyWeight &#123; void setColor(String c); String getColor(); void display(Coordinate c);&#125;class ConcreteChess implements ChessFlyWeight &#123; private String color; public ConcreteChess(String color) &#123; super(); this.color = color; &#125; @Override public void display(Coordinate c) &#123; System.out.println(&quot;棋子颜色：&quot;+color); System.out.println(&quot;棋子位置：&quot;+c.getX()+&quot;----&quot;+c.getY()); &#125; @Override public String getColor() &#123; return color; &#125; @Override public void setColor(String c) &#123; this.color = c; &#125;&#125; 1234567891011121314151617181920212223242526272829/** * 外部状态UnSharedConcreteFlyWeight */public class Coordinate &#123; private int x,y; public Coordinate(int x, int y) &#123; super(); this.x = x; this.y = y; &#125; public int getX() &#123; return x; &#125; public void setX(int x) &#123; this.x = x; &#125; public int getY() &#123; return y; &#125; public void setY(int y) &#123; this.y = y; &#125;&#125; 12345678910111213141516171819/** * 享元工厂类 */public class ChessFlyWeightFactory &#123; //享元池 private static Map&lt;String,ChessFlyWeight&gt; map = new HashMap&lt;String, ChessFlyWeight&gt;(); public static ChessFlyWeight getChess(String color)&#123; if(map.get(color)!=null)&#123; return map.get(color); &#125;else&#123; ChessFlyWeight cfw = new ConcreteChess(color); map.put(color, cfw); return cfw; &#125; &#125;&#125; 123456789101112public class Client &#123; public static void main(String[] args) &#123; ChessFlyWeight chess1 = ChessFlyWeightFactory.getChess(&quot;黑色&quot;); ChessFlyWeight chess2 = ChessFlyWeightFactory.getChess(&quot;黑色&quot;); System.out.println(chess1); System.out.println(chess2); System.out.println(&quot;增加外部状态的处理===========&quot;); chess1.display(new Coordinate(10, 10)); chess2.display(new Coordinate(20, 20)); &#125;&#125;","categories":[],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/tags/设计模式/"}],"keywords":[]},{"title":"组合模式","slug":"组合模式","date":"2020-04-04T07:50:56.361Z","updated":"2020-04-04T07:45:28.090Z","comments":true,"path":"2020/04/04/组合模式/","link":"","permalink":"http://yoursite.com/2020/04/04/组合模式/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778//抽象构建public interface AbstractFile &#123; void killVirus(); //杀毒&#125;class ImageFile implements AbstractFile &#123; private String name; public ImageFile(String name) &#123; super(); this.name = name; &#125; @Override public void killVirus() &#123; System.out.println(&quot;---图像文件：&quot;+name+&quot;,进行查杀！&quot;); &#125;&#125;class TextFile implements AbstractFile &#123; private String name; public TextFile(String name) &#123; super(); this.name = name; &#125; @Override public void killVirus() &#123; System.out.println(&quot;---文本文件：&quot;+name+&quot;,进行查杀！&quot;); &#125;&#125;class VideoFile implements AbstractFile &#123; private String name; public VideoFile(String name) &#123; super(); this.name = name; &#125; @Override public void killVirus() &#123; System.out.println(&quot;---视频文件：&quot;+name+&quot;,进行查杀！&quot;); &#125;&#125;class Folder implements AbstractFile &#123; private String name; //定义容器，用来存放本容器构建下的子节点 private List&lt;AbstractFile&gt; list = new ArrayList&lt;AbstractFile&gt;(); public Folder(String name) &#123; super(); this.name = name; &#125; public void add(AbstractFile file)&#123; list.add(file); &#125; public void remove(AbstractFile file)&#123; list.remove(file); &#125; public AbstractFile getChild(int index)&#123; return list.get(index); &#125; @Override public void killVirus() &#123; System.out.println(&quot;---文件夹：&quot;+name+&quot;,进行查杀&quot;); for (AbstractFile file : list) &#123; file.killVirus(); &#125; &#125;&#125; 123456789101112131415161718192021222324public class Client &#123; public static void main(String[] args) &#123; AbstractFile f2,f3,f4,f5; Folder f1 = new Folder(&quot;我的收藏&quot;); f2 = new ImageFile(&quot;老高的大头像.jpg&quot;); f3 = new TextFile(&quot;Hello.txt&quot;); f1.add(f2); f1.add(f3); Folder f11 = new Folder(&quot;电影&quot;); f4 = new VideoFile(&quot;笑傲江湖.avi&quot;); f5 = new VideoFile(&quot;神雕侠侣.avi&quot;); f11.add(f4); f11.add(f5); f1.add(f11);// f2.killVirus(); f1.killVirus(); &#125;&#125;","categories":[],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/tags/设计模式/"}],"keywords":[]},{"title":"装饰模式","slug":"装饰模式","date":"2020-04-04T07:50:56.357Z","updated":"2020-04-04T07:46:08.766Z","comments":true,"path":"2020/04/04/装饰模式/","link":"","permalink":"http://yoursite.com/2020/04/04/装饰模式/","excerpt":"","text":"12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485/** * 抽象构建 */public interface ICar &#123; void move();&#125;//ConcreteComponent 具体构件角色(真实对象)class Car implements ICar &#123; @Override public void move() &#123; System.out.println(&quot;陆地上跑！&quot;); &#125;&#125;//Decorator装饰角色class SuperCar implements ICar &#123; protected ICar car; public SuperCar(ICar car) &#123; super(); this.car = car; &#125; @Override public void move() &#123; car.move(); &#125;&#125;//ConcreteDecorator具体装饰角色class FlyCar extends SuperCar &#123; public FlyCar(ICar car) &#123; super(car); &#125; public void fly()&#123; System.out.println(&quot;天上飞！&quot;); &#125; @Override public void move() &#123; super.move(); fly(); &#125;&#125;//ConcreteDecorator具体装饰角色class WaterCar extends SuperCar &#123; public WaterCar(ICar car) &#123; super(car); &#125; public void swim()&#123; System.out.println(&quot;水上游！&quot;); &#125; @Override public void move() &#123; super.move(); swim(); &#125;&#125;//ConcreteDecorator具体装饰角色class AICar extends SuperCar &#123; public AICar(ICar car) &#123; super(car); &#125; public void autoMove()&#123; System.out.println(&quot;自动跑！&quot;); &#125; @Override public void move() &#123; super.move(); autoMove(); &#125;&#125; 12345678910111213141516171819202122public class Client &#123; public static void main(String[] args) &#123; Car car = new Car(); car.move(); System.out.println(&quot;增加新的功能，飞行----------&quot;); FlyCar flycar = new FlyCar(car); flycar.move(); System.out.println(&quot;增加新的功能，水里游---------&quot;); WaterCar waterCar = new WaterCar(car); waterCar.move(); System.out.println(&quot;增加两个新的功能，飞行，水里游-------&quot;); WaterCar waterCar2 = new WaterCar(new FlyCar(car)); waterCar2.move();// Reader r = new BufferedReader(new InputStreamReader(new FileInputStream(new File(&quot;d:/a.txt&quot;)))); &#125;&#125;","categories":[],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/tags/设计模式/"}],"keywords":[]},{"title":"中介者模式","slug":"中介者模式","date":"2020-04-04T07:50:56.354Z","updated":"2020-04-04T07:46:40.812Z","comments":true,"path":"2020/04/04/中介者模式/","link":"","permalink":"http://yoursite.com/2020/04/04/中介者模式/","excerpt":"","text":"12345//同事类的接口public interface Department &#123; void selfAction(); //做本部门的事情 void outAction(); //向总经理发出申请&#125; 1234public interface Mediator &#123; void register(String dname,Department d); void command(String dname);&#125; 123456789101112131415161718192021public class Development implements Department &#123; private Mediator m; //持有中介者(总经理)的引用 public Development(Mediator m) &#123; super(); this.m = m; m.register(&quot;development&quot;, this); &#125; @Override public void outAction() &#123; System.out.println(&quot;汇报工作！没钱了，需要资金支持！&quot;); &#125; @Override public void selfAction() &#123; System.out.println(&quot;专心科研，开发项目！&quot;); &#125;&#125; 12345678910111213141516171819public class Finacial implements Department &#123; private Mediator m; //持有中介者(总经理)的引用 public Finacial(Mediator m) &#123; super(); this.m = m; m.register(&quot;finacial&quot;, this); &#125; @Override public void outAction() &#123; System.out.println(&quot;汇报工作！没钱了，钱太多了！怎么花?&quot;); &#125; @Override public void selfAction() &#123; System.out.println(&quot;数钱！&quot;); &#125;&#125; 12345678910111213141516171819202122public class Market implements Department &#123; private Mediator m; //持有中介者(总经理)的引用 public Market(Mediator m) &#123; super(); this.m = m; m.register(&quot;market&quot;, this); &#125; @Override public void outAction() &#123; System.out.println(&quot;汇报工作！项目承接的进度，需要资金支持！&quot;); m.command(&quot;finacial&quot;); &#125; @Override public void selfAction() &#123; System.out.println(&quot;跑去接项目！&quot;); &#125;&#125; 12345678910111213public class President implements Mediator &#123; private Map&lt;String,Department&gt; map = new HashMap&lt;String , Department&gt;(); @Override public void command(String dname) &#123; map.get(dname).selfAction(); &#125; @Override public void register(String dname, Department d) &#123; map.put(dname, d); &#125;&#125; 12345678910111213public class Client &#123; public static void main(String[] args) &#123; Mediator m = new President(); Market market = new Market(m); Development devp = new Development(m); Finacial f = new Finacial(m); market.selfAction(); market.outAction(); &#125;&#125;","categories":[],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/tags/设计模式/"}],"keywords":[]},{"title":"责任链模式","slug":"责任链模式","date":"2020-04-04T07:50:56.351Z","updated":"2020-04-04T07:47:23.527Z","comments":true,"path":"2020/04/04/责任链模式/","link":"","permalink":"http://yoursite.com/2020/04/04/责任链模式/","excerpt":"","text":"12345678910111213141516171819202122232425262728293031323334/** * 封装请假的基本信息 */public class LeaveRequest &#123; private String empName; private int leaveDays; private String reason; public LeaveRequest(String empName, int leaveDays, String reason) &#123; super(); this.empName = empName; this.leaveDays = leaveDays; this.reason = reason; &#125; public String getEmpName() &#123; return empName; &#125; public void setEmpName(String empName) &#123; this.empName = empName; &#125; public int getLeaveDays() &#123; return leaveDays; &#125; public void setLeaveDays(int leaveDays) &#123; this.leaveDays = leaveDays; &#125; public String getReason() &#123; return reason; &#125; public void setReason(String reason) &#123; this.reason = reason; &#125;&#125; 123456789101112131415161718192021222324/** * 抽象类 */public abstract class Leader &#123; protected String name; protected Leader nextLeader; //责任链上的后继对象 public Leader(String name) &#123; super(); this.name = name; &#125; //设定责任链上的后继对象 public void setNextLeader(Leader nextLeader) &#123; this.nextLeader = nextLeader; &#125; /** * 处理请求的核心的业务方法 * @param request */ public abstract void handleRequest(LeaveRequest request);&#125; 1234567891011121314151617181920/** * 总经理 */public class GeneralManager extends Leader &#123; public GeneralManager(String name) &#123; super(name); &#125; @Override public void handleRequest(LeaveRequest request) &#123; if(request.getLeaveDays()&lt;30)&#123; System.out.println(&quot;员工：&quot;+request.getEmpName()+&quot;请假，天数：&quot;+request.getLeaveDays()+&quot;,理由：&quot;+request.getReason()); System.out.println(&quot;总经理：&quot;+this.name+&quot;,审批通过！&quot;); &#125;else&#123; System.out.println(&quot;莫非&quot;+request.getEmpName()+&quot;想辞职，居然请假&quot;+request.getLeaveDays()+&quot;天！&quot;); &#125; &#125;&#125; 12345678910111213141516171819202122/** * 经理 */public class Manager extends Leader &#123; public Manager(String name) &#123; super(name); &#125; @Override public void handleRequest(LeaveRequest request) &#123; if(request.getLeaveDays()&lt;10)&#123; System.out.println(&quot;员工：&quot;+request.getEmpName()+&quot;请假，天数：&quot;+request.getLeaveDays()+&quot;,理由：&quot;+request.getReason()); System.out.println(&quot;经理：&quot;+this.name+&quot;,审批通过！&quot;); &#125;else&#123; if(this.nextLeader!=null)&#123; this.nextLeader.handleRequest(request); &#125; &#125; &#125;&#125; 1234567891011121314151617181920 * 副总经理 */public class ViceGeneralManager extends Leader &#123; public ViceGeneralManager(String name) &#123; super(name); &#125; @Override public void handleRequest(LeaveRequest request) &#123; if(request.getLeaveDays()&lt;20)&#123; System.out.println(&quot;员工：&quot;+request.getEmpName()+&quot;请假，天数：&quot;+request.getLeaveDays()+&quot;,理由：&quot;+request.getReason()); System.out.println(&quot;副总经理：&quot;+this.name+&quot;,审批通过！&quot;); &#125;else&#123; if(this.nextLeader!=null)&#123; this.nextLeader.handleRequest(request); &#125; &#125; &#125;&#125; 123456789101112131415161718192021/** * 主任 */public class Director extends Leader &#123; public Director(String name) &#123; super(name); &#125; @Override public void handleRequest(LeaveRequest request) &#123; if(request.getLeaveDays()&lt;3)&#123; System.out.println(&quot;员工：&quot;+request.getEmpName()+&quot;请假，天数：&quot;+request.getLeaveDays()+&quot;,理由：&quot;+request.getReason()); System.out.println(&quot;主任：&quot;+this.name+&quot;,审批通过！&quot;); &#125;else&#123; if(this.nextLeader!=null)&#123; this.nextLeader.handleRequest(request); &#125; &#125; &#125;&#125; 1234567891011121314151617public class Client &#123; public static void main(String[] args) &#123; Leader a = new Director(&quot;张三&quot;); Leader b = new Manager(&quot;李四&quot;); Leader b2 = new ViceGeneralManager(&quot;李小四&quot;); Leader c = new GeneralManager(&quot;王五&quot;); //组织责任链对象的关系 a.setNextLeader(b); b.setNextLeader(b2); b2.setNextLeader(c); //开始请假操作 LeaveRequest req1 = new LeaveRequest(&quot;TOM&quot;, 15, &quot;回英国老家探亲！&quot;); a.handleRequest(req1); &#125;&#125;","categories":[],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/tags/设计模式/"}],"keywords":[]},{"title":"原型模式","slug":"原型模式","date":"2020-04-04T07:50:56.348Z","updated":"2020-04-04T07:48:36.644Z","comments":true,"path":"2020/04/04/原型模式/","link":"","permalink":"http://yoursite.com/2020/04/04/原型模式/","excerpt":"","text":"12345678910111213141516171819@Datapublic class Sheep implements Cloneable,Serializable &#123; //1997,英国的克隆羊，多利！ private String sname; private Date birthday; @Override protected Object clone() throws CloneNotSupportedException &#123; Object obj = super.clone(); //直接调用object对象的clone()方法！ return obj; &#125; public Sheep(String sname, Date birthday) &#123; super(); this.sname = sname; this.birthday = birthday; &#125; public Sheep() &#123;&#125;&#125; 123456789101112131415161718192021222324//测试深复制public class Sheep2 implements Cloneable &#123; //1997,英国的克隆羊，多利！ private String sname; private Date birthday; @Override protected Object clone() throws CloneNotSupportedException &#123; Object obj = super.clone(); //直接调用object对象的clone()方法！ //添加如下代码实现深复制(deep Clone) Sheep2 s = (Sheep2) obj; s.birthday = (Date) this.birthday.clone(); //把属性也进行克隆！ return obj; &#125; public Sheep2(String sname, Date birthday) &#123; super(); this.sname = sname; this.birthday = birthday; &#125; public Sheep2() &#123;&#125;&#125; 12345678910111213141516171819202122232425262728293031323334/** * 原型模式(深复制,使用序列化和反序列化的方式实现深复制) */public class Client3 &#123; public static void main(String[] args) throws CloneNotSupportedException, Exception &#123; Date date = new Date(12312321331L); Sheep s1 = new Sheep(&quot;少利&quot;,date); System.out.println(s1); System.out.println(s1.getSname()); System.out.println(s1.getBirthday());// 使用序列化和反序列化实现深复制 ByteArrayOutputStream bos = new ByteArrayOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(bos); oos.writeObject(s1); byte[] bytes = bos.toByteArray(); ByteArrayInputStream bis = new ByteArrayInputStream(bytes); ObjectInputStream ois = new ObjectInputStream(bis); Sheep s2 = (Sheep) ois.readObject(); //克隆好的对象！ System.out.println(&quot;修改原型对象的属性值&quot;); date.setTime(23432432423L); System.out.println(s1.getBirthday()); s2.setSname(&quot;多利&quot;); System.out.println(s2); System.out.println(s2.getSname()); System.out.println(s2.getBirthday()); &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950/** * 测试普通new方式创建对象和clone方式创建对象的效率差异！ * 如果需要短时间创建大量对象，并且new的过程比较耗时。则可以考虑使用原型模式！ * @author 尚学堂高淇 www.sxt.cn * */public class Client4 &#123; public static void testNew(int size)&#123; long start = System.currentTimeMillis(); for(int i=0;i&lt;size;i++)&#123; Laptop t = new Laptop(); &#125; long end = System.currentTimeMillis(); System.out.println(&quot;new的方式创建耗时：&quot;+(end-start)); &#125; public static void testClone(int size) throws CloneNotSupportedException&#123; long start = System.currentTimeMillis(); Laptop t = new Laptop(); for(int i=0;i&lt;size;i++)&#123; Laptop temp = (Laptop) t.clone(); &#125; long end = System.currentTimeMillis(); System.out.println(&quot;clone的方式创建耗时：&quot;+(end-start)); &#125; public static void main(String[] args) throws Exception &#123; testNew(1000); testClone(1000); &#125;&#125;class Laptop implements Cloneable &#123; //笔记本电脑 public Laptop() &#123; try &#123; Thread.sleep(10); //模拟创建对象耗时的过程! &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; @Override protected Object clone() throws CloneNotSupportedException &#123; Object obj = super.clone(); //直接调用object对象的clone()方法！ return obj; &#125;&#125;","categories":[],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/tags/设计模式/"}],"keywords":[]},{"title":"迭代器模式","slug":"迭代器模式","date":"2020-04-04T07:50:56.320Z","updated":"2020-04-04T07:49:17.938Z","comments":true,"path":"2020/04/04/迭代器模式/","link":"","permalink":"http://yoursite.com/2020/04/04/迭代器模式/","excerpt":"","text":"12345678910111213/** * 自定义的迭代器接口 */public interface MyIterator &#123; void first(); //将游标指向第一个元素 void next(); //将游标指向下一个元素 boolean hasNext();//判断是否存在下一个元素 boolean isFirst(); boolean isLast(); Object getCurrentObj(); //获取当前游标指向的对象&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071/** * 自定义的聚合类 */public class ConcreteMyAggregate &#123; private List&lt;Object&gt; list = new ArrayList&lt;Object&gt;(); public void addObject(Object obj)&#123; this.list.add(obj); &#125; public void removeObject(Object obj)&#123; this.list.remove(obj); &#125; public List&lt;Object&gt; getList() &#123; return list; &#125; public void setList(List&lt;Object&gt; list) &#123; this.list = list; &#125; //获得迭代器 public MyIterator createIterator()&#123; return new ConcreteIterator(); &#125; //使用内部类定义迭代器，可以直接使用外部类的属性 private class ConcreteIterator implements MyIterator &#123; private int cursor; //定义游标用于记录遍历时的位置 @Override public void first() &#123; cursor = 0; &#125; @Override public Object getCurrentObj() &#123; return list.get(cursor); &#125; @Override public boolean hasNext() &#123; if(cursor&lt;list.size())&#123; return true; &#125; return false; &#125; @Override public boolean isFirst() &#123; return cursor==0?true:false; &#125; @Override public boolean isLast() &#123; return cursor==(list.size()-1)?true:false; &#125; @Override public void next() &#123; if(cursor&lt;list.size())&#123; cursor++; &#125; &#125; &#125;&#125; 123456789101112131415public class Client &#123; public static void main(String[] args) &#123; ConcreteMyAggregate cma = new ConcreteMyAggregate(); cma.addObject(&quot;aa&quot;); cma.addObject(&quot;bb&quot;); cma.addObject(&quot;cc&quot;); MyIterator iter = cma.createIterator(); while(iter.hasNext())&#123; System.out.println(iter.getCurrentObj()); iter.next(); &#125; &#125;&#125;","categories":[],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/tags/设计模式/"}],"keywords":[]},{"title":"jdk1.8新特性","slug":"java8","date":"2020-03-12T14:22:51.254Z","updated":"2020-03-12T14:22:08.174Z","comments":true,"path":"2020/03/12/java8/","link":"","permalink":"http://yoursite.com/2020/03/12/java8/","excerpt":"","text":"HashMap结构 HashMap如果不用Hash算法、Hash表，那么每添加一个元素都要进行equals判断一次，效率很慢，HashMap默认大小为16。 jdk1.7 数组+链表 首先取对象的HashCode进行运算，生成数组的索引值，根据索引值找到位置，如果对应位置没有元素，则直接存储。如果存在元素，再通过equals比较两个对象的内容，如果内容一样，则覆盖原先的值，内容不一样，则在表头插入，形成链表。我们应该尽量减少元素的碰撞，否则效率很低，一旦出现碰撞，就得遍历整个链表的元素进行equals判断，所以HashCode和equals要尽量写得严谨些。但是，即使再严谨碰撞的情况也避免不了。所以HashMap提供了加载因子，当HashMap的大小超过75%时进行扩容，将会对元素重新运算位置，碰撞的概率也因此降低。 jdk1.8 数组+链表+红黑树 当某个链表的长度 &gt; 8 并且总元素 &gt; 64时，将会把链表转成红黑树。这样的好处是，出了添加操作，其他的操作都比链表快，而且扩容时，只需要将整棵树从新运算位置即可。同时，ConcurrentHashMap 的结构也跟着改变，也是数组+链表+红黑树的结构删除了concurrentlevel = 16,采用CAS算法，效率比锁高。 JVM内存结构 jdk1.7 存在永久区，永久区也会被垃圾回收，只是回收机制比较苛刻。 jdk1.8 没有永久区，取而代之的是MetaSpace元空间。元空间使用的是物理内存（物理内存有多大，元空间就有多大）只有当元空间的容量快满时，才会被回收。现在取决于物理内存（很大）。所以，垃圾回收机制触发的概率也低了。OOM发生的概率也低了。调优参数由以前的PremGenSize、MaxPremGenSize替换为MetaSpaceSize和MaxMetaSpaceSize 接口中的默认方法与静态方法demo1:12345public interface MyFun &#123; default String getName()&#123; return &quot;哈哈哈&quot;; &#125;&#125; 12345public class MyClass &#123; public String getName()&#123; return &quot;嘿嘿嘿&quot;; &#125;&#125; 1public class SubClass extends MyClass implements MyFun &#123;&#125; 123456public class TestDefaultInterface &#123; public static void main(String[] args) &#123; SubClass sc = new SubClass(); System.out.println(sc.getName()); //嘿嘿嘿 &#125;&#125; demo2:123456789public interface MyInterface &#123; default String getName()&#123; return &quot;呵呵呵&quot;; &#125; public static void show()&#123; System.out.println(&quot;接口中的静态方法&quot;); &#125;&#125; 123456public class SubClass /*extends MyClass*/ implements MyFun, MyInterface&#123; @Override public String getName() &#123; return MyInterface.super.getName(); &#125;&#125; 12345678public class TestDefaultInterface &#123; public static void main(String[] args) &#123; SubClass sc = new SubClass(); System.out.println(sc.getName()); //呵呵呵 MyInterface.show(); //接口中的静态方法 &#125;&#125; Stream API 的操作步骤创建 Stream：12345678910111213141516171819202122232425//创建 Stream： @Test public void test1()&#123; //1. Collection 提供了两个方法 stream() 与 parallelStream() List&lt;String&gt; list = new ArrayList&lt;&gt;(); Stream&lt;String&gt; stream = list.stream(); //获取一个顺序流 Stream&lt;String&gt; parallelStream = list.parallelStream(); //获取一个并行流 //2. 通过 Arrays 中的 stream() 获取一个数组流 Integer[] nums = new Integer[10]; Stream&lt;Integer&gt; stream1 = Arrays.stream(nums); //3. 通过 Stream 类中静态方法 of() Stream&lt;Integer&gt; stream2 = Stream.of(1,2,3,4,5,6); //4. 创建无限流 //迭代 Stream&lt;Integer&gt; stream3 = Stream.iterate(0, (x) -&gt; x + 2).limit(10); stream3.forEach(System.out::println); //生成 Stream&lt;Double&gt; stream4 = Stream.generate(Math::random).limit(2); stream4.forEach(System.out::println); &#125; 中间操作：12345678910// 初始化数据 List&lt;Employee&gt; emps = Arrays.asList( new Employee(102, &quot;李四&quot;, 59, 6666.66, Status.BUSY), new Employee(101, &quot;张三&quot;, 18, 9999.99, Status.FREE), new Employee(103, &quot;王五&quot;, 28, 3333.33, Status.VOCATION), new Employee(104, &quot;赵六&quot;, 8, 7777.77, Status.BUSY), new Employee(104, &quot;赵六&quot;, 8, 7777.77, Status.FREE), new Employee(104, &quot;赵六&quot;, 8, 7777.77, Status.FREE), new Employee(105, &quot;田七&quot;, 38, 5555.55, Status.BUSY) ); 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556/* 筛选与切片 filter——接收 Lambda ， 从流中排除某些元素。 limit——截断流，使其元素不超过给定数量。 skip(n) —— 跳过元素，返回一个扔掉了前 n 个元素的流。若流中元素不足 n 个，则返回一个空流。与 limit(n) 互补 distinct——筛选，通过流所生成元素的 hashCode() 和 equals() 去除重复元素 *///内部迭代：迭代操作 Stream API 内部完成@Testpublic void test2()&#123; //所有的中间操作不会做任何的处理 Stream&lt;Employee&gt; stream = emps.stream() .filter((e) -&gt; &#123; System.out.println(&quot;测试中间操作&quot;); return e.getAge() &lt;= 35; &#125;); //只有当做终止操作时，所有的中间操作会一次性的全部执行，称为“惰性求值” stream.forEach(System.out::println);&#125;//外部迭代@Testpublic void test3()&#123; Iterator&lt;Employee&gt; it = emps.iterator(); while(it.hasNext())&#123; System.out.println(it.next()); &#125;&#125;@Testpublic void test4()&#123; emps.stream() .filter((e) -&gt; &#123; System.out.println(&quot;短路！&quot;); // &amp;&amp; || return e.getSalary() &gt;= 5000; &#125;).limit(3) .forEach(System.out::println);&#125;@Testpublic void test5()&#123; emps.parallelStream() .filter((e) -&gt; e.getSalary() &gt;= 5000) .skip(2) .forEach(System.out::println);&#125;@Testpublic void test6()&#123; emps.stream() .distinct() .forEach(System.out::println);&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344/* 映射 map——接收 Lambda ， 将元素转换成其他形式或提取信息。接收一个函数作为参数，该函数会被应用到每个元素上，并将其映射成一个新的元素。 flatMap——接收一个函数作为参数，将流中的每个值都换成另一个流，然后把所有流连接成一个流 */@Testpublic void test1()&#123; Stream&lt;String&gt; str = emps.stream() .map((e) -&gt; e.getName()); System.out.println(&quot;-------------------------------------------&quot;); List&lt;String&gt; strList = Arrays.asList(&quot;aaa&quot;, &quot;bbb&quot;, &quot;ccc&quot;, &quot;ddd&quot;, &quot;eee&quot;); Stream&lt;String&gt; stream = strList.stream() .map(String::toUpperCase); stream.forEach(System.out::println); Stream&lt;Stream&lt;Character&gt;&gt; stream2 = strList.stream() .map(TestStreamAPI1::filterCharacter); stream2.forEach((sm) -&gt; &#123; sm.forEach(System.out::println); &#125;); System.out.println(&quot;---------------------------------------------&quot;); Stream&lt;Character&gt; stream3 = strList.stream() .flatMap(TestStreamAPI1::filterCharacter); stream3.forEach(System.out::println);&#125;public static Stream&lt;Character&gt; filterCharacter(String str)&#123; List&lt;Character&gt; list = new ArrayList&lt;&gt;(); for (Character ch : str.toCharArray()) &#123; list.add(ch); &#125; return list.stream();&#125; 12345678910111213141516171819202122/* sorted()——自然排序 sorted(Comparator com)——定制排序 */@Testpublic void test2()&#123; emps.stream() .map(Employee::getName) .sorted() .forEach(System.out::println); System.out.println(&quot;------------------------------------&quot;); emps.stream() .sorted((x, y) -&gt; &#123; if(x.getAge() == y.getAge())&#123; return x.getName().compareTo(y.getName()); &#125;else&#123; return Integer.compare(x.getAge(), y.getAge()); &#125; &#125;).forEach(System.out::println);&#125; 终止操作：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229/* allMatch——检查是否匹配所有元素 anyMatch——检查是否至少匹配一个元素 noneMatch——检查是否没有匹配的元素 findFirst——返回第一个元素 findAny——返回当前流中的任意元素 count——返回流中元素的总个数 max——返回流中最大值 min——返回流中最小值 */@Testpublic void test1()&#123; boolean bl = emps.stream() .allMatch((e) -&gt; e.getStatus().equals(Status.BUSY)); System.out.println(bl); boolean bl1 = emps.stream() .anyMatch((e) -&gt; e.getStatus().equals(Status.BUSY)); System.out.println(bl1); boolean bl2 = emps.stream() .noneMatch((e) -&gt; e.getStatus().equals(Status.BUSY)); System.out.println(bl2);&#125;@Testpublic void test2()&#123; Optional&lt;Employee&gt; op = emps.stream() .sorted((e1, e2) -&gt; Double.compare(e1.getSalary(), e2.getSalary())) .findFirst(); System.out.println(op.get()); System.out.println(&quot;--------------------------------&quot;); Optional&lt;Employee&gt; op2 = emps.parallelStream() .filter((e) -&gt; e.getStatus().equals(Status.FREE)) .findAny(); System.out.println(op2.get());&#125;@Testpublic void test3()&#123; long count = emps.stream() .filter((e) -&gt; e.getStatus().equals(Status.FREE)) .count(); System.out.println(count); Optional&lt;Double&gt; op = emps.stream() .map(Employee::getSalary) .max(Double::compare); System.out.println(op.get()); Optional&lt;Employee&gt; op2 = emps.stream() .min((e1, e2) -&gt; Double.compare(e1.getSalary(), e2.getSalary())); System.out.println(op2.get());&#125;//注意：流进行了终止操作后，不能再次使用@Testpublic void test4()&#123; Stream&lt;Employee&gt; stream = emps.stream() .filter((e) -&gt; e.getStatus().equals(Status.FREE)); long count = stream.count(); stream.map(Employee::getSalary) .max(Double::compare);&#125;/* 归约 reduce(T identity, BinaryOperator) / reduce(BinaryOperator) ——可以将流中元素反复结合起来，得到一个值。 */@Testpublic void test1()&#123; List&lt;Integer&gt; list = Arrays.asList(1,2,3,4,5,6,7,8,9,10); Integer sum = list.stream() .reduce(0, (x, y) -&gt; x + y); System.out.println(sum); System.out.println(&quot;----------------------------------------&quot;); Optional&lt;Double&gt; op = emps.stream() .map(Employee::getSalary) .reduce(Double::sum); System.out.println(op.get());&#125;//需求：搜索名字中 “六” 出现的次数@Testpublic void test2()&#123; Optional&lt;Integer&gt; sum = emps.stream() .map(Employee::getName) .flatMap(TestStreamAPI1::filterCharacter) .map((ch) -&gt; &#123; if(ch.equals(&apos;六&apos;)) return 1; else return 0; &#125;).reduce(Integer::sum); System.out.println(sum.get());&#125;//collect——将流转换为其他形式。接收一个 Collector接口的实现，用于给Stream中元素做汇总的方法@Testpublic void test3()&#123; List&lt;String&gt; list = emps.stream() .map(Employee::getName) .collect(Collectors.toList()); list.forEach(System.out::println); System.out.println(&quot;----------------------------------&quot;); Set&lt;String&gt; set = emps.stream() .map(Employee::getName) .collect(Collectors.toSet()); set.forEach(System.out::println); System.out.println(&quot;----------------------------------&quot;); HashSet&lt;String&gt; hs = emps.stream() .map(Employee::getName) .collect(Collectors.toCollection(HashSet::new)); hs.forEach(System.out::println);&#125;@Testpublic void test4()&#123; Optional&lt;Double&gt; max = emps.stream() .map(Employee::getSalary) .collect(Collectors.maxBy(Double::compare)); System.out.println(max.get()); Optional&lt;Employee&gt; op = emps.stream() .collect(Collectors.minBy((e1, e2) -&gt; Double.compare(e1.getSalary(), e2.getSalary()))); System.out.println(op.get()); Double sum = emps.stream() .collect(Collectors.summingDouble(Employee::getSalary)); System.out.println(sum); Double avg = emps.stream() .collect(Collectors.averagingDouble(Employee::getSalary)); System.out.println(avg); Long count = emps.stream() .collect(Collectors.counting()); System.out.println(count); System.out.println(&quot;--------------------------------------------&quot;); DoubleSummaryStatistics dss = emps.stream() .collect(Collectors.summarizingDouble(Employee::getSalary)); System.out.println(dss.getMax());&#125;//分组@Testpublic void test5()&#123; Map&lt;Status, List&lt;Employee&gt;&gt; map = emps.stream() .collect(Collectors.groupingBy(Employee::getStatus)); System.out.println(map);&#125;//多级分组@Testpublic void test6()&#123; Map&lt;Status, Map&lt;String, List&lt;Employee&gt;&gt;&gt; map = emps.stream() .collect(Collectors.groupingBy(Employee::getStatus, Collectors.groupingBy((e) -&gt; &#123; if(e.getAge() &gt;= 60) return &quot;老年&quot;; else if(e.getAge() &gt;= 35) return &quot;中年&quot;; else return &quot;成年&quot;; &#125;))); System.out.println(map);&#125;//分区@Testpublic void test7()&#123; Map&lt;Boolean, List&lt;Employee&gt;&gt; map = emps.stream() .collect(Collectors.partitioningBy((e) -&gt; e.getSalary() &gt;= 5000)); System.out.println(map);&#125;//@Testpublic void test8()&#123; String str = emps.stream() .map(Employee::getName) .collect(Collectors.joining(&quot;,&quot; , &quot;----&quot;, &quot;----&quot;)); System.out.println(str);&#125;@Testpublic void test9()&#123; Optional&lt;Double&gt; sum = emps.stream() .map(Employee::getSalary) .collect(Collectors.reducing(Double::sum)); System.out.println(sum.get());&#125; 时间日期操作jdk8以前时间操作线程问题：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293 class DateFormatThreadLocal &#123; private static final ThreadLocal&lt;DateFormat&gt; df = new ThreadLocal&lt;DateFormat&gt;()&#123; protected DateFormat initialValue()&#123; return new SimpleDateFormat(&quot;yyyyMMdd&quot;); &#125; &#125;; public static final Date convert(String source) throws ParseException&#123; return df.get().parse(source); &#125; &#125;public static void main(String[] args) throws Exception &#123; /*SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyyMMdd&quot;); Callable&lt;Date&gt; task = new Callable&lt;Date&gt;() &#123; @Override public Date call() throws Exception &#123; return sdf.parse(&quot;20161121&quot;); &#125; &#125;; ExecutorService pool = Executors.newFixedThreadPool(10); List&lt;Future&lt;Date&gt;&gt; results = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; 10; i++) &#123; results.add(pool.submit(task)); &#125; for (Future&lt;Date&gt; future : results) &#123; System.out.println(future.get()); &#125; pool.shutdown();*/ //解决多线程安全问题 /*Callable&lt;Date&gt; task = new Callable&lt;Date&gt;() &#123; @Override public Date call() throws Exception &#123; return DateFormatThreadLocal.convert(&quot;20161121&quot;); &#125; &#125;; ExecutorService pool = Executors.newFixedThreadPool(10); List&lt;Future&lt;Date&gt;&gt; results = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; 10; i++) &#123; results.add(pool.submit(task)); &#125; for (Future&lt;Date&gt; future : results) &#123; System.out.println(future.get()); &#125; pool.shutdown();*/ DateTimeFormatter dtf = DateTimeFormatter.ofPattern(&quot;yyyyMMdd&quot;); Callable&lt;LocalDate&gt; task = new Callable&lt;LocalDate&gt;() &#123; @Override public LocalDate call() throws Exception &#123; LocalDate ld = LocalDate.parse(&quot;20161121&quot;, dtf); return ld; &#125; &#125;; ExecutorService pool = Executors.newFixedThreadPool(10); List&lt;Future&lt;LocalDate&gt;&gt; results = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; 10; i++) &#123; results.add(pool.submit(task)); &#125; for (Future&lt;LocalDate&gt; future : results) &#123; System.out.println(future.get()); &#125; pool.shutdown();&#125; 新的时间API12345678910111213141516171819202122232425//1. LocalDate、LocalTime、LocalDateTime@Testpublic void test1()&#123; LocalDateTime ldt = LocalDateTime.now(); System.out.println(ldt); LocalDateTime ld2 = LocalDateTime.of(2016, 11, 21, 10, 10, 10); System.out.println(ld2); LocalDateTime ldt3 = ld2.plusYears(20); System.out.println(ldt3); LocalDateTime ldt4 = ld2.minusMonths(2); System.out.println(ldt4); LocalDateTime ldt5 = LocalDateTime.ofInstant(Instant.now(), ZoneId.systemDefault()); System.out.println(ldt5); System.out.println(ldt.getYear()); System.out.println(ldt.getMonthValue()); System.out.println(ldt.getDayOfMonth()); System.out.println(ldt.getHour()); System.out.println(ldt.getMinute()); System.out.println(ldt.getSecond());&#125; 12345678910111213141516171819//2. Instant : 时间戳。 （使用 Unix 元年 1970年1月1日 00:00:00 所经历的毫秒值）@Testpublic void test2()&#123; Instant ins = Instant.now(); //默认使用 UTC 时区 System.out.println(ins); OffsetDateTime odt = ins.atOffset(ZoneOffset.ofHours(8)); System.out.println(odt); System.out.println(ins.getNano()); Instant ins2 = Instant.ofEpochSecond(5); // Instant.ofEpochMilli(1471337924226L) System.out.println(ins2); // 时间戳转Date Date date = Date.from(Instant.ofEpochMilli(1471337924226L); System.out.println(date);&#125; 123456789101112131415161718192021222324252627//3.//Duration : 用于计算两个“时间”间隔//Period : 用于计算两个“日期”间隔@Testpublic void test3()&#123; Instant ins1 = Instant.now(); System.out.println(&quot;--------------------&quot;); try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; &#125; Instant ins2 = Instant.now(); System.out.println(&quot;所耗费时间为：&quot; + Duration.between(ins1, ins2)); System.out.println(&quot;----------------------------------&quot;); LocalDate ld1 = LocalDate.now(); LocalDate ld2 = LocalDate.of(2011, 1, 1); Period pe = Period.between(ld2, ld1); System.out.println(pe.getYears()); System.out.println(pe.getMonths()); System.out.println(pe.getDays());&#125; 123456789101112131415161718192021222324252627282930//4. TemporalAdjuster : 时间校正器@Testpublic void test4()&#123;LocalDateTime ldt = LocalDateTime.now(); System.out.println(ldt); LocalDateTime ldt2 = ldt.withDayOfMonth(10); System.out.println(ldt2); LocalDateTime ldt3 = ldt.with(TemporalAdjusters.next(DayOfWeek.SUNDAY)); System.out.println(ldt3); //自定义：下一个工作日 LocalDateTime ldt5 = ldt.with((l) -&gt; &#123; LocalDateTime ldt4 = (LocalDateTime) l; DayOfWeek dow = ldt4.getDayOfWeek(); if(dow.equals(DayOfWeek.FRIDAY))&#123; return ldt4.plusDays(3); &#125;else if(dow.equals(DayOfWeek.SATURDAY))&#123; return ldt4.plusDays(2); &#125;else&#123; return ldt4.plusDays(1); &#125; &#125;); System.out.println(ldt5);&#125; 123456789101112131415 //5. DateTimeFormatter : 解析和格式化日期或时间 @Test public void test5()&#123;// DateTimeFormatter dtf = DateTimeFormatter.ISO_LOCAL_DATE; DateTimeFormatter dtf = DateTimeFormatter.ofPattern(&quot;yyyy年MM月dd日 HH:mm:ss E&quot;); LocalDateTime ldt = LocalDateTime.now(); String strDate = ldt.format(dtf); System.out.println(strDate); LocalDateTime newLdt = ldt.parse(strDate, dtf); System.out.println(newLdt); &#125; 123456789101112131415161718//6.ZonedDate、ZonedTime、ZonedDateTime ： 带时区的时间或日期********@Testpublic void test7()&#123; LocalDateTime ldt = LocalDateTime.now(ZoneId.of(&quot;Asia/Shanghai&quot;)); System.out.println(ldt); ZonedDateTime zdt = ZonedDateTime.now(ZoneId.of(&quot;US/Pacific&quot;)); System.out.println(zdt);&#125;@Testpublic void test6()&#123; Set&lt;String&gt; set = ZoneId.getAvailableZoneIds(); set.forEach(System.out::println); ZoneId defaultZone = ZoneId.systemDefault(); System.out.println(defaultZone);&#125; Optional类1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889/* * 一、Optional 容器类：用于尽量避免空指针异常 * Optional.of(T t) : 创建一个 Optional 实例 * Optional.empty() : 创建一个空的 Optional 实例 * Optional.ofNullable(T t):若 t 不为 null,创建 Optional 实例,否则创建空实例 * isPresent() : 判断是否包含值 * orElse(T t) : 如果调用对象包含值，返回该值，否则返回t * orElseGet(Supplier s) :如果调用对象包含值，返回该值，否则返回 s 获取的值 * map(Function f): 如果有值对其处理，并返回处理后的Optional，否则返回 Optional.empty() * flatMap(Function mapper):与 map 类似，要求返回值必须是Optional */ @Test public void test1()&#123; Optional&lt;Employee&gt; op = Optional.of(new Employee()); Employee emp = op.get(); System.out.println(emp); &#125; @Test public void test2()&#123; /*Optional&lt;Employee&gt; op = Optional.ofNullable(null); System.out.println(op.get());*/// Optional&lt;Employee&gt; op = Optional.empty();// System.out.println(op.get()); &#125; @Test public void test3()&#123; Optional&lt;Employee&gt; op = Optional.ofNullable(new Employee()); if(op.isPresent())&#123; System.out.println(op.get()); &#125; Employee emp = op.orElse(new Employee(&quot;张三&quot;)); System.out.println(emp); Employee emp2 = op.orElseGet(() -&gt; new Employee()); System.out.println(emp2); &#125; @Test public void test4()&#123; Optional&lt;Employee&gt; op = Optional.of(new Employee(101, &quot;张三&quot;, 18, 9999.99)); Optional&lt;String&gt; op2 = op.map(Employee::getName); System.out.println(op2.get()); Optional&lt;String&gt; op3 = op.flatMap((e) -&gt; Optional.of(e.getName())); System.out.println(op3.get()); &#125; //需求：获取一个男人心中女神的名字 public String getGodnessName(Man man)&#123; if(man != null)&#123; Godness g = man.getGod(); if(g != null)&#123; return g.getName(); &#125; &#125; return &quot;苍老师&quot;; &#125; public String getGodnessName2(Optional&lt;NewMan&gt; man)&#123; return man.orElse(new NewMan()) .getGodness() .orElse(new Godness(&quot;苍老师&quot;)) .getName(); &#125; @Test public void test5()&#123; Man man = new Man(); String name = getGodnessName(man); System.out.println(name); &#125; //运用 Optional 的实体类 @Test public void test6()&#123; Optional&lt;Godness&gt; godness = Optional.ofNullable(new Godness(&quot;林志玲&quot;)); Optional&lt;NewMan&gt; op = Optional.ofNullable(new NewMan(godness)); String name = getGodnessName2(op); System.out.println(name); &#125;","categories":[],"tags":[{"name":"java8","slug":"java8","permalink":"http://yoursite.com/tags/java8/"}],"keywords":[]},{"title":"Google Guava常用操作","slug":"Google Guava常用操作","date":"2020-03-12T14:19:53.651Z","updated":"2020-03-12T07:26:48.266Z","comments":true,"path":"2020/03/12/Google Guava常用操作/","link":"","permalink":"http://yoursite.com/2020/03/12/Google Guava常用操作/","excerpt":"","text":"Maps.newHashMap()1234// 原生和使用Maps.newHashMap()唯一的区别就是简化代码，一个需要你手动加泛型，一个不需要你手动加// jdk 1.8 之后已经不用加泛型了Map&lt;String, Object&gt; result = new HashMap&lt;String,Object&gt;();Map&lt;String, Object&gt; result = Maps.newHashMap(); Joiner 和 Splitter12Map&lt;String, String&gt; join = Splitter.on(&quot;&amp;&quot;).withKeyValueSeparator(&quot;=&quot;).split(&quot;id=1&amp;name=lcs&quot;);String split = Joiner.on(&quot;&amp;&quot;).withKeyValueSeparator(&quot;=&quot;).join(join); 1234// skipNulls会过滤掉空的参数，包括数组中的null值。Joiner.on(&quot;|&quot;).skipNulls().join(stringList);// usefornull会以参数替换空的参数，包括数组中的null值。Joiner.on(&quot;|&quot;).useForNull(&quot;no value&quot;).join(stringList); 12// join参数可以很复杂String result = Joiner.on(&quot;_&quot;).join(&quot;user_common_count&quot;, &quot;name&quot;, new Object[]&#123;&quot;nick&quot;,&quot;adidas&quot;,10000&#125;) MD5加密123456789101112public class HashUtils &#123; private static final HashFunction FUNCTION = Hashing.md5(); private static final String SALT = &quot;abcd&quot;; public static String encryPassword(String password)&#123; HashCode hashCode = FUNCTION.hashString(password + SALT, Charset.forName(&quot;UTF-8&quot;)); return hashCode.toString(); &#125;&#125; 参考：https://www.tinymind.net.cn/articles/6e6def50718372参考：https://ifeve.com/google-guava-hashing/ Cache123456789private final Cache&lt;String, String&gt; cache = CacheBuilder.newBuilder().maximumSize(100).expireAfterAccess(15, TimeUnit.MINUTES) .removalListener(new RemovalListener&lt;String, String&gt;() &#123; @Override public void onRemoval(RemovalNotification&lt;String, String&gt; notification) &#123; ... &#125; &#125;).build();","categories":[],"tags":[{"name":"Google Guava","slug":"Google-Guava","permalink":"http://yoursite.com/tags/Google-Guava/"}],"keywords":[]},{"title":"kapacitor lambda","slug":"kapacitor_lambda","date":"2020-03-12T13:40:28.033Z","updated":"2019-09-16T09:40:06.994Z","comments":true,"path":"2020/03/12/kapacitor_lambda/","link":"","permalink":"http://yoursite.com/2020/03/12/kapacitor_lambda/","excerpt":"","text":"lambda使用简单使用：123|where(lambda: &quot;tag&quot; == &apos;v1&apos; AND &quot;field&quot; == &apos;v2&apos;)|eval(lambda: (&quot;field1&quot; - &quot;field2&quot;) / &quot;field3&quot; * 100.0)|eval(lambda: float(&quot;field1&quot;) / float(&quot;field2&quot;) * 100.0) 保留两位小数：1|eval(lambda: float(int(&quot;field&quot; * 100.0)) / 100.0) // 保留两位小数 整数转成小数：1|eval(lambda:(&quot;field1&quot; + &quot;field2&quot;) / 2.0)","categories":[],"tags":[{"name":"kapacitor","slug":"kapacitor","permalink":"http://yoursite.com/tags/kapacitor/"}],"keywords":[]},{"title":"同一时间只允许一个客户端操作前端界面","slug":"同一时间只允许一个客户端操作前端界面","date":"2020-03-12T13:33:21.384Z","updated":"2020-03-12T13:32:36.496Z","comments":true,"path":"2020/03/12/同一时间只允许一个客户端操作前端界面/","link":"","permalink":"http://yoursite.com/2020/03/12/同一时间只允许一个客户端操作前端界面/","excerpt":"","text":"设计：123后端使用Guava cache存储一个key，来作为锁，每个用户拥有一个锁，如果10分钟没有对cache进行写操作，则过期失效用户操作前端界面时，会请求后端获取锁（如果cache的size &lt; 1，说明此时没人正在操作，系统给用户分配锁，否则返回null），如果用户拿到锁，则可以操作前端界面，否则无法操作用户在前端操作完后需要后需要请求后端，释放自己分配到的锁 防止用户长时间占用界面导致其它用户无法使用：1用户在前端操作时，启用定时器2分钟后禁用操作，并请求后端释放自己分配到的锁 后端：123456789101112131415161718192021222324252627282930313233343536373839404142434445@Service@Slf4jpublic class CacheService &#123; /** * 缓存，限制人数为1，设置10分钟没有写操作则过期 */ private final Cache&lt;String, Boolean&gt; cache = CacheBuilder.newBuilder().maximumSize(1).expireAfterWrite(10, TimeUnit.MINUTES).build(); /** * 释放锁 * @param key */ public void releaseLock(String key) &#123; if (key != null) &#123; log.debug(&quot;==========释放前 cache 大小 =&#123;&#125; ==========&quot;, cache.size()); log.debug(&quot;========== cache key =&#123;&#125; ==========&quot;, cache.asMap().keySet()); log.debug(&quot;========== key =&#123;&#125; ==========&quot;, key); cache.invalidate(key); log.debug(&quot;==========释放后 cache 大小 =&#123;&#125; ==========&quot;, cache.size()); &#125; &#125; /** * 获取锁 * @return */ public String getLock() &#123; log.debug(&quot;========== cache 大小 =&#123;&#125; ==========&quot;, cache.size()); if (cache.size() &lt; 1) &#123; // 没被占用，生成id，锁住，并返回 String key = UUIDGenerateUtil.getNextId(); cache.put(key, true); log.debug(&quot;========== 生成 key =&#123;&#125; ==========&quot;, key); log.debug(&quot;========== 返回 key =&#123;&#125; ==========&quot;, key); return key; &#125; else &#123; log.debug(&quot;========== cache key =&#123;&#125; ==========&quot;, cache.asMap().keySet()); log.debug(&quot;========== 返回 key =&#123;&#125; ==========&quot;, &quot;null&quot;); return null; &#125; &#125;&#125; 1234567891011121314@Servicepublic class XService &#123; @Autowired private CacheService cacheService; /** *如果某些业务操作会导致前端的操作结束，需要将对应锁释放 */ @Transactional public void operate(String key) &#123; ... cacheService.releaseLock(key); &#125;&#125; 123456789101112131415161718192021222324252627282930@RestController@RequestMapping(&quot;/X&quot;)public class XController &#123; @Autowired private CacheService cacheService; @Autowired private XService xService; @GetMapping(&quot;/edit/flag&quot;) @ApiOperation(value=&quot;查询是否可以操作&quot;) public ResponseDTO&lt;String&gt; getEditFlag()&#123; return ResponseDTO.ok(cacheService.getLock()); &#125; @PostMapping(&quot;/edit/flag&quot;) @ApiOperation(value=&quot;操作完成后处理&quot;) public ResponseDTO&lt;Integer&gt; removeEditFlag(@ApiParam(value=&quot;操作时分配的key&quot;) String key)&#123; cacheService.releaseLock(key); return ResponseDTO.ok(); &#125; @PutMapping @ApiOperation(value=&quot;业务操作&quot;) public ResponseDTO&lt;Integer&gt; operate(String key)&#123; xService.operate(key); return ResponseDTO.ok(); &#125;&#125; 前端：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667/** * ts */export default class XComponent extends Vue &#123; key = null as any; delay = 120000; timer = null as any; initEvent(f: any) &#123; const w = window as any; w.onload = f; w.onscroll = f; w.onresize = f; w.onclick = f; w.onmouseup = f; w.onmousemove = f; w.onmousedown = f; w.onkeydown = f; w.onkeypress = f; w.onkeyup = f; &#125; isActive(e: any) &#123; //console.log(&apos;活跃&apos;); if (this.timer) &#123; clearTimeout(this.timer); &#125; if (this.key) &#123; this.timer = setTimeout((t: any) =&gt; &#123; //过期需要把key置空并向后台发请求释放锁 //console.log(&apos;超过2分钟没操作&apos;); //console.log(&apos;释放key %o&apos;, this.key); this.closeForm(); &#125;, this.delay); &#125; &#125; closeForm() &#123; //console.log(&apos;关闭操作窗口释放key %o&apos;, this.key); clearTimeout(this.timer); this.initEvent(null); this.$http.post(`.../X/edit/flag?key=$&#123;this.key ? this.key : &apos;&apos;&#125;`).then(res =&gt; &#123; if (res.data.code === &apos;10000000&apos;) &#123; this.key = null; //console.log(&apos;释放完key %o&apos;, this.key); &#125; &#125;); &#125; // 生命构造时 created() &#123; this.initEvent(this.isActive); //console.log(&apos;开始操作&apos;); this.$http.get(`.../X/edit/flag`).then(res =&gt; &#123; if (res.data.code === &apos;10000000&apos;) &#123; this.key = res.data.data; //console.log(&apos;获取key %o&apos;, this.key); &#125; &#125;); &#125; // 生命销毁时 destroyed() &#123; this.closeForm(); &#125;&#125; 12345678910/** * html */&lt;div&gt; ... &lt;q-btn label=&quot;提交&quot; type=&quot;submit&quot; :disable=&quot;key == null&quot; color=&quot;primary&quot; /&gt;&lt;/div&gt;","categories":[],"tags":[{"name":"业务场景","slug":"业务场景","permalink":"http://yoursite.com/tags/业务场景/"}],"keywords":[]},{"title":"idea常用设置","slug":"idea常用设置","date":"2020-03-12T13:33:13.111Z","updated":"2020-03-12T13:32:46.025Z","comments":true,"path":"2020/03/12/idea常用设置/","link":"","permalink":"http://yoursite.com/2020/03/12/idea常用设置/","excerpt":"","text":"修改编码UTF8设置maven设置打开的文件栏多行显示1settings—Editor—General—Editor Tabs—取消勾选Show tabs in one row 切换风格1settings—Appearance &amp; Behavior—Appearance—Theme—点击切换 设置护眼1settings—Editor—Color Scheme—General—Text—Default text—点击&quot;Background&quot;所对应的颜色框—R: 199, G:237, B:204 切换字体1settings—Editor—Font—选择 source code pro 自动删除类中无用的import包1settings—Editor—General—Auto Import—勾选Optimize imports on the fly 代码提示区分大小写1settings—Editor—General—Code Completion—取消勾选Match case","categories":[],"tags":[{"name":"idea","slug":"idea","permalink":"http://yoursite.com/tags/idea/"}],"keywords":[]},{"title":"java按汉字首字母排序","slug":"java按汉字首字母排序","date":"2020-02-08T12:53:07.541Z","updated":"2020-02-08T12:51:42.287Z","comments":true,"path":"2020/02/08/java按汉字首字母排序/","link":"","permalink":"http://yoursite.com/2020/02/08/java按汉字首字母排序/","excerpt":"","text":"123456List&lt;String&gt; list = Arrays.asList( new String[]&#123;&quot;中山&quot;,&quot;汕头&quot;,&quot;广州&quot;,&quot;安庆&quot;,&quot;阳江&quot;,&quot;南京&quot;,&quot;武汉&quot;,&quot;北京&quot;,&quot;安阳&quot;,&quot;北方&quot;&#125;);list = list.stream() .sorted(Collator.getInstance(Locale.CHINA)) .collect(Collectors.toList()); 12345678910111213141516171819public class Main &#123; public static void main(String[] args) &#123; List&lt;Address&gt; list = Arrays.asList(new Address[]&#123;new Address(&quot;中山&quot;), new Address(&quot;汕头&quot;), new Address(&quot;广州&quot;)&#125;); list = list.stream().sorted(Comparator.comparing(o-&gt;Collator.getInstance(Locale.CHINA).getCollationKey(o.getName()))).collect(Collectors.toList()); &#125; private static class Address &#123; public String id; public String name; public Address(String name) &#123; this.name = name; &#125; public String getName() &#123; return this.name; &#125; &#125;&#125;","categories":[],"tags":[{"name":"java8","slug":"java8","permalink":"http://yoursite.com/tags/java8/"}],"keywords":[]},{"title":"Chrome使用Restlet Client-REST API","slug":"Chrome使用Restlet Client-REST API","date":"2020-02-08T12:12:00.119Z","updated":"2020-02-08T12:11:26.315Z","comments":true,"path":"2020/02/08/Chrome使用Restlet Client-REST API/","link":"","permalink":"http://yoursite.com/2020/02/08/Chrome使用Restlet Client-REST API/","excerpt":"","text":"参考：https://chrome.google.com/webstore/detail/talend-api-tester-free-ed/aejoelaoggembcahagimdiliamlcdmfm?hl=en-US","categories":[],"tags":[{"name":"Chrome","slug":"Chrome","permalink":"http://yoursite.com/tags/Chrome/"}],"keywords":[]},{"title":"Spring Security技术栈开发企业级认证与授权-开始开发","slug":"Spring Security技术栈开发企业级认证与授权-开始开发","date":"2020-02-01T02:16:02.074Z","updated":"2020-02-01T02:13:27.509Z","comments":true,"path":"2020/02/01/Spring Security技术栈开发企业级认证与授权-开始开发/","link":"","permalink":"http://yoursite.com/2020/02/01/Spring Security技术栈开发企业级认证与授权-开始开发/","excerpt":"","text":"1.架构介绍security：主模块security-core: 核心业务逻辑（子模块）security-browser: 浏览器安全特定代码（子模块）security-app: app相关特定代码（子模块）security-demo: 样例程序（子模块）1234567891011 security security-core ↑ -------------- | |security-browser security-app ↑ ↑ -------------- | security-demo security pom.xml：123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;properties&gt; &lt;security.version&gt;1.0.0-SNAPSHOT&lt;/security.version&gt;&lt;/properties&gt;&lt;dependencyManagement&gt; &lt;!--管理版本、依赖--&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;io.spring.platform&lt;/groupId&gt; &lt;artifactId&gt;platform-bom&lt;/artifactId&gt; &lt;version&gt;Brussels-SR4&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;Dalston.SR2&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/dependencyManagement&gt;&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;version&gt;2.3.2&lt;/version&gt; &lt;configuration&gt; &lt;source&gt;1.8&lt;/source&gt; &lt;target&gt;1.8&lt;/target&gt; &lt;encoding&gt;UTF-8&lt;/encoding&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt;&lt;modules&gt; &lt;module&gt;../security-app&lt;/module&gt; &lt;module&gt;../security-browser&lt;/module&gt; &lt;module&gt;../security-core&lt;/module&gt; &lt;module&gt;../security-demo&lt;/module&gt;&lt;/modules&gt; security-core pom.xml：12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-oauth2&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.social&lt;/groupId&gt; &lt;artifactId&gt;spring-social-config&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.social&lt;/groupId&gt; &lt;artifactId&gt;spring-social-core&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.social&lt;/groupId&gt; &lt;artifactId&gt;spring-social-security&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.social&lt;/groupId&gt; &lt;artifactId&gt;spring-social-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;commons-lang&lt;/groupId&gt; &lt;artifactId&gt;commons-lang&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;commons-collections&lt;/groupId&gt; &lt;artifactId&gt;commons-collections&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;commons-beanutils&lt;/groupId&gt; &lt;artifactId&gt;commons-beanutils&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt; security-app pom.xml：1234567&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;com.security&lt;/groupId&gt; &lt;artifactId&gt;security-core&lt;/artifactId&gt; &lt;version&gt;$&#123;security.version&#125;&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; security-browser pom.xml：123456789101112&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;com.security&lt;/groupId&gt; &lt;artifactId&gt;security-core&lt;/artifactId&gt; &lt;version&gt;$&#123;security.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.session&lt;/groupId&gt; &lt;artifactId&gt;spring-session&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt; security-demo pom.xml：123456789101112&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;com.security&lt;/groupId&gt; &lt;artifactId&gt;security-browser&lt;/artifactId&gt; &lt;version&gt;$&#123;security.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 2.Hello Spring Securitysecurity-demo application.properties：12345678910spring.datasource.driver-class-name = com.mysql.jdbc.Driverspring.datasource.url= jdbc:mysql://127.0.0.1:3306/demo?useUnicode=yes&amp;characterEncoding=UTF-8&amp;useSSL=falsespring.datasource.username = rootspring.datasource.password = 123456spring.session.store-type = none#security.basic.enabled = falseserver.port = 8060","categories":[],"tags":[{"name":"Spring Security","slug":"Spring-Security","permalink":"http://yoursite.com/tags/Spring-Security/"}],"keywords":[]},{"title":"Google Map集成","slug":"googel_map集成","date":"2019-12-28T15:01:54.201Z","updated":"2019-12-28T14:59:58.585Z","comments":true,"path":"2019/12/28/googel_map集成/","link":"","permalink":"http://yoursite.com/2019/12/28/googel_map集成/","excerpt":"","text":"Get an API Key12参考：https://developers.google.cn/maps/documentation/javascript/get-api-key DemogoogleMap.html:123456789101112131415161718192021222324252627282930313233&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;Simple Map&lt;/title&gt; &lt;meta name=&quot;viewport&quot; content=&quot;initial-scale=1.0&quot;&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;style&gt; #map &#123; height: 100%; &#125; html, body &#123; height: 100%; margin: 0; padding: 0; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;map&quot;&gt;&lt;/div&gt; &lt;script&gt; var map; function initMap() &#123; map = new google.maps.Map(document.getElementById(&apos;map&apos;), &#123; center: &#123;lat: -34.397, lng: 150.644&#125;, zoom: 8 &#125;); &#125; &lt;/script&gt; &lt;!-- 将YOUR_API_KEY替换成可用的API Key --&gt; &lt;script src=&quot;https://maps.googleapis.com/maps/api/js?key=YOUR_API_KEY&amp;callback=initMap&quot; async defer&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; Vue集成Google MapGet an API Key1参考上述操作 Typescript版本集成1.安装依赖1npm install vue2-google-maps 2.googleMap.ts代码12345678910import Vue from &apos;vue&apos;import * as VueGoogleMaps from &apos;vue2-google-maps&apos;Vue.use(VueGoogleMaps, &#123; load: &#123; key: &apos;YOUR_API_TOKEN&apos;,// 替换成可用的API Key libraries: &apos;places&apos;, &#125;, installComponents: true&#125;) 错误：12Could not find a declaration file for module &apos;vue2-google-maps&apos;.... 解决：创建vue2-google-maps.d.ts,并添加以下内容12345678910declare module &apos;vue2-google-maps&apos; &#123; //如果Vue.use报错则加入以下两行 import &#123; PluginFunction &#125; from &quot;vue&quot;; export const install: PluginFunction&lt;&#123;&#125;&gt;; // 将下列url返回的内容添加在这里 // https://raw.githubusercontent.com/DefinitelyTyped/DefinitelyTyped/master/types/googlemaps/index.d.ts&#125; 参考：https://github.com/xkjyeah/vue-google-maps/issues/560 3.googleMap.html1234567&lt;GmapMap :center=&quot;&#123;lat:10, lng:10&#125;&quot; :zoom=&quot;7&quot; map-type-id=&quot;terrain&quot; style=&quot;width: 500px; height: 300px&quot;&gt;&lt;/GmapMap&gt; 错误：如果是单页面应用则不会出现以下错误12345error .../node_modules/vue2-google-maps/dist/components/infoWindow.vue:3^SyntaxError: Unexpected token &lt;... 解决：需要将ssr相关配置关闭，不同框架修改不同，本人是使用Quasar框架需修改以下配置package.json1234567&#123; ... &quot;scripts&quot;: &#123; &quot;serve&quot;: &quot;quasar dev -m ssr&quot; // 将ssr修改为spa ... &#125;,&#125; quasar.conf.js123456module.exports = function () &#123; return &#123; ... preFetch: true // 修改为false &#125;&#125; Typescript版本集成(服务端渲染)1.googleMap.ts代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354...mounted() &#123; this.loadAMapJS().then(result =&gt; &#123; if (result) &#123; //刷新地图初始化 this.initialize(); &#125; &#125;);&#125;loadAMapJS() &#123; return new Promise((resolve, reject) =&gt; &#123; // 替换成可用的API Key this.asyncLoadJs(&apos;https://maps.googleapis.com/maps/api/js?key=YOUR_API_KEY&apos;) .then((result) =&gt; &#123; resolve(result) &#125;) .catch(err =&gt; &#123; reject(err) &#125;) &#125;)&#125;asyncLoadJs(url: any) &#123; return new Promise((resolve, reject) =&gt; &#123; const hasLoaded = document.getElementById(&quot;googleMapScript&quot;); if (hasLoaded) &#123; resolve(true) return &#125; const script = document.createElement(&apos;script&apos;) script.type = &apos;text/javascript&apos; script.id = &quot;googleMapScript&quot; script.src = url document.body.appendChild(script) script.onload = () =&gt; &#123; resolve(true) &#125; script.onerror = () =&gt; &#123; reject(false) &#125; &#125;)&#125;//初始化地圖initialize() &#123; this.centerDot = new google.maps.LatLng(22.2041179884, 113.557519102); const options = &#123; zoom: 12, center: this.centerDot, // 設定地圖中心點 mapTypeId: google.maps.MapTypeId.ROADMAP // HYBRID,ROADMAP,SATELLITE,TERRAIN &#125;; this.map = new google.maps.Map(document.getElementById(&quot;map&quot;), options);&#125; 错误：有可能会出现1Cannot find name &apos;google&apos; 解决：1declare let google: any; 2.googleMap.html1&lt;div id=&quot;map&quot; style=&quot;height: 600px; width: 1000px;&quot;&gt;&lt;/div&gt; 界面问题1.出现此页面无法正确加载Google地图。的弹窗12限制密钥在Google云平台的[应用限制]里我们对密钥使用进行限制，只允许特定的地址使用密钥，这样可以防止我们的配额泄露或被窃取。 2.出现For development purposes only的覆盖层123正常使用API Key需要开通结算账户在Google云平台的[导航菜单]-[结算]中关联结算账户，注意需要信用卡验证身份，支持VISA、运通、JCB、MasterCard，暂不支持银联。验证身份时会先扣除一美元，验证成功后会返还。","categories":[],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/tags/Vue/"}],"keywords":[]},{"title":"树形结构业务模型实践","slug":"树形结构业务模型","date":"2019-12-28T15:01:53.396Z","updated":"2020-03-12T13:58:27.997Z","comments":true,"path":"2019/12/28/树形结构业务模型/","link":"","permalink":"http://yoursite.com/2019/12/28/树形结构业务模型/","excerpt":"","text":"数据库表结构TREE表：12345678910ID P_CODE CODE NAME1 null 001 1级12 null 002 1级23 null 003 1级34 001 001001 2级15 002 002001 2级26 002 002002 2级37 003 003001 2级48 003001 003001001 3级19 003001001 003001001001 4级1 MybatistreeMapper.xml：12345&lt;mapper ...&gt; &lt;select id=&quot;list&quot; ...&gt; SELECT * FROM TREE &lt;/select&gt;&lt;/mapper&gt; JavaNode:1234567891011public class Node &#123; private Long id; private String pCode; private String code; private String name; private List&lt;Node&gt; children;&#125; TreeMapper：123public interface TreeMapper &#123; List&lt;Node&gt; list();&#125; TreeService:123456789101112131415161718192021222324252627282930313233343536@Servicepublic class TreeService &#123; @Autowired private TreeMapper treeMapper; public List&lt;Node&gt; getTree() &#123; List&lt;Node&gt; list = treeMapper.list(); return getFatherNode(list); &#125; private List&lt;Node&gt; getFatherNode(List&lt;Node&gt; treesList) &#123; List&lt;Node&gt; newTrees = new ArrayList&lt;&gt;(); for (Node node : treesList) &#123; if (StringUtils.isEmpty(node.getPCode())) &#123;//如果pCode为空，则该节点为父节点 //递归获取父节点下的子节点 node.setChildren(getChildrenNode(node.getCode(), treesList)); newTrees.add(node); &#125; &#125; return newTrees; &#125; private List&lt;Node&gt; getChildrenNode(String pCode, List&lt;Node&gt; treesList) &#123; List&lt;Node&gt; newTrees = new ArrayList&lt;&gt;(); for (Node node : treesList) &#123; if (StringUtils.isEmpty(node.getPCode())) continue; if (node.getPCode().equals(pCode)) &#123; //递归获取子节点下的子节点，即设置树控件中的children node.setChildren(getChildrenNode(node.getCode(), treesList)); newTrees.add(node); &#125; &#125; return newTrees; &#125;&#125; 参考：https://www.cnblogs.com/WHqingwei/p/5852657.html","categories":[],"tags":[{"name":"业务场景","slug":"业务场景","permalink":"http://yoursite.com/tags/业务场景/"}],"keywords":[]},{"title":"面向对象","slug":"面向对象","date":"2019-09-10T07:34:04.678Z","updated":"2019-09-10T07:32:01.789Z","comments":true,"path":"2019/09/10/面向对象/","link":"","permalink":"http://yoursite.com/2019/09/10/面向对象/","excerpt":"","text":"匿名对象·匿名对象：就是没有名字的对象。 是对象的一种简化表示形式·匿名对象的两种使用情况 对象调用方法仅仅一次的时候 作为实际参数传递 1234567891011121314151617181920212223class Student &#123; public void show() &#123; System.out.println(“show”); &#125;&#125;class StudentDemo &#123; //如果参数是一个类名，那么实际需要的是一个具体的对象 public void method(Student s) &#123; s.show(); &#125;&#125;class StudentTest &#123; public static void main(String[] args) &#123; StudentDemo sd = new StudentDemo(); Student s = new Student(); sd.method(s); //多个匿名对象的写法 new StudentDemo.method(new Student()); &#125;&#125; this关键字·this:代表所在类的对象引用·记住：·方法被哪个对象调用，this就代表那个对象 什么时候使用this呢? 局部变量隐藏成员变量 其他用法后面和super一起讲解 static关键字·可以修饰成员变量和成员方法·static关键字特点 随着类的加载而加载 优先于对象存在 被类的所有对象共享 这也是我们判断是否使用静态关键字的条件 可以通过类名调用·static关键字注意事项 在静态方法中是没有this关键字的 静态方法只能访问静态的成员变量和静态的成员方法 代码块在Java中，使用{}括起来的代码被称为代码块，根据其位置和声明的不同，可以分为局部代码块，构造代码块，静态代码块，同步代码块(多线程讲解)。·局部代码块 在方法中出现；限定变量生命周期，及早释放，提高内存利用率·构造代码块 在类中方法外出现；多个构造方法方法中相同的代码存放到一起，每次调用 构造都执行，并且在构造方法前执行·静态代码块 在类中方法外出现，加了static修饰 在类中方法外出现，并加上static修饰；用于给类进行初始化，在加载的时 候就执行，并且值执行一次。 执行顺序静态代码块&gt;构造代码块&gt;构造方法 1234567891011static &#123; System.out.println(“静态代码块”);&#125;&#123; System.out.println(“构造代码块”);&#125;public Student() &#123; System.out.println(“构造方法”);&#125; 面试题：12345678910111213141516171819202122class Student&#123; static&#123; System.out.print(&quot;Student 静态代码块&quot;); &#125; &#123; System.out.print(&quot;Student 构造代码块&quot;); &#125; public student()&#123; System.out.print(&quot;Student 构造方法&quot;); &#125;&#125;class StudentDemo &#123; static&#123; System.out.print(&quot;林青霞都60了，我很伤心&quot;); &#125; public static void main(String[] args)&#123; System.out.print(&quot;我是main方法&quot;); student s1 = new Student(); student s2 = new Student(); &#125;&#125; 结果:1234567林青霞都60了，我很伤心我是main方法Student 静态代码块Student 构造代码块Student 构造方法Student 构造代码块Student 构造方法 继承中成员变量的关系·在子类方法中访问一个变量 首先在子类局部范围找 然后在子类成员范围找 最后在父类成员范围找(肯定不能访问到父类局部范围) 如果还是没有就报错。(不考虑父亲的父亲…) 如果我要访问父类的成员变量该怎么办呢?通过回想this来引入super关键字 继承中成员方法的关系·通过子类对象去访问一个方法 首先在子类中找 然后在父类中找 如果还是没有就报错。(不考虑父亲的父亲…) 如果我要访问父类的成员方法该怎么办呢?回想刚才提过的super关键字·方法重写的注意事项 父类中私有方法不能被重写 子类重写父类方法时，访问权限不能更低 父类静态方法，子类也必须通过静态方法进行重写。 继承中构造方法的关系·每一个构造方法的第一条语句默认都是：super()·如何父类中没有构造方法，该怎么办呢? 子类通过super去显示调用父类其他的带参的构造方法 子类通过this去调用本类的其他构造方法，本类其他构造也必须首先访问了父类构造·一定要注意： super(…)或者this(….)必须出现在第一条语句山 面试题:1234567891011121314151617181920212223242526272829class Fu &#123; static &#123; System.out.println(&quot;静态代码块Fu&quot;); &#125; &#123; System.out.println(&quot;构造代码块Fu&quot;); &#125; public Fu() &#123; System.out.println(&quot;构造方法Fu&quot;); &#125;&#125;class Zi extends Fu &#123; static &#123; System.out.println(&quot;静态代码块Zi&quot;); &#125; &#123; System.out.println(&quot;构造代码块Zi&quot;); &#125; public Zi() &#123; System.out.println(&quot;构造方法Zi&quot;); &#125;&#125;Zi z = new Zi(); A:静态随着类的加载而加载。B:静态代码块 – 构造代码块 – 构造方法的执行流程 静态代码块 – 构造代码块 – 构造方法C:只要有子父关系，肯定先初始化父亲的数据，然后初始化子类的数据。 结果：123456静态代码块Fu静态代码块Zi构造代码块Fu构造方法Fu构造代码块Zi构造方法Zi 面试题:1234567891011121314151617181920class X &#123; Y b = new Y(); X() &#123; System.out.print(&quot;X&quot;); &#125;&#125;class Y &#123; Y() &#123; System.out.print(&quot;Y&quot;); &#125;&#125;public class Z extends X &#123; Y y = new Y(); Z() &#123; System.out.print(&quot;Z&quot;); &#125; public static void main(String[] args) &#123; new Z(); &#125;&#125; 结果：YXYZ 第一个：成员变量有基本类型和引用类型的。1234class Demo &#123; int x = 10;//基本类型 Student s = new Student();//引用类型&#125; 第二个：类的初始化过程123456加载class文件堆中开辟空间变量的默认初始化变量的显示初始化构造代码块初始化构造方法初始化 第三个：遇到extends，就要知道，先初始化父类数据，然后初始化子类数据。分层初始化。 多态·成员访问特点 成员变量：编译看左边，运行看左边·成员方法：编译看左边，运行看右边·静态方法：编译看左边，运行看左边（所以前面我说静态方法不能算方法的重写） 面试题：12345678910111213141516171819202122232425262728293031323334class A&#123; public void show()&#123; show2(); &#125; public void show2()&#123; System.out.println(&quot;我&quot;); &#125;&#125;class B extends A &#123; public void show2()&#123; System.out.println(“爱”); &#125;&#125;class C extends B &#123; public void show()&#123; super.show(); &#125; public void show2()&#123; System.out.println(&quot;你&quot;); &#125;&#125; public class Test&#123; public static void main(String[] args) &#123; A a = new B(); a.show(); B b = new C(); b.show(); &#125;&#125; 结果：爱 你 多态中的转型问题·向上转型·向下转型 12345678910111213141516171819202122232425262728293031323334class Animal&#123; public void eat()&#123;..&#125;&#125;class Dog extends Animal&#123; public void eat()&#123;..&#125; public void lookdoor()&#123;..&#125;&#125;class Cat extends Animal&#123; public void eat()&#123;..&#125; public void playgame()&#123;..&#125;&#125;class AnimalDemo&#123; public static void main(String[] args)&#123; Animal a=new Dog(); a.eat(); a.lookdoor();//报错 Dog d=(Dog)a; d.eat(); d.lookdoor(); a=new Cat(); a.eat(); a.playgame();//报错 Cat c=(Cat)a; c.eat(); c.playgame(); Dog dd=(Dog)a;//报错 &#125;&#125; 抽象类的几个小问题·abstract不能和哪些关键字共存 private 冲突 final 冲突 static 无意义 抽象类和接口的区别·成员区别 抽象类 变量,常量;有构造方法;抽象方法,非抽象方法 接口 常量(默认public static final);抽象方法(默认public abstract)·关系区别 类与类 继承，单继承 类与接口 实现，单实现，多实现 接口与接口 继承，单继承，多继承·设计理念区别 抽象类 被继承体现的是：”is a”的关系。共性功能 接口 被实现体现的是：”like a”的关系。扩展功能 内部类位置·成员位置(成员内部类)·成员内部的常见修饰符 private：为了保证数据的安全性 static ：为了让数据访问更方便 成员内部类不是静态的：外部类名.内部类名 对象名 = new 外部类名.new 内部类名();成员内部类是静态的：外部类名.内部类名 对象名 = new 外部类名.内部类名(); 非静态的成员内部类，成员只能是非静态的被静态修饰的成员内部类只能访问外部类的静态成员被静态修饰的成员内部类中的方法有静态和非静态之分访问非静态方法：外部类名.内部类名 对象名 = new 外部类名.内部类名();访问静态方法： 上面创建的对象访问，或者外部类名.内部类名.方法名(); 面试题：123456789101112131415161718192021class Outer &#123; public int num = 10; class Inner &#123; public int num = 20; public void show() &#123; int num = 30; System.out.println(num); System.out.println(this.num); System.out.println(Outer.this.num); &#125; &#125;&#125;class OuterDemo &#123; public static void main(String[] args) &#123; Outer.Inner oi = new Outer().new Inner(); oi.show(); &#125;&#125; ·局部位置(局部内部类)·可以创建内部类对象，通过对象调用内部类方法，来使用局部内部类功能·局部内部类访问局部变量的注意事项： 必须被final修饰? 为什么呢?(因为局部变量会随着方法的调用完毕而消失，这个时候，局部对象并没有立马从堆内存中消失，还要使用那个变量。为了让数据还能继续被使用，就用fianl修饰，这样，在堆内存里面存储的其实是一个常量值。通过反编译工具可以看一下。) 1234567891011121314151617181920class Outer &#123; public void method() &#123; final int n = 100; class Inner &#123; public void show() &#123; System.out.println(n); &#125; &#125; Inner i = new Inner(); i.show(); &#125;&#125;class OuterDemo &#123; public static void main(String[] args) &#123; Outer o = new Outer(); o.method(); &#125;&#125; 匿名内部类·就是内部类的简化写法。·前提：存在一个类或者接口 这里的类可以是具体类也可以是抽象类。·格式： new 类名或者接口名() {重写方法;}·本质： 是一个继承了类或者实现了接口的子类匿名对象 123456789101112131415161718192021abstract class Person &#123; public abstract void show();&#125;class PersonDemo &#123; public void method(Person p) &#123; s.show(); &#125;&#125;class PersonTest &#123; public static void main(String[] args) &#123; //如何调用PersonDemo中的method方法呢? PersonDemo pd = new PersonDemo (); pd.method(new Person() &#123; public void show() &#123; System.out.println(“show”); &#125; &#125;); &#125;&#125; 面试题：按照要求，补齐代码12345678910111213141516171819 interface Inter &#123; void show(); &#125; class Outer &#123; //补齐代码 &#125; class OuterDemo &#123; public static void main(String[] args) &#123; Outer.method().show(); &#125; &#125;要求在控制台输出”HelloWorld”答案：class Outer &#123; //补齐代码 public static Inter method() &#123; return new Inter() &#123; public void show() &#123; System.out.println(&quot;HelloWorld&quot;); &#125; &#125;; &#125;&#125;","categories":[],"tags":[{"name":"java基础","slug":"java基础","permalink":"http://yoursite.com/tags/java基础/"}],"keywords":[]},{"title":"集合","slug":"集合","date":"2019-09-07T02:23:08.950Z","updated":"2019-09-05T05:31:25.202Z","comments":true,"path":"2019/09/07/集合/","link":"","permalink":"http://yoursite.com/2019/09/07/集合/","excerpt":"","text":"集合和数组的区别?123456789A:长度区别 数组固定 集合可变B:内容区别 数组可以是基本类型，也可以是引用类型 集合只能是引用类型C:元素内容 数组只能存储同一种类型 集合可以存储不同类型(其实集合一般存储的也是同一种类型) 集合的继承体系结构12345678910由于需求不同，Java就提供了不同的集合类。这多个集合类的数据结构不同，但是它们都是要提供存储和遍历功能的，我们把它们的共性不断的向上提取，最终就形成了集合的继承体系结构图。 Collection |--List |--ArrayList |--Vector |--LinkedList |--Set |--HashSet |--TreeSet Collection接口1234567891011121314151617181920212223242526Collection 层次结构中的根接口。Collection 表示一组对象，这些对象也称为 collection 的元素。一些 collection 允许有重复的元素，而另一些则不允许。一些 collection 是有序的，而另一些则是无序的。Collection接口成员方法 A:添加功能 boolean add(E e) boolean addAll(collection c) B:删除功能 boolean remove(Object o) boolean removeAll(collection c)只要有一个元素被删除就返回true void clear() C:判断功能 boolean contains(Object o) boolean containsAll(Collection c)只有包含所有的元素才叫包含 D:获取功能 boolean isEmpty() E:长度功能 int size() F:交集 boolean retainAll(Collection c) 假设有两个集合A,B A对B做交集，最终的结果保存在A中，B不变 返回值表示的是A是否发生改变 H:Collection集合的遍历 A:把集合转数组 Object[] toArray() B:迭代器(集合专用方式) Iterator iterator() Iterator接口123456789对 collection 进行迭代的迭代器 A:是集合的获取元素的方式。 B:是依赖于集合而存在的。 C:迭代器的原理和源码。 a:为什么定义为了一个接口而不是实现类? b:看了看迭代器的内部类实现。Iterator接口成员方法boolean hasNext()如果还有元素可以迭代，则返回trueE next() 获取元素，并返回到下一个位置 List接口1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374(1)List是Collection的子接口 特点：有序(存储顺序和取出顺序一致)，可重复。(2)List的特有功能：(自己补齐) A:添加功能 void add(int index,E element) B:删除功能 E remove(int index) C:获取功能 E get(int index) D:迭代器功能 ListIterator listIterator() E:修改功能 E set(int index,E element)(3)List集合的特有遍历功能 A:由size()和get()结合。 B:代码演示 //创建集合对象 List list = new ArrayList(); //创建并添加元素 list.add(&quot;hello&quot;); list.add(&quot;world&quot;); list.add(&quot;java&quot;); //遍历集合 Iterator it = list.iterator(); while(it.hasNext()) &#123; String s =(String) it.next(); System.out.println(s); &#125; System.out.println(&quot;----------&quot;); for(int x=0; x&lt;list.size(); x++) &#123; String s =(String) list.get(x); System.out.println(s); &#125;(4)ListIterator接口的成员方法boolean hasPrevious()E previous() 可以逆向遍历，但是要先正向遍历，所以无意义，基本不使用。（5)并发修改异常ConcurrentModificationException当方法检测到对象的并发修改，但不允许这种修改时，抛出此异常 A:出现的现象 迭代器遍历集合，集合修改集合元素 B:原因 迭代器是依赖于集合的，而集合的改变迭代器并不知道。 C:解决方案 a:迭代器遍历，迭代器修改(ListIterator) 元素添加在刚才迭代的位置 b:集合遍历，集合修改(size()和get()) 元素添加在集合的末尾(6)常见数据结构 A:栈 先进后出 B:队列 先进先出 C:数组 查询快，增删慢 D:链表 查询慢，增删快(7)List的子类特点(面试题) ArrayList 底层数据结构是数组，查询快，增删慢。 线程不安全，效率高。 Vector 底层数据结构是数组，查询快，增删慢。 线程安全，效率低。 LinkedList 底层数据结构是链表，查询慢，增删快。 线程不安全，效率高。 到底使用谁呢?看需求? 分析： 要安全吗? 要：Vector(即使要，也不使用这个，后面再说) 不要：ArrayList或者LinkedList 查询多；ArrayList 增删多：LinkedList 什么都不知道，就用ArrayList。 Vector:1234Vector类特有功能public void addElement(E obj) -- add()public E elementAt(int index) -- get()public E numeration elements() -- iterator() LinkedList:1234LinkedList类特有功能public void addFirst(E e) 及 addLast(E e)public E getFirst() 及 getLast()public E removeFirst() 及 public E removeLast() 泛型泛型类格式:public class 类名&lt;泛型类型1,…&gt;注意:泛型类型必须是引用类型1234567891011121314151617181920212223242526272829303132/* * 泛型类：把泛型定义在类上 */public class ObjectTool&lt;T&gt; &#123; private T obj; public T getObj() &#123; return obj; &#125; public void setObj(T obj) &#123; this.obj = obj; &#125;&#125;/* * 泛型类的测试 */public class ObjectToolDemo &#123; public static void main(String[] args) &#123; ObjectTool&lt;String&gt; ot = new ObjectTool&lt;String&gt;(); ot.setObj(new String(&quot;林青霞&quot;)); String s = ot.getObj(); System.out.println(&quot;姓名是：&quot; + s); ObjectTool&lt;Integer&gt; ot2 = new ObjectTool&lt;Integer&gt;(); ot2.setObj(new Integer(27)); Integer i = ot2.getObj(); System.out.println(&quot;年龄是：&quot; + i); &#125;&#125; 泛型方法格式:public &lt;泛型类型&gt; 返回类型 方法名(泛型类型 .)1234567891011121314151617/* * 泛型方法：把泛型定义在方法上 */public class ObjectTool &#123; public &lt;T&gt; void show(T t) &#123; System.out.println(t); &#125;&#125;public class ObjectToolDemo &#123; public static void main(String[] args) &#123; ObjectTool ot = new ObjectTool(); ot.show(&quot;hello&quot;); ot.show(100); ot.show(true); &#125;&#125; 泛型接口格式:public interface 接口名&lt;泛型类型1…&gt;12345678910111213141516171819202122232425/* * 泛型接口：把泛型定义在接口上 */public interface Inter&lt;T&gt; &#123; public abstract void show(T t);&#125;public class InterImpl&lt;T&gt; implements Inter&lt;T&gt; &#123; @Override public void show(T t) &#123; System.out.println(t); &#125;&#125;public class InterDemo &#123; public static void main(String[] args) &#123; Inter&lt;String&gt; i = new InterImpl&lt;String&gt;(); i.show(&quot;hello&quot;); Inter&lt;Integer&gt; ii = new InterImpl&lt;Integer&gt;(); ii.show(100); &#125;&#125; 泛型高级(通配符)泛型通配符&lt;?&gt;任意类型，如果没有明确，那么就是Object以及任意的Java类了? extends E向下限定，E及其子类? super E向上限定，E及其父类123456789101112131415161718192021class Animal &#123;&#125;class Dog extends Animal &#123;&#125;class Cat extends Animal &#123;&#125;public class CollectionDemo &#123; public static void main(String[] args) &#123; Collection&lt;?&gt; c1 = new ArrayList&lt;Animal&gt;(); Collection&lt;?&gt; c2 = new ArrayList&lt;Dog&gt;(); Collection&lt;?&gt; c3 = new ArrayList&lt;Cat&gt;(); Collection&lt;?&gt; c4 = new ArrayList&lt;Object&gt;(); Collection&lt;? extends Animal&gt; c5 = new ArrayList&lt;Animal&gt;(); Collection&lt;? extends Animal&gt; c6 = new ArrayList&lt;Dog&gt;(); Collection&lt;? extends Animal&gt; c7 = new ArrayList&lt;Cat&gt;(); // Collection&lt;? extends Animal&gt; c8 = new ArrayList&lt;Object&gt;(); Collection&lt;? super Animal&gt; c9 = new ArrayList&lt;Animal&gt;(); // Collection&lt;? super Animal&gt; c10 = new ArrayList&lt;Dog&gt;(); // Collection&lt;? super Animal&gt; c11 = new ArrayList&lt;Cat&gt;(); Collection&lt;? super Animal&gt; c12 = new ArrayList&lt;Object&gt;(); &#125;&#125;","categories":[],"tags":[{"name":"java基础","slug":"java基础","permalink":"http://yoursite.com/tags/java基础/"}],"keywords":[]},{"title":"多线程3","slug":"多线程3","date":"2019-09-07T02:23:08.947Z","updated":"2019-09-07T02:19:36.164Z","comments":true,"path":"2019/09/07/多线程3/","link":"","permalink":"http://yoursite.com/2019/09/07/多线程3/","excerpt":"","text":"java并发包介绍12JDK5.0 以后的版本都引入了高级并发特性，大多数的特性在java.util.concurrent 包中，是专门用于多线程发编程的，充分利用了现代多处理器和多核心系统的功能以编写大规模并发应用程序。主要包含原子量、并发集合、同步器、可重入锁，并对线程池的构造提供了强力的支持。 线程池1、Single Thread Executor : 只有一个线程的线程池，因此所有提交的任务是顺序执行，Executors.newSingleThreadExecutor() 2、Cached Thread Pool : 线程池里有很多线程需要同时执行，老的可用线程将被新的任务触发重新执行，如果线程超过60秒内没执行，那么将被终止并从池中删除，Executors.newCachedThreadPool() 3、Fixed Thread Pool : 拥有固定线程数的线程池，如果没有任务执行，那么线程会一直等待，Executors.newFixedThreadPool(4)在构造函数中的参数4是线程池的大小，你可以随意设置，也可以和cpu的数量保持一致，获取cpu的数量int cpuNums = Runtime.getRuntime().availableProcessors(); 4、Scheduled Thread Pool : 用来调度即将执行的任务的线程池，Executors.newScheduledThreadPool() 5、Single Thread Scheduled Pool : 只有一个线程，用来调度执行将来的任务，Executors.newSingleThreadScheduledExecutor() 123456789101112131415161718192021222324import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;import java.util.concurrent.ScheduledExecutorService;/** * 列出并发包中的各种线程池 * */public class ExecutorDemo &#123; public static void main(String[] args) &#123; ExecutorService newSingleThreadExecutor = Executors.newSingleThreadExecutor(); ExecutorService newCachedThreadPool = Executors.newCachedThreadPool(); int cpuNums = Runtime.getRuntime().availableProcessors(); System.out.println(cpuNums); ExecutorService newFixedThreadPool = Executors.newFixedThreadPool(cpuNums); ScheduledExecutorService newScheduledThreadPool = Executors.newScheduledThreadPool(8); ScheduledExecutorService newSingleThreadScheduledExecutor = Executors.newSingleThreadScheduledExecutor(); &#125;&#125; 提交 Runnable ，任务完成后 Future 对象返回 null12345678910111213141516171819202122232425262728import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;public class ThreadPoolWithRunable &#123; /** * 通过线程池执行线程 * @param args */ public static void main(String[] args) &#123; //创建一个线程池 ExecutorService pool = Executors.newCachedThreadPool(); for(int i = 1; i &lt; 5; i++)&#123; pool.execute(new Runnable() &#123; @Override public void run() &#123; System.out.println(&quot;thread name: &quot; + Thread.currentThread().getName()); try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;); &#125; pool.shutdown(); &#125;&#125; 提交 Callable，该方法返回一个 Future 实例表示任务的状态12345678910111213141516171819202122232425262728293031323334import java.util.ArrayList;import java.util.List;import java.util.concurrent.Callable;import java.util.concurrent.ExecutionException;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;import java.util.concurrent.Future;/** * callable 跟runnable的区别： * runnable的run方法不会有任何返回结果，所以主线程无法获得任务线程的返回值 * * callable的call方法可以返回结果，但是主线程在获取时是被阻塞，需要等待任务线程返回才能拿到结果 * */public class ThreadPoolWithcallable &#123; public static void main(String[] args) throws InterruptedException, ExecutionException &#123; ExecutorService pool = Executors.newFixedThreadPool(4); for(int i = 0; i &lt; 10; i++)&#123; Future&lt;String&gt; submit = pool.submit(new Callable&lt;String&gt;()&#123; @Override public String call() throws Exception &#123; //System.out.println(&quot;a&quot;); Thread.sleep(5000); return &quot;b--&quot;+Thread.currentThread().getName(); &#125; &#125;); //从Future中get结果，这个方法是会被阻塞的，一直要等到线程任务返回结果 System.out.println(submit.get()); &#125; pool.shutdown(); &#125;&#125; 1234567891011121314151617181920212223242526272829import java.util.Random;import java.util.concurrent.Callable;public class TaskCallable implements Callable&lt;String&gt;&#123; private int s; Random r = new Random(); public TaskCallable(int s)&#123; this.s = s; &#125; @Override public String call() throws Exception &#123; String name = Thread.currentThread().getName(); long currentTimeMillis = System.currentTimeMillis(); System.out.println(name+&quot; 启动时间：&quot; + currentTimeMillis/1000); int rint = r.nextInt(3); try &#123; Thread.sleep(rint*1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(name + &quot; is working...&quot;+s); return s+&quot;&quot;; &#125;&#125; 12345678910111213141516171819202122232425262728import java.util.Random;public class TaskRunnable implements Runnable&#123; private int s; public TaskRunnable(int s)&#123; this.s = s; &#125; Random r = new Random(); @Override public void run() &#123; String name = Thread.currentThread().getName(); long currentTimeMillis = System.currentTimeMillis(); System.out.println(name+&quot; 启动时间：&quot; + currentTimeMillis/1000); int rint = r.nextInt(3); try &#123; Thread.sleep(rint*1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(name + &quot; is working...&quot;+s); &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647import java.util.ArrayList;import java.util.HashMap;import java.util.Random;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;import java.util.concurrent.Future;import java.util.concurrent.ScheduledExecutorService;import java.util.concurrent.TimeUnit;public class TestPool &#123; public static void main(String[] args) throws Exception &#123; Future&lt;?&gt; submit = null; Random random = new Random(); //创建固定数量线程池// ExecutorService exec = Executors.newFixedThreadPool(4); //创建调度线程池 ScheduledExecutorService exec = Executors.newScheduledThreadPool(4); //用来记录各线程的返回结果 ArrayList&lt;Future&lt;?&gt;&gt; results = new ArrayList&lt;Future&lt;?&gt;&gt;(); for (int i = 0; i &lt; 10; i++) &#123; //fixedPool提交线程，runnable无返回值，callable有返回值 /*submit = exec.submit(new TaskRunnable(i));*/ /*submit = exec.submit(new TaskCallable(i));*/ //对于schedulerPool来说，调用submit提交任务时，跟普通pool效果一致 /*submit = exec.submit(new TaskCallable(i));*/ //对于schedulerPool来说，调用schedule提交任务时，则可按延迟，按间隔时长来调度线程的运行 submit = exec.schedule(new TaskCallable(i), random.nextInt(10), TimeUnit.SECONDS); //存储线程执行结果 results.add(submit); &#125; //打印结果 for(Future f: results)&#123; boolean done = f.isDone(); System.out.println(done?&quot;已完成&quot;:&quot;未完成&quot;); //从结果的打印顺序可以看到，即使未完成，也会阻塞等待 System.out.println(&quot;线程返回future结果： &quot; + f.get()); &#125; exec.shutdown(); &#125;&#125; 同步容器类同步类容器都是线程安全的,但在某些场景下可能需要加锁来保护复合操作,复合类操作如选代(反复访问元素,遍历完容器中所有的元素)、跳转(根据指定的顺序找到当前元素的下一个元素)、以及条件运算,这些复合操作在多线程并发地修改容器时,可能会表现出意外的行为,最经典的便是ConcurrengModificationException,原因是当容器迭代的过程中,被井发的修改了内容,这是由于早期达代器设计的时候并没有考虑并发修改的问题。同步类容器:如古老的Vector, Hash Table.这些容器的同步功能其实是在JDK的Collections.synchronized**等工厂方法去创建实现的,其底层的机制无非就是用传统的synchronized关键字对每个公用的方法都进行同步,使得每次只能有一个线程访问容器的状态,这很明显不满足我们今天互联网时代高并发的需求,在保证线程安全的同时,他必续要有足够好的性能 并发类容器jak5.0以后提供了多种并发类容器来替代同步类容器从而改善性能.同步类容器的状态都是串行化的,他们虽然实现了线程安全,但是严重降低了并发性,在多线程环境时,严重降低了应用程序的吞吐量。并发类容器是专门针对并发设计的,使用ConcurrentHashMap来代替给子散列的传统的HashTable,而且在ConcurrentHashMap中,添加了一些常见复合操作的支持,以及使用了CopyOnWriteArrayList代替Voctor,并发的CopyonWriteArraySet,以及并发的Queue, ConcurrentLinkedQueue和LinkedBlockingQueue,前者是高性能的队列,后者是以阻塞形式的队列,具体实现Queue还有很多,例如ArrayBlockingQueue.PriorityBlockingQueue. Synchronous Queue等 ConcurrntMap:ConcurrentMap接口下有俩个重要的实现ConcurrentHashapConcurentSkipListMap (支持并发排序功能,弥补ConcurrentHashMap)ConcurrentHashMap内部使用段(Segmen)未表示这些不同的部分,每个段其实就是一个小的Hash Table,它们有自己的锁.只要多个修改操作发生在不同的段上,它们就可以并发进行,把一个整体分成了16个段(Segment).也就是最高支持16个线程的并发修改操作,这也是在多线程场景时减小锁的粒度从面降低锁竞争的一种方案。并且代码中大多共享变量使用volatile关键字声明,目的是第一时间获取修改的内容,性能非常好. Copy-On-Write容器:Copy-on-Write简称cow,是种用于程序设计中的优化策略。JDK里的CoW容器有两种: CopyOnWriteArrayList和CopyOnWriteArraySet,Cow容器非常有用,可以在非常多的并发场景中使用到什么是CopyOnWrite容器?CopyOnWrite容器即写时复制的容器,通俗的理解是当我们往一个容器添加元素的时候,不直接往当前容器添加,而是先将当前容器进行Copy,复制出一个新的容器,然后新的容器里添加元素,添加完元素之后,再将原容器的引用指向新的容器。这样放的好处是我们可以对CopyOnWrite容器进行并发的读,而不需要加锁,因为当前容器不会添加任何元素,所以CopyOnWrite容器也是一种读写分离的思想,读和写不同的容器。 并发Queue在并发队列上JDK提供了两套实现,一个是以ConcurrentLinkedQueue为代表的高性能队列,一个是以BlockingQueue接口为代表的阻塞队列,无论哪种都维承自Queue ConcurrentLinkedQueue:ConcurrentLinkedQueue:是一个适用于高并发场景下的队列,通过无锁的方式,实现了高并发状态下的高性能,通常ConcurrentLinkedQueue性能好于BlockingQueue.它是一个基于链接节点的无界线程安全队列,该队列的元素遵循先进先出的原则,头是最先加入的,尾是最近加入的,该队列不允许null元素。ConcurrentLinkedQueue重要方法:add()和 ofter()都是加入元素的方法(在ConcurrentLinkedaueue中,这两个方法没有任何区别)pol()和peek()都是取头元素节点,区别在于前者会删除元素,后者不会. ClockingQueue接口:ArrayBlockingQueue:基于数组的阻塞队列实现,在ArrayBlockingQueue内部,维护了一个定长数组,以便缓存队列中的数据对象,其内部没实现读写分离,也就意味着生产和消费不能完全并行,长度是需要定义的,可以指定先进先出或者先进后出,也叫有界队列,在很多场合非常适合使用.LinkedBlockingQueue:基于链表的阻塞队列,同ArrayBlockingQueue类似,其内部也维持着一个数据缓冲队列(该队列由一个链表构成) , LinkedBlockingQueue之所以能够高效的处理并发数据,是因为其内部实现采用分离锁(读写分离两个锁) ,从而实现生产者和消费者操作的完全并行运行。他是一个无界队列。SynchronousQueue :一种没有缓冲的队列,生产者产生的数据直接会被消费者获取并消费。PriorityBlockingQueue:基于优先级的阻塞队列(优先级的判断通过构造函数传入的Compator对象来决定,也就是说传入队列的对象必须实现Comparable接口) ,在实现PriorityBlockingQueue时,内部控制线程同步的锁采用的是公平锁,他也是一个无界的队列。DelayQueue:带有延迟时间的Queue,其中的元素只有当其指定的延迟时间到了,才能够从队列中获取到该元素. Delayqueue中的元素必须实现Delayed接口, Delayqueue是一个没有大小限制的队列,应用场景很多,比如对缓存超时的数据进行移除、任务超时处理、空闲连接的关闭等等. 生产消费模型应用:客户端服务器端数据传输，可能我们没有使用什么消息中间件，通过直连的手段，比如tcp, netty等。客服端与服务器直连进行数据传输，我们发现使用netty一般都会与队列结合使用，可能有一个客户端每秒发送10条数据到服务器端，但是处理的速度与生产的步伐不一致，服务器每秒只能消费1条。如果我们用netty,在业务高峰期，把这10条数据直接放到队列中，但是要有限制，使用有界队列，防止服务器内存溢出，非高峰期，用一些无界队列。或者有些在不同时间段使用不同类型队列。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081import java.util.concurrent.SynchronousQueue;public class UseQueue &#123; public static void main(String[] args) throws Exception &#123; //高性能无阻塞无界队列：ConcurrentLinkedQueue /** ConcurrentLinkedQueue&lt;String&gt; q = new ConcurrentLinkedQueue&lt;String&gt;(); q.offer(&quot;a&quot;); q.offer(&quot;b&quot;); q.offer(&quot;c&quot;); q.offer(&quot;d&quot;); q.add(&quot;e&quot;); System.out.println(q.poll()); //a 从头部取出元素，并从队列里删除 System.out.println(q.size()); //4 System.out.println(q.peek()); //b System.out.println(q.size()); //4 */ /** ArrayBlockingQueue&lt;String&gt; array = new ArrayBlockingQueue&lt;String&gt;(5); array.put(&quot;a&quot;); array.put(&quot;b&quot;); array.add(&quot;c&quot;); array.add(&quot;d&quot;); array.add(&quot;e&quot;); array.add(&quot;f&quot;); //System.out.println(array.offer(&quot;a&quot;, 3, TimeUnit.SECONDS)); */ /** //阻塞队列 LinkedBlockingQueue&lt;String&gt; q = new LinkedBlockingQueue&lt;String&gt;(); q.offer(&quot;a&quot;); q.offer(&quot;b&quot;); q.offer(&quot;c&quot;); q.offer(&quot;d&quot;); q.offer(&quot;e&quot;); q.add(&quot;f&quot;); //System.out.println(q.size());// for (Iterator iterator = q.iterator(); iterator.hasNext();) &#123;// String string = (String) iterator.next();// System.out.println(string);// &#125; List&lt;String&gt; list = new ArrayList&lt;String&gt;(); System.out.println(q.drainTo(list, 3)); System.out.println(list.size()); for (String string : list) &#123; System.out.println(string); &#125; */ final SynchronousQueue&lt;String&gt; q = new SynchronousQueue&lt;String&gt;(); Thread t1 = new Thread(new Runnable() &#123; @Override public void run() &#123; try &#123; System.out.println(q.take()); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;); t1.start(); Thread t2 = new Thread(new Runnable() &#123; @Override public void run() &#123; q.add(&quot;asdasd&quot;); &#125; &#125;); t2.start(); &#125;&#125; PriorityBlockingQueue:123456789101112131415161718192021222324252627public class Task implements Comparable&lt;Task&gt;&#123; private int id ; private String name; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; @Override public int compareTo(Task task) &#123; return this.id &gt; task.id ? 1 : (this.id &lt; task.id ? -1 : 0); &#125; public String toString()&#123; return this.id + &quot;,&quot; + this.name; &#125;&#125; 123456789101112131415161718192021222324252627282930313233import java.util.concurrent.PriorityBlockingQueue;public class UsePriorityBlockingQueue &#123; public static void main(String[] args) throws Exception&#123; PriorityBlockingQueue&lt;Task&gt; q = new PriorityBlockingQueue&lt;Task&gt;(); Task t1 = new Task(); t1.setId(3); t1.setName(&quot;id为3&quot;); Task t2 = new Task(); t2.setId(4); t2.setName(&quot;id为4&quot;); Task t3 = new Task(); t3.setId(1); t3.setName(&quot;id为1&quot;); //return this.id &gt; task.id ? 1 : 0; q.add(t1); //3 q.add(t2); //4 q.add(t3); //1 // 1 3 4 System.out.println(&quot;容器：&quot; + q); System.out.println(q.take().getId()); System.out.println(&quot;容器：&quot; + q);// System.out.println(q.take().getId());// System.out.println(q.take().getId()); &#125; take的时候才排序，放的时候不排序123容器：[1,id为1, 4,id为4, 3,id为3]1容器：[3,id为3, 4,id为4] DelayQueue:123456789101112131415161718192021222324252627282930313233343536373839404142434445import java.util.concurrent.Delayed;import java.util.concurrent.TimeUnit;public class Wangmin implements Delayed &#123; private String name; //身份证 private String id; //截止时间 private long endTime; //定义时间工具类 private TimeUnit timeUnit = TimeUnit.SECONDS; public Wangmin(String name,String id,long endTime)&#123; this.name=name; this.id=id; this.endTime = endTime; &#125; public String getName()&#123; return this.name; &#125; public String getId()&#123; return this.id; &#125; /** * 用来判断是否到了截止时间 */ @Override public long getDelay(TimeUnit unit) &#123; //return unit.convert(endTime, TimeUnit.MILLISECONDS) - unit.convert(System.currentTimeMillis(), TimeUnit.MILLISECONDS); return endTime - System.currentTimeMillis(); &#125; /** * 相互批较排序用 */ @Override public int compareTo(Delayed delayed) &#123; Wangmin w = (Wangmin)delayed; return this.getDelay(this.timeUnit) - w.getDelay(this.timeUnit) &gt; 0 ? 1:0; &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647import java.util.concurrent.DelayQueue;public class WangBa implements Runnable &#123; private DelayQueue&lt;Wangmin&gt; queue = new DelayQueue&lt;Wangmin&gt;(); public boolean yinye =true; public void shangji(String name,String id,int money)&#123; Wangmin man = new Wangmin(name, id, 1000 * money + System.currentTimeMillis()); System.out.println(&quot;网名&quot;+man.getName()+&quot; 身份证&quot;+man.getId()+&quot;交钱&quot;+money+&quot;块,开始上机...&quot;); this.queue.add(man); &#125; public void xiaji(Wangmin man)&#123; System.out.println(&quot;网名&quot;+man.getName()+&quot; 身份证&quot;+man.getId()+&quot;时间到下机...&quot;); &#125; @Override public void run() &#123; while(yinye)&#123; try &#123; Wangmin man = queue.take(); xiaji(man); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; public static void main(String args[])&#123; try&#123; System.out.println(&quot;网吧开始营业&quot;); WangBa siyu = new WangBa(); Thread shangwang = new Thread(siyu); shangwang.start(); siyu.shangji(&quot;路人甲&quot;, &quot;123&quot;, 1); siyu.shangji(&quot;路人乙&quot;, &quot;234&quot;, 10); siyu.shangji(&quot;路人丙&quot;, &quot;345&quot;, 5); &#125; catch(Exception e)&#123; e.printStackTrace(); &#125; &#125;&#125; 1234567网吧开始营业网名路人甲 身份证123交钱1块,开始上机...网名路人乙 身份证234交钱10块,开始上机...网名路人丙 身份证345交钱5块,开始上机...网名路人甲 身份证123时间到下机...网名路人丙 身份证345时间到下机...网名路人乙 身份证234时间到下机... 1234567891011121314151617181920212223242526BlockingQueue也是java.util.concurrent下的主要用来控制线程同步的工具。主要的方法是：put、take一对阻塞存取；add、poll一对非阻塞存取。 插入: 1)add(anObject):把anObject加到BlockingQueue里,即如果BlockingQueue可以容纳,则返回true,否则抛出 2)offer(anObject):表示如果可能的话,将anObject加到BlockingQueue里,即如果BlockingQueue可以容纳,则返回true,否则返回false. 3)put(anObject):把anObject加到BlockingQueue里,如果BlockQueue没有空间,则调用此方法的线程被阻断直到BlockingQueue里面有空间再继续. 读取： 4)poll(time):取走BlockingQueue里排在首位的对象,若不能立即取出,则可以等time参数规定的时间,取不到时返回null 5)take():取走BlockingQueue里排在首位的对象,若BlockingQueue为空,阻断进入等待状态直到Blocking有新的对象被加入为止 其他int remainingCapacity();返回队列剩余的容量，在队列插入和获取的时候，不要瞎搞，数 据可能不准boolean remove(Object o); 从队列移除元素，如果存在，即移除一个或者更多，队列改 变了返回truepublic boolean contains(Object o); 查看队列是否存在这个元素，存在返回trueint drainTo(Collection&lt;? super E&gt; c); 移除此队列中所有可用的元素，并将它们添加到给定collection中int drainTo(Collection&lt;? super E&gt; c, int maxElements); 和上面方法的区别在于，制定了移动的数量BlockingQueue有四个具体的实现类,常用的两种实现类为：1、ArrayBlockingQueue：一个由数组支持的有界阻塞队列，规定大小的BlockingQueue,其构造函数必须带一个int参数来指明其大小.其所含的对象是以FIFO(先入先出)顺序排序的。2、LinkedBlockingQueue：大小不定的BlockingQueue,若其构造函数带一个规定大小的参数,生成的BlockingQueue有大小限制,若不带大小参数,所生成的BlockingQueue的大小由Integer.MAX_VALUE来决定.其所含的对象是以FIFO(先入先出)顺序排序的。 LinkedBlockingQueue 可以指定容量，也可以不指定，不指定的话，默认最大是Integer.MAX_VALUE,其中主要用到put和take方法，put方法在队列满的时候会阻塞直到有队列成员被消费，take方法在队列空的时候会阻塞，直到有队列成员被放进来。LinkedBlockingQueue和ArrayBlockingQueue区别：LinkedBlockingQueue和ArrayBlockingQueue比较起来,它们背后所用的数据结构不一样,导致LinkedBlockingQueue的数据吞吐量要大于ArrayBlockingQueue,但在线程数量很大时其性能的可预见性低于ArrayBlockingQueue. java并发编程的一些总结1.不应用线程池的缺点有些开发者图省事，遇到需要多线程处理的地方，直接new Thread(…).start()，对于一般场景是没问题的，但如果是在并发请求很高的情况下，就会有些隐患：新建线程的开销。线程虽然比进程要轻量许多，但对于JVM来说，新建一个线程的代价还是挺大的，决不同于新建一个对象资源消耗量。没有一个池来限制线程的数量，会导致线程的数量直接取决于应用的并发量，这样有潜在的线程数据巨大的可能，那么资源消耗量将是巨大的稳定性。当线程数量超过系统资源所能承受的程度，稳定性就会成问题2.制定执行策略在每个需要多线程处理的地方，不管并发量有多大，需要考虑线程的执行策略任务以什么顺序执行可以有多少个任何并发执行可以有多少个任务进入等待执行队列系统过载的时候，应该放弃哪些任务？如何通知到应用程序？一个任务的执行前后应该做什么处理3.线程池的类型不管是通过Executors创建线程池，还是通过Spring来管理，都得清楚知道有哪几种线程池：FixedThreadPool：定长线程池，提交任务时创建线程，直到池的最大容量，如果有线程非预期结束，会补充新线程CachedThreadPool：可变线程池，它犹如一个弹簧，如果没有任务需求时，它回收空闲线程，如果需求增加，则按需增加线程，不对池的大小做限制SingleThreadExecutor：单线程。处理不过来的任务会进入FIFO队列等待执行SecheduledThreadPool：周期性线程池。支持执行周期性线程任务其实，这些不同类型的线程池都是通过构建一个ThreadPoolExecutor来完成的，所不同的是corePoolSize,maximumPoolSize,keepAliveTime,unit,workQueue,threadFactory这么几个参数。具体可以参见JDK DOC。4.线程池饱和策略由以上线程池类型可知，除了CachedThreadPool其他线程池都有饱和的可能，当饱和以后就需要相应的策略处理请求线程的任务，ThreadPoolExecutor采取的方式通过队列来存储这些任务，当然会根据池类型不同选择不同的队列，比如FixedThreadPool和SingleThreadExecutor默认采用的是无限长度的LinkedBlockingQueue。但从系统可控性讲，最好的做法是使用定长的ArrayBlockingQueue或有限的LinkedBlockingQueue，并且当达到上限时通过ThreadPoolExecutor.setRejectedExecutionHandler方法设置一个拒绝任务的策略，JDK提供了AbortPolicy、CallerRunsPolicy、DiscardPolicy、DiscardOldestPolicy几种策略，具体差异可见JDK DOC5.线程无依赖性多线程任务设计上尽量使得各任务是独立无依赖的，所谓依赖性可两个方面：线程之间的依赖性。如果线程有依赖可能会造成死锁或饥饿调用者与线程的依赖性。调用者得监视线程的完成情况，影响可并发量当然，在有些业务里确实需要一定的依赖性，比如调用者需要得到线程完成后结果，传统的Thread是不便完成的，因为run方法无返回值，只能通过一些共享的变量来传递结果，但在Executor框架里可以通过Future和Callable实现需要有返回值的任务，当然线程的异步性导致需要有相应机制来保证调用者能等待任务完成。 多线程的设计模式并行设计模式属于设计优化的一部分,它是对一些常用的多线程结构的总结和抽象与串行程序相比,并行程序的结构通常更为复杂。因此合理的使用并行模式在多线程开发中更具有意义,在这里主要介绍Future, Master-Worker和生产者-消费者模型。 Future模式Future模式有点类似于商品订单。比如在网购时,当看重某一件商品事,就可以提交订 ,当订单处理完成后,在家里等待商品送货上门即可。或者说更形象的我们发送Ajax请求的时候,页面是异步的进行后台处理,用户无须一直等待请求的结果,可以继续浏览或操作其他内容。 Data:123public interface Data &#123; String getRequest();&#125; RealData:123456789101112131415161718192021public class RealData implements Data&#123; private String result ; public RealData (String queryStr)&#123; System.out.println(&quot;根据&quot; + queryStr + &quot;进行查询，这是一个很耗时的操作..&quot;); try &#123; Thread.sleep(5000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(&quot;操作完毕，获取结果&quot;); result = &quot;查询结果&quot;; &#125; @Override public String getRequest() &#123; return result; &#125;&#125; FutureData:12345678910111213141516171819202122232425262728293031public class FutureData implements Data&#123; private RealData realData ; private boolean isReady = false; public synchronized void setRealData(RealData realData) &#123; //如果已经装载完毕了，就直接返回 if(isReady)&#123; return; &#125; //如果没装载，进行装载真实对象 this.realData = realData; isReady = true; //进行通知 notify(); &#125; @Override public synchronized String getRequest() &#123; //如果没装载好 程序就一直处于阻塞状态 while(!isReady)&#123; try &#123; wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; //装载好直接获取数据即可 return this.realData.getRequest(); &#125;&#125; FutureClient:123456789101112131415161718public class FutureClient &#123; public Data request(final String queryStr)&#123; //1 我想要一个代理对象（Data接口的实现类）先返回给发送请求的客户端，告诉他请求已经接收到，可以做其他的事情 final FutureData futureData = new FutureData(); //2 启动一个新的线程，去加载真实的数据，传递给这个代理对象 new Thread(new Runnable() &#123; @Override public void run() &#123; //3 这个新的线程可以去慢慢的加载真实对象，然后传递给代理对象 RealData realData = new RealData(queryStr); futureData.setRealData(realData); &#125; &#125;).start(); return futureData; &#125;&#125; Main:1234567891011121314public class Main &#123; public static void main(String[] args) throws InterruptedException &#123; FutureClient fc = new FutureClient(); Data data = fc.request(&quot;请求参数&quot;); System.out.println(&quot;请求发送成功!&quot;); System.out.println(&quot;做其他的事情...&quot;); String result = data.getRequest(); System.out.println(result); &#125;&#125; Master-Worker模式Master-Worker模式是常用的并行计算模式。它的核心思想是系统由两类进程协作工作: Master进程和Worker进程。Master负责接收和分配任务,Worker负责处理子任务。当各个Worker子进程处理完成后,会将结果返回给Master, 由Master做归纳和总结。其好处是能将一个大任务分解成若干个小任务,并行执行,从而提高系统的吞吐量。Task:123456789101112131415161718public class Task &#123; private int id; private int price ; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public int getPrice() &#123; return price; &#125; public void setPrice(int price) &#123; this.price = price; &#125;&#125; Master:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758import java.util.HashMap;import java.util.Map;import java.util.concurrent.ConcurrentHashMap;import java.util.concurrent.ConcurrentLinkedQueue;public class Master &#123; //1 有一个盛放任务的容器 private ConcurrentLinkedQueue&lt;Task&gt; workQueue = new ConcurrentLinkedQueue&lt;Task&gt;(); //2 需要有一个盛放worker的集合 private HashMap&lt;String, Thread&gt; workers = new HashMap&lt;String, Thread&gt;(); //3 需要有一个盛放每一个worker执行任务的结果集合 private ConcurrentHashMap&lt;String, Object&gt; resultMap = new ConcurrentHashMap&lt;String, Object&gt;(); //4 构造方法 public Master(Worker worker , int workerCount)&#123; worker.setWorkQueue(this.workQueue); worker.setResultMap(this.resultMap); for(int i = 0; i &lt; workerCount; i ++)&#123; this.workers.put(Integer.toString(i), new Thread(worker)); &#125; &#125; //5 需要一个提交任务的方法 public void submit(Task task)&#123; this.workQueue.add(task); &#125; //6 需要有一个执行的方法，启动所有的worker方法去执行任务 public void execute()&#123; for(Map.Entry&lt;String, Thread&gt; me : workers.entrySet())&#123; me.getValue().start(); &#125; &#125; //7 判断是否运行结束的方法 public boolean isComplete() &#123; for(Map.Entry&lt;String, Thread&gt; me : workers.entrySet())&#123; if(me.getValue().getState() != Thread.State.TERMINATED)&#123; return false; &#125; &#125; return true; &#125; //8 计算结果方法 public int getResult() &#123; int priceResult = 0; for(Map.Entry&lt;String, Object&gt; me : resultMap.entrySet())&#123; priceResult += (Integer)me.getValue(); &#125; return priceResult; &#125;&#125; Worker:1234567891011121314151617181920212223242526272829303132333435363738import java.util.concurrent.ConcurrentHashMap;import java.util.concurrent.ConcurrentLinkedQueue;public class Worker implements Runnable &#123; private ConcurrentLinkedQueue&lt;Task&gt; workQueue; private ConcurrentHashMap&lt;String, Object&gt; resultMap; public void setWorkQueue(ConcurrentLinkedQueue&lt;Task&gt; workQueue) &#123; this.workQueue = workQueue; &#125; public void setResultMap(ConcurrentHashMap&lt;String, Object&gt; resultMap) &#123; this.resultMap = resultMap; &#125; @Override public void run() &#123; while(true)&#123; Task input = this.workQueue.poll(); if(input == null) break; Object output = handle(input); this.resultMap.put(Integer.toString(input.getId()), output); &#125; &#125; private Object handle(Task input) &#123; Object output = null; try &#123; //处理任务的耗时。。 比如说进行操作数据库。。。 Thread.sleep(500); output = input.getPrice(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; return output; &#125;&#125; Main:12345678910111213141516171819202122232425262728import java.util.Random;public class Main &#123; public static void main(String[] args) &#123; Master master = new Master(new Worker(), 20); Random r = new Random(); for(int i = 1; i &lt;= 100; i++)&#123; Task t = new Task(); t.setId(i); t.setPrice(r.nextInt(1000)); master.submit(t); &#125; master.execute(); long start = System.currentTimeMillis(); while(true)&#123; if(master.isComplete())&#123; long end = System.currentTimeMillis() - start; int priceResult = master.getResult(); System.out.println(&quot;最终结果：&quot; + priceResult + &quot;, 执行时间：&quot; + end); break; &#125; &#125; &#125;&#125; 生产者-消费者生产者和消费者也是一个非常经典的多线程模式,我们在实际开发中应用非常广泛的思想理念。在生产-消费模式中:通常由两类线程,即若干个生产者的线程和若干个消费者的线程。生产者线程负责提交用户请求,消费者线程则负责具体处理生产者提交的任务,在生产者和消费者之间通过共享内存缓存区进行通信。Data:1234567891011121314151617181920212223242526272829303132public final class Data &#123; private String id; private String name; public Data(String id, String name)&#123; this.id = id; this.name = name; &#125; public String getId() &#123; return id; &#125; public void setId(String id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; @Override public String toString()&#123; return &quot;&#123;id: &quot; + id + &quot;, name: &quot; + name + &quot;&#125;&quot;; &#125;&#125; Provider:12345678910111213141516171819202122232425262728293031323334353637383940414243444546import java.util.Random;import java.util.concurrent.BlockingQueue;import java.util.concurrent.TimeUnit;import java.util.concurrent.atomic.AtomicInteger;public class Provider implements Runnable&#123; //共享缓存区 private BlockingQueue&lt;Data&gt; queue; //多线程间是否启动变量，有强制从主内存中刷新的功能。即时返回线程的状态 private volatile boolean isRunning = true; //id生成器 private static AtomicInteger count = new AtomicInteger(); //随机对象 private static Random r = new Random(); public Provider(BlockingQueue queue)&#123; this.queue = queue; &#125; @Override public void run() &#123; while(isRunning)&#123; try &#123; //随机休眠0 - 1000 毫秒 表示获取数据(产生数据的耗时) Thread.sleep(r.nextInt(1000)); //获取的数据进行累计... int id = count.incrementAndGet(); //比如通过一个getData方法获取了 Data data = new Data(Integer.toString(id), &quot;数据&quot; + id); System.out.println(&quot;当前线程:&quot; + Thread.currentThread().getName() + &quot;, 获取了数据，id为:&quot; + id + &quot;, 进行装载到公共缓冲区中...&quot;); if(!this.queue.offer(data, 2, TimeUnit.SECONDS))&#123; System.out.println(&quot;提交缓冲区数据失败....&quot;); //do something... 比如重新提交 &#125; &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; public void stop()&#123; this.isRunning = false; &#125;&#125; Consumer:1234567891011121314151617181920212223242526public class Consumer implements Runnable&#123; private BlockingQueue&lt;Data&gt; queue; public Consumer(BlockingQueue queue)&#123; this.queue = queue; &#125; //随机对象 private static Random r = new Random(); @Override public void run() &#123; while(true)&#123; try &#123; //获取数据 Data data = this.queue.take(); //进行数据处理。休眠0 - 1000毫秒模拟耗时 Thread.sleep(r.nextInt(1000)); System.out.println(&quot;当前消费线程：&quot; + Thread.currentThread().getName() + &quot;， 消费成功，消费数据为id: &quot; + data.getId()); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; Main:12345678910111213141516171819202122232425262728293031323334353637383940414243444546import java.util.concurrent.BlockingQueue;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;import java.util.concurrent.LinkedBlockingQueue;public class Main &#123; public static void main(String[] args) throws Exception &#123; //内存缓冲区 BlockingQueue&lt;Data&gt; queue = new LinkedBlockingQueue&lt;Data&gt;(10); //生产者 Provider p1 = new Provider(queue); Provider p2 = new Provider(queue); Provider p3 = new Provider(queue); //消费者 Consumer c1 = new Consumer(queue); Consumer c2 = new Consumer(queue); Consumer c3 = new Consumer(queue); //创建线程池运行,这是一个缓存的线程池，可以创建无穷大的线程，没有任务的时候不创建线程。空闲线程存活时间为60s（默认值） ExecutorService cachePool = Executors.newCachedThreadPool(); cachePool.execute(p1); cachePool.execute(p2); cachePool.execute(p3); cachePool.execute(c1); cachePool.execute(c2); cachePool.execute(c3); try &#123; Thread.sleep(3000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; p1.stop(); p2.stop(); p3.stop(); try &#123; Thread.sleep(2000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125;// cachePool.shutdown();// cachePool.shutdownNow(); &#125;&#125; Executor框架为了更好的控制多线程, JDK提供了一套线程框架Executor,帮助开发人员有效地进行线程控制。它们都在java.util.concurrent包中,是JDK并发包的核心。其中有一个比较重要的类: Executors,他扮演这线程工厂的角色,我们通过Executors可以创建特定功能的线程池。Executors创建线程池方法:newFixedThreadPool)方法,该方法返回一个固定数量的线程池,该方法的线程数始终不变,当有一个任务提交时,若线程池中空闲,则立即执行,若没有,则会被暂缓在一个任务队列中等待有空闲的线程去执行。newSingleThreadExecutor()方法,创建一个线程的线程池,若空闲则执行,若没有空闲线程则暂缓在任务列队中。newCachedThreadPool)方法,返回一个可根据实际情况调整线程个数的线程池,不限制最大线程数量,若有任务,则创建线程,若无任务则不创建线程。如果没有任务则线程在60s后自动回收(空闲时间60s) .newScheduled ThreadPool)方法,该方法返回一个SchededExecutorService对象,但该线程池可以指定线程的数量 自定义线程池若Executors工厂类无法满足我们的需求,可以自己去创建自定义的线程池,其实Executors工广类里面的创建线程方法其内部实现均是用了ThreadPoolExecutor这个类,这个类可以自定义线程。构造方法如下:public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize， long keepAliveTime, TimeUnit unit, BlockingQueue workQueue, ThreadFactory ThreadFactory, RejectedExecutionHandler handler) {…} 比如：maximumPoolSize=2，maximumPoolSize=10，ArrayBlockingqueue=10当一次性来了30个任务，放到这个线程池里，肯定会有一堆任务被拒绝，首先，corePoolSize有2个，还有28个任务待处理，我们可以根据上限maximumPoolSize再去提高8个线程去处理，还剩20个，再往队列里扔10个，最后还剩10个，这10个就会去走RejectedExecutionHandler任务过多的时候会导致内存溢出，队列会逐渐变大。 自定义线程池使用详细这个构造方法对于队列是什么类型的比较关键:在使用有界队列时: 若有新的任务需要执行,如果线程池实际线程数小于corePoolSize,则优先创建线程,若大于corePoolsize,则会将任务加入队列，若队列已满，则在总线程数不大于maximumPoolSize的前提下创建新的线程，若线程数大于maximumPoolsize,则执行拒绝策略。或其他自定义方式。无界的任务队列时: LinkedBlockingQueue,与有界队列相比,除非系统资源耗尽,否则无界的任务队列不存在任务入队失败的情况。当有新在务到来,系统的线程数小于corePoolsize时,则新建线程执行任务,当达到orePoolSize后,就不会继续增加。若后续仍有新的在务加入,而有没有闲的线程资源，则任务直接进入队列等待。若任务创建和处理的速度差异很大,无界队列会保持快速增长,直到耗尽系统内存。JDK拒绝策略:AbortPolicy:直接抛出异常组织系统正常工作CallerRunsPolicy:只要线程池未关闭,该策略直接在调用者线程中,运行当前被丢弃的任务。DiscardoldestPolicy:丢弃最老的一个请求,尝试再次提交当前任务。DiscardPolicy:丢弃无法处理的任务,不给予任何处理。如果需要自定义拒绝策略可以实现RejectedExecutionHandler接口。","categories":[],"tags":[{"name":"java基础","slug":"java基础","permalink":"http://yoursite.com/tags/java基础/"}],"keywords":[]},{"title":"多线程2","slug":"多线程2","date":"2019-09-07T02:23:08.946Z","updated":"2019-09-07T02:19:32.280Z","comments":true,"path":"2019/09/07/多线程2/","link":"","permalink":"http://yoursite.com/2019/09/07/多线程2/","excerpt":"","text":"线程之间通信线程通信概念 线程是操作系统中独立的个体,但这些个体如果不经过特殊的处理就不能成为一个整体,线程间的通信就成为整体的必用方式之一,当线程存在通信指挥,系统间的交互性会更强大,在提高CPU利用率的同时还会使开发人员对线程任务在处理的过程中进行有效的把控与监督.使用wait notily方法实现线程间的通信。 (注意这两个方法都是object的类的方法,换句话说java为所有的对象都提供了这两个方法)1 wait和 notify 必须配合synchronized关键字使用2 wait方法释放锁, notify方法不释放锁.123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869import java.util.ArrayList;import java.util.List;/** * wait notfiy 方法，wait释放锁，notfiy不释放锁 */public class ListAdd2 &#123; private volatile static List list = new ArrayList(); public void add()&#123; list.add(&quot;bjsxt&quot;); &#125; public int size()&#123; return list.size(); &#125; public static void main(String[] args) &#123; final ListAdd2 list2 = new ListAdd2(); // 1 实例化出来一个 lock // 当使用wait 和 notify 的时候 ， 一定要配合着synchronized关键字去使用 final Object lock = new Object(); // final CountDownLatch countDownLatch = new CountDownLatch(1); Thread t1 = new Thread(new Runnable() &#123; @Override public void run() &#123; try &#123; synchronized (lock) &#123; for(int i = 0; i &lt;10; i++)&#123; list2.add(); System.out.println(&quot;当前线程：&quot; + Thread.currentThread().getName() + &quot;添加了一个元素..&quot;); Thread.sleep(500); if(list2.size() == 5)&#123; System.out.println(&quot;已经发出通知..&quot;); //countDownLatch.countDown(); lock.notify(); &#125; &#125; &#125; &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;, &quot;t1&quot;); Thread t2 = new Thread(new Runnable() &#123; @Override public void run() &#123; synchronized (lock) &#123; if(list2.size() != 5)&#123; try &#123; //System.out.println(&quot;t2进入...&quot;); lock.wait(); // countDownLatch.await(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; System.out.println(&quot;当前线程：&quot; + Thread.currentThread().getName() + &quot;收到通知线程停止..&quot;); throw new RuntimeException(); &#125; &#125; &#125;, &quot;t2&quot;); t2.start(); t1.start(); &#125;&#125; 123456789101112131415当前线程：t1添加了一个元素..当前线程：t1添加了一个元素..当前线程：t1添加了一个元素..当前线程：t1添加了一个元素..当前线程：t1添加了一个元素..已经发出通知..当前线程：t1添加了一个元素..当前线程：t1添加了一个元素..当前线程：t1添加了一个元素..当前线程：t1添加了一个元素..当前线程：t1添加了一个元素..当前线程：t2收到通知线程停止..Exception in thread &quot;t2&quot; java.lang.RuntimeException at com.bjsxt.base.conn008.ListAdd2$2.run(ListAdd2.java:65) at java.lang.Thread.run(Thread.java:745) 上述方式需要等到notify所在代码全部执行完毕，其它方式CountDownLatch（跟锁没有关系）countdownlatch同样拥有wait和notify功能，对应的是await和countDown,不过它是即时的，不需要等待notify代码块执行完毕后才释放锁，只要执行了notify函数后，其他线程就能拿到锁，不过countdownlatch不具备锁的功能123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172import java.util.ArrayList;import java.util.List;import java.util.concurrent.CountDownLatch;/** * wait notfiy 方法，wait释放锁，notfiy不释放锁 */public class ListAdd2 &#123; private volatile static List list = new ArrayList(); public void add()&#123; list.add(&quot;bjsxt&quot;); &#125; public int size()&#123; return list.size(); &#125; public static void main(String[] args) &#123; final ListAdd2 list2 = new ListAdd2(); // 1 实例化出来一个 lock // 当使用wait 和 notify 的时候 ， 一定要配合着synchronized关键字去使用 //final Object lock = new Object(); final CountDownLatch countDownLatch = new CountDownLatch(1); Thread t1 = new Thread(new Runnable() &#123; @Override public void run() &#123; try &#123; //synchronized (lock) &#123; for(int i = 0; i &lt;10; i++)&#123; list2.add(); System.out.println(&quot;当前线程：&quot; + Thread.currentThread().getName() + &quot;添加了一个元素..&quot;); Thread.sleep(500); if(list2.size() == 5)&#123; System.out.println(&quot;已经发出通知..&quot;); countDownLatch.countDown(); //lock.notify(); &#125; &#125; //&#125; &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;, &quot;t1&quot;); Thread t2 = new Thread(new Runnable() &#123; @Override public void run() &#123; //synchronized (lock) &#123; if(list2.size() != 5)&#123; try &#123; //System.out.println(&quot;t2进入...&quot;); //lock.wait(); countDownLatch.await(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; System.out.println(&quot;当前线程：&quot; + Thread.currentThread().getName() + &quot;收到通知线程停止..&quot;); throw new RuntimeException(); //&#125; &#125; &#125;, &quot;t2&quot;); t2.start(); t1.start(); &#125;&#125; 123456789101112131415当前线程：t1添加了一个元素..当前线程：t1添加了一个元素..当前线程：t1添加了一个元素..当前线程：t1添加了一个元素..当前线程：t1添加了一个元素..已经发出通知..Exception in thread &quot;t2&quot; 当前线程：t1添加了一个元素..当前线程：t2收到通知线程停止..java.lang.RuntimeException at com.bjsxt.base.conn008.ListAdd2$2.run(ListAdd2.java:68) at java.lang.Thread.run(Thread.java:745)当前线程：t1添加了一个元素..当前线程：t1添加了一个元素..当前线程：t1添加了一个元素..当前线程：t1添加了一个元素.. 应用：12有一个client去连接zk,去连接的时候需要耗时1~2秒，但是主程序是不阻塞的一直往下走，这就会导致可能返回的zk还没有值，但是主线程已经拿着zk进行操作，就会出现空指针所以我们需要在主线程countDownLatch.await(),在zk连接成功返回时countDownLatch.countDown() ThreadLocalThreadLocal概念:线程局部变量,是一种多线程间并发访问变量的解决方案.与其synchronized等加锁的方式不同, ThreadlLocal完全不提供锁,而使用以空问换时间的手段,为每个线程提供变量的独立副本,以保障线程安全从性能上说, ThreadLocal不具有绝对的优势,在并发不是很高的时候,加锁的性能会更好,但作为一套与镇完全无关的线程安全解决方案,在高并发或者竞争激烈的场景,用ThreadLocal可以在一定程度上减少锁竞争。 12345678910111213141516171819202122232425262728293031323334353637public class ConnThreadLocal &#123; public static ThreadLocal&lt;String&gt; th = new ThreadLocal&lt;String&gt;(); public void setTh(String value)&#123; th.set(value); &#125; public void getTh()&#123; System.out.println(Thread.currentThread().getName() + &quot;:&quot; + this.th.get()); &#125; public static void main(String[] args) throws InterruptedException &#123; final ConnThreadLocal ct = new ConnThreadLocal(); Thread t1 = new Thread(new Runnable() &#123; @Override public void run() &#123; ct.setTh(&quot;张三&quot;); ct.getTh(); &#125; &#125;, &quot;t1&quot;); Thread t2 = new Thread(new Runnable() &#123; @Override public void run() &#123; try &#123; Thread.sleep(1000); ct.getTh(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;, &quot;t2&quot;); t1.start(); t2.start(); &#125;&#125; 12t1:张三t2:null","categories":[],"tags":[{"name":"java基础","slug":"java基础","permalink":"http://yoursite.com/tags/java基础/"}],"keywords":[]},{"title":"常用类","slug":"常用类","date":"2019-09-07T02:23:08.915Z","updated":"2019-09-10T07:15:06.211Z","comments":true,"path":"2019/09/07/常用类/","link":"","permalink":"http://yoursite.com/2019/09/07/常用类/","excerpt":"","text":"Object类概述及其构造方法构造方法public Object() 成员方法public int hashCode()12A:返回该对象的哈希码值。默认情况下，该方法会根据对象的地址来计算B:不是实际地址值，可以理解为逻辑地址值。 public final Class getClass()123A:返回对象的字节码文件对象，反射中我们会详细讲解B:可以通过Class类中的一个方法，获取对象的真实类的全名称。 public String getName() public String toString()12345678A:返回该对象的字符串表示。 底层源码。 public static String valueOf(Object obj) &#123; return (obj == null) ? &quot;null&quot; : obj.toString(); &#125;B:它的值等于： getClass().getName() + &apos;@&apos; + Integer.toHexString(hashCode())C:由于默认情况下的数据对我们来说没有意义，一般建议重写该方法，但是最终还是自动生成。 public boolean equals(Object?obj)123456789101112A:指示其他某个对象是否与此对象“相等”。B:默认情况下比较的是对象的引用是否相同。C:由于比较对象的引用没有意义，一般建议重写该方法，但是最终还是自动生成。D:两个注意问题: ·直接输出一个对象名称，其实默认调用了该对象的toString()方法。 ·==和equals()的区别。(面试题) A:== 基本类型：比较的是值是否相同 引用类型：比较的是地址值是否相同 B:equals() 只能比较引用类型。默认情况下，比较的是地址值是否相同。 但是，我们可以根据自己的需要重写该方法。 protected void finalize()123A:当垃圾回收器确定不存在对该对象的更多引用时，由对象的垃圾回收器调用此方法。B:垃圾回收器不会马上回收垃圾，但是我们可以建议它尽快回收垃圾。(System.gc()方法)C:主要针对堆内存。 protected Object clone()1234567891011121314151617181920212223创建并返回此对象的一个副本，这种克隆机制十分高效，而且二者之间完全隔离。自定义类实现克隆步骤： A:自定义类实现Cloneable接口，这是个标记性接口，实现这个接口的类的对象可实现自我克隆。 B:自定义类中重写Object类的clone()方法。 C:重写clone()方法时通过super.clone()调用Object类的clone()方法来得到该对象的副本，并返回该副本。注意：A:克隆和两个引用指向同一个对象的区别? B:Object类clone()方法虽然简单，易用，但仅仅是一种”浅克隆”,它只克隆该对象所有的Field值， 不会对引用类型的Field所引用的对象进行克隆。开发中，我们也可以实现对象的”深度克隆”。public class Student implements cloneable&#123; ... @Override protected Object clone()&#123; return super.clone(); &#125;&#125;public class StudentDemo&#123; public static void main(String[] args)&#123; Student s=new Student(); Object obj=s.clone(); Student s2=(Student)obj; &#125;&#125; Scanner类概述及其构造方法构造方法12345678A:讲解了System.in这个东西。 它其实是标准的输入流,对应于键盘录入B:构造方法 InputStream is = System.in; Scanner(InputStream is)C:常用的格式 Scanner sc = new Scanner(System.in); 基本方法格式12A:hasNextXxx() 判断是否是某种类型的B:nextXxx() 返回某种类型的元素 掌握的两个方法12A:public int nextInt()B:public String nextLine() 12345需要注意的小问题A:同一个Scanner对象，先获取数值，再获取字符串会出现一个小问题。B:解决方案： a:重新定义一个Scanner对象 b:把所有的数据都用字符串获取，然后再进行相应的转换 String类概述及其构造方法构造方法123456789public String()public String(byte[] bytes)public String(byte[] bytes,int offset,int length)public String(char[] value)public String(char[] value,int offset,int count)public String(String original)·注意： String s = “helloworld”; s也是一个对象。 String类的特点及面试题12345678910111213141516171819202122232425262728293031323334·字符串一旦被赋值，就不能改变。（这里指的是字符串的内容不能改变，而不是引用不能改变。）·String s = new String(&quot;hello&quot;);和String s = &quot;hello&quot;的区别? 前者创建2个对象，后者创建1个对象。说一下字符串中的equals()方法重写了Object()的方法，比较的是内容。A:==和equals() String s1 = new String(&quot;hello&quot;); String s2 = new String(&quot;hello&quot;); System.out.println(s1 == s2);// false System.out.println(s1.equals(s2));// true String s3 = new String(&quot;hello&quot;); String s4 = &quot;hello&quot;; System.out.println(s3 == s4);// false System.out.println(s3.equals(s4));// true String s5 = &quot;hello&quot;; String s6 = &quot;hello&quot;; System.out.println(s5 == s6);// true System.out.println(s5.equals(s6));// trueB:字符串的拼接 String s1 = &quot;hello&quot;; String s2 = &quot;world&quot;; String s3 = &quot;helloworld&quot;; System.out.println(s3 == s1 + s2);// false System.out.println(s3.equals((s1 + s2)));// true System.out.println(s3 == &quot;hello&quot; + &quot;world&quot;);// true System.out.println(s3.equals(&quot;hello&quot; + &quot;world&quot;));// true字符串如果是变量相加，先开空间，再拼接。字符串如果是常量相加，是先加，然后在常量池找，如果有就直接返回，否则，就创建。 String类的判断功能123456boolean equals(Object obj)：区分大小写boolean equalsIgnoreCase(String str)：忽略大小写boolean contains(String str)：判断大字符串中是否包含小字符串boolean startsWith(String str)：判断字符串是否以某个指定的字符串开头boolean endsWith(String str)：boolean isEmpty()判断字符串内容是否为空 String类的获取功能12345678int length()char charAt(int index)int indexOf(int ch)int indexOf(String str)int indexOf(int ch,int fromIndex)int indexOf(String str,int fromIndex)String substring(int start)String substring(int start,int end)（包start不包end） String类的转换功能1234567byte[] getBytes()char[] toCharArray()static String valueOf(char[] chs)static String valueOf(int i)String toLowerCase()String toUpperCase()String concat(String str） String类的其他功能12345678·替换功能 String replace(char old,char new) String replace(String old,String new)·去除字符串两空格 String trim()·按字典顺序比较两个字符串 int compareTo(String str) int compareToIgnoreCase(String str) StringBuffer类概述用字符串做拼接，比较耗时并且也耗内存，而这种拼接操作又是比较常见的，为 了解决这个问题，Java就提供了一个字符串缓冲区类。StringBuffer供我们使用 构造方法123StringBuffer()StringBuffer(int size)StringBuffer(String str) 成员方法123456789101112131415·添加功能 public StringBuffer append(String str) public StringBuffer insert(int offset,String str)·删除功能 public StringBuffer deleteCharAt(int index) public StringBuffer delete(int start,int end)·替换功能 public StringBuffer replace(int start,int end,String str)·反转功能 public StringBuffer reverse()·截取功能 public String substring(int start) public String substring(int start,int end) 截取功能和前面几个功能的不同 返回值类型是String类型，本身没有发生改变 StringBuffer和String的区别?12前者长度和内容可变，后者不可变如果使用前者做字符串的拼接，不会浪费太多的资源 面试题12345678小细节： StringBuffer：同步的，数据安全，效率低。 StringBuilder：不同步的，数据不安全，效率高。A:String,StringBuffer,StringBuilder的区别B:StringBuffer和数组的区别? 二者都可以看做是一个容器，装其他的数据， 但是，StringBuffer的数据最终是一个字符串数据 而数组可以放置多种数据，但必须是同一种类型 String作为形式参数，StringBuffer作为形式参数。123456789101112131415161718192021222324public static void main(String[] args) &#123; String s1=&quot;hello&quot;; String s2=&quot;world&quot;; System.out.println(s1+&quot;---&quot;+s2); change(s1,s2); System.out.println(s1+&quot;---&quot;+s2); StringBuffer sb1=new StringBuffer(&quot;hello&quot;); StringBuffer sb2=new StringBuffer(&quot;world&quot;); System.out.println(sb1+&quot;---&quot;+sb2); change(sb1,sb2); System.out.println(sb1+&quot;---&quot;+sb2);&#125;private static void change(String s1,String s2)&#123; s1 = s2; s2 = s1 + s2;&#125;private static void change(StringBuffer sb1,StringBuffer sb2)&#123; sb1 = sb2; sb1.append(sb2);&#125; 1234hello---worldhello---worldhello---worldhello---worldworld 数组高级冒泡排序相邻元素两两比较，大的往后放，第一次完毕，最大值出现在了最大索引处。同理，其他的元素就可以排好。1234567891011public static void bubbleSort(int[] arr) &#123; for(int x=0; x&lt;arr.length-1; x++) &#123; for(int y=0; y&lt;arr.length-1-x; y++) &#123; if(arr[y] &gt; arr[y+1]) &#123; int temp = arr[y]; arr[y] = arr[y+1]; arr[y+1] = temp; &#125; &#125; &#125;&#125; 选择排序把0索引的元素，和索引1以后的元素都进行比较，第一次完毕，最小值出现在了0索引。同理，其他的元素就可以排好。1234567891011public static void selectSort(int[] arr) &#123; for(int x=0; x&lt;arr.length-1; x++) &#123; for(int y=x+1; y&lt;arr.length; y++) &#123; if(arr[y] &lt; arr[x]) &#123; int temp = arr[x]; arr[x] = arr[y]; arr[y] = temp; &#125; &#125; &#125;&#125; 基本查找针对数组无序的情况123456789101112public static int getIndex(int[] arr,int value) &#123; int index = -1; for(int x=0; x&lt;arr.length; x++) &#123; if(arr[x] == value) &#123; index = x; break; &#125; &#125; return index;&#125; 二分查找(折半查找)针对数组有序的情况(千万不要先排序，在查找)123456789101112131415161718192021public static int binarySearch(int[] arr,int value) &#123; int min = 0; int max = arr.length-1; int mid = (min+max)/2; while(arr[mid] != value) &#123; if(arr[mid] &gt; value) &#123; max = mid - 1; &#125;else if(arr[mid] &lt; value) &#123; min = mid + 1; &#125; if(min &gt; max) &#123; return -1; &#125; mid = (min+max)/2; &#125; return mid;&#125; Arrays类概述及其常用方法Arrays类概述针对数组进行操作的工具类。提供了排序，查找等功能。 成员方法 public static String toString(int[] a) public static void sort(int[] a) public static int binarySearch(int[] a,int key) 基本类型包装类概述·常用的操作之一：用于基本数据类型与字符串之间的转换。·基本类型和包装类的对应 Byte,Short,Integer,Long,Float,Double，Character,Boolean Integer类概述及其构造方法构造方法12345 public Integer(int value) public Integer(String s) A:Integer i = new Integer(100); B:Integer i = new Integer(&quot;100&quot;);·注意：这里的字符串必须是由数字字符组成 成员方法12345678910111213141516171819202122·int类型和String类型的相互转换A:String -- int Integer.parseInt(&quot;100&quot;);B:int -- String String.valueOf(100);public int intValue()public static int parseInt(String s)public static String toString(int i)public static Integer valueOf(int i)public static Integer valueOf(String s)·常用的基本进制转换 public static String toBinaryString(int i) public static String toOctalString(int i) public static String toHexString(int i)·十进制到其他进制 public static String toString(int i,int radix)·其他进制到十进制 public static int parseInt(String s,int radix)·Java程序中的进制范围 2-36 JDK5的新特性123456·JDK1.5以后，简化了定义方式。 Integer x = new Integer(4);可以直接写成 Integer x = 4;//自动装箱。 x = x + 5;//自动拆箱。通过intValue方法。·需要注意： 在使用时，Integer x = null;上面的代码就会出现NullPointerException。 面试题缓冲池(看程序写结果)123456789101112131415161718192021Integer i1 = new Integer(127);Integer i2 = new Integer(127);System.out.println(i1 == i2);System.out.println(i1.equals(i2));Integer i3 = new Integer(128);Integer i4 = new Integer(128);System.out.println(i3 == i4);System.out.println(i3.equals(i4));Integer i5 = 127;Integer i6 = 127;System.out.println(i5 == i6);System.out.println(i5.equals(i6));Integer.valueOf(127);Integer i7 = 128;Integer i8 = 128;System.out.println(i7 == i8);System.out.println(i7.equals(i8)); 12345678falsetruefalsetruetruetruefalsetrue 注意：Integer的数据直接赋值，如果在-128到127之间，会直接从缓冲池里去取数据针对-128到127之间的数据，做了一个数据缓冲池。 Character类概述及其构造方法构造方法12 public Character(char value)Character ch = new Character(&apos;a&apos;); 成员方法1234567891011 public static boolean isUpperCase(char ch) public static boolean isLowerCase(char ch) public static boolean isDigit(char ch) public static char toUpperCase(char ch) public static char toLowerCase(char ch)A:判断给定的字符是否是大写B:判断给定的字符是否是小写C:判断给定的字符是否是数字字符D:把给定的字符转成大写E:把给定的字符转成小写 正则表达式概述及基本使用正则表达式：是指一个用来描述或者匹配一系列符合某个句法规则的字符串的单个字符串。其实就是一种规则。有自己特殊的应用。 常见规则字符:1234x 字符 x。举例：&apos;a&apos;表示字符a\\\\ 反斜线字符。\\n 新行（换行）符 (&apos;\\u000A&apos;)\\r 回车符 (&apos;\\u000D&apos;) 字符类:1234[abc] a、b 或 c（简单类）[^abc] 任何字符，除了 a、b 或 c（否定）[a-zA-Z] a到 z 或 A到 Z，两头的字母包括在内（范围）[0-9] 0到9的字符都包括 预定义字符类:1234. 任何字符。我的就是.字符本身，怎么表示呢? \\.\\d 数字：[0-9]\\w 单词字符：[a-zA-Z_0-9] 在正则表达式里面组成单词的东西必须有这些东西组成 边界匹配器:12345^ 行的开头$ 行的结尾\\b 单词边界 就是不是单词字符的地方。 举例：hello world?haha;xixi Greedy 数量词:123456X? X，一次或一次也没有X* X，零次或多次X+ X，一次或多次X&#123;n&#125; X，恰好 n 次X&#123;n,&#125; X，至少 n 次X&#123;n,m&#125; X，至少 n 次，但是不超过 m 次 常见功能：(分别用的是谁呢?)12345678910111213A:判断功能 String类的public boolean matches(String regex)B:分割功能 String类的public String[] split(String regex)C:替换功能 String类的public String replaceAll(String regex,String replacement)D:获取功能 Pattern和Matcher Pattern p = Pattern.compile(&quot;a*b&quot;); Matcher m = p.matcher(&quot;aaaaab&quot;); find():查找存不存在 group():获取刚才查找过的数据 判断:123456789101112public static booleam chackQQ(String qq)&#123; String reqex=&quot;[1-9][0-9]&#123;4,14&#125;&quot;; booleam flag=qq.matches(reqex); return flag;&#125;public static booleam chackEmail(String email)&#123; String reqex=&quot;[a-zA-Z_0-9]+@[a-zA-Z_0-9]&#123;2,6&#125;(\\\\.[a-zA-Z-0-9]&#123;2,3&#125;)+&quot;;// String reqex=&quot;\\\\w+@\\\\w&#123;2,6&#125;(\\\\.\\\\w&#123;2,3&#125;)+&quot;; booleam flag=email.matches(reqex); return flag;&#125; 分割:1234567891011121314151617181920212223242526272829303132333435363738String ages = &quot;18-24&quot;;String regex = &quot;-&quot;;String[] strArray = ages.split(regex);public static void main(String[] args) &#123; // 定义一个字符串 String s1 = &quot;aa,bb,cc&quot;; // 直接分割 String[] str1Array = s1.split(&quot;,&quot;); for (int x = 0; x &lt; str1Array.length; x++) &#123; System.out.println(str1Array[x]); &#125; System.out.println(&quot;---------------------&quot;); String s2 = &quot;aa.bb.cc&quot;; String[] str2Array = s2.split(&quot;\\\\.&quot;); for (int x = 0; x &lt; str2Array.length; x++) &#123; System.out.println(str2Array[x]); &#125; System.out.println(&quot;---------------------&quot;); String s3 = &quot;aa bb cc&quot;; String[] str3Array = s3.split(&quot; +&quot;); for (int x = 0; x &lt; str3Array.length; x++) &#123; System.out.println(str3Array[x]); &#125; System.out.println(&quot;---------------------&quot;); //硬盘上的路径，我们应该用\\\\替代\\ String s4 = &quot;E:\\\\JavaSE\\\\day14\\\\avi&quot;; String[] str4Array = s4.split(&quot;\\\\\\\\&quot;); for (int x = 0; x &lt; str4Array.length; x++) &#123; System.out.println(str4Array[x]); &#125; System.out.println(&quot;---------------------&quot;);&#125; 替换:12345678910111213141516171819202122 String类的public String replaceAll(String regex,String replacement) 使用给定的 replacement 替换此字符串所有匹配给定的正则表达式的子字符串。public class RegexDemo &#123; public static void main(String[] args) &#123; // 定义一个字符串 String s = &quot;helloqq12345worldkh622112345678java&quot;; // 我要去除所有的数字,用*给替换掉 // String regex = &quot;\\\\d+&quot;; // String regex = &quot;\\\\d&quot;; //String ss = &quot;*&quot;; // 直接把数字干掉 String regex = &quot;\\\\d+&quot;; String ss = &quot;&quot;; String result = s.replaceAll(regex, ss); System.out.println(result); &#125;&#125; 获取:123456789101112131415161718192021222324 Pattern和Matcher类的使用 模式和匹配器的基本使用顺序public class RegexDemo &#123; public static void main(String[] args) &#123; // 模式和匹配器的典型调用顺序 // 把正则表达式编译成模式对象 Pattern p = Pattern.compile(&quot;a*b&quot;); // 通过模式对象得到匹配器对象，这个时候需要的是被匹配的字符串 Matcher m = p.matcher(&quot;aaaaab&quot;); // 调用匹配器对象的功能 boolean b = m.matches(); System.out.println(b); //这个是判断功能，但是如果做判断，这样做就有点麻烦了，我们直接用字符串的方法做 String s = &quot;aaaaab&quot;; String regex = &quot;a*b&quot;; boolean bb = s.matches(regex); System.out.println(bb); &#125;&#125; find():查找存不存在 group():获取刚才查找过的数据 Math类概述Math 类包含用于执行基本数学运算的方法，如初等指数、对数、平方根和三角函数。 成员方法12345678public static int abs(int a)绝对值public static double ceil(double a)向上取整public static double floor(double a)向下取整public static int max(int a,int b) 两个数据中的大值 min自学public static double pow(double a,double b)a的b次幂public static double random()随机数public static int round(float a) 四舍五入 参数为double的自学public static double sqrt(double a)正平方根 Random类概述及其构造方法Random:产生随机数的类 构造方法1234public Random():没有给种子，用的是默认种子，是当前时间的毫秒值public Random(long seed):给出指定的种子给定种子后，每次得到的随机数是相同的。 成员方法12public int nextInt()：返回的是int范围内的随机数public int nextInt(int n):返回的是[0,n)范围的内随机数 12345678910111213public class RandomDemo &#123; public static void main(String[] args) &#123; // 创建对象 // Random r = new Random(); Random r = new Random(1111); for (int x = 0; x &lt; 10; x++) &#123; // int num = r.nextInt(); int num = r.nextInt(100) + 1; System.out.println(num); &#125; &#125;&#125; System类概述及其成员方法System类概述System 类包含一些有用的类字段和方法。它不能被实例化。 成员方法1234public static void gc()运行垃圾回收器public static void exit(int status)终止当前正在运行的 Java 虚拟机。参数用作状态码；根据惯例，非 0 的状态码表示异常终止。public static long currentTimeMillis()返回以毫秒为单位的当前时间public static void arraycopy(Object src,int srcPos,Object dest,int destPos,int length)数组复制 123456789101112131415161718192021public class Person &#123;... @Override protected void finalize() throws Throwable &#123; System.out.println(&quot;当前的对象被回收了&quot; + this); super.finalize(); &#125;&#125;public class SystemDemo &#123; public static void main(String[] args) &#123; Person p = new Person(&quot;赵雅芝&quot;, 60); System.out.println(p); p = null; // 让p不再指定堆内存 System.gc(); &#125;&#125; 12345678910111213public class SystemDemo &#123; public static void main(String[] args) &#123; // 定义数组 int[] arr = &#123; 11, 22, 33, 44, 55 &#125;; int[] arr2 = &#123; 6, 7, 8, 9, 10 &#125;; // 请大家看这个代码的意思 System.arraycopy(arr, 1, arr2, 2, 2); System.out.println(Arrays.toString(arr)); System.out.println(Arrays.toString(arr2)); &#125;&#125; 12[11, 22, 33, 44, 55][6, 7, 22, 33, 10] BigInteger类概述及其构造方法BigInteger:可以让超过Integer范围内的数据进行运算 构造方法1BigInteger(String val) 1234567891011121314151617public class BigIntegerDemo &#123; public static void main(String[] args) &#123; // 这几个测试，是为了简单超过int范围内，Integer就不能再表示，所以就更谈不上计算了。 // Integer i = new Integer(100); // System.out.println(i); // // System.out.println(Integer.MAX_VALUE); // Integer ii = new Integer(&quot;2147483647&quot;); // System.out.println(ii); // // NumberFormatException // Integer iii = new Integer(&quot;2147483648&quot;); // System.out.println(iii); // 通过大整数来创建对象 BigInteger bi = new BigInteger(&quot;2147483648&quot;); System.out.println(&quot;bi:&quot; + bi); &#125;&#125; 成员方法12345public BigInteger add(BigInteger val):加public BigInteger subtract(BigInteger val):减public BigInteger multiply(BigInteger val):乘public BigInteger divide(BigInteger val):除public BigInteger[] divideAndRemainder(BigInteger val):返回商和余数的数组 BigDecimal类概述及其构造方法因为float类型的数据存储和整数不一样导致的。它们大部分的时候，都是带有有效数字位。由于在运算的时候，float类型和double很容易丢失精度，演示案例。所以，为了能精确的表示、计算浮点数，Java提供了BigDecimalBigDecimal类：不可变的、任意精度的有符号十进制数,可以解决数据丢失问题。 成员方法12345public BigDecimal add(BigDecimal augend)public BigDecimal subtract(BigDecimal subtrahend)public BigDecimal multiply(BigDecimal multiplicand)public BigDecimal divide(BigDecimal divisor)public BigDecimal divide(BigDecimal divisor,int scale,int roundingMode):商，几位小数，如何舍取 Date类概述及其方法Date类概述类 Date 表示特定的瞬间，精确到毫秒。 构造方法12Date():根据当前的默认毫秒值创建日期对象Date(long date)：根据给定的毫秒值创建日期对象 成员方法12public long getTime():获取时间，以毫秒为单位public void setTime(long time):设置时间 DateFormat类概述及其方法DateForamt:可以进行日期和字符串的格式化和解析，但是由于是抽象类，所以使用具体子类SimpleDateFormat。 构造方法12public SimpleDateFormat():默认模式public SimpleDateFormat(String pattern):给定的模式 成员方法12345678public final String format(Date date) Date -- String(格式化)public Date parse(String source) String -- Date(解析)年 y月 M日 d时 H分 m秒 s 1234567891011121314151617public class DateFormatDemo &#123; public static void main(String[] args) throws ParseException &#123; Date d = new Date(); SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy年MM月dd日 HH:mm:ss&quot;); String s = sdf.format(d); System.out.println(s); String str = &quot;2008-08-08 12:12:12&quot;; //在把一个字符串解析为日期的时候，请注意格式必须和给定的字符串格式匹配 SimpleDateFormat sdf2 = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;); Date dd = sdf2.parse(str); System.out.println(dd); &#125;&#125; Calendar类概述及其方法Calendar:它为特定瞬间与一组诸如 YEAR、MONTH、DAY_OF_MONTH、HOUR 等 日历字段之间的转换提供了一些方法，并为操作日历字段（例如获得下星期的日期）提供了一些方法。 成员方法1234public static Calendar getInstance()本质返回的是子类对象public int get(int field)public void add(int field,int amount):根据给定的日历字段和对应的时间，来对当前的日历进行操作。public final void set(int year,int month,int date)设置当前日历的年月日 1234567891011121314151617181920212223242526272829303132333435public class CalendarDemo &#123; public static void main(String[] args) &#123; // 获取当前的日历时间 Calendar c = Calendar.getInstance(); // 获取年 int year = c.get(Calendar.YEAR); // 获取月 int month = c.get(Calendar.MONTH); // 获取日 int date = c.get(Calendar.DATE); System.out.println(year + &quot;年&quot; + (month + 1) + &quot;月&quot; + date + &quot;日&quot;); // 5年后的10天前 c.add(Calendar.YEAR, 5); c.add(Calendar.DATE, -10); // 获取年 year = c.get(Calendar.YEAR); // 获取月 month = c.get(Calendar.MONTH); // 获取日 date = c.get(Calendar.DATE); System.out.println(year + &quot;年&quot; + (month + 1) + &quot;月&quot; + date + &quot;日&quot;); System.out.println(&quot;--------------&quot;); c.set(2011, 11, 11); // 获取年 year = c.get(Calendar.YEAR); // 获取月 month = c.get(Calendar.MONTH); // 获取日 date = c.get(Calendar.DATE); System.out.println(year + &quot;年&quot; + (month + 1) + &quot;月&quot; + date + &quot;日&quot;); &#125;&#125; Runtime类Runtime:每个 Java 应用程序都有一个 Runtime 类实例，使应用程序能够与其运行的环境相连接。1234567891011121314151617181920exec(String command)public class RuntimeDemo &#123; public static void main(String[] args) throws IOException &#123; Runtime r = Runtime.getRuntime();// r.exec(&quot;winmine&quot;); // r.exec(&quot;notepad&quot;); // r.exec(&quot;calc&quot;);// r.exec(&quot;shutdown -s -t 10000&quot;); r.exec(&quot;shutdown -a&quot;); &#125;&#125;class Runtime &#123; private Runtime() &#123;&#125; private static Runtime currentRuntime = new Runtime(); public static Runtime getRuntime() &#123; return currentRuntime; &#125;&#125;","categories":[],"tags":[{"name":"java基础","slug":"java基础","permalink":"http://yoursite.com/tags/java基础/"}],"keywords":[]},{"title":"位运算","slug":"位运算","date":"2019-09-03T10:35:53.851Z","updated":"2019-09-03T10:44:50.502Z","comments":true,"path":"2019/09/03/位运算/","link":"","permalink":"http://yoursite.com/2019/09/03/位运算/","excerpt":"","text":"Demo1:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859/* 位运算符： &amp;,|,^,~ &lt;&lt;,&gt;&gt;,&gt;&gt;&gt; 注意： 要做位运算，首先要把数据转换为二进制。*/class OperatorDemo &#123; public static void main(String[] args) &#123; //&amp;,|,^,~ int a = 3; int b = 4; System.out.println(3 &amp; 4); System.out.println(3 | 4); System.out.println(3 ^ 4); System.out.println(~3); &#125;&#125;/* 分析：因为是位运算，所以我们必须先把数据换算成二进制。 3的二进制：11 00000000 00000000 00000000 00000011 4的二进制：100 00000000 00000000 00000000 00000100 &amp;位与运算：有0则0。 00000000 00000000 00000000 00000011 &amp;00000000 00000000 00000000 00000100 ----------------------------------- 00000000 00000000 00000000 00000000 结果是：0 |位或运算：有1则1。 00000000 00000000 00000000 00000011 |00000000 00000000 00000000 00000100 ----------------------------------- 00000000 00000000 00000000 00000111 结果是：7 ^位异或运算：相同则0，不同则1。 00000000 00000000 00000000 00000011 &amp;00000000 00000000 00000000 00000100 ----------------------------------- 00000000 00000000 00000000 00000111 结果是：7 ~按位取反运算符：0变1，1变0 00000000 00000000 00000000 00000011 ~11111111 11111111 11111111 11111100 (补码) 补码：11111111 11111111 11111111 11111100 反码：11111111 11111111 11111111 11111011 原码：10000000 00000000 00000000 00000100 结果是：-4*/ Demo2:123456789101112/* ^的特点：一个数据对另一个数据位异或两次，该数本身不变。*/class OperatorDemo2 &#123; public static void main(String[] args) &#123; int a = 10; int b = 20; System.out.println(a ^ b ^ b); //10 System.out.println(a ^ b ^ a); //20 &#125;&#125; Demo3:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556/* &lt;&lt;:左移 左边最高位丢弃，右边补齐0 &gt;&gt;:右移 最高位是0，左边补齐0；最高为是1，左边补齐1 &gt;&gt;&gt;:无符号右移 无论最高位是0还是1，左边补齐0 面试题： 请用最有效率的方式写出计算2乘以8的结果? 2 * 8 2 &lt;&lt; 3*/class OperatorDemo3 &#123; public static void main(String[] args) &#123; //&lt;&lt; 把&lt;&lt;左边的数据乘以2的移动次幂 System.out.println(3 &lt;&lt; 2); //3*2^2 = 3*4 = 12; //&gt;&gt; 把&gt;&gt;左边的数据除以2的移动次幂 System.out.println(24 &gt;&gt; 2); //24 / 2^2 = 24 / 4 = 6 System.out.println(24 &gt;&gt;&gt; 2); System.out.println(-24 &gt;&gt; 2); System.out.println(-24 &gt;&gt;&gt; 2); &#125;&#125;/* 计算出3的二进制：11 00000000 00000000 00000000 00000011 (00)000000 00000000 00000000 0000001100 &gt;&gt;的移动： 计算出24的二进制：11000 原码：10000000 00000000 00000000 00011000 反码：11111111 11111111 11111111 11100111 补码：11111111 11111111 11111111 11101000 11111111 11111111 11111111 11101000 1111111111 11111111 11111111 111010(00) 补码 补码：1111111111 11111111 11111111 111010 反码：1111111111 11111111 11111111 111001 原码：1000000000 00000000 00000000 000110 结果：-6 &gt;&gt;&gt;的移动： 计算出24的二进制：11000 原码：10000000 00000000 00000000 00011000 反码：11111111 11111111 11111111 11100111 补码：11111111 11111111 11111111 11101000 11111111 11111111 11111111 11101000 0011111111 11111111 11111111 111010(00) 结果：*/ Demo4:123456789101112131415161718192021222324252627282930313233343536373839404142/* 实现两个整数变量的交换*/class OperatorTest &#123; public static void main(String[] args) &#123; int a = 10; int b = 20; System.out.println(&quot;a:&quot;+a+&quot;,b:&quot;+b); //方式1：使用第三方变量(开发中用的) /* int c = a; a = b; b = c; System.out.println(&quot;a:&quot;+a+&quot;,b:&quot;+b); System.out.println(&quot;------------&quot;); */ //方式2：用位异或实现 //左边：a,b,a //右边：a ^ b /* a = a ^ b; b = a ^ b; //a ^ b ^ b = a a = a ^ b; //a ^ b ^ a = b System.out.println(&quot;a:&quot;+a+&quot;,b:&quot;+b); */ //方式3：用变量相加的做法 /* a = a + b; //a=30 b = a - b; //b=10 a = a - b; //a=20 System.out.println(&quot;a:&quot;+a+&quot;,b:&quot;+b); */ //方式4：一句话搞定 b = (a+b) - (a=b); //b=30-20=10,a=20 System.out.println(&quot;a:&quot;+a+&quot;,b:&quot;+b); &#125;&#125;","categories":[],"tags":[{"name":"java基础","slug":"java基础","permalink":"http://yoursite.com/tags/java基础/"}],"keywords":[]},{"title":"高并发解决方案","slug":"高并发解决方案","date":"2019-08-25T10:31:43.530Z","updated":"2019-08-25T12:52:32.080Z","comments":true,"path":"2019/08/25/高并发解决方案/","link":"","permalink":"http://yoursite.com/2019/08/25/高并发解决方案/","excerpt":"","text":"高并发处理思路与手段扩容 123随着并发线程的增加，从几十到几百，几千，几万垂直扩展：可能就得考虑给系统增内存水平扩展：复杂一点可能要增服务器来分担压力 缓存特征、场景及组件介绍 123456789101112131415适合读多写少的场景，实时性越低越适合缓存在相同key和请求数的情况下，缓存的时间越长命中率越高。缓存的粒度越小，命中率越高。当缓存当个对象时，比如单个用户信息，只有当该对象对应的数据发生变化的时候我们才要更新缓存或者移除缓存。而当缓存一个集合时，例如我们要缓存所有用户数据，期中任何一个对象当中的数据发生变化时，我们都要更新或移除缓存。还有另一种情况，假设其他地方也要获取该对象对应的数据时，比如也要获取单个用户信息，如果缓存的是单个对象，那么就可以直接命中缓存，否则就无法直接命中。此外，缓存的更新过期策略也直接影响到缓存的命中率，当数据发生变化时，直接更新缓存的值会比移除缓存或让缓存过期的命中率更高，当然这个时候的系统复杂度也会变得更高。缓存的容量有限，就容易引起缓存失效和被淘汰，目前多数的缓存框架或中间件都采用LRU算法。同时缓存的技术选型也是至关重要的，比如采用应用内置的本地缓存，比较容易出现单机瓶颈，而采用分布式缓存则容易拓展，所以需要做好系统容量规划，并考虑是否可拓展。此外，不同的缓存框架和中间件的效率和稳定性也是存在一定的差异，还有一些会影响到缓存命中率的因素，比如当缓存节点发生故障时，需要避免缓存失效并最大化程度降低影响，业内比较典型的做法就是通过一致性哈希算法或者节点冗余的方式来避免这个问题，并发越高，缓存的收益越高，即使缓存的时间很短。需要应用尽可能的通过缓存来直接获取数据并避免缓存失效，尽可能的聚集在高频访问且时效性不高的热点业务上，通过缓存预加载，增加存储容量，调整缓存粒度，更新缓存等手段来提高命中率。对于时效性很高或缓存空间有限的情况下内容跨度越大或者访问很随机并且访问量不高的业务来说，缓存命中率可能会长期的很低，可能预热后的缓存还没来得及访问就过期了。 12345678910111213redis是远程内存数据库，非关系型数据库，性能强劲，具有复制特性，解决问题而生的独一无二的数据模型，存储键值对与5种不同类型的值之间的映射，可以将存储在内存的键值对数据持久化到硬盘，可以使用复制特性来拓展读性能，还可以使用客户端分片来拓展写性能。特点：支持数据的持久化，可以将数据保存到磁盘里，重启的时候可以再次加载进行使用，redis不仅支持简单的key,value数据，同时它还提供特殊类型的存储如：list，hash支持数据的备份，即master slave模式（主从数据备份）性能极高：读的速度 11万次/s 写的速度 81000次/s丰富的数据类型原子性支持对多个操作后的原子性执行支持publish,subscribe，key过期等等特性场景：取最新n个操作；排行榜（取top N 操作）精准设置过期的应用；应用于计数器；做唯一性检查的操作；实时系统；队列系统 高并发场景问题及实战讲解 123在高并发的场景下，如果某个key被高并发的访问，没有被命中，出于对容错性的考虑，可以尝试去后端数据库获取，从而达到了大量请求到达数据库，而当该key对应的数据本身就是空的情况下，这就导致数据库中并发的执行了很多不必要的查询操作，从而导致了巨大的冲击和压力。我们可以缓存空对象，对查询结果为空的对象也进行缓存，如果是集合的话，可以缓存一个空的集合，但不是null，如果是缓存单个对象，则可以通过字段标识来区分，避免请求穿透到后端数据库，同时也需要保证缓存数据的时效性，这种方式实现起来成本较低，比较适合命中不高，但比较频繁更新的数据。单独过滤处理，对所有可能对应数据为空的key进行统一的存放，并在请求前做拦截，这样避免请求穿透到后端的数据库，这种方式实现起来相对复杂一些，比较适合命中不高但是更新不频繁的数据。 123456由于缓存的原因导致大量的请求到达后端数据库而导致数据库奔溃整个系统奔溃发生灾难。导致的原因有很多种，比如提到的缓存并发，缓存穿透，缓存抖动，都有可能造成缓存雪崩的现象。这些问题也可能被恶意攻击者利用，还有一种情况，例如某个时间点内，系统预加载的缓存周期性的集中失效了，也有可能导致雪崩。为了避免这种周期性的失效，可以通过设置不同的过期时间来错开他们的缓存过期时间，从而避免缓存集中失效。从应用架构角度，我们可以通过限流，降级，熔断等手段来降低影响，也可以通过多级缓存来避免这种灾难。此外，从整个研发体系流程角度，应该多加强压力测试，尽量模拟真实场景，尽早暴露问题，从而进行防范。 参考:http://www.imooc.com/article/20918 消息队列 业务解耦1234所谓解耦，本质上讲的就是一个事务只关心简单的流程，而需要依赖其它的系统但不那么重要的事情，有通知即可无需等待结果。基于消息的模型关心的是通知，不是处理。如：对于订单系统，用户支付成功之后，我们可能需要给用户发送一条短信通知。但其实呢，这已经不是系统的核心流程了。如果外部系统偏慢，比如短信网关速度不好，那么主流程的时间就会加强很多，用户肯定不想点击支付之后几分钟才看到结果，那么我们只需通知短信系统我们支付成功了，去发送短信通知就好了，并不一定要等待它处理完成才结束。 最终一致性12345678910111213141516指的是两个系统的状态保持一致，要么都成功，要么都失败。当然了，有个时间限制，理论上是越快越好。但实际上各种异常的情况下，可能会有一定的延迟达到最终的一致状态。但最后两个系统的状态还是要一样的。如：转账功能，A系统扣钱成功，B系统加钱一定也要成功。反之，它们就一起回滚，像什么都没发生一样，然而这个过程中存在很多可能的意外，比如：1.A系统扣钱成功，调用B系统加钱失效2.A扣钱成功，调用B系统加钱接口虽然成功，但是获取最终结果的时候网络异常引起的超时3.A扣钱成功，但B系统加钱失效了，A系统想回滚刚才扣除的钱，但是系统宕机了，无法回滚通过这三个场景，我们看出了想把这件看似简单的事情做成真的不容易，所有跨JVM一致性的问题，从技术的角度讲，通用的解决方法包括两个：1.强一致性分布式事务，落地太难，而且成本太高，我们就不做具体介绍了。2.最终一致性也是消息队列可以使用的场景，主要是用记录和补偿的方式来处理，在做所有的不确定事情之前，先把事情记录下来，然后去做不确定的事，它的结果通常分三种：成功/失败/不确定（超时等等可以等价为失败）如果是成功的话，就可以把我们记录的东西清理掉，对于失败和不确定，我们可以依靠定时任务等方式把所有失败的事情重新做一遍，知道成功为止。系统在A扣钱成功的情况下，需要给B通知的这件事情记录在库中，为了保证最高的可靠性，也可以把通知B系统加钱和扣钱成功这两件事情维护在一个本地事务里面。通知成功，则删除这条记录，通知失败或不确定则依靠定时任务可尝试地通知我们，直到我们把状态更加为正确的为止。这时，可能会遇到重复消息的问题，需要处理消息的地方做好幂等操作。最终一致性不是消息队列必备的特性。但确实可以依靠队列来做最终一致性的事情。需要注意的是，像kafka等消息队列，它的设计层面上有丢消息的可能，比如定时刷盘，如果掉列会丢消息的可能等等。哪怕只丢千分之一的消息，业务也要通过其它手段来保证结果的正确。 广播1如果没有队列，每当一个新的业务方介入，我们都要联调一次新接口，有了消息队列，我们只需要关心消息是否达到消息队列，新接入的接口订阅相关的消息，自己去做处理就可以了。 错峰和流控1234567上下游对性能处理能力是不同的，比如：Web前端每秒承受上千万的请求并不是什么神奇的事情，只需要多加一点机器，再搭建一些LVS负载均衡设备和nginx服务器即可。但是，数据库处理却是十分有限，即使使用了SSD加上分库分表单机处理能力仍然有限，出于成本考虑，我们不能奢求数据库的机器数量追上前端。这种问题同样出现于系统和系统之间，比如短信系统可能由于短板效应，速度卡在网关上，比如每秒几百次请求，它跟前端的并发量不是一个数量级的，但是，用户晚个半分钟左右收到短信一般也不会有太大问题，如果没有消息队列，两个系统之间通过协商，滑动窗口等方案也不是不能实现。但是，系统的复杂性将会成指数性增长。势必在上游或下游做些存储，并且要处理定时、阻塞等一些列问题，而且每当处理能力有些差异的时候，都需要单独开发一套逻辑来维护这套逻辑。所以，利用中间系统，如消息队列转储两个系统的消息内容，并在下游系统有能力处理这些消息的时候再处理，是一套相对比较通用的方式。总而言之，对于需要强事务保证，而且延迟很敏感的，RPC是优于队列的，对于一些无关痛痒或者一些对于别人很重要，但对于自己不是那么关心的事情可以利用消息队列去做。支持最终一致性的消息队列能够用来处理延迟不那么敏感的分布式事务场景，而且相对于笨重的分布式事务可能是更优的处理方式。 应用拆分 应用限流 服务降级与服务熔断 12对一些服务，界面有策略地降级以此缓解保证了部分甚至大部分客户能得到正确的响应，简单来说，如果当前请求处理不了了或者出错了，我给一个默认的返回，根据不同的接口做不同的默认返回和定制 1熔断是指软件系统里由于某些原因使得服务出现了过载的现象，为了防止整个系统出现故障，从而采用的一种保护措施，所以很多地方也把熔断称为过载保护 数据库切库、分库、分表","categories":[],"tags":[{"name":"并发编程与高并发解决方案","slug":"并发编程与高并发解决方案","permalink":"http://yoursite.com/tags/并发编程与高并发解决方案/"}],"keywords":[]},{"title":"并发编程","slug":"并发编程与高并发解决方案","date":"2019-08-25T03:46:27.324Z","updated":"2019-08-25T04:12:28.561Z","comments":true,"path":"2019/08/25/并发编程与高并发解决方案/","link":"","permalink":"http://yoursite.com/2019/08/25/并发编程与高并发解决方案/","excerpt":"","text":"准备 基本概念 CPU多级缓存 JAVA内存模型 并发的优势与风险 线程安全性 原子性 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051import lombok.extern.slf4j.Slf4j;import java.util.concurrent.CountDownLatch;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;import java.util.concurrent.Semaphore;import java.util.concurrent.atomic.AtomicInteger;import java.util.concurrent.atomic.AtomicLong;import java.util.concurrent.atomic.LongAdder;@Slf4j@ThreadSafepublic class AtomicExample1 &#123; // 请求总数 public static int clientTotal = 5000; // 同时并发执行的线程数 public static int threadTotal = 200; public static AtomicInteger count = new AtomicInteger(0); // public static AtomicLong count = new AtomicLong(0); // public static LongAdder count = new LongAdder(); public static void main(String[] args) throws Exception &#123; ExecutorService executorService = Executors.newCachedThreadPool(); final Semaphore semaphore = new Semaphore(threadTotal); final CountDownLatch countDownLatch = new CountDownLatch(clientTotal); for (int i = 0; i &lt; clientTotal ; i++) &#123; executorService.execute(() -&gt; &#123; try &#123; semaphore.acquire(); add(); semaphore.release(); &#125; catch (Exception e) &#123; log.error(&quot;exception&quot;, e); &#125; countDownLatch.countDown(); &#125;); &#125; countDownLatch.await(); executorService.shutdown(); log.info(&quot;count:&#123;&#125;&quot;, count.get()); &#125; private static void add() &#123; count.incrementAndGet(); // count.getAndIncrement(); // count.increment(); &#125;&#125; 123456789101112131415161718192021222324import lombok.extern.slf4j.Slf4j;import java.util.concurrent.CountDownLatch;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;import java.util.concurrent.Semaphore;import java.util.concurrent.atomic.AtomicReference;import java.util.concurrent.atomic.LongAdder;@Slf4j@ThreadSafepublic class AtomicExample4 &#123; private static AtomicReference&lt;Integer&gt; count = new AtomicReference&lt;&gt;(0); public static void main(String[] args) &#123; count.compareAndSet(0, 2); // 2 count.compareAndSet(0, 1); // no count.compareAndSet(1, 3); // no count.compareAndSet(2, 4); // 4 count.compareAndSet(3, 5); // no log.info(&quot;count:&#123;&#125;&quot;, count.get()); &#125;&#125; 1234567891011121314151617181920212223242526272829import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;import lombok.Getter;import lombok.extern.slf4j.Slf4j;@Slf4jpublic class AtomicExample5 &#123; private static AtomicIntegerFieldUpdater&lt;AtomicExample5&gt; updater = AtomicIntegerFieldUpdater.newUpdater(AtomicExample5.class, &quot;count&quot;); @Getter public volatile int count = 100; public static void main(String[] args) &#123; AtomicExample5 example5 = new AtomicExample5(); if (updater.compareAndSet(example5, 100, 120)) &#123; log.info(&quot;update success 1, &#123;&#125;&quot;, example5.getCount()); &#125; if (updater.compareAndSet(example5, 100, 120)) &#123; log.info(&quot;update success 2, &#123;&#125;&quot;, example5.getCount()); &#125; else &#123; log.info(&quot;update failed, &#123;&#125;&quot;, example5.getCount()); &#125; &#125;&#125; 结果:1223:15:33.084 [main] INFO com.mmall.concurrency.example.atomic.AtomicExample5 - update success 1, 12023:15:33.089 [main] INFO com.mmall.concurrency.example.atomic.AtomicExample5 - update failed, 120 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647import lombok.extern.slf4j.Slf4j;import java.util.concurrent.CountDownLatch;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;import java.util.concurrent.Semaphore;import java.util.concurrent.atomic.AtomicBoolean;@Slf4j@ThreadSafepublic class AtomicExample6 &#123; private static AtomicBoolean isHappened = new AtomicBoolean(false); // 请求总数 public static int clientTotal = 5000; // 同时并发执行的线程数 public static int threadTotal = 200; public static void main(String[] args) throws Exception &#123; ExecutorService executorService = Executors.newCachedThreadPool(); final Semaphore semaphore = new Semaphore(threadTotal); final CountDownLatch countDownLatch = new CountDownLatch(clientTotal); for (int i = 0; i &lt; clientTotal ; i++) &#123; executorService.execute(() -&gt; &#123; try &#123; semaphore.acquire(); test(); semaphore.release(); &#125; catch (Exception e) &#123; log.error(&quot;exception&quot;, e); &#125; countDownLatch.countDown(); &#125;); &#125; countDownLatch.await(); executorService.shutdown(); log.info(&quot;isHappened:&#123;&#125;&quot;, isHappened.get()); &#125; private static void test() &#123; if (isHappened.compareAndSet(false, true)) &#123; log.info(&quot;execute&quot;); &#125; &#125;&#125; 结果:1223:19:09.823 [pool-1-thread-1] INFO com.mmall.concurrency.example.atomic.AtomicExample6 - execute23:19:09.840 [main] INFO com.mmall.concurrency.example.atomic.AtomicExample6 - isHappened:true 可见性 有序性 安全发布对象 123456789101112131415161718192021222324import lombok.extern.slf4j.Slf4j;@Slf4j@NotThreadSafe@NotRecommendpublic class Escape &#123; private int thisCanBeEscape = 0; public Escape () &#123; new InnerClass(); &#125; private class InnerClass &#123; public InnerClass() &#123; log.info(&quot;&#123;&#125;&quot;, Escape.this.thisCanBeEscape); &#125; &#125; public static void main(String[] args) &#123; new Escape(); &#125;&#125; 123456789101112131415161718192021import lombok.extern.slf4j.Slf4j;import java.util.Arrays;@Slf4j@NotThreadSafepublic class UnsafePublish &#123; private String[] states = &#123;&quot;a&quot;, &quot;b&quot;, &quot;c&quot;&#125;; public String[] getStates() &#123; return states; &#125; public static void main(String[] args) &#123; UnsafePublish unsafePublish = new UnsafePublish(); log.info(&quot;&#123;&#125;&quot;, Arrays.toString(unsafePublish.getStates())); unsafePublish.getStates()[0] = &quot;d&quot;; log.info(&quot;&#123;&#125;&quot;, Arrays.toString(unsafePublish.getStates())); &#125;&#125; 1234567891011121314151617181920/** * 懒汉模式 * 单例实例在第一次使用时进行创建 */@NotThreadSafepublic class SingletonExample1 &#123; // 私有构造函数 private SingletonExample1() &#123;&#125; // 单例对象 private static SingletonExample1 instance = null; // 静态的工厂方法 public static SingletonExample1 getInstance() &#123; if (instance == null) &#123; instance = new SingletonExample1(); &#125; return instance; &#125;&#125; 1234567891011121314151617/** * 饿汉模式 * 单例实例在类装载时进行创建 */@ThreadSafepublic class SingletonExample2 &#123; // 私有构造函数 private SingletonExample2() &#123;&#125; // 单例对象 private static SingletonExample2 instance = new SingletonExample2(); // 静态的工厂方法 public static SingletonExample2 getInstance() &#123; return instance; &#125;&#125; 123456789101112131415161718192021/** * 懒汉模式 * 单例实例在第一次使用时进行创建 */@ThreadSafe@NotRecommendpublic class SingletonExample3 &#123; // 私有构造函数 private SingletonExample3() &#123;&#125; // 单例对象 private static SingletonExample3 instance = null; // 静态的工厂方法 public static synchronized SingletonExample3 getInstance() &#123; if (instance == null) &#123; instance = new SingletonExample3(); &#125; return instance; &#125;&#125; 12345678910111213141516171819202122232425262728293031323334/** * 懒汉模式 -》 双重同步锁单例模式 * 单例实例在第一次使用时进行创建 */@NotThreadSafepublic class SingletonExample4 &#123; // 私有构造函数 private SingletonExample4() &#123;&#125; // 1、memory = allocate() 分配对象的内存空间 // 2、ctorInstance() 初始化对象 // 3、instance = memory 设置instance指向刚分配的内存 // JVM和cpu优化，发生了指令重排 // 1、memory = allocate() 分配对象的内存空间 // 3、instance = memory 设置instance指向刚分配的内存 // 2、ctorInstance() 初始化对象 // 单例对象 private static SingletonExample4 instance = null; // 静态的工厂方法 public static SingletonExample4 getInstance() &#123; if (instance == null) &#123; // 双重检测机制 // B synchronized (SingletonExample4.class) &#123; // 同步锁 if (instance == null) &#123; instance = new SingletonExample4(); // A - 3 &#125; &#125; &#125; return instance; &#125;&#125; 12345678910111213141516171819202122232425262728/** * 懒汉模式 -》 双重同步锁单例模式 * 单例实例在第一次使用时进行创建 */@ThreadSafepublic class SingletonExample5 &#123; // 私有构造函数 private SingletonExample5() &#123;&#125; // 1、memory = allocate() 分配对象的内存空间 // 2、ctorInstance() 初始化对象 // 3、instance = memory 设置instance指向刚分配的内存 // 单例对象 volatile + 双重检测机制 -&gt; 禁止指令重排 private volatile static SingletonExample5 instance = null; // 静态的工厂方法 public static SingletonExample5 getInstance() &#123; if (instance == null) &#123; // 双重检测机制 // B synchronized (SingletonExample5.class) &#123; // 同步锁 if (instance == null) &#123; instance = new SingletonExample5(); // A - 3 &#125; &#125; &#125; return instance; &#125;&#125; 1234567891011121314151617181920212223242526/** * 饿汉模式 * 单例实例在类装载时进行创建 */@ThreadSafepublic class SingletonExample6 &#123; // 私有构造函数 private SingletonExample6() &#123;&#125; // 单例对象 private static SingletonExample6 instance = null; static &#123; instance = new SingletonExample6(); &#125; // 静态的工厂方法 public static SingletonExample6 getInstance() &#123; return instance; &#125; public static void main(String[] args) &#123; System.out.println(getInstance().hashCode()); System.out.println(getInstance().hashCode()); &#125;&#125; 1234567891011121314151617181920212223242526272829/** * 枚举模式：最安全 */@ThreadSafe@Recommendpublic class SingletonExample7 &#123; // 私有构造函数 private SingletonExample7() &#123;&#125; public static SingletonExample7 getInstance() &#123; return Singleton.INSTANCE.getInstance(); &#125; private enum Singleton &#123; INSTANCE; private SingletonExample7 singleton; // JVM保证这个方法绝对只调用一次 Singleton() &#123; singleton = new SingletonExample7(); &#125; public SingletonExample7 getInstance() &#123; return singleton; &#125; &#125;&#125; 不可变对象 12345678910111213141516171819202122232425262728293031import com.google.common.collect.Maps;import lombok.extern.slf4j.Slf4j;import java.util.Map;@Slf4j@NotThreadSafepublic class ImmutableExample1 &#123; private final static Integer a = 1; private final static String b = &quot;2&quot;; private final static Map&lt;Integer, Integer&gt; map = Maps.newHashMap(); static &#123; map.put(1, 2); map.put(3, 4); map.put(5, 6); &#125; public static void main(String[] args) &#123;// a = 2;// b = &quot;3&quot;;// map = Maps.newHashMap(); map.put(1, 3); log.info(&quot;&#123;&#125;&quot;, map.get(1)); &#125; private void test(final int a) &#123;// a = 1; &#125;&#125; 12345678910111213141516171819202122232425import com.google.common.collect.Maps;import lombok.extern.slf4j.Slf4j;import java.util.Collections;import java.util.Map;@Slf4j@ThreadSafepublic class ImmutableExample2 &#123; private static Map&lt;Integer, Integer&gt; map = Maps.newHashMap(); static &#123; map.put(1, 2); map.put(3, 4); map.put(5, 6); map = Collections.unmodifiableMap(map); &#125; public static void main(String[] args) &#123; map.put(1, 3); log.info(&quot;&#123;&#125;&quot;, map.get(1)); &#125;&#125; 结果:12Exception in thread &quot;main&quot; java.lang.UnsupportedOperationException at java.util.Collections$UnmodifiableMap.put(Collections.java:1457) 123456789101112131415161718import com.google.common.collect.ImmutableList;import com.google.common.collect.ImmutableMap;import com.google.common.collect.ImmutableSet;@ThreadSafepublic class ImmutableExample3 &#123; private final static ImmutableList&lt;Integer&gt; list = ImmutableList.of(1, 2, 3); private final static ImmutableSet set = ImmutableSet.copyOf(list); private final static ImmutableMap&lt;Integer, Integer&gt; map = ImmutableMap.of(1, 2, 3, 4); private final static ImmutableMap&lt;Integer, Integer&gt; map2 = ImmutableMap.&lt;Integer, Integer&gt;builder() .put(1, 2).put(3, 4).put(5, 6).build(); public static void main(String[] args) &#123; System.out.println(map2.get(3)); &#125;&#125; 线程封闭 线程不安全类与写法 JodaTime:12345678910111213141516171819202122232425262728293031323334353637383940414243444546import com.mmall.concurrency.annoations.ThreadSafe;import lombok.extern.slf4j.Slf4j;import org.joda.time.DateTime;import org.joda.time.format.DateTimeFormat;import org.joda.time.format.DateTimeFormatter;import java.util.concurrent.CountDownLatch;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;import java.util.concurrent.Semaphore;@Slf4j@ThreadSafepublic class DateFormatExample3 &#123; // 请求总数 public static int clientTotal = 5000; // 同时并发执行的线程数 public static int threadTotal = 200; private static DateTimeFormatter dateTimeFormatter = DateTimeFormat.forPattern(&quot;yyyyMMdd&quot;); public static void main(String[] args) throws Exception &#123; ExecutorService executorService = Executors.newCachedThreadPool(); final Semaphore semaphore = new Semaphore(threadTotal); final CountDownLatch countDownLatch = new CountDownLatch(clientTotal); for (int i = 0; i &lt; clientTotal; i++) &#123; final int count = i; executorService.execute(() -&gt; &#123; try &#123; semaphore.acquire(); update(count); semaphore.release(); &#125; catch (Exception e) &#123; log.error(&quot;exception&quot;, e); &#125; countDownLatch.countDown(); &#125;); &#125; countDownLatch.await(); executorService.shutdown(); &#125; private static void update(int i) &#123; log.info(&quot;&#123;&#125;, &#123;&#125;&quot;, i, DateTime.parse(&quot;20180208&quot;, dateTimeFormatter).toDate()); &#125;&#125; 同步容器 Vector不是线程安全的情况:1234567891011121314151617181920212223242526272829303132333435import java.util.Vector;@NotThreadSafepublic class VectorExample2 &#123; private static Vector&lt;Integer&gt; vector = new Vector&lt;&gt;(); public static void main(String[] args) &#123; while (true) &#123; for (int i = 0; i &lt; 10; i++) &#123; vector.add(i); &#125; Thread thread1 = new Thread() &#123; public void run() &#123; for (int i = 0; i &lt; vector.size(); i++) &#123; vector.remove(i); &#125; &#125; &#125;; Thread thread2 = new Thread() &#123; public void run() &#123; for (int i = 0; i &lt; vector.size(); i++) &#123; vector.get(i); &#125; &#125; &#125;; thread1.start(); thread2.start(); &#125; &#125;&#125; ConcurrentModificationException:123456789101112131415161718192021222324252627282930313233343536373839404142import java.util.Iterator;import java.util.Vector;public class VectorExample3 &#123; // java.util.ConcurrentModificationException private static void test1(Vector&lt;Integer&gt; v1) &#123; // foreach for(Integer i : v1) &#123; if (i.equals(3)) &#123; v1.remove(i); &#125; &#125; &#125; // java.util.ConcurrentModificationException private static void test2(Vector&lt;Integer&gt; v1) &#123; // iterator Iterator&lt;Integer&gt; iterator = v1.iterator(); while (iterator.hasNext()) &#123; Integer i = iterator.next(); if (i.equals(3)) &#123; v1.remove(i); &#125; &#125; &#125; // success private static void test3(Vector&lt;Integer&gt; v1) &#123; // for for (int i = 0; i &lt; v1.size(); i++) &#123; if (v1.get(i).equals(3)) &#123; v1.remove(i); &#125; &#125; &#125; public static void main(String[] args) &#123; Vector&lt;Integer&gt; vector = new Vector&lt;&gt;(); vector.add(1); vector.add(2); vector.add(3); test1(vector); &#125;&#125; Collections.synchronizedXXX1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556import com.google.common.collect.Lists;import com.google.common.collect.Sets;import com.mmall.concurrency.annoations.ThreadSafe;import lombok.extern.slf4j.Slf4j;import java.util.Collections;import java.util.List;import java.util.Vector;import java.util.Set;import java.util.concurrent.CountDownLatch;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;import java.util.concurrent.Semaphore;@Slf4j@ThreadSafepublic class CollectionsExample1 &#123; // 请求总数 public static int clientTotal = 5000; // 同时并发执行的线程数 public static int threadTotal = 200; private static List&lt;Integer&gt; list = Collections.synchronizedList(Lists.newArrayList()); // private static Set&lt;Integer&gt; set = Collections.synchronizedSet(Sets.newHashSet()); // private static Map&lt;Integer, Integer&gt; map = Collections.synchronizedMap(new HashMap&lt;&gt;()); public static void main(String[] args) throws Exception &#123; ExecutorService executorService = Executors.newCachedThreadPool(); final Semaphore semaphore = new Semaphore(threadTotal); final CountDownLatch countDownLatch = new CountDownLatch(clientTotal); for (int i = 0; i &lt; clientTotal; i++) &#123; final int count = i; executorService.execute(() -&gt; &#123; try &#123; semaphore.acquire(); update(count); semaphore.release(); &#125; catch (Exception e) &#123; log.error(&quot;exception&quot;, e); &#125; countDownLatch.countDown(); &#125;); &#125; countDownLatch.await(); executorService.shutdown(); log.info(&quot;size:&#123;&#125;&quot;, list.size()); &#125; private static void update(int i) &#123; list.add(i); // set.add(i); // map.put(i, i); &#125;&#125; 安全共享策略 AQS Sync queue 同步队列（底层是双向链表）Condition queue 单向链表（不是必须的，需要用到的时候才会使用） aqs实现的具体大致思路:123aqs内部维护了一个clh队列来管理锁，线程会首先尝试获取锁，如果失败，就将当前线程以及等待信息包成一个node节点，加入到之前介绍的同步队列，接着会不断循环尝试获取锁，条件是，当前节点为head的直接后继才会尝试，如果失败，就会阻塞自己，直到自己被唤醒，而当持有锁的线程释放锁的时候，会唤醒队列中的后继线程，基于这些基础的设计和思路，jdk提供了很多基于aqs的子类 使用场景:123程序执行需要等待某个条件完成后才能继续执行后续的操作，典型的应用比如：并行计算当某个处理的运算量很大时，可以将该运算任务拆分成多个子任务，等待所有的子任务都完成后，父任务再拿到所有子任务的运算结果进行汇总 12345678910111213141516171819202122232425262728293031323334353637383940import lombok.extern.slf4j.Slf4j;import java.util.concurrent.CountDownLatch;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;@Slf4jpublic class CountDownLatchExample1 &#123; private final static int threadCount = 200; public static void main(String[] args) throws Exception &#123; ExecutorService exec = Executors.newCachedThreadPool(); final CountDownLatch countDownLatch = new CountDownLatch(threadCount); for (int i = 0; i &lt; threadCount; i++) &#123; final int threadNum = i; exec.execute(() -&gt; &#123; try &#123; test(threadNum); &#125; catch (Exception e) &#123; log.error(&quot;exception&quot;, e); &#125; finally &#123; countDownLatch.countDown(); &#125; &#125;); &#125; countDownLatch.await(); log.info(&quot;finish&quot;); exec.shutdown(); &#125; private static void test(int threadNum) throws Exception &#123; Thread.sleep(100); log.info(&quot;&#123;&#125;&quot;, threadNum); Thread.sleep(100); &#125;&#125; 结果:123456789101115:14:51.589 [pool-1-thread-10] INFO com.mmall.concurrency.example.aqs.CountDownLatchExample1 - 915:14:51.589 [pool-1-thread-6] INFO com.mmall.concurrency.example.aqs.CountDownLatchExample1 - 515:14:51.589 [pool-1-thread-3] INFO com.mmall.concurrency.example.aqs.CountDownLatchExample1 - 215:14:51.589 [pool-1-thread-7] INFO com.mmall.concurrency.example.aqs.CountDownLatchExample1 - 615:14:51.589 [pool-1-thread-1] INFO com.mmall.concurrency.example.aqs.CountDownLatchExample1 - 015:14:51.589 [pool-1-thread-5] INFO com.mmall.concurrency.example.aqs.CountDownLatchExample1 - 415:14:51.589 [pool-1-thread-9] INFO com.mmall.concurrency.example.aqs.CountDownLatchExample1 - 815:14:51.589 [pool-1-thread-4] INFO com.mmall.concurrency.example.aqs.CountDownLatchExample1 - 315:14:51.589 [pool-1-thread-2] INFO com.mmall.concurrency.example.aqs.CountDownLatchExample1 - 115:14:51.589 [pool-1-thread-8] INFO com.mmall.concurrency.example.aqs.CountDownLatchExample1 - 715:14:51.696 [main] INFO com.mmall.concurrency.example.aqs.CountDownLatchExample1 - finish 12345678910111213141516171819202122232425262728293031323334353637383940import java.util.concurrent.CountDownLatch;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;import java.util.concurrent.TimeUnit;import lombok.extern.slf4j.Slf4j;@Slf4jpublic class CountDownLatchExample2 &#123; private final static int threadCount = 10; public static void main(String[] args) throws Exception &#123; ExecutorService exec = Executors.newCachedThreadPool(); final CountDownLatch countDownLatch = new CountDownLatch(threadCount); for (int i = 0; i &lt; threadCount; i++) &#123; final int threadNum = i; exec.execute(() -&gt; &#123; try &#123; test(threadNum); &#125; catch (Exception e) &#123; log.error(&quot;exception&quot;, e); &#125; finally &#123; countDownLatch.countDown(); &#125; &#125;); &#125; countDownLatch.await(10, TimeUnit.MILLISECONDS); log.info(&quot;finish&quot;); exec.shutdown(); &#125; private static void test(int threadNum) throws Exception &#123; Thread.sleep(100); log.info(&quot;&#123;&#125;&quot;, threadNum); &#125;&#125; 结果:123456789101115:17:50.556 [main] INFO com.mmall.concurrency.example.aqs.CountDownLatchExample2 - finish15:17:50.644 [pool-1-thread-1] INFO com.mmall.concurrency.example.aqs.CountDownLatchExample2 - 015:17:50.644 [pool-1-thread-4] INFO com.mmall.concurrency.example.aqs.CountDownLatchExample2 - 315:17:50.644 [pool-1-thread-3] INFO com.mmall.concurrency.example.aqs.CountDownLatchExample2 - 215:17:50.644 [pool-1-thread-7] INFO com.mmall.concurrency.example.aqs.CountDownLatchExample2 - 615:17:50.644 [pool-1-thread-8] INFO com.mmall.concurrency.example.aqs.CountDownLatchExample2 - 715:17:50.644 [pool-1-thread-2] INFO com.mmall.concurrency.example.aqs.CountDownLatchExample2 - 115:17:50.645 [pool-1-thread-10] INFO com.mmall.concurrency.example.aqs.CountDownLatchExample2 - 915:17:50.644 [pool-1-thread-9] INFO com.mmall.concurrency.example.aqs.CountDownLatchExample2 - 815:17:50.644 [pool-1-thread-6] INFO com.mmall.concurrency.example.aqs.CountDownLatchExample2 - 515:17:50.644 [pool-1-thread-5] INFO com.mmall.concurrency.example.aqs.CountDownLatchExample2 - 4 使用场景:12仅能提供有限的访问资源，比如：我们项目中的数据库，数据库的最大连接数只有20，而我们的上层应用的并发数会远远大于20，如果同时对数据库进行操作，就可能会出现因为无法获取数据库连接数导致异常，这时候就可以通过信号量来做并发访问控制，当信号量semaphore把并发数控制到1时，就跟单线程运行很相似， 1234567891011121314151617181920212223242526272829303132333435363738import lombok.extern.slf4j.Slf4j;import java.util.concurrent.CountDownLatch;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;import java.util.concurrent.Semaphore;@Slf4jpublic class SemaphoreExample1 &#123; private final static int threadCount = 10; public static void main(String[] args) throws Exception &#123; ExecutorService exec = Executors.newCachedThreadPool(); final Semaphore semaphore = new Semaphore(3); for (int i = 0; i &lt; threadCount; i++) &#123; final int threadNum = i; exec.execute(() -&gt; &#123; try &#123; semaphore.acquire(); // 获取一个许可 test(threadNum); semaphore.release(); // 释放一个许可 &#125; catch (Exception e) &#123; log.error(&quot;exception&quot;, e); &#125; &#125;); &#125; exec.shutdown(); &#125; private static void test(int threadNum) throws Exception &#123; log.info(&quot;&#123;&#125;&quot;, threadNum); Thread.sleep(1000); &#125;&#125; 结果: 大概每隔1s打印3行1234567891012:14:18.188 [pool-1-thread-2] INFO com.mmall.concurrency.example.aqs.SemaphoreExample1 - 112:14:18.188 [pool-1-thread-1] INFO com.mmall.concurrency.example.aqs.SemaphoreExample1 - 012:14:18.188 [pool-1-thread-3] INFO com.mmall.concurrency.example.aqs.SemaphoreExample1 - 212:14:19.194 [pool-1-thread-4] INFO com.mmall.concurrency.example.aqs.SemaphoreExample1 - 312:14:19.194 [pool-1-thread-5] INFO com.mmall.concurrency.example.aqs.SemaphoreExample1 - 412:14:19.194 [pool-1-thread-6] INFO com.mmall.concurrency.example.aqs.SemaphoreExample1 - 512:14:20.195 [pool-1-thread-8] INFO com.mmall.concurrency.example.aqs.SemaphoreExample1 - 712:14:20.195 [pool-1-thread-9] INFO com.mmall.concurrency.example.aqs.SemaphoreExample1 - 812:14:20.195 [pool-1-thread-7] INFO com.mmall.concurrency.example.aqs.SemaphoreExample1 - 612:14:21.196 [pool-1-thread-10] INFO com.mmall.concurrency.example.aqs.SemaphoreExample1 - 9 12345678910111213141516171819202122232425262728293031323334353637import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;import java.util.concurrent.Semaphore;import lombok.extern.slf4j.Slf4j;@Slf4jpublic class SemaphoreExample2 &#123; private final static int threadCount = 10; public static void main(String[] args) throws Exception &#123; ExecutorService exec = Executors.newCachedThreadPool(); final Semaphore semaphore = new Semaphore(3); for (int i = 0; i &lt; threadCount; i++) &#123; final int threadNum = i; exec.execute(() -&gt; &#123; try &#123; semaphore.acquire(3); // 获取多个许可 test(threadNum); semaphore.release(3); // 释放多个许可 &#125; catch (Exception e) &#123; log.error(&quot;exception&quot;, e); &#125; &#125;); &#125; exec.shutdown(); &#125; private static void test(int threadNum) throws Exception &#123; log.info(&quot;&#123;&#125;&quot;, threadNum); Thread.sleep(1000); &#125;&#125; 结果: 大概每隔1s打印1行1234567891012:17:05.304 [pool-1-thread-1] INFO com.mmall.concurrency.example.aqs.SemaphoreExample2 - 012:17:06.310 [pool-1-thread-2] INFO com.mmall.concurrency.example.aqs.SemaphoreExample2 - 112:17:07.310 [pool-1-thread-3] INFO com.mmall.concurrency.example.aqs.SemaphoreExample2 - 212:17:08.310 [pool-1-thread-4] INFO com.mmall.concurrency.example.aqs.SemaphoreExample2 - 312:17:09.311 [pool-1-thread-5] INFO com.mmall.concurrency.example.aqs.SemaphoreExample2 - 412:17:10.312 [pool-1-thread-6] INFO com.mmall.concurrency.example.aqs.SemaphoreExample2 - 512:17:11.312 [pool-1-thread-7] INFO com.mmall.concurrency.example.aqs.SemaphoreExample2 - 612:17:12.313 [pool-1-thread-8] INFO com.mmall.concurrency.example.aqs.SemaphoreExample2 - 712:17:13.314 [pool-1-thread-9] INFO com.mmall.concurrency.example.aqs.SemaphoreExample2 - 812:17:14.314 [pool-1-thread-10] INFO com.mmall.concurrency.example.aqs.SemaphoreExample2 - 9 123456789101112131415161718192021222324252627282930313233343536373839import lombok.extern.slf4j.Slf4j;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;import java.util.concurrent.Semaphore;import java.util.concurrent.TimeUnit;@Slf4jpublic class SemaphoreExample3 &#123; private final static int threadCount = 20; public static void main(String[] args) throws Exception &#123; ExecutorService exec = Executors.newCachedThreadPool(); final Semaphore semaphore = new Semaphore(3); for (int i = 0; i &lt; threadCount; i++) &#123; final int threadNum = i; exec.execute(() -&gt; &#123; try &#123; if (semaphore.tryAcquire()) &#123; // 尝试获取一个许可 test(threadNum); semaphore.release(); // 释放一个许可 &#125; &#125; catch (Exception e) &#123; log.error(&quot;exception&quot;, e); &#125; &#125;); &#125; exec.shutdown(); &#125; private static void test(int threadNum) throws Exception &#123; log.info(&quot;&#123;&#125;&quot;, threadNum); Thread.sleep(1000); &#125;&#125; 结果:12312:19:05.556 [pool-1-thread-3] INFO com.mmall.concurrency.example.aqs.SemaphoreExample3 - 212:19:05.556 [pool-1-thread-1] INFO com.mmall.concurrency.example.aqs.SemaphoreExample3 - 012:19:05.556 [pool-1-thread-2] INFO com.mmall.concurrency.example.aqs.SemaphoreExample3 - 1 123456789101112131415161718192021222324252627282930313233343536373839import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;import java.util.concurrent.Semaphore;import java.util.concurrent.TimeUnit;import lombok.extern.slf4j.Slf4j;@Slf4jpublic class SemaphoreExample4 &#123; private final static int threadCount = 10; public static void main(String[] args) throws Exception &#123; ExecutorService exec = Executors.newCachedThreadPool(); final Semaphore semaphore = new Semaphore(3); for (int i = 0; i &lt; threadCount; i++) &#123; final int threadNum = i; exec.execute(() -&gt; &#123; try &#123; if (semaphore.tryAcquire(5000, TimeUnit.MILLISECONDS)) &#123; // 尝试获取一个许可 test(threadNum); semaphore.release(); // 释放一个许可 &#125; &#125; catch (Exception e) &#123; log.error(&quot;exception&quot;, e); &#125; &#125;); &#125; exec.shutdown(); &#125; private static void test(int threadNum) throws Exception &#123; log.info(&quot;&#123;&#125;&quot;, threadNum); Thread.sleep(1000); &#125;&#125; 结果: 大概每隔1s打印3行12345678910111213141512:22:58.289 [pool-1-thread-1] INFO com.mmall.concurrency.example.aqs.SemaphoreExample4 - 012:22:58.289 [pool-1-thread-3] INFO com.mmall.concurrency.example.aqs.SemaphoreExample4 - 212:22:58.289 [pool-1-thread-2] INFO com.mmall.concurrency.example.aqs.SemaphoreExample4 - 112:22:59.294 [pool-1-thread-6] INFO com.mmall.concurrency.example.aqs.SemaphoreExample4 - 512:22:59.294 [pool-1-thread-5] INFO com.mmall.concurrency.example.aqs.SemaphoreExample4 - 412:22:59.294 [pool-1-thread-4] INFO com.mmall.concurrency.example.aqs.SemaphoreExample4 - 312:23:00.294 [pool-1-thread-8] INFO com.mmall.concurrency.example.aqs.SemaphoreExample4 - 712:23:00.294 [pool-1-thread-7] INFO com.mmall.concurrency.example.aqs.SemaphoreExample4 - 612:23:00.294 [pool-1-thread-9] INFO com.mmall.concurrency.example.aqs.SemaphoreExample4 - 812:23:01.294 [pool-1-thread-11] INFO com.mmall.concurrency.example.aqs.SemaphoreExample4 - 1012:23:01.294 [pool-1-thread-10] INFO com.mmall.concurrency.example.aqs.SemaphoreExample4 - 912:23:01.294 [pool-1-thread-12] INFO com.mmall.concurrency.example.aqs.SemaphoreExample4 - 1112:23:02.295 [pool-1-thread-15] INFO com.mmall.concurrency.example.aqs.SemaphoreExample4 - 1412:23:02.295 [pool-1-thread-13] INFO com.mmall.concurrency.example.aqs.SemaphoreExample4 - 1212:23:02.295 [pool-1-thread-14] INFO com.mmall.concurrency.example.aqs.SemaphoreExample4 - 13 12345678910111213141516171819202122232425262728293031323334353637383940414243import lombok.extern.slf4j.Slf4j;import java.util.concurrent.CyclicBarrier;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;@Slf4jpublic class CyclicBarrierExample1 &#123; private static CyclicBarrier barrier = new CyclicBarrier(5); public static void main(String[] args) throws Exception &#123; ExecutorService executor = Executors.newCachedThreadPool(); for (int i = 0; i &lt; 10; i++) &#123; final int threadNum = i; Thread.sleep(1000); executor.execute(() -&gt; &#123; try &#123; race(threadNum); &#125; catch (Exception e) &#123; log.error(&quot;exception&quot;, e); &#125; &#125;); &#125; executor.shutdown(); &#125; private static void race(int threadNum) throws Exception &#123; Thread.sleep(1000); log.info(&quot;&#123;&#125; is ready&quot;, threadNum); barrier.await();/* try &#123; barrier.await(2000, TimeUnit.MILLISECONDS); &#125; catch (Exception e) &#123; log.warn(&quot;BarrierException&quot;, e); &#125;*/ log.info(&quot;&#123;&#125; continue&quot;, threadNum); &#125;&#125; 结果：123456789101112131415161718192023:57:27.925 [pool-1-thread-1] INFO com.mmall.concurrency.example.aqs.CyclicBarrierExample1 - 0 is ready23:57:28.916 [pool-1-thread-2] INFO com.mmall.concurrency.example.aqs.CyclicBarrierExample1 - 1 is ready23:57:29.917 [pool-1-thread-3] INFO com.mmall.concurrency.example.aqs.CyclicBarrierExample1 - 2 is ready23:57:30.917 [pool-1-thread-4] INFO com.mmall.concurrency.example.aqs.CyclicBarrierExample1 - 3 is ready23:57:31.918 [pool-1-thread-5] INFO com.mmall.concurrency.example.aqs.CyclicBarrierExample1 - 4 is ready23:57:31.918 [pool-1-thread-5] INFO com.mmall.concurrency.example.aqs.CyclicBarrierExample1 - 4 continue23:57:31.918 [pool-1-thread-1] INFO com.mmall.concurrency.example.aqs.CyclicBarrierExample1 - 0 continue23:57:31.918 [pool-1-thread-2] INFO com.mmall.concurrency.example.aqs.CyclicBarrierExample1 - 1 continue23:57:31.918 [pool-1-thread-3] INFO com.mmall.concurrency.example.aqs.CyclicBarrierExample1 - 2 continue23:57:31.918 [pool-1-thread-4] INFO com.mmall.concurrency.example.aqs.CyclicBarrierExample1 - 3 continue23:57:32.919 [pool-1-thread-6] INFO com.mmall.concurrency.example.aqs.CyclicBarrierExample1 - 5 is ready23:57:33.918 [pool-1-thread-4] INFO com.mmall.concurrency.example.aqs.CyclicBarrierExample1 - 6 is ready23:57:34.919 [pool-1-thread-1] INFO com.mmall.concurrency.example.aqs.CyclicBarrierExample1 - 7 is ready23:57:35.919 [pool-1-thread-2] INFO com.mmall.concurrency.example.aqs.CyclicBarrierExample1 - 8 is ready23:57:36.920 [pool-1-thread-3] INFO com.mmall.concurrency.example.aqs.CyclicBarrierExample1 - 9 is ready23:57:36.920 [pool-1-thread-3] INFO com.mmall.concurrency.example.aqs.CyclicBarrierExample1 - 9 continue23:57:36.920 [pool-1-thread-6] INFO com.mmall.concurrency.example.aqs.CyclicBarrierExample1 - 5 continue23:57:36.920 [pool-1-thread-4] INFO com.mmall.concurrency.example.aqs.CyclicBarrierExample1 - 6 continue23:57:36.920 [pool-1-thread-1] INFO com.mmall.concurrency.example.aqs.CyclicBarrierExample1 - 7 continue23:57:36.920 [pool-1-thread-2] INFO com.mmall.concurrency.example.aqs.CyclicBarrierExample1 - 8 continue 1234567891011121314151617181920212223242526272829303132333435363738import lombok.extern.slf4j.Slf4j;import java.util.concurrent.CyclicBarrier;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;@Slf4jpublic class CyclicBarrierExample3 &#123; private static CyclicBarrier barrier = new CyclicBarrier(5, () -&gt; &#123; log.info(&quot;callback is running&quot;); &#125;); public static void main(String[] args) throws Exception &#123; ExecutorService executor = Executors.newCachedThreadPool(); for (int i = 0; i &lt; 10; i++) &#123; final int threadNum = i; Thread.sleep(1000); executor.execute(() -&gt; &#123; try &#123; race(threadNum); &#125; catch (Exception e) &#123; log.error(&quot;exception&quot;, e); &#125; &#125;); &#125; executor.shutdown(); &#125; private static void race(int threadNum) throws Exception &#123; Thread.sleep(1000); log.info(&quot;&#123;&#125; is ready&quot;, threadNum); barrier.await(); log.info(&quot;&#123;&#125; continue&quot;, threadNum); &#125;&#125; 1234567891011121314151617181920212200:00:48.622 [pool-1-thread-1] INFO com.mmall.concurrency.example.aqs.CyclicBarrierExample3 - 0 is ready00:00:49.618 [pool-1-thread-2] INFO com.mmall.concurrency.example.aqs.CyclicBarrierExample3 - 1 is ready00:00:50.618 [pool-1-thread-3] INFO com.mmall.concurrency.example.aqs.CyclicBarrierExample3 - 2 is ready00:00:51.618 [pool-1-thread-4] INFO com.mmall.concurrency.example.aqs.CyclicBarrierExample3 - 3 is ready00:00:52.617 [pool-1-thread-5] INFO com.mmall.concurrency.example.aqs.CyclicBarrierExample3 - 4 is ready00:00:52.617 [pool-1-thread-5] INFO com.mmall.concurrency.example.aqs.CyclicBarrierExample3 - callback is running00:00:52.617 [pool-1-thread-5] INFO com.mmall.concurrency.example.aqs.CyclicBarrierExample3 - 4 continue00:00:52.618 [pool-1-thread-2] INFO com.mmall.concurrency.example.aqs.CyclicBarrierExample3 - 1 continue00:00:52.618 [pool-1-thread-1] INFO com.mmall.concurrency.example.aqs.CyclicBarrierExample3 - 0 continue00:00:52.618 [pool-1-thread-3] INFO com.mmall.concurrency.example.aqs.CyclicBarrierExample3 - 2 continue00:00:52.618 [pool-1-thread-4] INFO com.mmall.concurrency.example.aqs.CyclicBarrierExample3 - 3 continue00:00:53.619 [pool-1-thread-6] INFO com.mmall.concurrency.example.aqs.CyclicBarrierExample3 - 5 is ready00:00:54.618 [pool-1-thread-4] INFO com.mmall.concurrency.example.aqs.CyclicBarrierExample3 - 6 is ready00:00:55.619 [pool-1-thread-3] INFO com.mmall.concurrency.example.aqs.CyclicBarrierExample3 - 7 is ready00:00:56.619 [pool-1-thread-2] INFO com.mmall.concurrency.example.aqs.CyclicBarrierExample3 - 8 is ready00:00:57.620 [pool-1-thread-1] INFO com.mmall.concurrency.example.aqs.CyclicBarrierExample3 - 9 is ready00:00:57.620 [pool-1-thread-1] INFO com.mmall.concurrency.example.aqs.CyclicBarrierExample3 - callback is running00:00:57.620 [pool-1-thread-1] INFO com.mmall.concurrency.example.aqs.CyclicBarrierExample3 - 9 continue00:00:57.620 [pool-1-thread-6] INFO com.mmall.concurrency.example.aqs.CyclicBarrierExample3 - 5 continue00:00:57.620 [pool-1-thread-4] INFO com.mmall.concurrency.example.aqs.CyclicBarrierExample3 - 6 continue00:00:57.620 [pool-1-thread-3] INFO com.mmall.concurrency.example.aqs.CyclicBarrierExample3 - 7 continue00:00:57.620 [pool-1-thread-2] INFO com.mmall.concurrency.example.aqs.CyclicBarrierExample3 - 8 continue synchronized:12345678910111213141516171819202122232425262728293031323334353637383940414243import lombok.extern.slf4j.Slf4j;import java.util.concurrent.CountDownLatch;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;import java.util.concurrent.Semaphore;@Slf4j@ThreadSafepublic class LockExample1 &#123; // 请求总数 public static int clientTotal = 5000; // 同时并发执行的线程数 public static int threadTotal = 200; public static int count = 0; public static void main(String[] args) throws Exception &#123; ExecutorService executorService = Executors.newCachedThreadPool(); final Semaphore semaphore = new Semaphore(threadTotal); final CountDownLatch countDownLatch = new CountDownLatch(clientTotal); for (int i = 0; i &lt; clientTotal ; i++) &#123; executorService.execute(() -&gt; &#123; try &#123; semaphore.acquire(); add(); semaphore.release(); &#125; catch (Exception e) &#123; log.error(&quot;exception&quot;, e); &#125; countDownLatch.countDown(); &#125;); &#125; countDownLatch.await(); executorService.shutdown(); log.info(&quot;count:&#123;&#125;&quot;, count); &#125; private synchronized static void add() &#123; count++; &#125;&#125; ReentrantLock:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253import lombok.extern.slf4j.Slf4j;import java.util.concurrent.CountDownLatch;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;import java.util.concurrent.Semaphore;import java.util.concurrent.locks.Lock;import java.util.concurrent.locks.ReentrantLock;@Slf4j@ThreadSafepublic class LockExample2 &#123; // 请求总数 public static int clientTotal = 5000; // 同时并发执行的线程数 public static int threadTotal = 200; public static int count = 0; private final static Lock lock = new ReentrantLock(); public static void main(String[] args) throws Exception &#123; ExecutorService executorService = Executors.newCachedThreadPool(); final Semaphore semaphore = new Semaphore(threadTotal); final CountDownLatch countDownLatch = new CountDownLatch(clientTotal); for (int i = 0; i &lt; clientTotal ; i++) &#123; executorService.execute(() -&gt; &#123; try &#123; semaphore.acquire(); add(); semaphore.release(); &#125; catch (Exception e) &#123; log.error(&quot;exception&quot;, e); &#125; countDownLatch.countDown(); &#125;); &#125; countDownLatch.await(); executorService.shutdown(); log.info(&quot;count:&#123;&#125;&quot;, count); &#125; private static void add() &#123; lock.lock(); try &#123; count++; &#125; finally &#123; lock.unlock(); &#125; &#125;&#125; ReentrantReadWriteLock:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748import lombok.extern.slf4j.Slf4j;import java.util.Map;import java.util.Set;import java.util.TreeMap;import java.util.concurrent.locks.Lock;import java.util.concurrent.locks.ReentrantReadWriteLock;@Slf4jpublic class LockExample3 &#123; private final Map&lt;String, Data&gt; map = new TreeMap&lt;&gt;(); private final ReentrantReadWriteLock lock = new ReentrantReadWriteLock(); private final Lock readLock = lock.readLock(); private final Lock writeLock = lock.writeLock(); public Data get(String key) &#123; readLock.lock(); try &#123; return map.get(key); &#125; finally &#123; readLock.unlock(); &#125; &#125; public Set&lt;String&gt; getAllKeys() &#123; readLock.lock(); try &#123; return map.keySet(); &#125; finally &#123; readLock.unlock(); &#125; &#125; public Data put(String key, Data value) &#123; writeLock.lock(); try &#123; return map.put(key, value); &#125; finally &#123; readLock.unlock(); &#125; &#125; class Data &#123;&#125;&#125; StampedLock:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657import java.util.concurrent.locks.StampedLock;public class LockExample4 &#123; class Point &#123; private double x, y; private final StampedLock sl = new StampedLock(); void move(double deltaX, double deltaY) &#123; // an exclusively locked method long stamp = sl.writeLock(); try &#123; x += deltaX; y += deltaY; &#125; finally &#123; sl.unlockWrite(stamp); &#125; &#125; //下面看看乐观读锁案例 double distanceFromOrigin() &#123; // A read-only method long stamp = sl.tryOptimisticRead(); //获得一个乐观读锁 double currentX = x, currentY = y; //将两个字段读入本地局部变量 if (!sl.validate(stamp)) &#123; //检查发出乐观读锁后同时是否有其他写锁发生？ stamp = sl.readLock(); //如果没有，我们再次获得一个读悲观锁 try &#123; currentX = x; // 将两个字段读入本地局部变量 currentY = y; // 将两个字段读入本地局部变量 &#125; finally &#123; sl.unlockRead(stamp); &#125; &#125; return Math.sqrt(currentX * currentX + currentY * currentY); &#125; //下面是悲观读锁案例 void moveIfAtOrigin(double newX, double newY) &#123; // upgrade // Could instead start with optimistic, not read mode long stamp = sl.readLock(); try &#123; while (x == 0.0 &amp;&amp; y == 0.0) &#123; //循环，检查当前状态是否符合 long ws = sl.tryConvertToWriteLock(stamp); //将读锁转为写锁 if (ws != 0L) &#123; //这是确认转为写锁是否成功 stamp = ws; //如果成功 替换票据 x = newX; //进行状态改变 y = newY; //进行状态改变 break; &#125; else &#123; //如果不能成功转换为写锁 sl.unlockRead(stamp); //我们显式释放读锁 stamp = sl.writeLock(); //显式直接进行写锁 然后再通过循环再试 &#125; &#125; &#125; finally &#123; sl.unlock(stamp); //释放读锁或写锁 &#125; &#125; &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152import lombok.extern.slf4j.Slf4j;import java.util.concurrent.CountDownLatch;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;import java.util.concurrent.Semaphore;import java.util.concurrent.locks.StampedLock;@Slf4j@ThreadSafepublic class LockExample5 &#123; // 请求总数 public static int clientTotal = 5000; // 同时并发执行的线程数 public static int threadTotal = 200; public static int count = 0; private final static StampedLock lock = new StampedLock(); public static void main(String[] args) throws Exception &#123; ExecutorService executorService = Executors.newCachedThreadPool(); final Semaphore semaphore = new Semaphore(threadTotal); final CountDownLatch countDownLatch = new CountDownLatch(clientTotal); for (int i = 0; i &lt; clientTotal ; i++) &#123; executorService.execute(() -&gt; &#123; try &#123; semaphore.acquire(); add(); semaphore.release(); &#125; catch (Exception e) &#123; log.error(&quot;exception&quot;, e); &#125; countDownLatch.countDown(); &#125;); &#125; countDownLatch.await(); executorService.shutdown(); log.info(&quot;count:&#123;&#125;&quot;, count); &#125; private static void add() &#123; long stamp = lock.writeLock(); try &#123; count++; &#125; finally &#123; lock.unlock(stamp); &#125; &#125;&#125; Condition:1234567891011121314151617181920212223242526272829303132333435363738import lombok.extern.slf4j.Slf4j;import java.util.concurrent.locks.Condition;import java.util.concurrent.locks.ReentrantLock;@Slf4jpublic class LockExample6 &#123; public static void main(String[] args) &#123; ReentrantLock reentrantLock = new ReentrantLock(); Condition condition = reentrantLock.newCondition(); new Thread(() -&gt; &#123; try &#123; reentrantLock.lock(); log.info(&quot;wait signal&quot;); // 1 condition.await(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; log.info(&quot;get signal&quot;); // 4 reentrantLock.unlock(); &#125;).start(); new Thread(() -&gt; &#123; reentrantLock.lock(); log.info(&quot;get lock&quot;); // 2 try &#123; Thread.sleep(3000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; condition.signalAll(); log.info(&quot;send signal ~ &quot;); // 3 reentrantLock.unlock(); &#125;).start(); &#125;&#125; Future:1234567891011121314151617181920212223242526272829import lombok.extern.slf4j.Slf4j;import java.util.concurrent.Callable;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;import java.util.concurrent.Future;@Slf4jpublic class FutureExample &#123; static class MyCallable implements Callable&lt;String&gt; &#123; @Override public String call() throws Exception &#123; log.info(&quot;do something in callable&quot;); Thread.sleep(5000); return &quot;Done&quot;; &#125; &#125; public static void main(String[] args) throws Exception &#123; ExecutorService executorService = Executors.newCachedThreadPool(); Future&lt;String&gt; future = executorService.submit(new MyCallable()); log.info(&quot;do something in main&quot;); Thread.sleep(1000); String result = future.get(); log.info(&quot;result：&#123;&#125;&quot;, result); &#125;&#125; FutureTask:12345678910111213141516171819202122232425import lombok.extern.slf4j.Slf4j;import java.util.concurrent.Callable;import java.util.concurrent.FutureTask;@Slf4jpublic class FutureTaskExample &#123; public static void main(String[] args) throws Exception &#123; FutureTask&lt;String&gt; futureTask = new FutureTask&lt;String&gt;(new Callable&lt;String&gt;() &#123; @Override public String call() throws Exception &#123; log.info(&quot;do something in callable&quot;); Thread.sleep(5000); return &quot;Done&quot;; &#125; &#125;); new Thread(futureTask).start(); log.info(&quot;do something in main&quot;); Thread.sleep(1000); String result = futureTask.get(); log.info(&quot;result：&#123;&#125;&quot;, result); &#125;&#125; 结果:12309:06:15.160 [main] INFO com.mmall.concurrency.example.aqs.FutureTaskExample - do something in main09:06:15.160 [Thread-0] INFO com.mmall.concurrency.example.aqs.FutureTaskExample - do something in callable09:06:20.164 [main] INFO com.mmall.concurrency.example.aqs.FutureTaskExample - result：Done JUC组件拓展 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364import lombok.extern.slf4j.Slf4j;import java.util.concurrent.ForkJoinPool;import java.util.concurrent.Future;import java.util.concurrent.RecursiveTask;@Slf4jpublic class ForkJoinTaskExample extends RecursiveTask&lt;Integer&gt; &#123; public static final int threshold = 2; private int start; private int end; public ForkJoinTaskExample(int start, int end) &#123; this.start = start; this.end = end; &#125; @Override protected Integer compute() &#123; int sum = 0; //如果任务足够小就计算任务 boolean canCompute = (end - start) &lt;= threshold; if (canCompute) &#123; for (int i = start; i &lt;= end; i++) &#123; sum += i; &#125; &#125; else &#123; // 如果任务大于阈值，就分裂成两个子任务计算 int middle = (start + end) / 2; ForkJoinTaskExample leftTask = new ForkJoinTaskExample(start, middle); ForkJoinTaskExample rightTask = new ForkJoinTaskExample(middle + 1, end); // 执行子任务 leftTask.fork(); rightTask.fork(); // 等待任务执行结束合并其结果 int leftResult = leftTask.join(); int rightResult = rightTask.join(); // 合并子任务 sum = leftResult + rightResult; &#125; return sum; &#125; public static void main(String[] args) &#123; ForkJoinPool forkjoinPool = new ForkJoinPool(); //生成一个计算任务，计算1+2+3+4 ForkJoinTaskExample task = new ForkJoinTaskExample(1, 100); //执行一个任务 Future&lt;Integer&gt; result = forkjoinPool.submit(task); try &#123; log.info(&quot;result:&#123;&#125;&quot;, result.get()); &#125; catch (Exception e) &#123; log.error(&quot;exception&quot;, e); &#125; &#125;&#125; 线程调度-线程池 1234运行的线程数量 &lt; corePoolSize 直接创建新线程来处理任务即使线程池中的其他线程是空闲的corePoolSize &lt;= 线程池的线程数量 &lt; maximumPoolSize 只有当workQueue满时才会创建新的线程处理任务corePoolSize = maximumPoolSize 创建的线程池大小是固定的，这时如果有新任务提交，workQueue没满时，把请求放到workQueue里面，等待有空闲等待线程从里面取出任务进行处理运行的线程数量 &gt; maximumPoolSize 如果workQueue满了，通过指定策略来处理这个任务 1234提交一个新的任务到线程池以后，线程池会根据当前线程池中运行的线程数量来决定该任务的处理方式1.直接切换 SynchronousQueue2.使用无界队列 LnkedBlockingQueue 能创建的最大线程数就是corePoolSize3.使用有界队列 ArrayBlockQueue 将线程的最大线程数量设置为maximumPoolSize ，降低资源的消耗 12降低系统资源的消耗（cpu使用率，操作系统资源的消耗）可以设置一个较大的队列容量，较小的线程池容量，降低线程处理任务的吞吐量提交的任务经常发生阻塞，调用设置线程最大线程数方法重新设置线程的容量，如果队列容量设置较小通常需要把线程池容量设置大一点，CPU的使用率会相对高一些 1234AbortPolicy：直接抛出异常CallerRunsPolicy：用调用者使用的线程来执行任务DiscardOldestPolicy：丢弃掉阻塞队列中最靠前的任务，并执行当前任务DiscardPolicy：直接丢弃当前任务 12345678910111213141516171819202122232425import lombok.extern.slf4j.Slf4j;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;@Slf4jpublic class ThreadPoolExample1 &#123; public static void main(String[] args) &#123; ExecutorService executorService = Executors.newCachedThreadPool(); // ExecutorService executorService = Executors.newFixedThreadPool(3); // ExecutorService executorService = Executors.newSingleThreadExecutor(); for (int i = 0; i &lt; 10; i++) &#123; final int index = i; executorService.execute(new Runnable() &#123; @Override public void run() &#123; log.info(&quot;task:&#123;&#125;&quot;, index); &#125; &#125;); &#125; executorService.shutdown(); &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738import lombok.extern.slf4j.Slf4j;import java.util.Date;import java.util.Timer;import java.util.TimerTask;import java.util.concurrent.Executors;import java.util.concurrent.ScheduledExecutorService;import java.util.concurrent.TimeUnit;@Slf4jpublic class ThreadPoolExample4 &#123; public static void main(String[] args) &#123; ScheduledExecutorService executorService = Executors.newScheduledThreadPool(1);// executorService.schedule(new Runnable() &#123;// @Override// public void run() &#123;// log.warn(&quot;schedule run&quot;);// &#125;// &#125;, 3, TimeUnit.SECONDS); executorService.scheduleAtFixedRate(new Runnable() &#123; @Override public void run() &#123; log.warn(&quot;schedule run&quot;); &#125; &#125;, 1, 3, TimeUnit.SECONDS);// executorService.shutdown(); Timer timer = new Timer(); timer.schedule(new TimerTask() &#123; @Override public void run() &#123; log.warn(&quot;timer run&quot;); &#125; &#125;, new Date(), 5 * 1000); &#125;&#125; 死锁 1234567891011避免死锁1.按顺序加锁2.加锁时间（超过一定时间就放弃该锁的请求，并释放自己占有的锁）3.死锁检测（以上两种方式都无法解决）每当一个线程获取了锁，会在线程和锁的相关数据结构中记下来，除此之外，每当有线程请求锁，也需要记录在这个数据结构中，当一个线程请求锁失败的时候，这个线程可以遍历锁的关系图，看是否有死锁发生，并决定后续操作该怎么办，具体这个结构需要大家根据实际情况去设计一下，那么，当检测出死锁的时候，线程都可以做哪些是事情呢，一个可执行的做法是释放所有锁，回退，并且等待一定时间（随机）后，之后进行重试，这个和简单的加锁超时有些类似，不一样的是，只有死锁发生了才回退而不会因为加锁请求超时了，虽然有了回退和等待，但是，如果有大量线程又同时竞争同一批锁，他们还是有可能出现重复死锁，这时候有个更好的方案，给这些线程设置优先级，让一个或几个线程回退，剩下的线程就像reantran锁一样，继续保持他们，如果赋予这些线程的优先级是固定不变的，可以在死锁发生的时候设置随机的线程优先级 并发最佳实践 spring与线程安全 HashMap与ConcurrentHashMap解析","categories":[],"tags":[{"name":"并发编程与高并发解决方案","slug":"并发编程与高并发解决方案","permalink":"http://yoursite.com/tags/并发编程与高并发解决方案/"}],"keywords":[]},{"title":"docker安装Oracle 12c","slug":"docker安装Oracle 12c","date":"2019-07-10T08:35:48.819Z","updated":"2019-07-10T08:33:12.394Z","comments":true,"path":"2019/07/10/docker安装Oracle 12c/","link":"","permalink":"http://yoursite.com/2019/07/10/docker安装Oracle 12c/","excerpt":"","text":"1.配置阿里的docker源1234cat /etc/docker/daemon.json&#123;&quot;registry-mirrors&quot;: [&quot;https://pee6w651.mirror.aliyuncs.com&quot;]&#125; 2.重启docker服务1systemctl restart docker 3.拉取镜像1docker pull sath89/oracle-12c 4.运行容器1docker run -d --name oracle -p 8080:8080 -p 1521:1521 -v $PWD/data:/mnt -e TZ=Asia/Shanghai sath89/oracle-12c 5.进行容器1docker exec -it ef7e5bc1c20e /bin/bash (ef7e5bc1c20e自己容器的ID) 6.相关操作1234567891011121314#root用户切换到oracle用户su oracle#使用sysdba登陆/u01/app/oracle-product/12.1.0/xe/bin/sqlplus / as sysdba#create tablespace 表空间名称 datafile 表空间路劲 size 3000m;SQL&gt;create tablespace bspdb datafile &apos;/u01/app/oracle/oradata/xe/bspdb.dbf&apos; size 3000m;#create user 用户名 identified by 密码 default tablespace 用户默认使用哪一个表空间;SQL&gt;create user bspdb identified by 123456 default tablespace bspdb;#grant 角色1,角色2 to 用户名;SQL&gt;grant dba, connect to bspdb; 参考：https://www.cnblogs.com/Dev0ps/p/10676930.htmlhttps://blog.csdn.net/Damionew/article/details/84566718https://www.cnblogs.com/forturn/p/9371841.html","categories":[],"tags":[{"name":"oracle","slug":"oracle","permalink":"http://yoursite.com/tags/oracle/"}],"keywords":[]},{"title":"解决SqlPlus前台程序出现中文乱码的问题","slug":"解决SqlPlus前台程序出现中文乱码的问题","date":"2019-05-24T09:22:11.891Z","updated":"2019-04-18T13:32:34.319Z","comments":true,"path":"2019/05/24/解决SqlPlus前台程序出现中文乱码的问题/","link":"","permalink":"http://yoursite.com/2019/05/24/解决SqlPlus前台程序出现中文乱码的问题/","excerpt":"","text":"第一步：12345在sqlplus中执行 select userenv(&apos;language&apos;) from dual;查看当前数据库的字符集为：SIMPLIFIED CHINESE_CHINA.ZHS16GBK。我们只需要把客户端字符集和操作系统字符集都设置成这个就行了开始-运行-CMD：SET NLS_LANG=SIMPLIFIED CHINESE_CHINA.ZHS16GBK以上参数设置只是在当前会话生效 第二步：12在环境变量中查找一个名为“NLS_LANG”的环境变量，如果找不到，则新建一个，把变量值赋值为：“SIMPLIFIED CHINESE_CHINA.ZHS16GBK” 参考：http://blog.itpub.net/26839123/viewspace-722870/","categories":[],"tags":[{"name":"oracle","slug":"oracle","permalink":"http://yoursite.com/tags/oracle/"}],"keywords":[]},{"title":"telegraf file plugin inputs","slug":"telegraf_volume","date":"2019-05-24T09:20:36.214Z","updated":"2019-05-24T08:56:27.428Z","comments":true,"path":"2019/05/24/telegraf_volume/","link":"","permalink":"http://yoursite.com/2019/05/24/telegraf_volume/","excerpt":"","text":"需要使用新增过功能的telegraf1.telegraf.conf1234567891011121314151617181920212223242526272829303132333435363738394041[global_tags][agent] interval = &quot;1h&quot; #修改成实际的抓取间隔 round_interval = true metric_batch_size = 1000 metric_buffer_limit = 10000 collection_jitter = &quot;0s&quot; flush_interval = &quot;20s&quot; flush_jitter = &quot;0s&quot; precision = &quot;&quot; debug = false quiet = false hostname = &quot;&quot; omit_hostname = false################################################################################ OUTPUTS ################################################################################[[outputs.influxdb]] urls = [&quot;http://ip:8086&quot;] #修改成实际的influxdb地址 database = &quot;volume_monitor&quot; skip_database_creation = true username = &quot;admin&quot; #有权限验证则修改用户名，否则删除该行配置 password = &quot;admin&quot; #有权限验证则修改密码，否则删除该行配置 namepass=[&quot;volume_*&quot;]################################################################################ INPUTS ################################################################################[[inputs.filecount]] name_prefix=&quot;volume_&quot; directories = [&quot;E:\\\\volume01&quot;] #实际抓取的文件目录 name = &quot;*&quot; recursive = true regular_only = true size = 0 large_file_size = 4 mtime = &quot;0s&quot; 2.启动1telegraf --config telegraf.conf --input-filter filecount --output-filter influxdb","categories":[],"tags":[{"name":"telegraf","slug":"telegraf","permalink":"http://yoursite.com/tags/telegraf/"}],"keywords":[]},{"title":"telegraf prometheus plugin inputs","slug":"telegraf_prometheus","date":"2019-05-24T09:20:24.839Z","updated":"2019-05-24T08:51:11.426Z","comments":true,"path":"2019/05/24/telegraf_prometheus/","link":"","permalink":"http://yoursite.com/2019/05/24/telegraf_prometheus/","excerpt":"","text":"Prometheus Input plugins（需要结合修改过的oracledb_exporter）安装与启动1.启动oracledb_exporter，并访问oracledb_exporter启动时指定的ip:port，确认数据无误。加载不同配置启动oracledb_exporter：oracle.conf12345678connections: - connection: userName/userPassword@ip:1521/databaseName database: databaseName instance: ip id: customId metrics: process,top_sql,session,wait_time,activity,physical_io,cache topsql: rownum: 10 oracledb_exporter -configfile=oracle.conf -web.listen-address ip:port oracle_table.conf12345678connections: - connection: userName/userPassword@ip:1521/databaseName database: databaseName instance: ip id: customId metrics: top_table,tablespace toptable: rownum: 10 oracledb_exporter -configfile=oracle_table.conf -web.listen-address ip:port 2.配置Telegraf Prometheus输入插件（对于抓取不同metric的输agent，需要不同的telegraf配置）抓取以oracle.conf启动的oracle_exporter的telegraf.conf12345678910111213141516171819202122232425262728293031323334353637383940414243[global_tags][agent] interval = &quot;60s&quot; #修改成实际的抓取间隔 round_interval = true metric_batch_size = 1000 metric_buffer_limit = 10000 collection_jitter = &quot;0s&quot; flush_interval = &quot;10s&quot; flush_jitter = &quot;0s&quot; precision = &quot;&quot; debug = false quiet = false logfile = &quot;&quot; hostname = &quot;hostname&quot; #修改成抓取的数据库所在主机名 omit_hostname = false################################################################################ OUTPUT PLUGINS ################################################################################[[outputs.influxdb]] urls = [&quot;http://ip:8086&quot;] #修改成实际的influxdb地址 database = &quot;oracledb_monitor&quot; skip_database_creation = true username = &quot;admin&quot; #有权限验证则修改用户名，否则删除该行配置 password = &quot;admin&quot; #有权限验证则修改密码，否则删除该行配置 namepass=[&quot;oracledb_*&quot;]################################################################################ PROCESSOR PLUGINS ################################################################################[[processors.converter]] [processors.converter.tags] string = [&quot;info_version&quot;, &quot;sql_text&quot;, &quot;sql_username&quot;] boolean = [&quot;info_is_rac&quot;] float = [&quot;info_uptime&quot;, &quot;info_dbtime&quot;, &quot;sql_exec&quot;]################################################################################ INPUT PLUGINS ################################################################################[[inputs.prometheus]] urls = [&quot;http://ip:9162/metrics&quot;] #修改成实际的exporter地址 response_timeout = &quot;150s&quot; 抓取以oracle_table.conf启动的oracle_exporter的telegraf.conf1234567891011121314151617181920212223242526272829303132333435363738394041[global_tags][agent] interval = &quot;24h&quot; #修改成实际的抓取间隔 round_interval = true metric_batch_size = 1000 metric_buffer_limit = 10000 collection_jitter = &quot;0s&quot; flush_interval = &quot;10s&quot; flush_jitter = &quot;0s&quot; precision = &quot;&quot; debug = false quiet = false logfile = &quot;&quot; hostname = &quot;hostname&quot; #修改成抓取的数据库所在主机名 omit_hostname = false################################################################################ OUTPUT PLUGINS ################################################################################[[outputs.influxdb]] urls = [&quot;http://ip:8086&quot;] #修改成实际的influxdb地址 database = &quot;oracledb_monitor&quot; skip_database_creation = true username = &quot;admin&quot; #有权限验证则修改用户名，否则删除该行配置 password = &quot;admin&quot; #有权限验证则修改密码，否则删除该行配置 namepass=[&quot;oracledb_*&quot;]################################################################################ PROCESSOR PLUGINS ################################################################################[[processors.converter]] [processors.converter.tags] integer = [&quot;index_bytes&quot;, &quot;lob_bytes&quot;, &quot;num_rows&quot;]################################################################################ INPUT PLUGINS ################################################################################[[inputs.prometheus]] urls = [&quot;http://ip:9162/metrics&quot;] #修改成实际的exporter地址 response_timeout = &quot;150s&quot; 3.启动telegraf收集不同exporter启动时加载不同的配置文件12telegraf --config telegraf.conf --input-filter prometheus --processor-filter converter --output-filter influxdbtelegraf --config telegraf_table.conf --input-filter prometheus --processor-filter converter --output-filter influxdb","categories":[],"tags":[{"name":"telegraf","slug":"telegraf","permalink":"http://yoursite.com/tags/telegraf/"}],"keywords":[]},{"title":"spring常用操作","slug":"spring常用操作","date":"2019-05-24T09:18:45.228Z","updated":"2019-05-15T12:17:24.726Z","comments":true,"path":"2019/05/24/spring常用操作/","link":"","permalink":"http://yoursite.com/2019/05/24/spring常用操作/","excerpt":"","text":"初始化bean时，普通成员变量获取不到@Value注解的变量值问题：12345678public class Xxx &#123; @Value(&quot;$&#123;value&#125;&quot;) private String value; private Map&lt;String, String&gt; map = new HashMap&lt;String, String&gt;()&#123;&#123; put(&quot;key&quot;, value);// value取不到值 &#125;&#125;;&#125; 修改：123456789101112public class Xxx &#123; @Value(&quot;$&#123;value&#125;&quot;) private String value; private Map&lt;String, String&gt; map; @PostConstruct private void init()&#123; map = new HashMap&lt;String, String&gt;()&#123;&#123; put(&quot;key&quot;, value); &#125;&#125;; &#125;&#125; 参考：https://blog.csdn.net/zlp1992/article/details/78346420 springboot yaml文件数组表示1array: item1, item2, item3, item4, item5 参考：https://stackoverflow.com/questions/26699385/spring-boot-yaml-configuration-for-a-list-of-strings","categories":[],"tags":[{"name":"spring","slug":"spring","permalink":"http://yoursite.com/tags/spring/"}],"keywords":[]},{"title":"oracle-monitor-topsql","slug":"oracle_top","date":"2019-04-16T12:34:53.056Z","updated":"2019-05-24T09:15:32.329Z","comments":true,"path":"2019/04/16/oracle_top/","link":"","permalink":"http://yoursite.com/2019/04/16/oracle_top/","excerpt":"","text":"最大增量（即最大Elapsed_Time的一次sql）1234567891011121314151617181920// 最近快照select * from ( SELECT m.*, TO_CHAR(dbms_lob.substr(v.sql_text, 3900)) SQL_Text FROM ( select distinct snap_id, sql_id, EXECUTIONS_DELTA, trunc(max(ELAPSED_TIME_DELTA)OVER(PARTITION BY snap_id, sql_id),0) max_elapsed, trunc(max(cpu_time_delta)OVER(PARTITION BY snap_id, sql_id),0) max_cpu from dba_hist_sqlstat t WHERE t.snap_id IN (SELECT MAX(snap_id) FROM dba_hist_sqlstat) ) M,dba_hist_sqltext v where v.sql_id(+)=m.sql_id and v.SQL_TEXT not like &apos;%v$%&apos; order by max_elapsed desc) where rownum &lt; 10; 12345678910111213141516171819202122232425-- 不区分快照，关联sql执行用户select * from ( select sqt.sql_id, sqt.max_exec, sqt.max_elapsed, su.username, TO_CHAR(dbms_lob.substr(st.sql_text, 3900)) sql_text from (select sql_id, min(snap_id) snap_id, max(executions_delta) max_exec, max(cpu_time_delta) max_cpu, NVL((MAX(elapsed_time_delta) / 1000000), to_number(null)) max_elapsed from dba_hist_sqlstat where module = &apos;tcserver.exe&apos; -- 过滤某个程序执行的sql语句 group by sql_id) sqt, dba_hist_sqltext st, (SELECT sql_id, parsing_schema_name username FROM ( SELECT t.sql_id,t.parsing_schema_name,row_number() over(partition by t.sql_id order by t.snap_id asc) rn FROM dba_hist_sqlstat t WHERE module =&apos;tcserver.exe&apos;) -- 过滤某个程序执行的sql语句 WHERE rn = 1) su where st.sql_id(+) = sqt.sql_id and su.sql_id(+) = sqt.sql_id order by nvl(sqt.max_elapsed, -1) desc, sqt.sql_id) where rownum &lt;= 10; 总量（即某条sql的总时长）123456789101112131415161718192021222324252627select * from ( select sqt.sql_id, sqt.exec Executions, nvl((sqt.elap / 1000000), to_number(null)) Elapsed_Time_s, nvl((sqt.cput / 1000000), to_number(null)) CPU_Time_s, decode(sqt.exec, 0, to_number(null), (sqt.elap / sqt.exec / 1000000)) Elap_per_Exec_s, TO_CHAR(dbms_lob.substr(st.sql_text, 3900)) SQL_Text from (select sql_id, max(module) module, sum(elapsed_time_delta) elap, sum(cpu_time_delta) cput, sum(executions_delta) exec from dba_hist_sqlstat group by sql_id) sqt, dba_hist_sqltext st where st.sql_id(+) = sqt.sql_id and st.sql_text not like &apos;%v$%&apos; order by nvl(sqt.elap, -1) desc, sqt.sql_id) where rownum &lt; 10; 12345678910111213141516171819202122select sql_id, executions, elapsed_time, cpu_time, (elapsed_time / executions ) Elap_per_Exec, TO_CHAR(dbms_lob.substr(sql_fulltext, 3900)) SQL_Textfrom (select sql_id, child_number, sql_text, elapsed_time, cpu_time, disk_reads, sql_fulltext, executions, rank () over(order by elapsed_time desc) as sql_rank from v$sql where sql_fulltext not like &apos;%v$%&apos;)where sql_rank &lt; 10; 注意： 使用TO_CHAR(dbms_lob.substr(BLOB_FIELD, 3900))将BLOB转成VARCHAR 根据情况选择查询dba_hist_sqlstat表或v$sql表 row_number() over( partition by 分组字段 order by 排序字段 desc ) oracle按某个字段分组然后从每组取出最大的一条纪录 参考：http://www.cnblogs.com/david-zhang-index/archive/2012/03/16/2399846.htmlhttp://www.dba-oracle.com/t_sql_longest_elapsed_time.htmhttp://blog.itpub.net/12679300/viewspace-2125679/https://stackoverflow.com/questions/828650/how-do-i-get-textual-contents-from-blob-in-oracle-sqlhttps://www.cnblogs.com/ryanchancrj/p/6437288.html其他情境下的sql:https://blog.csdn.net/yingwang9/article/details/80853484https://blog.csdn.net/xwnxwn/article/details/78062433","categories":[],"tags":[{"name":"oracle","slug":"oracle","permalink":"http://yoursite.com/tags/oracle/"}],"keywords":[]},{"title":"world目录，显示“错误！未定义书签”","slug":"world目录，显示“错误！未定义书签","date":"2019-04-04T06:40:18.116Z","updated":"2019-04-04T04:06:35.086Z","comments":true,"path":"2019/04/04/world目录，显示“错误！未定义书签/","link":"","permalink":"http://yoursite.com/2019/04/04/world目录，显示“错误！未定义书签/","excerpt":"","text":"解决方法：全选后CTRL+SHIFT+F9参考：https://zhidao.baidu.com/question/421631748.html","categories":[],"tags":[{"name":"office","slug":"office","permalink":"http://yoursite.com/tags/office/"}],"keywords":[]},{"title":"Drag And Drop In Angular 7","slug":"angularInDragAndDrop","date":"2019-04-04T06:36:53.285Z","updated":"2019-04-04T06:30:28.577Z","comments":true,"path":"2019/04/04/angularInDragAndDrop/","link":"","permalink":"http://yoursite.com/2019/04/04/angularInDragAndDrop/","excerpt":"","text":"resource-grouping-listhtml:123456789&lt;button nz-button nzType=&quot;primary&quot; (click)=&quot;showModal(0, null, &apos;新建分组&apos;)&quot;&gt;&lt;i nz-icon type=&quot;plus&quot;&gt;&lt;/i&gt;新建分组&lt;/button&gt;&lt;nz-table&gt;...&lt;a (click)=&quot;showModal(1, data._id, &apos;修改分组&apos;)&quot;&gt;&lt;i nz-icon type=&quot;form&quot;&gt;&lt;/i&gt;&lt;/a&gt;&lt;/nz-table&gt;&lt;nz-modal [(nzVisible)]=&quot;modalIsVisible&quot; [(nzTitle)]=&quot;modalTitle&quot; (nzOnCancel)=&quot;handleCancel()&quot; (nzOnOk)=&quot;handleOk()&quot; nzWidth=&quot;1200&quot;&gt; &lt;app-resource-grouping-form #form [resourceGroupId]=&quot;resourceGroupId&quot;&gt;&lt;/app-resource-grouping-form&gt;&lt;/nz-modal&gt; component:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849export class ResourceGroupingListComponent implements OnInit &#123; resourceGroupId: string; modalTitle = &apos;新增分组&apos;; modalIsVisible = false; modalType = 0; @ViewChild(&apos;form&apos;) form: ResourceGroupingFormComponent; constructor(private message: NzMessageService) &#123;&#125; showModal(type: number, id: string, modalTitle: string): void &#123; this.modalType = type; this.modalTitle = modalTitle; this.modalIsVisible = true; this.resourceGroupId = id; if (type === 1) &#123; this.form.initResourceData(id); &#125; &#125; handleCancel(): void &#123; this.modalIsVisible = false; if (this.modalType === 1) &#123; this.form.clearForm(); &#125; &#125; handleOk(): void &#123; if (this.modalType === 0) &#123; const params = this.form.submitForm(); if (params !== null) &#123; // 调用service添加 this.dealOkResp(resp, this.modalType, &apos;添加成功&apos;); &#125; &#125; else if (this.modalType === 1) &#123; const params = this.form.submitForm(); if (params !== null) &#123; // 调用service修改 this.dealOkResp(resp, this.modalType, &apos;修改成功&apos;); &#125; &#125; &#125; dealOkResp(resp: any, type: number, content: string) &#123; if (resp &amp;&amp; resp._id) &#123; this.modalIsVisible = false; this.message.create(&apos;success&apos;, content); // 刷新列表数据 this.form.clearForm(); &#125; &#125;&#125; resource-grouping-formhtml:1234567891011121314151617181920212223242526272829303132333435363738394041&lt;form nz-form [formGroup]=&quot;validateForm&quot; (ngSubmit)=&quot;submitForm()&quot;&gt; &lt;nz-form-item&gt; &lt;nz-form-control [nzSm]=&quot;5&quot; [nzXs]=&quot;24&quot; [nzOffset]=&quot;3&quot;&gt; &lt;nz-card style=&quot;width:200px;&quot; nzTitle=&quot;已选择的资源&quot;&gt; &lt;div class=&quot;example-container&quot;&gt; &lt;div cdkDropList id=&quot;selectedList&quot; [cdkDropListData]=&quot;selected&quot; [cdkDropListConnectedTo]=&quot;toList&quot; class=&quot;example-list&quot; (cdkDropListDropped)=&quot;drop($event)&quot;&gt; &lt;div class=&quot;example-box&quot; *ngFor=&quot;let item of selected&quot; cdkDrag [cdkDragData]=&quot;item&quot;&gt;&#123;&#123;item.title&#125;&#125; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/nz-card&gt; &lt;/nz-form-control&gt; &lt;ng-container *ngFor=&quot;let entity of resourceTypeMap | keyvalue&quot;&gt; &lt;nz-form-control [nzSm]=&quot;5&quot; [nzXs]=&quot;24&quot;&gt; &lt;nz-card style=&quot;width:200px; margin-bottom: 10px;&quot; [nzTitle]=&quot;entity.key.name&quot;&gt; &lt;div class=&quot;example-container&quot; style=&quot;overflow-y: auto;&quot;&gt; &lt;div cdkDropList [id]=&quot;entity.key.value&quot; [cdkDropListData]=&quot;entity.value&quot; [cdkDropListConnectedTo]=&quot;[&apos;selectedList&apos;]&quot; class=&quot;example-list&quot; [cdkDropListEnterPredicate]=&quot;evenPredicate&quot; (cdkDropListDropped)=&quot;drop($event)&quot;&gt; &lt;div class=&quot;example-box&quot; *ngFor=&quot;let item of entity.value&quot; cdkDrag [cdkDragData]=&quot;item&quot;&gt; &#123;&#123;item.title&#125;&#125; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/nz-card&gt; &lt;/nz-form-control&gt; &lt;/ng-container&gt; &lt;/nz-form-item&gt;&lt;/form&gt; css:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354.example-container &#123; width: 200px; max-width: 100%; display: inline-block; vertical-align: top; height: 164px;&#125;.example-list &#123; border: solid 1px #ccc; min-height: 33px; background: white; border-radius: 4px; overflow: hidden; display: block;&#125;.example-box &#123; padding: 6px 6px; border-bottom: solid 1px #ccc; color: rgba(0, 0, 0, 0.87); display: flex; flex-direction: row; align-items: center; justify-content: space-between; box-sizing: border-box; cursor: move; background: white; font-size: 14px;&#125;.cdk-drag-preview &#123; box-sizing: border-box; border-radius: 4px; box-shadow: 0 5px 5px -3px rgba(0, 0, 0, 0.2), 0 8px 10px 1px rgba(0, 0, 0, 0.14), 0 3px 14px 2px rgba(0, 0, 0, 0.12);&#125;.cdk-drag-placeholder &#123; opacity: 0;&#125;.cdk-drag-animating &#123; transition: transform 250ms cubic-bezier(0, 0, 0.2, 1);&#125;.example-box:last-child &#123; border: none;&#125;.example-list.cdk-drop-list-dragging .example-box:not(.cdk-drag-placeholder) &#123; transition: transform 250ms cubic-bezier(0, 0, 0.2, 1);&#125; component:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798export class ResourceGroupingFormComponent implements OnInit &#123; validateForm: FormGroup; selected = []; toList = []; resourceTypeMap: Map&lt;any, any[]&gt; = new Map(); resourceType = [&#123; name: &apos;主机&apos;, value: &apos;HOST&apos;, data: [&#123; key: &quot;192.168.174.170&quot;, title: &quot;192.168.174.170&quot;, type: &quot;HOST&quot; &#125;] &#125;, &#123; name: &apos;数据库&apos;, value: &apos;DATABASE&apos;, data: [&#123; key: &quot;orcl&quot;, title: &quot;192.168.174.154 orcl&quot;, type: &quot;DATABASE&quot; &#125;] &#125;]; @Input() resourceGroupId: string = null; evenPredicate(item: CdkDrag&lt;any&gt;, drop: CdkDropList) &#123; if (item.data.type === drop.id) &#123; return true; &#125; return false; &#125; drop(event: CdkDragDrop&lt;any[]&gt;) &#123; if (event.previousContainer === event.container) &#123; moveItemInArray(event.container.data, event.previousIndex, event.currentIndex); &#125; else &#123; transferArrayItem(event.previousContainer.data, event.container.data, event.previousIndex, event.currentIndex); &#125; &#125; constructor(private fb: FormBuilder) &#123;&#125; ngOnInit() &#123; this.initValidateForm(); &#125; initValidateForm() &#123; this.validateForm = this.fb.group(&#123; groupName: [null, [Validators.required]], &#125;); this.initFormData(); &#125; initFormData() &#123; this.selected = []; this.toList = []; this.resourceTypeMap = new Map&lt;any, any[]&gt;(); this.resourceType.forEach(item =&gt; &#123; this.resourceTypeMap.set(item, item.data); this.toList.push(item.value); &#125;); &#125; submitForm(): any &#123; if (this.validateForm.invalid) &#123; this.validAlarmForm(this.validateForm); return null; &#125; const resources = this.selected.map(item =&gt; new Resource(item.key, item.title, item.type)); this.setFormVal(this.validateForm, &apos;resources&apos;, resources); return this.validateForm.value; &#125; validForm(form: FormGroup) &#123; for (const key in form.controls) &#123; const control = form.controls[key]; if (control instanceof FormGroup) &#123; this.validForm(control); &#125; else if (control instanceof FormControl) &#123; control.markAsDirty(); control.updateValueAndValidity(); &#125; &#125; &#125; setFormVal(form: FormGroup, name: string, val: any) &#123; const formControl = new FormControl(); formControl.setValue(val); form.setControl(name, formControl); &#125; clearForm() &#123; this.validateForm.reset(); this.initFormData(); &#125;&#125; app.module.ts:12345import &#123; DragDropModule &#125; from &apos;@angular/cdk/drag-drop&apos;; imports: [ DragDropModule ], 参考:https://www.c-sharpcorner.com/article/drag-and-drop-using-angular-7/https://material.angular.io/cdk/drag-drop/overview其它插件:https://github.com/ObaidUrRehman/ng-drag-drop#readme","categories":[],"tags":[{"name":"angular","slug":"angular","permalink":"http://yoursite.com/tags/angular/"}],"keywords":[]},{"title":"angular基础-表单处理","slug":"angular基础-表单处理","date":"2019-03-31T04:34:41.855Z","updated":"2019-03-31T04:34:03.538Z","comments":true,"path":"2019/03/31/angular基础-表单处理/","link":"","permalink":"http://yoursite.com/2019/03/31/angular基础-表单处理/","excerpt":"","text":"模板式表单表单的数据模型是通过组件模板中的相关指令来定义的，因为使用这种方式定义表单的数据模型时，我们会受限于HTML的语法，所以，模板驱动方式只适合用于一些简单的场景。 需要在app.module.ts中引入：123imports: [ FormsModule] NgForm / ngNoForm:简单使用：12345&lt;div ngForm&gt;&lt;/div&gt;&lt;form ngNoForm&gt;&lt;/form&gt; 取值：123456&lt;form #myForm=&quot;ngForm&quot;&gt;&lt;/form&gt;&lt;div&gt; &#123;&#123;myForm.value | json&#125;&#125;&lt;/div&gt; 提交：123&lt;form #myForm=&quot;ngForm&quot; (onSubmit)=&quot;onSubmit(myForm.value)&quot;&gt; &lt;button type=&quot;submit&quot;&gt;注册&lt;/button&gt;&lt;/form&gt; NgModel:简单使用：1234&lt;form #myForm=&quot;ngForm&quot; (onSubmit)=&quot;onSubmit(myForm.value)&quot;&gt; &lt;div&gt;用户名：&lt;input ngModel name=&quot;username&quot; type=&quot;text&quot;&gt;&lt;/div&gt; &lt;button type=&quot;submit&quot;&gt;注册&lt;/button&gt;&lt;/form&gt; 取值：12345678&lt;form #myForm=&quot;ngForm&quot; (onSubmit)=&quot;onSubmit(myForm.value)&quot;&gt; &lt;div&gt;用户名：&lt;input #username=&quot;ngModel&quot; ngModel name=&quot;username&quot; type=&quot;text&quot;&gt;&lt;/div&gt; &lt;button type=&quot;submit&quot;&gt;注册&lt;/button&gt;&lt;/form&gt;&lt;div&gt; &#123;&#123;username.value&#125;&#125;&lt;/div&gt; NgModelGroup：简单使用：1234567&lt;div ngModelGroup=&quot;userInfo&quot;&gt; &lt;div&gt;用户名：&lt;input #username=&quot;ngModel&quot; ngModel name=&quot;username&quot; type=&quot;text&quot;&gt;&lt;/div&gt;&lt;/div&gt;&lt;div&gt; &#123;&#123;username.value&#125;&#125; &lt;!-- &#123;&quot;userInfo&quot;: &#123;&quot;username&quot;: &quot;&quot;&#125;&#125; --&gt;&lt;/div&gt; 样例：html：123456789&lt;form #myForm=&quot;ngForm&quot; (onSubmit)=&quot;onSubmit(myForm.value)&quot;&gt; &lt;div&gt;用户名：&lt;input ngModel name=&quot;username&quot; type=&quot;text&quot;&gt;&lt;/div&gt; &lt;div&gt;手机号：&lt;input ngModel name=&quot;mobile&quot; type=&quot;number&quot;&gt;&lt;/div&gt; &lt;div ngModelGroup=&quot;passwordsGroup&quot;&gt; &lt;div&gt;密码：&lt;input ngModel name=&quot;password&quot; type=&quot;password&quot;&gt;&lt;/div&gt; &lt;div&gt;确认密码：&lt;input ngModel name=&quot;pconfirm&quot; type=&quot;password&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;button type=&quot;submit&quot;&gt;注册&lt;/button&gt;&lt;/form&gt; component:123onSubmit(value: any) &#123; console.log(value);&#125; 响应式表单使用响应式表单时，那你通过编写TypeScript代码而不是Html代码来创建一个底层的数据模型，在这个模型定义好以后，你使用一些特定的指令，将模板上的html元素与底层的数据模型连接在一起。 需要在app.module.ts中引入：123imports: [ ReactiveFormsModule] FormGroup：html12345&lt;form [formGroup]=&quot;formModel&quot; (submit)=&quot;onSubmit()&quot;&gt; &lt;div&gt; &lt;button type=&quot;submit&quot;&gt;保存&lt;/button&gt; &lt;/div&gt;&lt;/form&gt; component12345formModel: FormGroup = new FormGroup (&#123;&#125;);onSubmit() &#123; console.log(this.formModel.value);&#125; FormControl：html12345678910&lt;form [formGroup]=&quot;formModel&quot; (submit)=&quot;onSubmit()&quot;&gt; &lt;input formControlName=&quot;username&quot;&gt; &lt;div formGroupName=&quot;dateRange&quot;&gt; 起始日期：&lt;input type=&quot;date&quot; formControlName=&quot;from&quot;&gt; 截止日期：&lt;input type=&quot;date&quot; formControlName=&quot;to&quot;&gt; &lt;/div&gt; &lt;div&gt; &lt;button type=&quot;submit&quot;&gt;保存&lt;/button&gt; &lt;/div&gt;&lt;/form&gt; component1234567formModel: FormGroup = new FormGroup (&#123; username: new FormControl(&apos;aaa&apos;), dateRange: new FormGroup(&#123; from: new FormControl(), to: new FormControl() &#125;)&#125;); FormArray：html1234567891011121314151617&lt;form [formGroup]=&quot;formModel&quot; (submit)=&quot;onSubmit()&quot;&gt; &lt;div formGroupName=&quot;dateRange&quot;&gt; 起始日期：&lt;input type=&quot;date&quot; formControlName=&quot;from&quot;&gt; 截止日期：&lt;input type=&quot;date&quot; formControlName=&quot;to&quot;&gt; &lt;/div&gt; &lt;div&gt; &lt;ul formArrayName=&quot;emails&quot;&gt; &lt;li *ngFor=&quot;let e of this.formModel.get(&apos;emails&apos;).controls; let i = index;&quot;&gt; &lt;input type=&quot;text&quot; [formControlName]=&quot;i&quot;&gt; &lt;/li&gt; &lt;/ul&gt; &lt;button type=&quot;button&quot; (click)=&quot;addEmail()&quot;&gt;增加Email&lt;/button&gt; &lt;/div&gt; &lt;div&gt; &lt;button type=&quot;submit&quot;&gt;保存&lt;/button&gt; &lt;/div&gt;&lt;/form&gt; component123456789101112131415formModel: FormGroup = new FormGroup (&#123; dateRange: new FormGroup(&#123; from: new FormControl(), to: new FormControl() &#125;), emails: new FormArray(&#123; new FormControl(&quot;a@a.com&quot;), new FormControl(&quot;b@b.com&quot;) &#125;)&#125;);addEmail() &#123; let emails = this.formModel.get(&apos;emails&apos;) as FormArray; emails.push(new FormControl());&#125; 样例html123456789&lt;form [FormGroup]=&quot;formModel&quot; (onSubmit)=&quot;onSubmit()&quot;&gt; &lt;div&gt;用户名：&lt;input type=&quot;text&quot; formControlName=&quot;username&quot;&gt;&lt;/div&gt; &lt;div&gt;手机号：&lt;input type=&quot;number&quot; formControlName=&quot;mobile&quot;&gt;&lt;/div&gt; &lt;div formGroupName=&quot;passwordsGroup&quot;&gt; &lt;div&gt;密码：&lt;input type=&quot;password&quot; formControlName=&quot;password&quot;&gt;&lt;/div&gt; &lt;div&gt;确认密码：&lt;input type=&quot;password&quot; formControlName=&quot;pconfirm&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;button type=&quot;submit&quot;&gt;注册&lt;/button&gt;&lt;/form&gt; component123456789101112formModel: FormGroup;constructor() &#123; this.formModel = new FormGroup (&#123; username: new FormControl(), mobile: new FormControl(), passwordsGroup: new FormGroup(&#123; password: new FormControl(), pconfirm: new FormControl() &#125;) &#125;);&#125; FromBuilder通过FromBuilder简化代码123456789101112formModel: FormGroup;constructor(fb: FormBuilder) &#123; this.formModel = fb.group (&#123; username: [&apos;&apos;], mobile: [&apos;&apos;], passwordsGroup: fb.group(&#123; password: [&apos;&apos;], pconfirm: [&apos;&apos;] &#125;) &#125;);&#125; 表单验证html123456789101112131415161718192021222324&lt;form [FormGroup]=&quot;formModel&quot; (onSubmit)=&quot;onSubmit()&quot;&gt; &lt;div&gt;用户名：&lt;input type=&quot;text&quot; formControlName=&quot;username&quot;&gt;&lt;/div&gt; &lt;div [hidden]=&quot;!formModel.hasError(&apos;required&apos;, &apos;username&apos;)&quot;&gt; 用户名是必填项 &lt;/div&gt; &lt;div [hidden]=&quot;!formModel.hasError(&apos;minLength&apos;, &apos;username&apos;)&quot;&gt; 用户名最小长度是6 &lt;/div&gt; &lt;div&gt;手机号：&lt;input type=&quot;number&quot; formControlName=&quot;mobile&quot;&gt;&lt;/div&gt; &lt;div [hidden]=&quot;!formModel.hasError(&apos;mobile&apos;, &apos;mobile&apos;)&quot;&gt; 请输入正确的手机号 &lt;/div&gt; &lt;div formGroupName=&quot;passwordsGroup&quot;&gt; &lt;div&gt;密码：&lt;input type=&quot;password&quot; formControlName=&quot;password&quot;&gt;&lt;/div&gt; &lt;div [hidden]=&quot;!formModel.hasError(&apos;minLength&apos;, [&apos;passwordsGroup&apos;, [&apos;password&apos;]])&quot;&gt; 密码最小长度是6 &lt;/div&gt; &lt;div&gt;确认密码：&lt;input type=&quot;password&quot; formControlName=&quot;pconfirm&quot;&gt;&lt;/div&gt; &lt;div [hidden]=&quot;!formModel.hasError(&apos;equal&apos;, &apos;passwordsGroup&apos;)&quot;&gt; &#123;&#123;formModel.getError(&apos;equal&apos;, &apos;passwordsGroup&apos;)?.descxxx&#125;&#125; &lt;/div&gt; &lt;/div&gt; &lt;button type=&quot;submit&quot;&gt;注册&lt;/button&gt;&lt;/form&gt; component12345678910111213141516171819202122232425262728293031323334353637383940414243444546// 可以将以下angular校验器抽取到一个ts文件中mobileValidator(control: FormControl): any &#123; const myreq = /^(((13[0-9]&#123;1&#125;)|(15[0-9]&#123;1&#125;)|(18[0-9]&#123;1&#125;))+\\d&#123;8&#125;)$/; const valid = myreq.test(control.calue); console.log(&apos;mobile的校验结果是：&apos; + valid); return valid ? null : &#123;mobile: true&#125;;&#125;mobileAsyncValidator(control: FormControl): any &#123; const myreq = /^(((13[0-9]&#123;1&#125;)|(15[0-9]&#123;1&#125;)|(18[0-9]&#123;1&#125;))+\\d&#123;8&#125;)$/; const valid = myreq.test(control.calue); console.log(&apos;mobile的校验结果是：&apos; + valid); // 模拟异步 return Observable.of(valid ? null : &#123;mobile: true&#125;).delay(5000);&#125;equalValidator(group: FormGroup): any &#123; const password: FormControl = group.get(&apos;password&apos;) as FormControl; const pconfirm: FormControl = group.get(&apos;pconfirm&apos;) as FormControl; const valid: boolean = (password.value === pconfirm.value); console.log(&apos;密码的校验结果是：&apos; + valid); return valid ? null : &#123;equal: &#123;descxxx: &apos;密码和确认密码不匹配&apos;&#125;&#125;;&#125;formModel: FormGroup;constructor(fb: FormBuilder) &#123; this.formModel = fb.group (&#123; username: [&apos;&apos;, [Vaildators.required, Validators.minLength(6)]], mobile: [&apos;&apos;, this.mobileValidator], passwordsGroup: fb.group(&#123; password: [&apos;&apos;], pconfirm: [&apos;&apos;] &#125;, &#123;validator: this.equalValidator&#125;) &#125;);&#125;onSubmit() &#123; // const isValid: boolean = this.formModel.get(&apos;username&apos;).valid; // console.log(&apos;username的校验结果：&apos; + isValid); // const errors: any = this.formModel.get(&quot;username&quot;).errors; // console.log(&apos;username的错误信息是：&apos; + JSON.stringify(errors)); if (this.formModel.valid) &#123; console.log(this.formModel.value); &#125;&#125; 状态字段touched和untouched123456789&lt;form [FormGroup]=&quot;formModel&quot; (onSubmit)=&quot;onSubmit()&quot;&gt; &lt;div&gt;用户名：&lt;input type=&quot;text&quot; formControlName=&quot;username&quot;&gt;&lt;/div&gt; &lt;div [hidden]=&quot;formModel.get(&apos;mobile&apos;).valid || formModel.get(&apos;mobile&apos;).untouched&quot;&gt; &lt;div [hidden]=&quot;!formModel.hasError(&apos;required&apos;, &apos;username&apos;)&quot;&gt; 用户名是必填项 &lt;/div&gt; &lt;/div&gt; ...&lt;/form&gt; pristine和dirty123456789&lt;form [FormGroup]=&quot;formModel&quot; (onSubmit)=&quot;onSubmit()&quot;&gt; &lt;div&gt;用户名：&lt;input type=&quot;text&quot; formControlName=&quot;username&quot;&gt;&lt;/div&gt; &lt;div [hidden]=&quot;formModel.get(&apos;mobile&apos;).valid || formModel.get(&apos;mobile&apos;).pristine&quot;&gt; &lt;div [hidden]=&quot;!formModel.hasError(&apos;required&apos;, &apos;username&apos;)&quot;&gt; 用户名是必填项 &lt;/div&gt; &lt;/div&gt; ...&lt;/form&gt; pending123456&lt;form [FormGroup]=&quot;formModel&quot; (onSubmit)=&quot;onSubmit()&quot;&gt; &lt;div [hidden]=&quot;!formModel.get(&apos;mobile&apos;).pending&quot;&gt; 正在校验手机合法性 &lt;/div&gt; ...&lt;/form&gt;","categories":[],"tags":[{"name":"angular","slug":"angular","permalink":"http://yoursite.com/tags/angular/"}],"keywords":[]},{"title":"influxdb query","slug":"influxdb_query","date":"2019-03-28T07:26:05.838Z","updated":"2019-03-28T07:34:31.930Z","comments":true,"path":"2019/03/28/influxdb_query/","link":"","permalink":"http://yoursite.com/2019/03/28/influxdb_query/","excerpt":"","text":"注意点 查询结果如果要显示tag，则无需指定查询tag，只需要在GROUP BY 中带上tag。 如果GROUP BY 除了time 还有其它tag，则最好不要加fill(previous)，否则数据可能会错乱。 SELECT * FROM (SELECT …) 会将值为空的数据过滤掉。 GROUP BY time() 之后要确定用FIRST() 或 LAST()。 如果查询的字段带有空格，则需要使用”字段名”查询。 demo数据以下数据来自telegraf 的[[inputs.prometheus]] 插件，每隔10秒从oracle_exporter中采集数据并写回influxdb，database为telegraf，measurement为oracledb_physical_iops，counter为field，其它为tag，部分tag省略，部分值已被修改。1234567891011121314# time counter database dbinstance host id type1 2019/3/28 6:21:20 1 orcl ip1 localhost orcl read_iops2 2019/3/28 6:21:20 2 orcl ip1 localhost orcl write_iops3 2019/3/28 6:21:20 1 orcl2 ip2 localhost orcl2 read_iops4 2019/3/28 6:21:20 2 orcl2 ip2 localhost orcl2 write_iops5 2019/3/28 6:21:30 1 orcl ip1 localhost orcl read_iops6 2019/3/28 6:21:30 2 orcl ip1 localhost orcl write_iops7 2019/3/28 6:21:30 1 orcl2 ip2 localhost orcl2 read_iops8 2019/3/28 6:21:30 2 orcl2 ip2 localhost orcl2 write_iops[...]13 2019/3/28 6:21:50 1 orcl ip1 localhost orcl read_iops14 2019/3/28 6:21:50 2 orcl ip1 localhost orcl write_iops15 2019/3/28 6:21:50 1 orcl2 ip2 localhost orcl2 read_iops16 2019/3/28 6:21:50 2 orcl2 ip2 localhost orcl2 write_iops mavenpom.xml：123456&lt;!-- https://mvnrepository.com/artifact/org.influxdb/influxdb-java --&gt;&lt;dependency&gt; &lt;groupId&gt;org.influxdb&lt;/groupId&gt; &lt;artifactId&gt;influxdb-java&lt;/artifactId&gt; &lt;version&gt;2.14&lt;/version&gt;&lt;/dependency&gt; springbootapplication.yml：123spring: influx: url: http://localhost:8086 javaconfig：12345678910111213141516171819@Componentpublic class InfluxDbHolder &#123; private final InfluxDBResultMapper mapper; private final InfluxDB db; @Autowired public InfluxDbHolder(InfluxDB db) &#123; this.db = db; this.mapper = new InfluxDBResultMapper(); &#125; public InfluxDBResultMapper getMapper() &#123; return mapper; &#125; public InfluxDB getDb() &#123; return db; &#125;&#125; entity：1234567891011121314@Data@Measurement(name = &quot;oracledb_physical_iops&quot;)public class DbIOps &#123; @Column(name = &quot;time&quot;) @JsonDeserialize(using = InstantJacksonDeserialize.class) @JsonSerialize(using = InstantJacksonSerializer.class) private Instant time; @Column(name = &quot;type&quot;, tag = true) private String type; @Column(name = &quot;counter&quot;) private Integer counter;&#125; 123456789101112131415161718@Datapublic class InfluxdbCriteria &#123; private Integer during; private Integer groupTime; private Integer offset; public void validate() &#123; if (during == null) &#123; during = 1; &#125; if (groupTime == null) &#123; groupTime = 10; &#125; if (offset == null) &#123; offset = 0; &#125; &#125;&#125; service：1234567891011121314151617181920public Map&lt;Instant, List&lt;DbIOps&gt;&gt; getDatabaseIOps(String dbId, InfluxdbCriteria databaseCriteria) &#123; databaseCriteria.validate(); Integer during = databaseCriteria.getDuring(); Integer groupTime = databaseCriteria.getGroupTime(); Integer offset = databaseCriteria.getOffset(); String sql = &quot;SELECT first(counter) as counter &quot; + &quot;FROM oracledb_physical_iops &quot; + &quot;WHERE id=&apos;&quot;+ dbId + &quot;&apos; AND time &gt; now() - &quot; + during + &quot;h &quot; + &quot;group by type, time(&quot;+ groupTime + &quot;m, &quot; + offset + &quot;s)&quot;; Query query = new Query(sql, &quot;telegraf&quot;); QueryResult result = holder.getDb().query(query); List&lt;DbIOps&gt; dbIOpsList = holder.getMapper().toPOJO(result, DbIOps.class); Map&lt;Instant, List&lt;DbIOps&gt;&gt; map = dbIOpsList.stream().collect(Collectors.groupingBy(DbIOps::getTime)); //对时间排序 Map&lt;Instant, List&lt;DbIOps&gt;&gt; sortMap = new TreeMap&lt;&gt;((Instant instant1, Instant instant2) -&gt; instant1.compareTo(instant2)); sortMap.putAll(map); return sortMap;&#125; controller：1234@GetMapping(&quot;/databaseIOps/&#123;dbId&#125;&quot;)public ResponseEntity getDatabaseIOps(@PathVariable String dbId, InfluxdbCriteria databaseCriteria) &#123; return ResponseEntity.ok(databaseService.getDatabaseIOps(dbId, databaseCriteria));&#125; angularservice：123456789101112131415161718/** * 查询数据库IOpsmetrics */getDatabaseIOps(dbId: string, during: number): Observable&lt;any&gt; &#123; // during: 最近during小时 const params = DateUtils.getInfluxdbParams(during); return this.http.get&lt;any&gt;(`databaseIOps/$&#123;dbId&#125;`, &#123; params: &#123; during: String(during), groupTime: String(params.groupTime), offset: String(params.offset) &#125; &#125;).pipe( retry(1), catchError(this.handleError.bind(this)) );&#125; utils：1234567891011121314151617export class DateUtils &#123; public static getInfluxdbParams(during: number): any &#123; let groupTime = 10; let offset = 0; if (during === 1) &#123; groupTime = 5; offset = (moment().minutes() % 5) * 60 - 30; &#125; else if (during === 3) &#123; groupTime = 15; offset = (moment().minutes() % 15) * 60 - 30; &#125; else if (during === 12) &#123; groupTime = 60; offset = (moment().minutes() % 60) * 60 - 30; &#125; return &#123;groupTime: groupTime, offset: offset&#125;; &#125;&#125;","categories":[],"tags":[{"name":"influxdb","slug":"influxdb","permalink":"http://yoursite.com/tags/influxdb/"}],"keywords":[]},{"title":"oracle账号","slug":"oracle账号","date":"2019-03-28T04:03:26.105Z","updated":"2019-03-28T03:33:24.496Z","comments":true,"path":"2019/03/28/oracle账号/","link":"","permalink":"http://yoursite.com/2019/03/28/oracle账号/","excerpt":"","text":"用户名：541509124@qq.com密码：LR4ever.1314 参考：https://blog.csdn.net/dengxt/article/details/81536099","categories":[],"tags":[{"name":"oracle","slug":"oracle","permalink":"http://yoursite.com/tags/oracle/"}],"keywords":[]},{"title":"influxdb issues","slug":"influxdb","date":"2019-03-28T04:03:05.994Z","updated":"2019-03-28T03:07:45.935Z","comments":true,"path":"2019/03/28/influxdb/","link":"","permalink":"http://yoursite.com/2019/03/28/influxdb/","excerpt":"","text":"org.influxdb.InfluxDBIOException: java.net.SocketTimeoutException: timeout使用influxdb的java客户端连接influxdb：1InfluxDB influxDB = InfluxDBFactory.connect(&quot;http://localhost:8086&quot;); 报错：123Exception in thread &quot;main&quot; org.influxdb.InfluxDBIOException: java.net.SocketTimeoutException: timeout at org.influxdb.impl.InfluxDBImpl.execute(InfluxDBImpl.java:800) at org.influxdb.impl.InfluxDBImpl.write(InfluxDBImpl.java:455) 更改OKHttpClient的默认超时：123456OkHttpClient.Builder client = new OkHttpClient.Builder() .connectTimeout(1, TimeUnit.MINUTES) .readTimeout(1, TimeUnit.MINUTES) .writeTimeout(2, TimeUnit.MINUTES) .retryOnConnectionFailure(true);InfluxDB influxDB = InfluxDBFactory.connect(&quot;http://localhost:8086&quot;, client); 参考：https://github.com/influxdata/influxdb-javahttps://stackoverflow.com/questions/50922473/influxdbioexception-java-net-sockettimeoutexception-timeout","categories":[],"tags":[{"name":"influxdb","slug":"influxdb","permalink":"http://yoursite.com/tags/influxdb/"}],"keywords":[]},{"title":"Chrome中启用Flash","slug":"Chrome中启用Flash","date":"2019-03-28T04:02:26.147Z","updated":"2019-03-27T13:26:53.572Z","comments":true,"path":"2019/03/28/Chrome中启用Flash/","link":"","permalink":"http://yoursite.com/2019/03/28/Chrome中启用Flash/","excerpt":"","text":"参考：https://support.digication.com/hc/en-us/articles/115003963468-Enabling-Flash-for-Google-Chrome-Windows-Macintosh-","categories":[],"tags":[{"name":"Chrome","slug":"Chrome","permalink":"http://yoursite.com/tags/Chrome/"}],"keywords":[]},{"title":"moment.js常用操作","slug":"momentJs常用操作","date":"2019-03-14T11:05:08.221Z","updated":"2019-03-07T13:17:44.737Z","comments":true,"path":"2019/03/14/momentJs常用操作/","link":"","permalink":"http://yoursite.com/2019/03/14/momentJs常用操作/","excerpt":"","text":"将String转成moment再格式化const date = ‘2019-03-07T21:16:00Z’;moment(date, ‘YYYY-MM-DDTHH:mm:ssZ’).format(‘HH:mm’)","categories":[],"tags":[{"name":"moment.js","slug":"moment-js","permalink":"http://yoursite.com/tags/moment-js/"}],"keywords":[]},{"title":"linux常用指令","slug":"linux常用指令","date":"2019-03-14T11:05:08.206Z","updated":"2019-02-19T14:08:05.230Z","comments":true,"path":"2019/03/14/linux常用指令/","link":"","permalink":"http://yoursite.com/2019/03/14/linux常用指令/","excerpt":"","text":"1.查看目录下有什么文件/目录 ls &emsp;&emsp;&emsp;&emsp;&emsp; //list 列出目录的文件信息ls -l或ll &emsp;&emsp;&ensp; //list -list 以”详细信息”查看目录文件ls -a &ensp;&emsp;&emsp; &emsp; //list -all 查看目录”全部”（包括隐藏文件）文件ls -al &ensp;&emsp;&emsp;&emsp; //list -all list 查看目录”全部”（包括隐藏文件）文件，以”详细信息”显示ls 目录 &ensp;&emsp; &emsp; //查看指定目录下有什么文件ls -i &emsp;&emsp;&emsp;&emsp; //查看文件索引号码 2.进行目录切换 cd dirname &emsp;//进行目录切换cd .. &emsp;&emsp;&emsp;&emsp;&ensp;//想上级目录切换cd ~ 或 cd &emsp;&ensp;//直接切换到当前用户 3.查看完整的操作位置 pwd 4.用户切换 su - 或 su - root &emsp;//向root用户切换exit &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&ensp; //退回到原用户su 用户名 &emsp;&emsp;&emsp;&emsp;//普通用户切换 多次使用su指令，会造成用户的”叠加”：（su和exit最好配合使用）lcs—&gt;root—&gt;lcs—&gt;root—&gt;lcs 5.查看当前用户是谁 whoami 6.图形界面与命令界面切换root用户可以切换 #init 3 #init 5 7.查看一个指令对应的执行程序文件在哪 which 指令 8.目录相关操作1）创建目录 make directory mkdir 目录名字mkdir -p newdir/newdir/newdir //递归方式创建多个连续目录，新的多级目录数目如果大于等于2个，&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp; 就要使用-p参数mkdir dir/newdir &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;//不用-p参数mkdir -p dir/newdir/newdir &emsp;&emsp;//使用-p参数 2）移动目录 move mv dir1 dir2 &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;//把dir1移动到dir2目录下mv dir1/dir2 dir3 &emsp;&emsp;&emsp;&ensp; //把dir2移动到dir3目录下mv dir1/dir2 dir3/dir4 &emsp;&ensp;//把dir2移动到dir4目录下mv dir1/dir2 ./ &emsp;&emsp;&emsp;&emsp;&emsp;//把dir2移动到当前目录下 3）改名字 mv dir1 newdir &emsp;&emsp;&emsp;&emsp;//修改dir1的名字为newdir mv是”移动”和”改名字”合并的指令mv dir1 ./newdir &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;//dir1移动到当前目录下，并改名字为newdirmv dir1/dir2 dir3 &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&ensp; //dir2移动到dir3目录下，并改名字为”原名”mv dir1/dir2 dir3/newdir &emsp;&emsp;&emsp;&emsp;//dir2移动到dir3目录下，并改名字为newdirmv dir1/dir2 dir3/dir4 &emsp;&emsp;&emsp;&emsp;&emsp; //dir2移动到dir4目录下，并改名字为”原名”mv dir1/dir2 dir3/dir4/newdir &emsp;&ensp;//dir2移动到dir4目录下，并改名字为newdir 4）复制（文件和目录）copy ①文件的复制 cp file1 dir/newfile2 &emsp;&emsp;&emsp;&emsp;//file1被复制一份到dir目录下，并改名字为newfile2cp file1 dir &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&ensp;//file1被复制一份到dir目录下，并改名字为”原名”cp dir1/filea dir2/newfile &emsp;&ensp; //filea被复制一份到dir目录下，并改名字为newfile ②目录的复制（需要设置-r[recursive递归]参数，无视目录的层次） cp -r dir1 dir2 &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;//dir1被复制到dir2目录下，并改名字为”原名”cp -r dir1/dir2 dir3/newdir &emsp;&emsp;&emsp;//dir2被复制到dir3目录下，并改名字为newdircp -r dir1/dir2 dir3/dir4 &emsp;&emsp;&emsp;&emsp; //dir2被复制到dir4目录下，并改名字为”原名”cp -r dir1/dir2 dir3/dir4/newdir &ensp;//dir2被复制到dir4目录下，并改名字为newdircp -r dir1 ../../newdir &emsp;&emsp;&emsp;&emsp;&emsp;&ensp;//dir1被复制到上两级目录下，并改名字为newdir ③删除（文件和目录）remove rm 文件rm -r 目录 &emsp;&emsp;&emsp;&emsp;&emsp;//-r[recursive递归]递归方式删除目录rm -rf 文件/目录 &emsp;&emsp; //-r force 递归强制方式删除文件，force强制，不需要额外导入提示 9.文件操作1）查看文件内容 cat filename &emsp;&emsp;&emsp;//打印文件内容到输出终端more filename &emsp;&emsp;//通过敲回车方式逐行查看文件的各个行内容，默认从第一行开始查看，&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp; //不支持回看，q退出查看less &emsp;&emsp;&emsp; &emsp;&emsp;&emsp;&emsp;//通过”上下左右”键查看文件的各个部分内容，支持回看，q退出查看head -n filename &ensp; //查看文件的前n行内容tail -n filename &emsp;&ensp; //查看文件的最末尾n行内容wc filename &emsp;&emsp;&emsp; //查看文件的行数 2）创建文件 touch dir1/filenametouch filename 3）给文件追加内容 echo 内容 &gt; 文件名称 &emsp;&emsp;&emsp;&emsp;//把”内容”以[覆盖写]方式追加给”文件”echo 内容 &gt;&gt; 文件名称 &emsp;&emsp;&emsp; //把”内容”以[追加]方式写给”文件” （如果文件不存在会创建文件） 10.用户操作配置文件：/etc/passwd1）创建用户 user add #useradd #useradd liming &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;//创建liming用户，同时会创建一个同名的组出来 #useradd -g 组别编号 username &emsp;&emsp;&ensp;//把用户的组别设置好，避免创建同名的组出来 #useradd -g 组编号 -u 用户编号 -d 家目录 username 2）修改用户 user modify #usermod -g 组编号 -u 用户编号 -d 家目录 -l 新名字 username（修改家目录时需要手动创建之） 3）删除用户 user delete #userdel username #userdel -r username //删除用户同时删除其家目录 4）给用户设置密码，使其登录系统 passwd 用户名 11.组别操作配置文件：/etc/group1）创建组 group add #groupadd music #groupadd movie #groupadd php 2）修改组 group modify #groupmod -g gid -n 新名字 groupname 3）删除组 group delete #groupdel groupname //组下边如果有用户存在，就禁止删除 12.查看指令可设置的参数 man 指令 13.给文件设置权限1）字母相对方式设置权限// 针对一个组别设置权限，其他组别权限没有变化，称为“相对方式”权限设置chmod指令chmod u+rwx filename //给filename文件的主人增加“读、写、执行”权限chmod g-rx filename //给filename文件的同组用户 删除“读、执行”权限 chmod u+/-rwx,g+/-rwx,o+/-rwx filename说明：①每个单元“+” “-”只能使用一个②可以同时给一个组或多个组设置权限，组别之间使用“，”分割③每个单元的权限可以是“rwx”中的一个或多个 chmod u+w,g-rx,o+rw filename //给filename文件主人增加写权限，同组删除读、执行权限，其他组增加读、写权限chmod u+w,u-x filename //给filename文件主人“增加写权限”同时“删除执行权限” chmod +/-rwx filename //无视具体组别，统一给全部的组设置权限 chmod +rw filename //给filename全部用户增加“读、写”权限 2）数字绝对方式设置权限r读：4 &emsp;&emsp; w写：2 &emsp;&emsp; x执行：10：没有权限1：执行2：写3：写、执行4：读5：读、执行6：读、写7：读、写、执行 chmod ABC filename //ABC分别代表主人、同组、其他组用户的数字权限 chmod 753 filename //主人读、写、执行；同组读、执行；其他组写、执行 问：字母相对 和 数字绝对 方式权限设置取舍？答：修改的权限相对“比较少”的时候使用“字母”方式，相反，权限变动“非常多”的时候就使用“数字”方式 14.在文件中查找内容grep 被搜索内容 文件 grep hello passwd //在passwd文件中搜索hello内容，会把hello所在行的内容都打印到终端显示 15.计算文件占据磁盘空间大小 du -h 文件（目录） 16.文件查找find 查找目录 选项 选项值 选项 选项值 …1）-name选项 根据名字进行查找 find / -name passwd &emsp;&emsp;&emsp;&emsp;//“递归遍历”/根目录及其内部深层目录，寻找名称等于“passwd”的文件find / -name “pas“[模糊查找] //在系统全部目录，模糊查找一个名字是“pas”开始的文件find / -name “er*” &emsp;&emsp;&emsp;&emsp;&emsp; //文件名字有出现“er”字样即可，不要位置 2）限制查找的目录层次 -maxdepth -mindepth-maxdepth 限制查找的最深目录-mindepth 限制查找的最浅目录 find / -maxdepth 4 -name passwdfind / -maxdepth 4 -mindepth 3 -name passwd 3）根据大小为条件进行文件查找-size +/-数字+号表示大小大于某个范围-号表示大小小于某个范围大小单位：-size 5 &emsp;&emsp; //单位是“512字节” 5512字节-size 10c &emsp; //单位是“字节” 10字节-size 3k &emsp;&ensp; //单位是“千字节” 31024字节-size 6M &emsp; //单位是“1024*千字节” 6M兆字节 find ./ -size 14c &emsp;&emsp;//在当前目录查找大小等于14千字节的文件find / -size +50M &emsp;//在系统全部目录里边查找大小大于50M的文件","categories":[],"tags":[{"name":"linux","slug":"linux","permalink":"http://yoursite.com/tags/linux/"}],"keywords":[]},{"title":"kapacitor issues","slug":"kapactior","date":"2019-03-14T11:05:08.203Z","updated":"2019-03-09T09:45:31.111Z","comments":true,"path":"2019/03/14/kapactior/","link":"","permalink":"http://yoursite.com/2019/03/14/kapactior/","excerpt":"","text":"kapacitor与influxdb在不同机器上通信时的配置kapacitor在启动时会向配置中的influxBD进行发现与创建订阅，这些订阅告诉InfluxDB将它收到的所有数据发送给Kapacitor。当kapacitor与influxdb不在同一台机器上时，需要在kapactior的配置中配置influxdb可以通信的IP或主机名。只要是在influxdb订阅过，influxdb之后都会像这些订阅发送数据 kapactior.conf:1hostname = &quot;localhost&quot; // 默认修改为influxdb可以ping得通的ip或主机名","categories":[],"tags":[{"name":"kapacitor","slug":"kapacitor","permalink":"http://yoursite.com/tags/kapacitor/"}],"keywords":[]},{"title":"pkg-config --cflags oci8, Package oci8 was not found in the pkg-config search path.","slug":"go-oracle","date":"2019-03-14T11:05:08.162Z","updated":"2019-02-01T09:56:37.529Z","comments":true,"path":"2019/03/14/go-oracle/","link":"","permalink":"http://yoursite.com/2019/03/14/go-oracle/","excerpt":"","text":"在linux下可以正常运行oracledb_exporter，在windows64下启动时报错12pkg-config --cflags oci8Package oci8 was not found in the pkg-config search path. 因为linux中已经安装了oracle客户端，所以怀疑可能是windows下没有导致的。1.go-oci8 地址：https://github.com/wendal/go-oci8 它是 https://github.com/mattn/go-oci8 的分支，增加了windows下中文的安装说明及相关文件。 从oracledb_exporter的代码中可以看到引用的是go-oci8_ &quot;github.com/mattn/go-oci8&quot;,所以需要安装windows的oracle连接。 2.安装oci 地址：https://www.oracle.com/technetwork/database/database-technologies/instant-client/downloads/index.html 我的安装目录为：F:\\instantclient_18 _3 3.安装oci-sdk 地址：同上。 我的安装目录为F:\\instantclient_18 _3\\sdk 4.安装MinGW 地址：https://sourceforge.net/projects/mingw-w64/files/ 我的安装目录为F:\\mingw-w64 配置环境变量：在系统变量path中追加 F:\\mingw-w64\\x86_64-8.1.0-posix-seh-rt_v6-rev0\\mingw64\\bin 5.下载go-oci8驱动 地址：https://github.com/wendal/go-oci8 运行命令 go get github.com/wendal/go-oci8 (报错先不管) 复制GOPATH目下的\\src\\github.com\\wendal\\go-oci8\\windows\\pkg-config.exe到到mingw的安装目录mingw64\\bin下。 复制GOPATH目下的\\src\\github.com\\wendal\\go-oci8\\windows\\oci8.pc到到mingw的安装目录mingw64\\lib\\pkg-config的下。 修改oci8.pc #Package Information for pkg-configprefix=F:/instantclient_18_3exec_prefix=F:/instantclient_18_3libdir=${exec_prefix}includedir=${prefix}/sdk/include/ Name: OCIDescription: Oracle database engineVersion: 18.3Libs: -L${libdir} -lociLibs.private:Cflags: -I${includedir} 6.环境变量配置 PATH=原有PATH;F:\\instantclient_18_3; PKG_CONFIG_PATH=F:\\mingw-w64\\x86_64-8.1.0-posix-seh-rt_v6-rev0\\mingw64\\lib\\pkg-config 启动报错1234F:\\GOENV\\src\\github.com\\wendal\\go-oci8\\oci8.go:119: cannot use (**_Ctype_struct_OCIServer)(unsafe.Pointer(&amp;conn.svc)) (type **_Ctype_struct_OCIServer) as type **_Ctype_struct_OCISvcCtx in argument to func literalF:\\GOENV\\src\\github.com\\wendal\\go-oci8\\oci8.go:136: cannot use (*_Ctype_struct_OCIServer)(c.svc) (type *_Ctype_struct_OCIServer) as type *_Ctype_struct_OCISvcCtx in argument to func literalF:\\GOENV\\src\\github.com\\wendal\\go-oci8\\oci8.go:263: cannot use (*_Ctype_struct_OCIServer)(s.c.svc) (type *_Ctype_struct_OCIServer) as type *_Ctype_struct_OCISvcCtx in argument to func literalF:\\GOENV\\src\\github.com\\wendal\\go-oci8\\oci8.go:383: cannot use (*_Ctype_struct_OCIServer)(s.c.svc) (type *_Ctype_struct_OCIServer) as type *_Ctype_struct_OCISvcCtx in argument to func literal 替换GOPATH目下的\\src\\github.com\\wendal\\go-oci8里四处OCIServer为OCISvcCtx。参考：https://www.cnblogs.com/ghj1976/p/3437250.htmlhttps://blog.csdn.net/wq57885/article/details/82841792","categories":[],"tags":[{"name":"go","slug":"go","permalink":"http://yoursite.com/tags/go/"}],"keywords":[]},{"title":"golang判断当前主机是物理机还是虚拟机","slug":"golang判断当前主机是物理机还是虚拟机","date":"2019-03-14T11:05:08.134Z","updated":"2019-03-14T10:31:59.655Z","comments":true,"path":"2019/03/14/golang判断当前主机是物理机还是虚拟机/","link":"","permalink":"http://yoursite.com/2019/03/14/golang判断当前主机是物理机还是虚拟机/","excerpt":"","text":"windows下命令行获取：1wmic path Win32_ComputerSystem get Model linux下命令行获取：1dmidecode | egrep -i &apos;system-product-name|product|domU&apos; 123456789101112131415161718192021222324func isVirtualMachine() (bool, error) &#123; model := &quot;&quot; var cmd *exec.Cmd if runtime.GOOS == &quot;windows&quot; &#123; cmd = exec.Command(&quot;cmd&quot;, &quot;/C&quot;, &quot;wmic path Win32_ComputerSystem get Model&quot;) &#125; else &#123; // linux cmd = exec.Command(&quot;/bin/bash&quot;, &quot;-c&quot;, &quot;dmidecode | egrep -i &apos;system-product-name|product|domU&apos;&quot;) &#125; stdout, err := cmd.Output() if err != nil &#123; return false, err &#125; model = string(stdout) if strings.Contains(model, &quot;VirtualBox&quot;) || strings.Contains(model, &quot;Virtual Machine&quot;) || strings.Contains(model, &quot;VMware Virtual Platform&quot;) || strings.Contains(model, &quot;KVM&quot;) || strings.Contains(model, &quot;Bochs&quot;) || strings.Contains(model, &quot;HVM domU&quot;) &#123; return true, nil &#125; return false, nil&#125; 参考：https://unix.stackexchange.com/questions/89714/easy-way-to-determine-virtualization-technologyhttps://blog.csdn.net/yangzhenping/article/details/49996765?utm_source=blogxgwz1https://blog.csdn.net/greless/article/details/71107767https://stackoverflow.com/questions/34229486/how-to-execute-a-linux-built-in-command-in-golanghttps://stackoverflow.com/questions/6182369/exec-a-shell-command-in-gohttps://stackoverflow.com/questions/13008255/how-to-execute-a-simple-windows-command-in-golang","categories":[],"tags":[{"name":"go","slug":"go","permalink":"http://yoursite.com/tags/go/"}],"keywords":[]},{"title":"centos7知识点","slug":"centos7","date":"2019-03-14T11:05:08.098Z","updated":"2019-03-09T09:08:56.389Z","comments":true,"path":"2019/03/14/centos7/","link":"","permalink":"http://yoursite.com/2019/03/14/centos7/","excerpt":"","text":"操作系统主机名修改centos6:1234#hostname //查看主机名#hostname newhostname //在当前会话修改主机名为newhostname，重启后失效#vim /etc/sysconfig/network //修改其中的HOSTNAME=newhostname，重启后依旧生效 centos7：123#hostname //查看主机名#vim /etc/hostname //直接修改其中的主机名，重启后依旧生效 时区操作centos6:123date // 查看时间date -R //查看时区cp /usr/share/zoneinfo/Asia/Tokyo /etc/localtime // 修改时区为东京时区 centos7:123timedatectl // 查看时间、时区。。。timedatectl set-timezone Asia/Tokyo // 修改时区为东京时区timedatectl set-local-rtc 1 //设置rtc时间与local时间相同 centos7 ip操作12345ip addr // 查看ip地址信息ip a add 192.168.8.149/24 dev eth0:2 // 添加网卡ipip a del 192.168.8.149/24 dev eth0:2 // 删除网卡ipip link set dev eth0 down // 将接口设备关闭ip link set dev eth0 up // 将接口设备启用","categories":[],"tags":[{"name":"centos7","slug":"centos7","permalink":"http://yoursite.com/tags/centos7/"}],"keywords":[]},{"title":"angular2中如何在发送delete请求时携带参数","slug":"angular发送带参数的delete请求","date":"2019-03-14T11:05:08.083Z","updated":"2019-02-13T15:07:03.434Z","comments":true,"path":"2019/03/14/angular发送带参数的delete请求/","link":"","permalink":"http://yoursite.com/2019/03/14/angular发送带参数的delete请求/","excerpt":"","text":"前端angular:1234567891011/** * 根据ids删除资源分组 */deleteResourceGroupByIds(ids: string[]) &#123; return this.http.request(&apos;DELETE&apos;, this.API + &apos;/resourceGroup&apos;, &#123; body: ids &#125;).pipe( retry(1), catchError(this.handleError.bind(this)) );&#125; 后台springboot:1234@DeleteMapping(&quot;/resourceGroup&quot;)public void deleteResourceGroupByIds(@RequestBody String[] ids) &#123; resourceGroupService.deleteResourceGroupByIds(ids);&#125; 参考：https://stackoverflow.com/questions/38819336/body-of-http-delete-request-in-angular2","categories":[],"tags":[{"name":"angular","slug":"angular","permalink":"http://yoursite.com/tags/angular/"}],"keywords":[]},{"title":"angular常用操作","slug":"angular常用操作","date":"2019-03-14T11:05:08.049Z","updated":"2019-05-24T09:13:35.029Z","comments":true,"path":"2019/03/14/angular常用操作/","link":"","permalink":"http://yoursite.com/2019/03/14/angular常用操作/","excerpt":"","text":"angular遍历maphtml:12345&lt;ul&gt; &lt;li *ngFor=&quot;let recipient of map | keyvalue&quot;&gt; &#123;&#123;recipient.key&#125;&#125; --&gt; &#123;&#123;recipient.value&#125;&#125; &lt;/li&gt;&lt;/ul&gt; cpmponent:12345myMap : Map&lt;string, boolean&gt;;for(let key of myMap.keys()) &#123; console.log(key); console.log(myMap.get(key));&#125; 1234Object.keys(myMap).map( key =&gt; &#123; console.log(&apos;key: &apos; + key); console.log(&apos;value: &apos; + result[key]);&#125;); 1234for (const [key, val] of map) &#123; console.log(key); console.log(val);&#125; 参考：https://stackoverflow.com/questions/48187362/how-to-iterate-using-ngfor-loop-map-containing-key-as-string-and-values-as-map-i/48187637 angular中html界面的if else 表示1234567&lt;div *ngIf=&quot;someCondition; else falsyTemplate&quot;&gt; &lt;h1&gt;Condition Passed!&lt;/h1&gt;&lt;/div&gt;&lt;ng-template #falsyTemplate&gt; &lt;h1&gt;Condition Failed!&lt;/h1&gt;&lt;/ng-template&gt; angular中http请求的option、params使用方式一：1234let option = &#123;&#125;;const params = new HttpParams().append(&apos;key&apos;, String(&apos;val&apos;));params = params.append(&apos;status&apos;, String(status)); // 注意要从新赋值给paramsoption = &#123;params&#125;; 方式二：12345678// 动态添加参数const option = &#123;&#125;;const params = &#123;&#125;;if (v != null) &#123; params[&apos;k&apos;] = v; option[&apos;params&apos;] = params;&#125; angular的html根据条件显示样式html：1&lt;div [class.hide]=&quot;someCondition&quot;&gt;&lt;/div&gt; css:123.hide &#123; display: none;&#125; 在父组件中直接调用子组件的函数父组件html：1&lt;app-child-form #childForm&gt;&lt;/app-child-form&gt; 父组件component：123456@ViewChild(&apos;childForm&apos;)childForm: ChildFormComponent;f(): void &#123; this.childForm.f();&#125; 子组件component：123f(): void &#123; console.log(&apos;child component&apos;);&#125; 日期格式转换java:1LocalDateTime time angular component：1time: Date html:1&#123;&#123;time| date:&apos;yyyy-MM-dd HH:mm:ss&apos;&#125;&#125; 在组件中使用自定义的管道pipe:12345678@Pipe(&#123; name: &apos;xxx&apos;&#125;)export class XxxPipe implements PipeTransform &#123; transform(value: AlarmRule, args?: any): any &#123; // ... &#125;&#125; Component：123456789101112131415@Component(&#123; selector: &apos;xxx&apos;, templateUrl: &apos;xxx.html&apos;, styleUrls: [&apos;xxx.css&apos;], providers: [ XxxPipe ]&#125;)export class XxxComponent &#123; constructor(private xxx: XxxPipe) &#123;&#125; // ... f(value) &#123;// 调用 this.xxx.transform(value); // ... &#125;&#125; 参考：https://alligator.io/angular/using-pipes-in-component-class/ 重置表单html:12&lt;form nz-form [formGroup]=&quot;form&quot;&gt;&lt;/form&gt; Component:1234567export class FormComponent implements OnInit &#123; form: FormGroup; clearForm() &#123; this.form.reset(); &#125;&#125; 参考：https://stackoverflow.com/questions/36655922/resetting-a-form-in-angular-2-after-submit 离开组件时销毁定时器12345678910111213export class xxxComponent implements OnInit, OnDestroy &#123; timer: any; ngOnInit() &#123; this.timer = setInterval(() =&gt; &#123; console.log(&apos;轮询&apos;); &#125;, 2000); &#125; ngOnDestroy() &#123; clearInterval(this.timer); &#125;&#125; 参考：https://stackoverflow.com/questions/35561320/end-interval-when-route-changes-in-angular-2/35561450 http请求返回非json数据返回类型：image/png1234567891011export class XxxService &#123; getRqCode() &#123; const url = &apos;&apos;; return this.http.post(url, &#123;&#125;, &#123; responseType: &apos;blob&apos; // 类型 &#125;).pipe( retry(1), catchError(this.handleError.bind(this)) ); &#125;&#125; img展示Blob类型数据component:1234567891011121314export class XxxComponent &#123; rqcode: any; getRqCode() &#123; this.xxxService.getRqCode().subscribe(resp =&gt; &#123; // blob转base64 const reader = new FileReader(); reader.readAsDataURL(resp); reader.onloadend = () =&gt; &#123; this.rqcode = reader.result; &#125;; &#125;); &#125;&#125; html:1&lt;img style=&quot;height: 200px; width: 200px;&quot; [src]=&quot;rqcode&quot;&gt; 参考：https://stackoverflow.com/questions/7650587/using-javascript-to-display-a-blob/44069294https://blog.csdn.net/fangquan1980/article/details/80675369https://stackoverflow.com/questions/18650168/convert-blob-to-base64","categories":[],"tags":[{"name":"angular","slug":"angular","permalink":"http://yoursite.com/tags/angular/"}],"keywords":[]},{"title":"通过策略模式和工厂模式减少代码中的if else","slug":"通过策略模式和工厂模式减少代码中的if else","date":"2019-03-14T11:05:08.039Z","updated":"2019-02-14T13:44:53.807Z","comments":true,"path":"2019/03/14/通过策略模式和工厂模式减少代码中的if else/","link":"","permalink":"http://yoursite.com/2019/03/14/通过策略模式和工厂模式减少代码中的if else/","excerpt":"","text":"枚举类：12345678910public enum ResourceStatus &#123; Health(1), UnHealth(0), NoAlarm(-1); @Getter private int seq; private ResourceStatus(int seq) &#123; this.seq = seq; &#125;&#125; 策略接口：12345678public interface Strategy &#123; /** *将val和状态值比较判断是否属于某种状态 * @param val 资源的健康值 * @return 是否属于某种状态 */ boolean compare(Double val);&#125; 策略具体实现类：12345678public class HealthStrategy implements Strategy&#123; private final Double healthVal = 60d; @Override public boolean compare(Double val) &#123; return val &gt;= healthVal; &#125;&#125; 12345678public class UnHealthStrategy implements Strategy&#123; private final Double healthVal = 60d; @Override public boolean compare(Double val) &#123; return val &lt; healthVal &amp;&amp; val &gt;= 0; &#125;&#125; 12345678public class NoAlarmStrategy implements Strategy&#123; private final Double healthVal = -1d; @Override public boolean compare(Double val) &#123; return val.equals(healthVal); &#125;&#125; 工厂类：1234567891011121314151617181920public class StrategyFactory &#123; private static StrategyFactory factory = new StrategyFactory(); private static Map&lt;Integer, Strategy&gt; strategyMap = new HashMap(); static&#123; strategyMap.put(ResourceStatus.Health.getSeq(), new HealthStrategy()); strategyMap.put(ResourceStatus.UnHealth.getSeq(), new UnHealthStrategy()); strategyMap.put(ResourceStatus.NoAlarm.getSeq(), new NoAlarmStrategy()); &#125; private StrategyFactory()&#123;&#125; public Strategy creator(Integer status)&#123; return strategyMap.get(status); &#125; public static StrategyFactory getInstance()&#123; return factory; &#125;&#125; 策略上下文：123456789@Datapublic class Context &#123; private Strategy strategy; public boolean compare(Double val, Integer status) &#123; strategy = StrategyFactory.getInstance().creator(status); return strategy.compare(val); &#125;&#125; 参考：https://blog.csdn.net/u011507568/article/details/70238491","categories":[],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/tags/设计模式/"}],"keywords":[]},{"title":"telegraf Jolokia2 plugin inputs","slug":"telegraf_Jolokia2_Input_Plugins","date":"2019-03-14T11:05:07.946Z","updated":"2019-05-24T09:19:32.017Z","comments":true,"path":"2019/03/14/telegraf_Jolokia2_Input_Plugins/","link":"","permalink":"http://yoursite.com/2019/03/14/telegraf_Jolokia2_Input_Plugins/","excerpt":"","text":"Jolokia2 Input PluginsJolokia Proxy: jolokia2 采集分为两种模式，一种是jvm代理，由java应用启动时修改参数引入jolokia2包-javaagent:/usr/local/jolokia-jvm-1.5.0-agent.jar=port=8778,host=0.0.0.0第二种是Proxy模式，由于第一种应用的限制，proxy模式不需要在应用端修改 在某些情况下，不可能在目标平台上部署Jolokia代理。这可能是出于政治原因，或者是仪表化服务器上已经建立的JSR-160导出。在这些环境中，Jolokia可以作为JMX代理进行操作。在此设置中，代理部署在专用代理Java EE服务器(或其他受支持的代理平台)上。代理连接Jolokia JSON请求和对目标服务器的远程JSR-160调用的响应。 Jolokia代理是通用的，与目标服务器无关，因为它通过传入请求(与HTTP代理相同)获取目标的信息。由于需要扩展信息，所以只能使用Jolokia POST请求进行代理，因为目前还没有方法将目标信息封装在GET Url中。请求的基本Jolokia URL是代理服务器的URL，而目标参数包含在请求中。在下一个示例中，一个代理Jolokia请求通过一个代理tomcat-proxy查询服务器jboss的活动线程数，该代理在Jolokia上下文中部署了一个代理。代理URL是这样的。 1http://jolokia-proxy:8080/jolokia 请求的POST参数如下： 12345678910&#123; &quot;type&quot;:&quot;READ&quot; &quot;mbean&quot;:&quot;java.lang:type=Threading&quot;, &quot;attribute&quot;:&quot;ThreadCount&quot;, &quot;target&quot;: &#123; &quot;url&quot;:&quot;service:jmx:rmi:///jndi/rmi://jboss-as:8686/jmxrmi&quot;, &quot;password&quot;:&quot;admin&quot;, &quot;user&quot;:&quot;s!cr!t&quot; &#125;,&#125; WAR Agent: WAR代理jolokia.war在Java EE服务器中部署为常规Web归档（WAR）。 此外，这是代理模式的代理，它部署在一个简单、专用的应用服务器中，比如Tomcat或Jetty。 安装与启动步骤1. 在Tomcat服务器上安装Jolokia代理1.从以下网址下载最新版本的Jolokia.war文件：https://jolokia.org/download.html2.将文件重命名jolokia-war-X.X.X.war为jolokia.war。3.将jolokia.war文件复制到${TOMCAT_HOME}/webapps。4.添加jolokia为角色tomcat-users.xml（Jolokia 1.6或更高版本强制使用）12&lt;role rolename=&quot;jolokia&quot;/&gt;&lt;user username=&quot;jolokia&quot; password=&quot;jolokia&quot; roles=&quot;jolokia&quot;/&gt; 5.启动Tomcat服务器。6.停止Tomcat服务器并修改jolokia的web.xml，添加以下内容（自版本1.5.0起，默认情况下不启用代理模式）12345678&lt;init-param&gt; &lt;description&gt; Classnames (comma separated) of RequestDispatcher used in addition to the LocalRequestDispatcher &lt;/description&gt; &lt;param-name&gt;dispatcherClasses&lt;/param-name&gt; &lt;param-value&gt;org.jolokia.jsr160.Jsr160RequestDispatcher&lt;/param-value&gt;&lt;/init-param&gt; 7.通过访问此URL验证Jolokia代理安装：http://tomcatip:8080/jolokia/version 步骤2.配置Telegraf Jolokia2输入插件1234567891011121314151617181920212223242526272829[[inputs.jolokia2_proxy]]# # default_tag_prefix = &quot;&quot;# # default_field_prefix = &quot;&quot;# # default_field_separator = &quot;.&quot;## ## Proxy agent url = &quot;http://tomcatip:8080/jolokia&quot; username = &quot;jolokia&quot; #如果是jolokia-war-unsecured-1.6.0.war则不需要username password = &quot;jolokia&quot; #如果是jolokia-war-unsecured-1.6.0.war则不需要password response_timeout = &quot;30s&quot;## ## Optional TLS config# # tls_ca = &quot;/var/private/ca.pem&quot;# # tls_cert = &quot;/var/private/client.pem&quot;# # tls_key = &quot;/var/private/client-key.pem&quot;# # insecure_skip_verify = false## ## Add proxy targets to query# # default_target_username = &quot;&quot;# # default_target_password = &quot;&quot; [[inputs.jolokia2_proxy.target]] url = &quot;service:jmx:rmi:///jndi/rmi://ip:port/jmxrmi&quot;# # username = &quot;&quot;# # password = &quot;&quot; [[inputs.jolokia2_agent.metric]] name = &quot;jvm_runtime&quot; mbean = &quot;java.lang:type=Runtime&quot; paths = [&quot;Uptime&quot;] 步骤3.配置多个targets12345678 [[inputs.jolokia2_proxy.target]] url = &quot;service:jmx:rmi:///jndi/rmi://ip:port/jmxrmi&quot;# # username = &quot;&quot;# # password = &quot;&quot; [[inputs.jolokia2_proxy.target]] url = &quot;service:jmx:rmi:///jndi/rmi://ip:port/jmxrmi&quot;# # username = &quot;&quot;# # password = &quot;&quot; 以抓取teamcenter的pool_manager为例telegraf.conf123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119[global_tags][agent] interval = &quot;60s&quot; #修改成实际的抓取间隔 round_interval = true metric_batch_size = 1000 metric_buffer_limit = 10000 collection_jitter = &quot;0s&quot; flush_interval = &quot;10s&quot; flush_jitter = &quot;0s&quot; precision = &quot;&quot; debug = false quiet = false logfile = &quot;&quot; hostname = &quot;&quot; omit_hostname = true################################################################################ OUTPUT PLUGINS ################################################################################[[outputs.influxdb]] urls = [&quot;http://ip:8086&quot;] #修改成实际的influxdb地址 database = &quot;volume_monitor&quot; skip_database_creation = true username = &quot;admin&quot; #有权限验证则修改用户名，否则删除该行配置 password = &quot;admin&quot; #有权限验证则修改密码，否则删除该行配置 namepass=[&quot;volume_*&quot;][[outputs.influxdb]] urls = [&quot;http://ip:8086&quot;] #修改成实际的influxdb地址 database = &quot;pool_monitor&quot; skip_database_creation = true username = &quot;admin&quot; #有权限验证则修改用户名，否则删除该行配置 password = &quot;admin&quot; #有权限验证则修改密码，否则删除该行配置 namepass=[&quot;pool_*&quot;]################################################################################ PROCESSOR PLUGINS ################################################################################[[processors.converter]] [processors.converter.fields] tag = [&quot;Assigned User&quot;][[processors.strings]] [[processors.strings.trim_prefix]] tag = &quot;jolokia_agent_url&quot; prefix = &quot;service:jmx:rmi:///jndi/rmi://&quot; [[processors.strings.trim_suffix]] tag = &quot;jolokia_agent_url&quot; suffix = &quot;/jmxrmi&quot;################################################################################ INPUT PLUGINS ################################################################################[[inputs.jolokia2_proxy]] name_prefix=&quot;volume_&quot; url = &quot;http://localhost:8181/jolokia&quot; #代理的tomcat地址 username = &quot;jolokia&quot; #代理的tomcat 用户名 password = &quot;jolokia&quot; #代理的tomcat 密码 response_timeout = &quot;60s&quot; [[inputs.jolokia2_proxy.target]] url = &quot;service:jmx:rmi:///jndi/rmi://ip:8999/jmxrmi&quot; #ip必须设置为主机名，即使是加了host映射 username = &quot;username&quot; #jmx有权限验证则修改用户名，否则删除该行配置 password = &quot;password&quot; #jmx有权限验证则修改密码，否则删除该行配置 [[inputs.jolokia2_proxy.metric]] name = &quot;fsc_local_read_write&quot; mbean = &quot;com.teamcenter.mld:units=mSec,name=LocalReadWholeFile-FMSWebHandlerRoot,type=*,SRC=*&quot; paths = [&quot;Active&quot;, &quot;ActiveSpan&quot;, &quot;AdHocValues&quot;, &quot;Age&quot;, &quot;CurrentFilter&quot;, &quot;FilterAlgorithm&quot;, &quot;FilterMovingAvgTime&quot;, &quot;FilterNum&quot;, &quot;FilterNumLastMax&quot;, &quot;FilterSpan&quot;, &quot;FilterTimeAvg&quot;, &quot;FilterTimeMax&quot;, &quot;FilterTimeMin&quot;, &quot;FilterTimeStdv&quot;, &quot;Histogram&quot;, &quot;KBytes&quot;, &quot;MeasureBytes&quot;, &quot;Name&quot;, &quot;NumFailures&quot;, &quot;NumSuccesses&quot;, &quot;TimeAvg&quot;, &quot;TimeMax&quot;, &quot;TimeMin&quot;, &quot;TimeNum&quot;, &quot;TimeStdv&quot;, &quot;Trace&quot;, &quot;TraceAboveMsec&quot;, &quot;TraceOneShot&quot;, &quot;TracePattern&quot;] tag_keys = [&quot;name&quot;] [[inputs.jolokia2_proxy.metric]] name = &quot;fsc_local_read_write&quot; mbean = &quot;com.teamcenter.mld:units=mSec,name=LocalWrite-FMSWebHandlerRoot,type=*,SRC=*&quot; paths = [&quot;Active&quot;, &quot;ActiveSpan&quot;, &quot;AdHocValues&quot;, &quot;Age&quot;, &quot;CurrentFilter&quot;, &quot;FilterAlgorithm&quot;, &quot;FilterMovingAvgTime&quot;, &quot;FilterNum&quot;, &quot;FilterNumLastMax&quot;, &quot;FilterSpan&quot;, &quot;FilterTimeAvg&quot;, &quot;FilterTimeMax&quot;, &quot;FilterTimeMin&quot;, &quot;FilterTimeStdv&quot;, &quot;Histogram&quot;, &quot;KBytes&quot;, &quot;MeasureBytes&quot;, &quot;Name&quot;, &quot;NumFailures&quot;, &quot;NumSuccesses&quot;, &quot;TimeAvg&quot;, &quot;TimeMax&quot;, &quot;TimeMin&quot;, &quot;TimeNum&quot;, &quot;TimeStdv&quot;, &quot;Trace&quot;, &quot;TraceAboveMsec&quot;, &quot;TraceOneShot&quot;, &quot;TracePattern&quot;] tag_keys = [&quot;name&quot;][[inputs.jolokia2_proxy]] name_prefix=&quot;pool_&quot; url = &quot;http://localhost:8181/jolokia&quot; #代理的tomcat地址 username = &quot;jolokia&quot; #代理的tomcat 用户名 password = &quot;jolokia&quot; #代理的tomcat 密码 response_timeout = &quot;60s&quot; [[inputs.jolokia2_proxy.target]] url = &quot;service:jmx:rmi:///jndi/rmi://ip:8088/jmxrmi&quot; #ip必须设置为主机名，即使是加了host映射 username = &quot;username&quot; #jmx有权限验证则修改用户名，否则删除该行配置 password = &quot;password&quot; #jmx有权限验证则修改密码，否则删除该行配置 [[inputs.jolokia2_proxy.metric]] name = &quot;administer_pool_manager&quot; mbean = &quot;Administer PoolA manager :id=*&quot; paths = [&quot;Assignment Service&quot;, &quot;Host&quot;, &quot;Mux&quot;, &quot;Number of Assigned Servers&quot;, &quot;Number of Cold Servers&quot;, &quot;Number of Servers&quot;, &quot;Number of Servers Terminated Before Normal Timeout&quot;, &quot;Number of Warm Servers&quot;, &quot;Number of Warming Up Servers&quot;, &quot;Pool ID&quot;, &quot;Servers in Edit Mode&quot;, &quot;Servers in Read Mode&quot;, &quot;Servers in Stateless Mode&quot;] tag_keys = [&quot;id&quot;] [[inputs.jolokia2_proxy.metric]] name = &quot;administer_pool_servers&quot; mbean = &quot;Administer PoolA servers :id=*&quot; paths = [&quot;Abandoned&quot;, &quot;Active&quot;, &quot;Assigned&quot;, &quot;Assigned User&quot;, &quot;Health Monitoring&quot;, &quot;Last Message Number&quot;,&quot;Last Message Time&quot;, &quot;Management Pipe Name&quot;, &quot;Process ID&quot;, &quot;Provisional&quot;, &quot;Ready&quot;, &quot;Remove&quot;, &quot;Request Pipe Name&quot;, &quot;Server ID&quot;, &quot;State&quot;] tag_keys = [&quot;id&quot;] 参考：https://github.com/influxdata/telegraf/tree/master/plugins/inputs/jolokia2https://jolokia.org/features/proxy.htmlhttps://jolokia.org/agent.htmlhttps://jolokia.org/tutorial.htmlhttps://jolokia.org/agent/war.htmlhttp://repo1.maven.org/maven2/org/jolokia/jolokia-war-unsecured/1.6.0/https://jolokia.org/reference/html/proxy.htmlhttps://jolokia.org/reference/html/proxy.htmlhttps://www.bountysource.com/issues/41049672-redesign-the-jolokia-input-plugin-as-jolokia2http://zhoujinl.github.io/2018/05/16/compared/","categories":[],"tags":[{"name":"telegraf","slug":"telegraf","permalink":"http://yoursite.com/tags/telegraf/"}],"keywords":[]},{"title":"Oracle报错，ORA-28001:口令已经失效","slug":"Oracle报错ORA-28001","date":"2019-03-14T11:05:07.935Z","updated":"2019-02-13T14:12:20.345Z","comments":true,"path":"2019/03/14/Oracle报错ORA-28001/","link":"","permalink":"http://yoursite.com/2019/03/14/Oracle报错ORA-28001/","excerpt":"","text":"WINDOWS下使用DOS命令行连接oracle数据库sqlplus userName/userPassword@netServiceName 1Oracle报错，ORA-28001: 口令已经失效 cmd命令行输入：12345678910sqlplus / as sysdbaSQL*Plus: Release 11.2.0.1.0 Production on 星期二 10月 17 15:42:58 2017Copyright (c) 1982, 2010, Oracle. All rights reserved.连接到:Oracle Database 11g Enterprise Edition Release 11.2.0.1.0 - ProductionWith the Partitioning, OLAP, Data Mining and Real Application Testing optionsSQL&gt; ALTER PROFILE DEFAULT LIMIT PASSWORD_LIFE_TIME UNLIMITED;配置文件已更改SQL&gt; alter user 用户名 dentified by 密码 account unlock;用户已更改。 再次测试登录即可","categories":[],"tags":[{"name":"oracle","slug":"oracle","permalink":"http://yoursite.com/tags/oracle/"}],"keywords":[]},{"title":"OCP-Oracle体系结构","slug":"OCP-Oracle体系结构","date":"2019-03-14T11:05:07.904Z","updated":"2019-07-26T08:19:11.574Z","comments":true,"path":"2019/03/14/OCP-Oracle体系结构/","link":"","permalink":"http://yoursite.com/2019/03/14/OCP-Oracle体系结构/","excerpt":"","text":"工具使用 sqlplus pl/sql develop sqldevelop toad …… 访问数据库的方式 本机直接通过sock方式访问（IPC） 1sqlplus / as sysdba 通过TCP建立连接到Oracle服务器&amp;Oracle网络配置 方式一： 123// ora10g --&gt;必须在 $ORACLE_HOME/network/admin/tnsnames.ora配置出如何访问到远程数据库服务器tnsping ora10gsqlplus sys/oracle@ora10g as sysdba 方式二： 12// 不需要任何配置，但oracle服务器必须在listener.ora定义被远程访问的方式sqlplus sys/oracle@ip:1521/ora10g as sysdba 数据库模型1.专用型一个进程一个会话2.共享型 执行sql流程 能执行sql语句的程序或进程就是用户进程 用户进程 执行一个查询语句，比如select * from emp where empno=7839; 用户进程已经跟服务进程建立链接,服务器进程会响应用户进程,一些会话信息就会存储在内存（PGA）中,把该用户进程的信息存储到PGA的UGA中。 语句经过PGA处理后传递给实例 实例中的共享池负责处理这条语句 库缓存区去判断语句如何分析–软分析或硬分析(以前是否执行过) sql语句操作的表在哪，表里面的行放在哪个block里面，所以需要数据字典 根据cbo得到的执行计划准备去执行语句，查询语句中的对象存放在哪个表空间的指定的行放在哪个块里面，数据字典缓存区得到这些信息 开始执行 判断在数据缓存区data buffer cache中是否缓存需要的块 如果是，在内存读取数据得到所需行的结果返回给用户，用户看到这行的结果如果没有，则服务器进程读取data file文件中对应的block到data buffer cache中，data buffer cache中的undo块用来做镜像，undo缓存块会对该块做镜像，然后读该镜像中的数据得到行的结果，用户看到执行的结果， redo log buffer记录数据库中块的更改，修改前后的块（提交和未提交）都在undo块中做了镜像，意味着可以写入磁盘与不可写入磁盘 oracle做这么多就是为了尽可能用内存去操作，关系型数据库最重要的就是内存和磁盘 语句执行性能的高低，从shared pool中的library cache和data dict cache的命中率进行判断 database buffer cache 命中率 关系到逻辑读（内存取数据）或物理读（磁盘取数据） redo log buffer 记录块的变化 DBWR进程会将已提交的数据写到物理磁盘data file，只有当redo log buffer 将所有块的变更信息记录下来之后才会开始写 内存中的redo log 日志会定时通过LGWR写到磁盘Redo Log file(主要用于恢复) CKPT保证数据同步，一旦触发，DBWR就开始写数据，接着LGWR也开始写数据（比如手动commit） rdbms的实现的一套完整的解决方案 一个实例（内存结构和后台进程）和数据库（物理文件和文件的逻辑结构）构成了oracle服务器 用户进程产生的日志文件12show parameter user_desc v$session v$process v$sql v$sqltext 1select username,sid from v$session;","categories":[],"tags":[{"name":"oracle","slug":"oracle","permalink":"http://yoursite.com/tags/oracle/"}],"keywords":[]}]}