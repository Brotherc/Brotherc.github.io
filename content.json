{"meta":{"title":"Brotherc","subtitle":null,"description":null,"author":"Brotherc","url":"http://yoursite.com"},"pages":[{"title":"all-tags","date":"2019-01-19T03:34:15.573Z","updated":"2019-01-19T03:34:15.573Z","comments":false,"path":"all-tags/index.html","permalink":"http://yoursite.com/all-tags/index.html","excerpt":"","text":""},{"title":"all-categories","date":"2019-01-19T03:33:53.552Z","updated":"2019-01-19T03:33:53.552Z","comments":false,"path":"all-categories/index.html","permalink":"http://yoursite.com/all-categories/index.html","excerpt":"","text":""},{"title":"all-archives","date":"2019-01-19T03:34:34.316Z","updated":"2019-01-19T03:34:34.316Z","comments":false,"path":"all-archives/index.html","permalink":"http://yoursite.com/all-archives/index.html","excerpt":"","text":""}],"posts":[{"title":"jdk1.8新特性","slug":"java8","date":"2019-03-28T03:44:49.456Z","updated":"2019-03-22T06:00:42.566Z","comments":true,"path":"2019/03/28/java8/","link":"","permalink":"http://yoursite.com/2019/03/28/java8/","excerpt":"","text":"HashMap结构 HashMap如果不用Hash算法、Hash表，那么每添加一个元素都要进行equals判断一次，效率很慢，HashMap默认大小为16。 jdk1.7 数组+链表 首先取对象的HashCode进行运算，生成数组的索引值，根据索引值找到位置，如果对应位置没有元素，则直接存储。如果存在元素，再通过equals比较两个对象的内容，如果内容一样，则覆盖原先的值，内容不一样，则在表头插入，形成链表。我们应该尽量减少元素的碰撞，否则效率很低，一旦出现碰撞，就得遍历整个链表的元素进行equals判断，所以HashCode和equals要尽量写得严谨些。但是，即使再严谨碰撞的情况也避免不了。所以HashMap提供了加载因子，当HashMap的大小超过75%时进行扩容，将会对元素重新运算位置，碰撞的概率也因此降低。 jdk1.8 数组+链表+红黑树 当某个链表的长度 &gt; 8 并且总元素 &gt; 64时，将会把链表转成红黑树。这样的好处是，出了添加操作，其他的操作都比链表快，而且扩容时，只需要将整棵树从新运算位置即可。同时，ConcurrentHashMap 的结构也跟着改变，也是数组+链表+红黑树的结构删除了concurrentlevel = 16,采用CAS算法，效率比锁高。 JVM内存结构 jdk1.7 存在永久区，永久区也会被垃圾回收，只是回收机制比较苛刻。 jdk1.8 没有永久区，取而代之的是MetaSpace元空间。元空间使用的是物理内存（物理内存有多大，元空间就有多大）只有当元空间的容量快满时，才会被回收。现在取决于物理内存（很大）。所以，垃圾回收机制触发的概率也低了。OOM发生的概率也低了。调优参数由以前的PremGenSize、MaxPremGenSize替换为MetaSpaceSize和MaxMetaSpaceSize 接口中的默认方法与静态方法demo1:12345public interface MyFun &#123; default String getName()&#123; return &quot;哈哈哈&quot;; &#125;&#125; 12345public class MyClass &#123; public String getName()&#123; return &quot;嘿嘿嘿&quot;; &#125;&#125; 1public class SubClass extends MyClass implements MyFun &#123;&#125; 123456public class TestDefaultInterface &#123; public static void main(String[] args) &#123; SubClass sc = new SubClass(); System.out.println(sc.getName()); //嘿嘿嘿 &#125;&#125; demo2:123456789public interface MyInterface &#123; default String getName()&#123; return &quot;呵呵呵&quot;; &#125; public static void show()&#123; System.out.println(&quot;接口中的静态方法&quot;); &#125;&#125; 123456public class SubClass /*extends MyClass*/ implements MyFun, MyInterface&#123; @Override public String getName() &#123; return MyInterface.super.getName(); &#125;&#125; 12345678public class TestDefaultInterface &#123; public static void main(String[] args) &#123; SubClass sc = new SubClass(); System.out.println(sc.getName()); //哈哈哈 MyInterface.show(); //接口中的静态方法 &#125;&#125; Stream API 的操作步骤创建 Stream：12345678910111213141516171819202122232425//创建 Stream： @Test public void test1()&#123; //1. Collection 提供了两个方法 stream() 与 parallelStream() List&lt;String&gt; list = new ArrayList&lt;&gt;(); Stream&lt;String&gt; stream = list.stream(); //获取一个顺序流 Stream&lt;String&gt; parallelStream = list.parallelStream(); //获取一个并行流 //2. 通过 Arrays 中的 stream() 获取一个数组流 Integer[] nums = new Integer[10]; Stream&lt;Integer&gt; stream1 = Arrays.stream(nums); //3. 通过 Stream 类中静态方法 of() Stream&lt;Integer&gt; stream2 = Stream.of(1,2,3,4,5,6); //4. 创建无限流 //迭代 Stream&lt;Integer&gt; stream3 = Stream.iterate(0, (x) -&gt; x + 2).limit(10); stream3.forEach(System.out::println); //生成 Stream&lt;Double&gt; stream4 = Stream.generate(Math::random).limit(2); stream4.forEach(System.out::println); &#125; 中间操作：12345678910// 初始化数据 List&lt;Employee&gt; emps = Arrays.asList( new Employee(102, &quot;李四&quot;, 59, 6666.66, Status.BUSY), new Employee(101, &quot;张三&quot;, 18, 9999.99, Status.FREE), new Employee(103, &quot;王五&quot;, 28, 3333.33, Status.VOCATION), new Employee(104, &quot;赵六&quot;, 8, 7777.77, Status.BUSY), new Employee(104, &quot;赵六&quot;, 8, 7777.77, Status.FREE), new Employee(104, &quot;赵六&quot;, 8, 7777.77, Status.FREE), new Employee(105, &quot;田七&quot;, 38, 5555.55, Status.BUSY) ); 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556/* 筛选与切片 filter——接收 Lambda ， 从流中排除某些元素。 limit——截断流，使其元素不超过给定数量。 skip(n) —— 跳过元素，返回一个扔掉了前 n 个元素的流。若流中元素不足 n 个，则返回一个空流。与 limit(n) 互补 distinct——筛选，通过流所生成元素的 hashCode() 和 equals() 去除重复元素 *///内部迭代：迭代操作 Stream API 内部完成@Testpublic void test2()&#123; //所有的中间操作不会做任何的处理 Stream&lt;Employee&gt; stream = emps.stream() .filter((e) -&gt; &#123; System.out.println(&quot;测试中间操作&quot;); return e.getAge() &lt;= 35; &#125;); //只有当做终止操作时，所有的中间操作会一次性的全部执行，称为“惰性求值” stream.forEach(System.out::println);&#125;//外部迭代@Testpublic void test3()&#123; Iterator&lt;Employee&gt; it = emps.iterator(); while(it.hasNext())&#123; System.out.println(it.next()); &#125;&#125;@Testpublic void test4()&#123; emps.stream() .filter((e) -&gt; &#123; System.out.println(&quot;短路！&quot;); // &amp;&amp; || return e.getSalary() &gt;= 5000; &#125;).limit(3) .forEach(System.out::println);&#125;@Testpublic void test5()&#123; emps.parallelStream() .filter((e) -&gt; e.getSalary() &gt;= 5000) .skip(2) .forEach(System.out::println);&#125;@Testpublic void test6()&#123; emps.stream() .distinct() .forEach(System.out::println);&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344/* 映射 map——接收 Lambda ， 将元素转换成其他形式或提取信息。接收一个函数作为参数，该函数会被应用到每个元素上，并将其映射成一个新的元素。 flatMap——接收一个函数作为参数，将流中的每个值都换成另一个流，然后把所有流连接成一个流 */@Testpublic void test1()&#123; Stream&lt;String&gt; str = emps.stream() .map((e) -&gt; e.getName()); System.out.println(&quot;-------------------------------------------&quot;); List&lt;String&gt; strList = Arrays.asList(&quot;aaa&quot;, &quot;bbb&quot;, &quot;ccc&quot;, &quot;ddd&quot;, &quot;eee&quot;); Stream&lt;String&gt; stream = strList.stream() .map(String::toUpperCase); stream.forEach(System.out::println); Stream&lt;Stream&lt;Character&gt;&gt; stream2 = strList.stream() .map(TestStreamAPI1::filterCharacter); stream2.forEach((sm) -&gt; &#123; sm.forEach(System.out::println); &#125;); System.out.println(&quot;---------------------------------------------&quot;); Stream&lt;Character&gt; stream3 = strList.stream() .flatMap(TestStreamAPI1::filterCharacter); stream3.forEach(System.out::println);&#125;public static Stream&lt;Character&gt; filterCharacter(String str)&#123; List&lt;Character&gt; list = new ArrayList&lt;&gt;(); for (Character ch : str.toCharArray()) &#123; list.add(ch); &#125; return list.stream();&#125; 12345678910111213141516171819202122/* sorted()——自然排序 sorted(Comparator com)——定制排序 */@Testpublic void test2()&#123; emps.stream() .map(Employee::getName) .sorted() .forEach(System.out::println); System.out.println(&quot;------------------------------------&quot;); emps.stream() .sorted((x, y) -&gt; &#123; if(x.getAge() == y.getAge())&#123; return x.getName().compareTo(y.getName()); &#125;else&#123; return Integer.compare(x.getAge(), y.getAge()); &#125; &#125;).forEach(System.out::println);&#125; 终止操作：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229/* allMatch——检查是否匹配所有元素 anyMatch——检查是否至少匹配一个元素 noneMatch——检查是否没有匹配的元素 findFirst——返回第一个元素 findAny——返回当前流中的任意元素 count——返回流中元素的总个数 max——返回流中最大值 min——返回流中最小值 */@Testpublic void test1()&#123; boolean bl = emps.stream() .allMatch((e) -&gt; e.getStatus().equals(Status.BUSY)); System.out.println(bl); boolean bl1 = emps.stream() .anyMatch((e) -&gt; e.getStatus().equals(Status.BUSY)); System.out.println(bl1); boolean bl2 = emps.stream() .noneMatch((e) -&gt; e.getStatus().equals(Status.BUSY)); System.out.println(bl2);&#125;@Testpublic void test2()&#123; Optional&lt;Employee&gt; op = emps.stream() .sorted((e1, e2) -&gt; Double.compare(e1.getSalary(), e2.getSalary())) .findFirst(); System.out.println(op.get()); System.out.println(&quot;--------------------------------&quot;); Optional&lt;Employee&gt; op2 = emps.parallelStream() .filter((e) -&gt; e.getStatus().equals(Status.FREE)) .findAny(); System.out.println(op2.get());&#125;@Testpublic void test3()&#123; long count = emps.stream() .filter((e) -&gt; e.getStatus().equals(Status.FREE)) .count(); System.out.println(count); Optional&lt;Double&gt; op = emps.stream() .map(Employee::getSalary) .max(Double::compare); System.out.println(op.get()); Optional&lt;Employee&gt; op2 = emps.stream() .min((e1, e2) -&gt; Double.compare(e1.getSalary(), e2.getSalary())); System.out.println(op2.get());&#125;//注意：流进行了终止操作后，不能再次使用@Testpublic void test4()&#123; Stream&lt;Employee&gt; stream = emps.stream() .filter((e) -&gt; e.getStatus().equals(Status.FREE)); long count = stream.count(); stream.map(Employee::getSalary) .max(Double::compare);&#125;/* 归约 reduce(T identity, BinaryOperator) / reduce(BinaryOperator) ——可以将流中元素反复结合起来，得到一个值。 */@Testpublic void test1()&#123; List&lt;Integer&gt; list = Arrays.asList(1,2,3,4,5,6,7,8,9,10); Integer sum = list.stream() .reduce(0, (x, y) -&gt; x + y); System.out.println(sum); System.out.println(&quot;----------------------------------------&quot;); Optional&lt;Double&gt; op = emps.stream() .map(Employee::getSalary) .reduce(Double::sum); System.out.println(op.get());&#125;//需求：搜索名字中 “六” 出现的次数@Testpublic void test2()&#123; Optional&lt;Integer&gt; sum = emps.stream() .map(Employee::getName) .flatMap(TestStreamAPI1::filterCharacter) .map((ch) -&gt; &#123; if(ch.equals(&apos;六&apos;)) return 1; else return 0; &#125;).reduce(Integer::sum); System.out.println(sum.get());&#125;//collect——将流转换为其他形式。接收一个 Collector接口的实现，用于给Stream中元素做汇总的方法@Testpublic void test3()&#123; List&lt;String&gt; list = emps.stream() .map(Employee::getName) .collect(Collectors.toList()); list.forEach(System.out::println); System.out.println(&quot;----------------------------------&quot;); Set&lt;String&gt; set = emps.stream() .map(Employee::getName) .collect(Collectors.toSet()); set.forEach(System.out::println); System.out.println(&quot;----------------------------------&quot;); HashSet&lt;String&gt; hs = emps.stream() .map(Employee::getName) .collect(Collectors.toCollection(HashSet::new)); hs.forEach(System.out::println);&#125;@Testpublic void test4()&#123; Optional&lt;Double&gt; max = emps.stream() .map(Employee::getSalary) .collect(Collectors.maxBy(Double::compare)); System.out.println(max.get()); Optional&lt;Employee&gt; op = emps.stream() .collect(Collectors.minBy((e1, e2) -&gt; Double.compare(e1.getSalary(), e2.getSalary()))); System.out.println(op.get()); Double sum = emps.stream() .collect(Collectors.summingDouble(Employee::getSalary)); System.out.println(sum); Double avg = emps.stream() .collect(Collectors.averagingDouble(Employee::getSalary)); System.out.println(avg); Long count = emps.stream() .collect(Collectors.counting()); System.out.println(count); System.out.println(&quot;--------------------------------------------&quot;); DoubleSummaryStatistics dss = emps.stream() .collect(Collectors.summarizingDouble(Employee::getSalary)); System.out.println(dss.getMax());&#125;//分组@Testpublic void test5()&#123; Map&lt;Status, List&lt;Employee&gt;&gt; map = emps.stream() .collect(Collectors.groupingBy(Employee::getStatus)); System.out.println(map);&#125;//多级分组@Testpublic void test6()&#123; Map&lt;Status, Map&lt;String, List&lt;Employee&gt;&gt;&gt; map = emps.stream() .collect(Collectors.groupingBy(Employee::getStatus, Collectors.groupingBy((e) -&gt; &#123; if(e.getAge() &gt;= 60) return &quot;老年&quot;; else if(e.getAge() &gt;= 35) return &quot;中年&quot;; else return &quot;成年&quot;; &#125;))); System.out.println(map);&#125;//分区@Testpublic void test7()&#123; Map&lt;Boolean, List&lt;Employee&gt;&gt; map = emps.stream() .collect(Collectors.partitioningBy((e) -&gt; e.getSalary() &gt;= 5000)); System.out.println(map);&#125;//@Testpublic void test8()&#123; String str = emps.stream() .map(Employee::getName) .collect(Collectors.joining(&quot;,&quot; , &quot;----&quot;, &quot;----&quot;)); System.out.println(str);&#125;@Testpublic void test9()&#123; Optional&lt;Double&gt; sum = emps.stream() .map(Employee::getSalary) .collect(Collectors.reducing(Double::sum)); System.out.println(sum.get());&#125; 时间日期操作jdk8以前时间操作线程问题：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293 class DateFormatThreadLocal &#123; private static final ThreadLocal&lt;DateFormat&gt; df = new ThreadLocal&lt;DateFormat&gt;()&#123; protected DateFormat initialValue()&#123; return new SimpleDateFormat(&quot;yyyyMMdd&quot;); &#125; &#125;; public static final Date convert(String source) throws ParseException&#123; return df.get().parse(source); &#125; &#125;public static void main(String[] args) throws Exception &#123; /*SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyyMMdd&quot;); Callable&lt;Date&gt; task = new Callable&lt;Date&gt;() &#123; @Override public Date call() throws Exception &#123; return sdf.parse(&quot;20161121&quot;); &#125; &#125;; ExecutorService pool = Executors.newFixedThreadPool(10); List&lt;Future&lt;Date&gt;&gt; results = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; 10; i++) &#123; results.add(pool.submit(task)); &#125; for (Future&lt;Date&gt; future : results) &#123; System.out.println(future.get()); &#125; pool.shutdown();*/ //解决多线程安全问题 /*Callable&lt;Date&gt; task = new Callable&lt;Date&gt;() &#123; @Override public Date call() throws Exception &#123; return DateFormatThreadLocal.convert(&quot;20161121&quot;); &#125; &#125;; ExecutorService pool = Executors.newFixedThreadPool(10); List&lt;Future&lt;Date&gt;&gt; results = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; 10; i++) &#123; results.add(pool.submit(task)); &#125; for (Future&lt;Date&gt; future : results) &#123; System.out.println(future.get()); &#125; pool.shutdown();*/ DateTimeFormatter dtf = DateTimeFormatter.ofPattern(&quot;yyyyMMdd&quot;); Callable&lt;LocalDate&gt; task = new Callable&lt;LocalDate&gt;() &#123; @Override public LocalDate call() throws Exception &#123; LocalDate ld = LocalDate.parse(&quot;20161121&quot;, dtf); return ld; &#125; &#125;; ExecutorService pool = Executors.newFixedThreadPool(10); List&lt;Future&lt;LocalDate&gt;&gt; results = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; 10; i++) &#123; results.add(pool.submit(task)); &#125; for (Future&lt;LocalDate&gt; future : results) &#123; System.out.println(future.get()); &#125; pool.shutdown();&#125; 新的时间API12345678910111213141516171819202122//1. LocalDate、LocalTime、LocalDateTime@Testpublic void test1()&#123; LocalDateTime ldt = LocalDateTime.now(); System.out.println(ldt); LocalDateTime ld2 = LocalDateTime.of(2016, 11, 21, 10, 10, 10); System.out.println(ld2); LocalDateTime ldt3 = ld2.plusYears(20); System.out.println(ldt3); LocalDateTime ldt4 = ld2.minusMonths(2); System.out.println(ldt4); System.out.println(ldt.getYear()); System.out.println(ldt.getMonthValue()); System.out.println(ldt.getDayOfMonth()); System.out.println(ldt.getHour()); System.out.println(ldt.getMinute()); System.out.println(ldt.getSecond());&#125; 1234567891011121314//2. Instant : 时间戳。 （使用 Unix 元年 1970年1月1日 00:00:00 所经历的毫秒值）@Testpublic void test2()&#123; Instant ins = Instant.now(); //默认使用 UTC 时区 System.out.println(ins); OffsetDateTime odt = ins.atOffset(ZoneOffset.ofHours(8)); System.out.println(odt); System.out.println(ins.getNano()); Instant ins2 = Instant.ofEpochSecond(5); System.out.println(ins2);&#125; 123456789101112131415161718192021222324252627//3.//Duration : 用于计算两个“时间”间隔//Period : 用于计算两个“日期”间隔@Testpublic void test3()&#123; Instant ins1 = Instant.now(); System.out.println(&quot;--------------------&quot;); try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; &#125; Instant ins2 = Instant.now(); System.out.println(&quot;所耗费时间为：&quot; + Duration.between(ins1, ins2)); System.out.println(&quot;----------------------------------&quot;); LocalDate ld1 = LocalDate.now(); LocalDate ld2 = LocalDate.of(2011, 1, 1); Period pe = Period.between(ld2, ld1); System.out.println(pe.getYears()); System.out.println(pe.getMonths()); System.out.println(pe.getDays());&#125; 123456789101112131415161718192021222324252627282930//4. TemporalAdjuster : 时间校正器@Testpublic void test4()&#123;LocalDateTime ldt = LocalDateTime.now(); System.out.println(ldt); LocalDateTime ldt2 = ldt.withDayOfMonth(10); System.out.println(ldt2); LocalDateTime ldt3 = ldt.with(TemporalAdjusters.next(DayOfWeek.SUNDAY)); System.out.println(ldt3); //自定义：下一个工作日 LocalDateTime ldt5 = ldt.with((l) -&gt; &#123; LocalDateTime ldt4 = (LocalDateTime) l; DayOfWeek dow = ldt4.getDayOfWeek(); if(dow.equals(DayOfWeek.FRIDAY))&#123; return ldt4.plusDays(3); &#125;else if(dow.equals(DayOfWeek.SATURDAY))&#123; return ldt4.plusDays(2); &#125;else&#123; return ldt4.plusDays(1); &#125; &#125;); System.out.println(ldt5);&#125; 123456789101112131415 //5. DateTimeFormatter : 解析和格式化日期或时间 @Test public void test5()&#123;// DateTimeFormatter dtf = DateTimeFormatter.ISO_LOCAL_DATE; DateTimeFormatter dtf = DateTimeFormatter.ofPattern(&quot;yyyy年MM月dd日 HH:mm:ss E&quot;); LocalDateTime ldt = LocalDateTime.now(); String strDate = ldt.format(dtf); System.out.println(strDate); LocalDateTime newLdt = ldt.parse(strDate, dtf); System.out.println(newLdt); &#125; 123456789101112131415//6.ZonedDate、ZonedTime、ZonedDateTime ： 带时区的时间或日期********@Testpublic void test7()&#123; LocalDateTime ldt = LocalDateTime.now(ZoneId.of(&quot;Asia/Shanghai&quot;)); System.out.println(ldt); ZonedDateTime zdt = ZonedDateTime.now(ZoneId.of(&quot;US/Pacific&quot;)); System.out.println(zdt);&#125;@Testpublic void test6()&#123; Set&lt;String&gt; set = ZoneId.getAvailableZoneIds(); set.forEach(System.out::println);&#125; Optional类1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889/* * 一、Optional 容器类：用于尽量避免空指针异常 * Optional.of(T t) : 创建一个 Optional 实例 * Optional.empty() : 创建一个空的 Optional 实例 * Optional.ofNullable(T t):若 t 不为 null,创建 Optional 实例,否则创建空实例 * isPresent() : 判断是否包含值 * orElse(T t) : 如果调用对象包含值，返回该值，否则返回t * orElseGet(Supplier s) :如果调用对象包含值，返回该值，否则返回 s 获取的值 * map(Function f): 如果有值对其处理，并返回处理后的Optional，否则返回 Optional.empty() * flatMap(Function mapper):与 map 类似，要求返回值必须是Optional */ @Test public void test1()&#123; Optional&lt;Employee&gt; op = Optional.of(new Employee()); Employee emp = op.get(); System.out.println(emp); &#125; @Test public void test2()&#123; /*Optional&lt;Employee&gt; op = Optional.ofNullable(null); System.out.println(op.get());*/// Optional&lt;Employee&gt; op = Optional.empty();// System.out.println(op.get()); &#125; @Test public void test3()&#123; Optional&lt;Employee&gt; op = Optional.ofNullable(new Employee()); if(op.isPresent())&#123; System.out.println(op.get()); &#125; Employee emp = op.orElse(new Employee(&quot;张三&quot;)); System.out.println(emp); Employee emp2 = op.orElseGet(() -&gt; new Employee()); System.out.println(emp2); &#125; @Test public void test4()&#123; Optional&lt;Employee&gt; op = Optional.of(new Employee(101, &quot;张三&quot;, 18, 9999.99)); Optional&lt;String&gt; op2 = op.map(Employee::getName); System.out.println(op2.get()); Optional&lt;String&gt; op3 = op.flatMap((e) -&gt; Optional.of(e.getName())); System.out.println(op3.get()); &#125; //需求：获取一个男人心中女神的名字 public String getGodnessName(Man man)&#123; if(man != null)&#123; Godness g = man.getGod(); if(g != null)&#123; return g.getName(); &#125; &#125; return &quot;苍老师&quot;; &#125; public String getGodnessName2(Optional&lt;NewMan&gt; man)&#123; return man.orElse(new NewMan()) .getGodness() .orElse(new Godness(&quot;苍老师&quot;)) .getName(); &#125; @Test public void test5()&#123; Man man = new Man(); String name = getGodnessName(man); System.out.println(name); &#125; //运用 Optional 的实体类 @Test public void test6()&#123; Optional&lt;Godness&gt; godness = Optional.ofNullable(new Godness(&quot;林志玲&quot;)); Optional&lt;NewMan&gt; op = Optional.ofNullable(new NewMan(godness)); String name = getGodnessName2(op); System.out.println(name); &#125;","categories":[],"tags":[{"name":"java8","slug":"java8","permalink":"http://yoursite.com/tags/java8/"}],"keywords":[]},{"title":"moment.js常用操作","slug":"momentJs常用操作","date":"2019-03-14T11:05:08.221Z","updated":"2019-03-07T13:17:44.737Z","comments":true,"path":"2019/03/14/momentJs常用操作/","link":"","permalink":"http://yoursite.com/2019/03/14/momentJs常用操作/","excerpt":"","text":"将String转成moment再格式化const date = ‘2019-03-07T21:16:00Z’;moment(date, ‘YYYY-MM-DDTHH:mm:ssZ’).format(‘HH:mm’)","categories":[],"tags":[{"name":"moment.js","slug":"moment-js","permalink":"http://yoursite.com/tags/moment-js/"}],"keywords":[]},{"title":"linux常用指令","slug":"linux常用指令","date":"2019-03-14T11:05:08.206Z","updated":"2019-02-19T14:08:05.230Z","comments":true,"path":"2019/03/14/linux常用指令/","link":"","permalink":"http://yoursite.com/2019/03/14/linux常用指令/","excerpt":"","text":"1.查看目录下有什么文件/目录 ls &emsp;&emsp;&emsp;&emsp;&emsp; //list 列出目录的文件信息ls -l或ll &emsp;&emsp;&ensp; //list -list 以”详细信息”查看目录文件ls -a &ensp;&emsp;&emsp; &emsp; //list -all 查看目录”全部”（包括隐藏文件）文件ls -al &ensp;&emsp;&emsp;&emsp; //list -all list 查看目录”全部”（包括隐藏文件）文件，以”详细信息”显示ls 目录 &ensp;&emsp; &emsp; //查看指定目录下有什么文件ls -i &emsp;&emsp;&emsp;&emsp; //查看文件索引号码 2.进行目录切换 cd dirname &emsp;//进行目录切换cd .. &emsp;&emsp;&emsp;&emsp;&ensp;//想上级目录切换cd ~ 或 cd &emsp;&ensp;//直接切换到当前用户 3.查看完整的操作位置 pwd 4.用户切换 su - 或 su - root &emsp;//向root用户切换exit &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&ensp; //退回到原用户su 用户名 &emsp;&emsp;&emsp;&emsp;//普通用户切换 多次使用su指令，会造成用户的”叠加”：（su和exit最好配合使用）lcs—&gt;root—&gt;lcs—&gt;root—&gt;lcs 5.查看当前用户是谁 whoami 6.图形界面与命令界面切换root用户可以切换 #init 3 #init 5 7.查看一个指令对应的执行程序文件在哪 which 指令 8.目录相关操作1）创建目录 make directory mkdir 目录名字mkdir -p newdir/newdir/newdir //递归方式创建多个连续目录，新的多级目录数目如果大于等于2个，&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp; 就要使用-p参数mkdir dir/newdir &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;//不用-p参数mkdir -p dir/newdir/newdir &emsp;&emsp;//使用-p参数 2）移动目录 move mv dir1 dir2 &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;//把dir1移动到dir2目录下mv dir1/dir2 dir3 &emsp;&emsp;&emsp;&ensp; //把dir2移动到dir3目录下mv dir1/dir2 dir3/dir4 &emsp;&ensp;//把dir2移动到dir4目录下mv dir1/dir2 ./ &emsp;&emsp;&emsp;&emsp;&emsp;//把dir2移动到当前目录下 3）改名字 mv dir1 newdir &emsp;&emsp;&emsp;&emsp;//修改dir1的名字为newdir mv是”移动”和”改名字”合并的指令mv dir1 ./newdir &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;//dir1移动到当前目录下，并改名字为newdirmv dir1/dir2 dir3 &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&ensp; //dir2移动到dir3目录下，并改名字为”原名”mv dir1/dir2 dir3/newdir &emsp;&emsp;&emsp;&emsp;//dir2移动到dir3目录下，并改名字为newdirmv dir1/dir2 dir3/dir4 &emsp;&emsp;&emsp;&emsp;&emsp; //dir2移动到dir4目录下，并改名字为”原名”mv dir1/dir2 dir3/dir4/newdir &emsp;&ensp;//dir2移动到dir4目录下，并改名字为newdir 4）复制（文件和目录）copy ①文件的复制 cp file1 dir/newfile2 &emsp;&emsp;&emsp;&emsp;//file1被复制一份到dir目录下，并改名字为newfile2cp file1 dir &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&ensp;//file1被复制一份到dir目录下，并改名字为”原名”cp dir1/filea dir2/newfile &emsp;&ensp; //filea被复制一份到dir目录下，并改名字为newfile ②目录的复制（需要设置-r[recursive递归]参数，无视目录的层次） cp -r dir1 dir2 &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;//dir1被复制到dir2目录下，并改名字为”原名”cp -r dir1/dir2 dir3/newdir &emsp;&emsp;&emsp;//dir2被复制到dir3目录下，并改名字为newdircp -r dir1/dir2 dir3/dir4 &emsp;&emsp;&emsp;&emsp; //dir2被复制到dir4目录下，并改名字为”原名”cp -r dir1/dir2 dir3/dir4/newdir &ensp;//dir2被复制到dir4目录下，并改名字为newdircp -r dir1 ../../newdir &emsp;&emsp;&emsp;&emsp;&emsp;&ensp;//dir1被复制到上两级目录下，并改名字为newdir ③删除（文件和目录）remove rm 文件rm -r 目录 &emsp;&emsp;&emsp;&emsp;&emsp;//-r[recursive递归]递归方式删除目录rm -rf 文件/目录 &emsp;&emsp; //-r force 递归强制方式删除文件，force强制，不需要额外导入提示 9.文件操作1）查看文件内容 cat filename &emsp;&emsp;&emsp;//打印文件内容到输出终端more filename &emsp;&emsp;//通过敲回车方式逐行查看文件的各个行内容，默认从第一行开始查看，&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp; //不支持回看，q退出查看less &emsp;&emsp;&emsp; &emsp;&emsp;&emsp;&emsp;//通过”上下左右”键查看文件的各个部分内容，支持回看，q退出查看head -n filename &ensp; //查看文件的前n行内容tail -n filename &emsp;&ensp; //查看文件的最末尾n行内容wc filename &emsp;&emsp;&emsp; //查看文件的行数 2）创建文件 touch dir1/filenametouch filename 3）给文件追加内容 echo 内容 &gt; 文件名称 &emsp;&emsp;&emsp;&emsp;//把”内容”以[覆盖写]方式追加给”文件”echo 内容 &gt;&gt; 文件名称 &emsp;&emsp;&emsp; //把”内容”以[追加]方式写给”文件” （如果文件不存在会创建文件） 10.用户操作配置文件：/etc/passwd1）创建用户 user add #useradd #useradd liming &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;//创建liming用户，同时会创建一个同名的组出来 #useradd -g 组别编号 username &emsp;&emsp;&ensp;//把用户的组别设置好，避免创建同名的组出来 #useradd -g 组编号 -u 用户编号 -d 家目录 username 2）修改用户 user modify #usermod -g 组编号 -u 用户编号 -d 家目录 -l 新名字 username（修改家目录时需要手动创建之） 3）删除用户 user delete #userdel username #userdel -r username //删除用户同时删除其家目录 4）给用户设置密码，使其登录系统 passwd 用户名 11.组别操作配置文件：/etc/group1）创建组 group add #groupadd music #groupadd movie #groupadd php 2）修改组 group modify #groupmod -g gid -n 新名字 groupname 3）删除组 group delete #groupdel groupname //组下边如果有用户存在，就禁止删除 12.查看指令可设置的参数 man 指令 13.给文件设置权限1）字母相对方式设置权限// 针对一个组别设置权限，其他组别权限没有变化，称为“相对方式”权限设置chmod指令chmod u+rwx filename //给filename文件的主人增加“读、写、执行”权限chmod g-rx filename //给filename文件的同组用户 删除“读、执行”权限 chmod u+/-rwx,g+/-rwx,o+/-rwx filename说明：①每个单元“+” “-”只能使用一个②可以同时给一个组或多个组设置权限，组别之间使用“，”分割③每个单元的权限可以是“rwx”中的一个或多个 chmod u+w,g-rx,o+rw filename //给filename文件主人增加写权限，同组删除读、执行权限，其他组增加读、写权限chmod u+w,u-x filename //给filename文件主人“增加写权限”同时“删除执行权限” chmod +/-rwx filename //无视具体组别，统一给全部的组设置权限 chmod +rw filename //给filename全部用户增加“读、写”权限 2）数字绝对方式设置权限r读：4 &emsp;&emsp; w写：2 &emsp;&emsp; x执行：10：没有权限1：执行2：写3：写、执行4：读5：读、执行6：读、写7：读、写、执行 chmod ABC filename //ABC分别代表主人、同组、其他组用户的数字权限 chmod 753 filename //主人读、写、执行；同组读、执行；其他组写、执行 问：字母相对 和 数字绝对 方式权限设置取舍？答：修改的权限相对“比较少”的时候使用“字母”方式，相反，权限变动“非常多”的时候就使用“数字”方式 14.在文件中查找内容grep 被搜索内容 文件 grep hello passwd //在passwd文件中搜索hello内容，会把hello所在行的内容都打印到终端显示 15.计算文件占据磁盘空间大小 du -h 文件（目录） 16.文件查找find 查找目录 选项 选项值 选项 选项值 …1）-name选项 根据名字进行查找 find / -name passwd &emsp;&emsp;&emsp;&emsp;//“递归遍历”/根目录及其内部深层目录，寻找名称等于“passwd”的文件find / -name “pas“[模糊查找] //在系统全部目录，模糊查找一个名字是“pas”开始的文件find / -name “er*” &emsp;&emsp;&emsp;&emsp;&emsp; //文件名字有出现“er”字样即可，不要位置 2）限制查找的目录层次 -maxdepth -mindepth-maxdepth 限制查找的最深目录-mindepth 限制查找的最浅目录 find / -maxdepth 4 -name passwdfind / -maxdepth 4 -mindepth 3 -name passwd 3）根据大小为条件进行文件查找-size +/-数字+号表示大小大于某个范围-号表示大小小于某个范围大小单位：-size 5 &emsp;&emsp; //单位是“512字节” 5512字节-size 10c &emsp; //单位是“字节” 10字节-size 3k &emsp;&ensp; //单位是“千字节” 31024字节-size 6M &emsp; //单位是“1024*千字节” 6M兆字节 find ./ -size 14c &emsp;&emsp;//在当前目录查找大小等于14千字节的文件find / -size +50M &emsp;//在系统全部目录里边查找大小大于50M的文件","categories":[],"tags":[{"name":"linux","slug":"linux","permalink":"http://yoursite.com/tags/linux/"}],"keywords":[]},{"title":"kapacitor issues","slug":"kapactior","date":"2019-03-14T11:05:08.203Z","updated":"2019-03-09T09:45:31.111Z","comments":true,"path":"2019/03/14/kapactior/","link":"","permalink":"http://yoursite.com/2019/03/14/kapactior/","excerpt":"","text":"kapacitor与influxdb在不同机器上通信时的配置kapacitor在启动时会向配置中的influxBD进行发现与创建订阅，这些订阅告诉InfluxDB将它收到的所有数据发送给Kapacitor。当kapacitor与influxdb不在同一台机器上时，需要在kapactior的配置中配置influxdb可以通信的IP或主机名。只要是在influxdb订阅过，influxdb之后都会像这些订阅发送数据 kapactior.conf:1hostname = &quot;localhost&quot; // 默认修改为influxdb可以ping得通的ip或主机名","categories":[],"tags":[{"name":"kapacitor","slug":"kapacitor","permalink":"http://yoursite.com/tags/kapacitor/"}],"keywords":[]},{"title":"Java常用操作","slug":"Java常用操作","date":"2019-03-14T11:05:08.200Z","updated":"2019-03-14T10:17:30.837Z","comments":true,"path":"2019/03/14/Java常用操作/","link":"","permalink":"http://yoursite.com/2019/03/14/Java常用操作/","excerpt":"","text":"java对Map进行排序根据key排序jdk8:12345// map为待排序的MapMap&lt;String, String&gt; sortMap = new TreeMap&lt;&gt;((String s1, String s2) -&gt; s1.compareTo(s2));sortMap.putAll(map);return sortMap; 参考：https://blog.csdn.net/weixin_41415986/article/details/82781618","categories":[],"tags":[{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"}],"keywords":[]},{"title":"pkg-config --cflags oci8, Package oci8 was not found in the pkg-config search path.","slug":"go-oracle","date":"2019-03-14T11:05:08.162Z","updated":"2019-02-01T09:56:37.529Z","comments":true,"path":"2019/03/14/go-oracle/","link":"","permalink":"http://yoursite.com/2019/03/14/go-oracle/","excerpt":"","text":"在linux下可以正常运行oracledb_exporter，在windows64下启动时报错12pkg-config --cflags oci8Package oci8 was not found in the pkg-config search path. 因为linux中已经安装了oracle客户端，所以怀疑可能是windows下没有导致的。1.go-oci8 地址：https://github.com/wendal/go-oci8 它是 https://github.com/mattn/go-oci8 的分支，增加了windows下中文的安装说明及相关文件。 从oracledb_exporter的代码中可以看到引用的是go-oci8_ &quot;github.com/mattn/go-oci8&quot;,所以需要安装windows的oracle连接。 2.安装oci 地址：https://www.oracle.com/technetwork/database/database-technologies/instant-client/downloads/index.html 我的安装目录为：F:\\instantclient_18 _3 3.安装oci-sdk 地址：同上。 我的安装目录为F:\\instantclient_18 _3\\sdk 4.安装MinGW 地址：https://sourceforge.net/projects/mingw-w64/files/ 我的安装目录为F:\\mingw-w64 配置环境变量：在系统变量path中追加 F:\\mingw-w64\\x86_64-8.1.0-posix-seh-rt_v6-rev0\\mingw64\\bin 5.下载go-oci8驱动 地址：https://github.com/wendal/go-oci8 运行命令 go get github.com/wendal/go-oci8 (报错先不管) 复制GOPATH目下的\\src\\github.com\\wendal\\go-oci8\\windows\\pkg-config.exe到到mingw的安装目录mingw64\\bin下。 复制GOPATH目下的\\src\\github.com\\wendal\\go-oci8\\windows\\oci8.pc到到mingw的安装目录mingw64\\lib\\pkg-config的下。 修改oci8.pc #Package Information for pkg-configprefix=F:/instantclient_18_3exec_prefix=F:/instantclient_18_3libdir=${exec_prefix}includedir=${prefix}/sdk/include/ Name: OCIDescription: Oracle database engineVersion: 18.3Libs: -L${libdir} -lociLibs.private:Cflags: -I${includedir} 6.环境变量配置 PATH=原有PATH;F:\\instantclient_18_3; PKG_CONFIG_PATH=F:\\mingw-w64\\x86_64-8.1.0-posix-seh-rt_v6-rev0\\mingw64\\lib\\pkg-config 启动报错1234F:\\GOENV\\src\\github.com\\wendal\\go-oci8\\oci8.go:119: cannot use (**_Ctype_struct_OCIServer)(unsafe.Pointer(&amp;conn.svc)) (type **_Ctype_struct_OCIServer) as type **_Ctype_struct_OCISvcCtx in argument to func literalF:\\GOENV\\src\\github.com\\wendal\\go-oci8\\oci8.go:136: cannot use (*_Ctype_struct_OCIServer)(c.svc) (type *_Ctype_struct_OCIServer) as type *_Ctype_struct_OCISvcCtx in argument to func literalF:\\GOENV\\src\\github.com\\wendal\\go-oci8\\oci8.go:263: cannot use (*_Ctype_struct_OCIServer)(s.c.svc) (type *_Ctype_struct_OCIServer) as type *_Ctype_struct_OCISvcCtx in argument to func literalF:\\GOENV\\src\\github.com\\wendal\\go-oci8\\oci8.go:383: cannot use (*_Ctype_struct_OCIServer)(s.c.svc) (type *_Ctype_struct_OCIServer) as type *_Ctype_struct_OCISvcCtx in argument to func literal 替换GOPATH目下的\\src\\github.com\\wendal\\go-oci8里四处OCIServer为OCISvcCtx。参考：https://www.cnblogs.com/ghj1976/p/3437250.htmlhttps://blog.csdn.net/wq57885/article/details/82841792","categories":[],"tags":[{"name":"go","slug":"go","permalink":"http://yoursite.com/tags/go/"}],"keywords":[]},{"title":"golang判断当前主机是物理机还是虚拟机","slug":"golang判断当前主机是物理机还是虚拟机","date":"2019-03-14T11:05:08.134Z","updated":"2019-03-14T10:31:59.655Z","comments":true,"path":"2019/03/14/golang判断当前主机是物理机还是虚拟机/","link":"","permalink":"http://yoursite.com/2019/03/14/golang判断当前主机是物理机还是虚拟机/","excerpt":"","text":"windows下命令行获取：1wmic path Win32_ComputerSystem get Model linux下命令行获取：1dmidecode | egrep -i &apos;system-product-name|product|domU&apos; 123456789101112131415161718192021222324func isVirtualMachine() (bool, error) &#123; model := &quot;&quot; var cmd *exec.Cmd if runtime.GOOS == &quot;windows&quot; &#123; cmd = exec.Command(&quot;cmd&quot;, &quot;/C&quot;, &quot;wmic path Win32_ComputerSystem get Model&quot;) &#125; else &#123; // linux cmd = exec.Command(&quot;/bin/bash&quot;, &quot;-c&quot;, &quot;dmidecode | egrep -i &apos;system-product-name|product|domU&apos;&quot;) &#125; stdout, err := cmd.Output() if err != nil &#123; return false, err &#125; model = string(stdout) if strings.Contains(model, &quot;VirtualBox&quot;) || strings.Contains(model, &quot;Virtual Machine&quot;) || strings.Contains(model, &quot;VMware Virtual Platform&quot;) || strings.Contains(model, &quot;KVM&quot;) || strings.Contains(model, &quot;Bochs&quot;) || strings.Contains(model, &quot;HVM domU&quot;) &#123; return true, nil &#125; return false, nil&#125; 参考：https://unix.stackexchange.com/questions/89714/easy-way-to-determine-virtualization-technologyhttps://blog.csdn.net/yangzhenping/article/details/49996765?utm_source=blogxgwz1https://blog.csdn.net/greless/article/details/71107767https://stackoverflow.com/questions/34229486/how-to-execute-a-linux-built-in-command-in-golanghttps://stackoverflow.com/questions/6182369/exec-a-shell-command-in-gohttps://stackoverflow.com/questions/13008255/how-to-execute-a-simple-windows-command-in-golang","categories":[],"tags":[{"name":"go","slug":"go","permalink":"http://yoursite.com/tags/go/"}],"keywords":[]},{"title":"centos7知识点","slug":"centos7","date":"2019-03-14T11:05:08.098Z","updated":"2019-03-09T09:08:56.389Z","comments":true,"path":"2019/03/14/centos7/","link":"","permalink":"http://yoursite.com/2019/03/14/centos7/","excerpt":"","text":"操作系统主机名修改centos6:1234#hostname //查看主机名#hostname newhostname //在当前会话修改主机名为newhostname，重启后失效#vim /etc/sysconfig/network //修改其中的HOSTNAME=newhostname，重启后依旧生效 centos7：123#hostname //查看主机名#vim /etc/hostname //直接修改其中的主机名，重启后依旧生效 时区操作centos6:123date // 查看时间date -R //查看时区cp /usr/share/zoneinfo/Asia/Tokyo /etc/localtime // 修改时区为东京时区 centos7:123timedatectl // 查看时间、时区。。。timedatectl set-timezone Asia/Tokyo // 修改时区为东京时区timedatectl set-local-rtc 1 //设置rtc时间与local时间相同 centos7 ip操作12345ip addr // 查看ip地址信息ip a add 192.168.8.149/24 dev eth0:2 // 添加网卡ipip a del 192.168.8.149/24 dev eth0:2 // 删除网卡ipip link set dev eth0 down // 将接口设备关闭ip link set dev eth0 up // 将接口设备启用","categories":[],"tags":[{"name":"centos7","slug":"centos7","permalink":"http://yoursite.com/tags/centos7/"}],"keywords":[]},{"title":"angular2中如何在发送delete请求时携带参数","slug":"angular发送带参数的delete请求","date":"2019-03-14T11:05:08.083Z","updated":"2019-02-13T15:07:03.434Z","comments":true,"path":"2019/03/14/angular发送带参数的delete请求/","link":"","permalink":"http://yoursite.com/2019/03/14/angular发送带参数的delete请求/","excerpt":"","text":"前端angular:1234567891011/** * 根据ids删除资源分组 */deleteResourceGroupByIds(ids: string[]) &#123; return this.http.request(&apos;DELETE&apos;, this.API + &apos;/resourceGroup&apos;, &#123; body: ids &#125;).pipe( retry(1), catchError(this.handleError.bind(this)) );&#125; 后台springboot:1234@DeleteMapping(&quot;/resourceGroup&quot;)public void deleteResourceGroupByIds(@RequestBody String[] ids) &#123; resourceGroupService.deleteResourceGroupByIds(ids);&#125; 参考：https://stackoverflow.com/questions/38819336/body-of-http-delete-request-in-angular2","categories":[],"tags":[{"name":"angular","slug":"angular","permalink":"http://yoursite.com/tags/angular/"}],"keywords":[]},{"title":"angular常用操作","slug":"angular常用操作","date":"2019-03-14T11:05:08.049Z","updated":"2019-03-07T13:13:36.369Z","comments":true,"path":"2019/03/14/angular常用操作/","link":"","permalink":"http://yoursite.com/2019/03/14/angular常用操作/","excerpt":"","text":"angular遍历maphtml:12345&lt;ul&gt; &lt;li *ngFor=&quot;let recipient of map | keyvalue&quot;&gt; &#123;&#123;recipient.key&#125;&#125; --&gt; &#123;&#123;recipient.value&#125;&#125; &lt;/li&gt;&lt;/ul&gt; cpmponent:12345myMap : Map&lt;string, boolean&gt;;for(let key of myMap.keys()) &#123; console.log(key); console.log(myMap.get(key));&#125; 1234Object.keys(myMap).map( key =&gt; &#123; console.log(&apos;key: &apos; + key); console.log(&apos;value: &apos; + result[key]);&#125;); 1234for (const [key, val] of map) &#123; console.log(key); console.log(val);&#125; 参考：https://stackoverflow.com/questions/48187362/how-to-iterate-using-ngfor-loop-map-containing-key-as-string-and-values-as-map-i/48187637 保留两位小数1Math.floor(15.7784514000 * 100) / 100 // 输出结果为 15.77 创建Map并赋值1const map = new Map([[2, &apos;foo&apos;], [1, &apos;bar&apos;]]); angular中html界面的if else 表示1234567&lt;div *ngIf=&quot;someCondition; else falsyTemplate&quot;&gt; &lt;h1&gt;Condition Passed!&lt;/h1&gt;&lt;/div&gt;&lt;ng-template #falsyTemplate&gt; &lt;h1&gt;Condition Failed!&lt;/h1&gt;&lt;/ng-template&gt; angular中http请求的option、params使用1234let option = &#123;&#125;;const params = new HttpParams().append(&apos;key&apos;, String(&apos;val&apos;));params = params.append(&apos;status&apos;, String(status)); // 注意要从新赋值给paramsoption = &#123;params&#125;; angular判断Map类型123isMap(obj) &#123; return obj instanceof Map;&#125; 删除数组中的某个元素123const arr = [&apos;a&apos;,&apos;b&apos;,&apos;c&apos;,&apos;d&apos;];arr.splice(1,1);console.log(arr); //[&apos;a&apos;,&apos;c&apos;,&apos;d&apos;]; angular的html根据条件显示样式html：1&lt;div [class.hide]=&quot;someCondition&quot;&gt;&lt;/div&gt; css:123.hide &#123; display: none;&#125; 在父组件中直接调用子组件的函数父组件html：1&lt;app-child-form #childForm&gt;&lt;/app-child-form&gt; 父组件component：123456@ViewChild(&apos;childForm&apos;)childForm: ChildFormComponent;f(): void &#123; this.childForm.f();&#125; 子组件component：123f(): void &#123; console.log(&apos;child component&apos;);&#125; Object转成Map1const result = new Map(Object.entries(map)); 将Map的key、value转成数组12const values = Array.from(map.values());const keys = Array.from(map.keys());","categories":[],"tags":[{"name":"angular","slug":"angular","permalink":"http://yoursite.com/tags/angular/"}],"keywords":[]},{"title":"通过策略模式和工厂模式减少代码中的if else","slug":"通过策略模式和工厂模式减少代码中的if else","date":"2019-03-14T11:05:08.039Z","updated":"2019-02-14T13:44:53.807Z","comments":true,"path":"2019/03/14/通过策略模式和工厂模式减少代码中的if else/","link":"","permalink":"http://yoursite.com/2019/03/14/通过策略模式和工厂模式减少代码中的if else/","excerpt":"","text":"枚举类：12345678910public enum ResourceStatus &#123; Health(1), UnHealth(0), NoAlarm(-1); @Getter private int seq; private ResourceStatus(int seq) &#123; this.seq = seq; &#125;&#125; 策略接口：12345678public interface Strategy &#123; /** *将val和状态值比较判断是否属于某种状态 * @param val 资源的健康值 * @return 是否属于某种状态 */ boolean compare(Double val);&#125; 策略具体实现类：12345678public class HealthStrategy implements Strategy&#123; private final Double healthVal = 60d; @Override public boolean compare(Double val) &#123; return val &gt;= healthVal; &#125;&#125; 12345678public class UnHealthStrategy implements Strategy&#123; private final Double healthVal = 60d; @Override public boolean compare(Double val) &#123; return val &lt; healthVal &amp;&amp; val &gt;= 0; &#125;&#125; 12345678public class NoAlarmStrategy implements Strategy&#123; private final Double healthVal = -1d; @Override public boolean compare(Double val) &#123; return val.equals(healthVal); &#125;&#125; 工厂类：1234567891011121314151617181920public class StrategyFactory &#123; private static StrategyFactory factory = new StrategyFactory(); private static Map&lt;Integer, Strategy&gt; strategyMap = new HashMap(); static&#123; strategyMap.put(ResourceStatus.Health.getSeq(), new HealthStrategy()); strategyMap.put(ResourceStatus.UnHealth.getSeq(), new UnHealthStrategy()); strategyMap.put(ResourceStatus.NoAlarm.getSeq(), new NoAlarmStrategy()); &#125; private StrategyFactory()&#123;&#125; public Strategy creator(Integer status)&#123; return strategyMap.get(status); &#125; public static StrategyFactory getInstance()&#123; return factory; &#125;&#125; 策略上下文：123456789@Datapublic class Context &#123; private Strategy strategy; public boolean compare(Double val, Integer status) &#123; strategy = StrategyFactory.getInstance().creator(status); return strategy.compare(val); &#125;&#125; 参考：https://blog.csdn.net/u011507568/article/details/70238491","categories":[],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/tags/设计模式/"}],"keywords":[]},{"title":"加密类型及其相关算法","slug":"加密类型及其相关算法","date":"2019-03-14T11:05:08.020Z","updated":"2019-02-11T16:14:23.617Z","comments":true,"path":"2019/03/14/加密类型及其相关算法/","link":"","permalink":"http://yoursite.com/2019/03/14/加密类型及其相关算法/","excerpt":"","text":"一、数据传输安全性在TCP/IP层中不涉及安全 机密性：明文传输（ftp,smtp,talnet）别人一拦截就能看到请求的内容。 完整性：10颗原子弹（被改成100）所以数据在互联网上传播的时候，不应该也不能够被其他人非法篡改掉当收到的和发送的不一致时拒绝接受这就能保证数据的完整性。 身份验证：通过有效的手段保证所访问的对象就是我们所要的那个人。 保证数据的机密性 plaintext(明文) –&gt; 加密（转换规则）–&gt; ciphertext（密文） ciphertext –&gt; 转换规则 –&gt; plaintext 转换算法：依赖密钥（即使得到了转换规则也没用） 对称加密：加密和解密使用同一个密钥（有加密算法和解密算法，算法不同，但密钥相同）。好处是计算速度快，在一定程度上解决了机密性问题。坏处是不能解决密钥有效管理的问题。假如a跟b，c,d通信，如果密钥相同，则c只要用密钥就可以看到a发送给b的内容，显然密钥不能相同，那就得维护很多密钥。 保证数据的完整性 A：plaintext:footprint –&gt; BB使用同样的加密算法去重复计算这个明文的特征码，并跟A所发过来的特征码进行比较，如果一样，则说明没被篡改。 单项加密算法：提取数据特征码，追加到数据后面。数据的输入一样：特征码必然相同。 特点：雪崩效应（输入的微小改变，将其会引起结果的巨大改变）、定长输出（无论原始数据是多长，结果大小都是相同的）、不可逆（无法根据原始特征码还原原来的数据）。 中间人攻击问题 E(A)：plaintext2:footprint2 –&gt; BA生成一段数据，并对它计算特征码，E在中间经过的路由时拿到这个明文，并重新修改明文和再计算特征码发给B，还声称自己是A，B拿到数据之后就算使用了数据完整性的算法之后，计算特征码还是一模一样，还认为是A发过来的，所以需要借助额外的机制。 解决办法：A：plaintext:footprint(加密) –&gt; B B拿到特征码之后通过密钥进行解密，能解密说明数据没有被改过。如果E拿到plaintext并修改为plaintext2，并重新生成特征码，就没办法加密特征码或者加密后就不是A和B之间实现约定的密码。 A与B之间如何进行密码约定 假如A与B之间从未通信或从未见过面，如何进行密码约定呢？ 协商生成密码：密码交换（Internet Key Exchange / IKE）,密码交换是不让第三方得到密钥，密码交换需要特殊的互联网协议支撑。比如：Dffie-Hellman协议。 A和B事先约定两个数p(大素数)，g(生成数)。A生成一个自己知道的x，B生成一个自己知道的y。A将 g^x % p 发送给B，B将g^y % p 发送给A。A拿到之后进行计算 （g^y % p）^x = g^xy % p，B拿到之后进行计算 （g^x % p）^y = g^xy % p。这个相同的结果就是密钥。在互联网上可以看到g、p、g^x % p、g^y % p，但看不到x、y。 A和B只需要选好几个数，让这些数的计算结果作为密钥来用，使得彼此不用计算密码，只要双方生成密钥的软件一样就可以随时生成密钥。 身份验证 之前是A和B一起约定好的密码，所以身份验证没问题。但是密钥是交换生成的，事先之前谁也不知道。E跳出来，截取了数据并篡改，然后与B进行连接通信，还告诉它自己是A。 解决办法：公钥加密算法（非对称加密算法） 特点：拥有一对密钥对，分别是公钥（是从私钥中提取出来的）、私钥。用公钥加密的，只能用私钥解密，反之亦然。 结论 机密性：用B的公钥加密，B的私钥解密。发送方用对方的公钥加密数据，可以保证数据机密性。 身份验证：用A的私钥加密，A的公钥加密。发送方用自己的私钥加密数据，可以实现身份验证。 公钥加密算法很少用来加密数据：速度太慢。 二、数据传输A beautiful sunrise — — — — — — —|&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;||&emsp;&emsp;&emsp;&emsp;A&emsp;&emsp;&emsp;&ensp;&ensp; ||&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;||&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;|— — — — — — —","categories":[],"tags":[{"name":"加密","slug":"加密","permalink":"http://yoursite.com/tags/加密/"}],"keywords":[]},{"title":"telegraf plugin inputs","slug":"telegraf_Jolokia2_Input_Plugins","date":"2019-03-14T11:05:07.946Z","updated":"2019-03-14T10:03:58.462Z","comments":true,"path":"2019/03/14/telegraf_Jolokia2_Input_Plugins/","link":"","permalink":"http://yoursite.com/2019/03/14/telegraf_Jolokia2_Input_Plugins/","excerpt":"","text":"Jolokia2 Input PluginsJolokia Proxy: jolokia2 采集分为两种模式，一种是jvm代理，由java应用启动时修改参数引入jolokia2包-javaagent:/usr/local/jolokia-jvm-1.5.0-agent.jar=port=8778,host=0.0.0.0第二种是Proxy模式，由于第一种应用的限制，proxy模式不需要在应用端修改 在某些情况下，不可能在目标平台上部署Jolokia代理。这可能是出于政治原因，或者是仪表化服务器上已经建立的JSR-160导出。在这些环境中，Jolokia可以作为JMX代理进行操作。在此设置中，代理部署在专用代理Java EE服务器(或其他受支持的代理平台)上。代理连接Jolokia JSON请求和对目标服务器的远程JSR-160调用的响应。 Jolokia代理是通用的，与目标服务器无关，因为它通过传入请求(与HTTP代理相同)获取目标的信息。由于需要扩展信息，所以只能使用Jolokia POST请求进行代理，因为目前还没有方法将目标信息封装在GET Url中。请求的基本Jolokia URL是代理服务器的URL，而目标参数包含在请求中。在下一个示例中，一个代理Jolokia请求通过一个代理tomcat-proxy查询服务器jboss的活动线程数，该代理在Jolokia上下文中部署了一个代理。代理URL是这样的。 1http://jolokia-proxy:8080/jolokia 请求的POST参数如下： 12345678910&#123; &quot;type&quot;:&quot;READ&quot; &quot;mbean&quot;:&quot;java.lang:type=Threading&quot;, &quot;attribute&quot;:&quot;ThreadCount&quot;, &quot;target&quot;: &#123; &quot;url&quot;:&quot;service:jmx:rmi:///jndi/rmi://jboss-as:8686/jmxrmi&quot;, &quot;password&quot;:&quot;admin&quot;, &quot;user&quot;:&quot;s!cr!t&quot; &#125;,&#125; WAR Agent: WAR代理jolokia.war在Java EE服务器中部署为常规Web归档（WAR）。 此外，这是代理模式的代理，它部署在一个简单、专用的应用服务器中，比如Tomcat或Jetty。 安装与启动步骤1. 在Tomcat服务器上安装Jolokia代理1.从以下网址下载最新版本的Jolokia.war文件：https://jolokia.org/download.html2.将文件重命名jolokia-war-X.X.X.war为jolokia.war。3.将jolokia.war文件复制到${TOMCAT_HOME}/webapps。4.添加jolokia为角色tomcat-users.xml（Jolokia 1.6或更高版本强制使用）12&lt;role rolename=&quot;jolokia&quot;/&gt;&lt;user username=&quot;jolokia&quot; password=&quot;jolokia&quot; roles=&quot;jolokia&quot;/&gt; 5.启动Tomcat服务器。6.停止Tomcat服务器并修改jolokia的web.xml，添加以下内容（自版本1.5.0起，默认情况下不启用代理模式）12345678&lt;init-param&gt; &lt;description&gt; Classnames (comma separated) of RequestDispatcher used in addition to the LocalRequestDispatcher &lt;/description&gt; &lt;param-name&gt;dispatcherClasses&lt;/param-name&gt; &lt;param-value&gt;org.jolokia.jsr160.Jsr160RequestDispatcher&lt;/param-value&gt;&lt;/init-param&gt; 7.通过访问此URL验证Jolokia代理安装：http://tomcatip:8080/jolokia/version 步骤2.配置Telegraf Jolokia2输入插件1234567891011121314151617181920212223242526272829[[inputs.jolokia2_proxy]]# # default_tag_prefix = &quot;&quot;# # default_field_prefix = &quot;&quot;# # default_field_separator = &quot;.&quot;## ## Proxy agent url = &quot;http://tomcatip:8080/jolokia&quot; username = &quot;jolokia&quot; #如果是jolokia-war-unsecured-1.6.0.war则不需要username password = &quot;jolokia&quot; #如果是jolokia-war-unsecured-1.6.0.war则不需要password response_timeout = &quot;30s&quot;## ## Optional TLS config# # tls_ca = &quot;/var/private/ca.pem&quot;# # tls_cert = &quot;/var/private/client.pem&quot;# # tls_key = &quot;/var/private/client-key.pem&quot;# # insecure_skip_verify = false## ## Add proxy targets to query# # default_target_username = &quot;&quot;# # default_target_password = &quot;&quot; [[inputs.jolokia2_proxy.target]] url = &quot;service:jmx:rmi:///jndi/rmi://ip:port/jmxrmi&quot;# # username = &quot;&quot;# # password = &quot;&quot; [[inputs.jolokia2_agent.metric]] name = &quot;jvm_runtime&quot; mbean = &quot;java.lang:type=Runtime&quot; paths = [&quot;Uptime&quot;] 步骤3.配置多个targets12345678 [[inputs.jolokia2_proxy.target]] url = &quot;service:jmx:rmi:///jndi/rmi://ip:port/jmxrmi&quot;# # username = &quot;&quot;# # password = &quot;&quot; [[inputs.jolokia2_proxy.target]] url = &quot;service:jmx:rmi:///jndi/rmi://ip:port/jmxrmi&quot;# # username = &quot;&quot;# # password = &quot;&quot; 参考：https://github.com/influxdata/telegraf/tree/master/plugins/inputs/jolokia2https://jolokia.org/features/proxy.htmlhttps://jolokia.org/agent.htmlhttps://jolokia.org/tutorial.htmlhttps://jolokia.org/agent/war.htmlhttp://repo1.maven.org/maven2/org/jolokia/jolokia-war-unsecured/1.6.0/https://jolokia.org/reference/html/proxy.htmlhttps://jolokia.org/reference/html/proxy.htmlhttps://www.bountysource.com/issues/41049672-redesign-the-jolokia-input-plugin-as-jolokia2http://zhoujinl.github.io/2018/05/16/compared/","categories":[],"tags":[{"name":"telegraf","slug":"telegraf","permalink":"http://yoursite.com/tags/telegraf/"}],"keywords":[]},{"title":"Oracle报错，ORA-28001:口令已经失效","slug":"Oracle报错ORA-28001","date":"2019-03-14T11:05:07.935Z","updated":"2019-02-13T14:12:20.345Z","comments":true,"path":"2019/03/14/Oracle报错ORA-28001/","link":"","permalink":"http://yoursite.com/2019/03/14/Oracle报错ORA-28001/","excerpt":"","text":"WINDOWS下使用DOS命令行连接oracle数据库sqlplus userName/userPassword@netServiceName 1Oracle报错，ORA-28001: 口令已经失效 cmd命令行输入：12345678910sqlplus / as sysdbaSQL*Plus: Release 11.2.0.1.0 Production on 星期二 10月 17 15:42:58 2017Copyright (c) 1982, 2010, Oracle. All rights reserved.连接到:Oracle Database 11g Enterprise Edition Release 11.2.0.1.0 - ProductionWith the Partitioning, OLAP, Data Mining and Real Application Testing optionsSQL&gt; ALTER PROFILE DEFAULT LIMIT PASSWORD_LIFE_TIME UNLIMITED;配置文件已更改SQL&gt; alter user 用户名 dentified by 密码 account unlock;用户已更改。 再次测试登录即可","categories":[],"tags":[{"name":"oracle","slug":"oracle","permalink":"http://yoursite.com/tags/oracle/"}],"keywords":[]},{"title":"OCP-Oracle体系结构","slug":"OCP-Oracle体系结构","date":"2019-03-14T11:05:07.904Z","updated":"2019-03-14T05:34:16.870Z","comments":true,"path":"2019/03/14/OCP-Oracle体系结构/","link":"","permalink":"http://yoursite.com/2019/03/14/OCP-Oracle体系结构/","excerpt":"","text":"工具使用 sqlplus pl/sql develop sqldevelop toad …… 访问数据库的方式 本机直接通过sock方式访问（IPC） 1sqlplus / as sysdba 通过TCP建立连接到Oracle服务器&amp;Oracle网络配置 方式一： 123// ora10g --&gt;必须在 $ORACLE_HOME/network/admin/tnsnames.ora配置出如何访问到远程数据库服务器tnsping ora10gsqlplus sys/oracle@ora10g as sysdba 方式二： 12// 不需要任何配置，但oracle服务器必须在listener.ora定义被远程访问的方式sqlplus sys/oracle@ip:1521/ora10g as sysdba","categories":[],"tags":[{"name":"oracle","slug":"oracle","permalink":"http://yoursite.com/tags/oracle/"}],"keywords":[]}]}