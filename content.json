{"meta":{"title":"Brotherc","subtitle":null,"description":null,"author":"Brotherc","url":"http://yoursite.com"},"pages":[{"title":"all-categories","date":"2019-01-19T03:33:53.552Z","updated":"2019-01-19T03:33:53.552Z","comments":false,"path":"all-categories/index.html","permalink":"http://yoursite.com/all-categories/index.html","excerpt":"","text":""},{"title":"all-tags","date":"2019-01-19T03:34:15.573Z","updated":"2019-01-19T03:34:15.573Z","comments":false,"path":"all-tags/index.html","permalink":"http://yoursite.com/all-tags/index.html","excerpt":"","text":""},{"title":"all-archives","date":"2019-01-19T03:34:34.316Z","updated":"2019-01-19T03:34:34.316Z","comments":false,"path":"all-archives/index.html","permalink":"http://yoursite.com/all-archives/index.html","excerpt":"","text":""}],"posts":[{"title":"kapacitor issues","slug":"kapactior","date":"2019-03-14T05:04:19.423Z","updated":"2019-03-09T09:45:31.111Z","comments":true,"path":"2019/03/14/kapactior/","link":"","permalink":"http://yoursite.com/2019/03/14/kapactior/","excerpt":"","text":"kapacitor与influxdb在不同机器上通信时的配置kapacitor在启动时会向配置中的influxBD进行发现与创建订阅，这些订阅告诉InfluxDB将它收到的所有数据发送给Kapacitor。当kapacitor与influxdb不在同一台机器上时，需要在kapactior的配置中配置influxdb可以通信的IP或主机名。只要是在influxdb订阅过，influxdb之后都会像这些订阅发送数据 kapactior.conf:1hostname = &quot;localhost&quot; // 默认修改为influxdb可以ping得通的ip或主机名","categories":[],"tags":[{"name":"kapacitor","slug":"kapacitor","permalink":"http://yoursite.com/tags/kapacitor/"}],"keywords":[]},{"title":"centos7知识点","slug":"centos7","date":"2019-03-14T05:04:19.322Z","updated":"2019-03-09T09:08:56.389Z","comments":true,"path":"2019/03/14/centos7/","link":"","permalink":"http://yoursite.com/2019/03/14/centos7/","excerpt":"","text":"操作系统主机名修改centos6:1234#hostname //查看主机名#hostname newhostname //在当前会话修改主机名为newhostname，重启后失效#vim /etc/sysconfig/network //修改其中的HOSTNAME=newhostname，重启后依旧生效 centos7：123#hostname //查看主机名#vim /etc/hostname //直接修改其中的主机名，重启后依旧生效 时区操作centos6:123date // 查看时间date -R //查看时区cp /usr/share/zoneinfo/Asia/Tokyo /etc/localtime // 修改时区为东京时区 centos7:123timedatectl // 查看时间、时区。。。timedatectl set-timezone Asia/Tokyo // 修改时区为东京时区timedatectl set-local-rtc 1 //设置rtc时间与local时间相同 centos7 ip操作12345ip addr // 查看ip地址信息ip a add 192.168.8.149/24 dev eth0:2 // 添加网卡ipip a del 192.168.8.149/24 dev eth0:2 // 删除网卡ipip link set dev eth0 down // 将接口设备关闭ip link set dev eth0 up // 将接口设备启用","categories":[],"tags":[{"name":"centos7","slug":"centos7","permalink":"http://yoursite.com/tags/centos7/"}],"keywords":[]},{"title":"moment.js常用操作","slug":"momentJs常用操作","date":"2019-03-14T05:04:19.297Z","updated":"2019-03-07T13:17:44.737Z","comments":true,"path":"2019/03/14/momentJs常用操作/","link":"","permalink":"http://yoursite.com/2019/03/14/momentJs常用操作/","excerpt":"","text":"将String转成moment再格式化const date = ‘2019-03-07T21:16:00Z’;moment(date, ‘YYYY-MM-DDTHH:mm:ssZ’).format(‘HH:mm’)","categories":[],"tags":[{"name":"moment.js","slug":"moment-js","permalink":"http://yoursite.com/tags/moment-js/"}],"keywords":[]},{"title":"angular常用操作","slug":"angular常用操作","date":"2019-03-14T05:00:50.303Z","updated":"2019-03-07T13:13:36.369Z","comments":true,"path":"2019/03/14/angular常用操作/","link":"","permalink":"http://yoursite.com/2019/03/14/angular常用操作/","excerpt":"","text":"angular遍历maphtml:12345&lt;ul&gt; &lt;li *ngFor=&quot;let recipient of map | keyvalue&quot;&gt; &#123;&#123;recipient.key&#125;&#125; --&gt; &#123;&#123;recipient.value&#125;&#125; &lt;/li&gt;&lt;/ul&gt; cpmponent:12345myMap : Map&lt;string, boolean&gt;;for(let key of myMap.keys()) &#123; console.log(key); console.log(myMap.get(key));&#125; 1234Object.keys(myMap).map( key =&gt; &#123; console.log(&apos;key: &apos; + key); console.log(&apos;value: &apos; + result[key]);&#125;); 1234for (const [key, val] of map) &#123; console.log(key); console.log(val);&#125; 参考：https://stackoverflow.com/questions/48187362/how-to-iterate-using-ngfor-loop-map-containing-key-as-string-and-values-as-map-i/48187637 保留两位小数1Math.floor(15.7784514000 * 100) / 100 // 输出结果为 15.77 创建Map并赋值1const map = new Map([[2, &apos;foo&apos;], [1, &apos;bar&apos;]]); angular中html界面的if else 表示1234567&lt;div *ngIf=&quot;someCondition; else falsyTemplate&quot;&gt; &lt;h1&gt;Condition Passed!&lt;/h1&gt;&lt;/div&gt;&lt;ng-template #falsyTemplate&gt; &lt;h1&gt;Condition Failed!&lt;/h1&gt;&lt;/ng-template&gt; angular中http请求的option、params使用1234let option = &#123;&#125;;const params = new HttpParams().append(&apos;key&apos;, String(&apos;val&apos;));params = params.append(&apos;status&apos;, String(status)); // 注意要从新赋值给paramsoption = &#123;params&#125;; angular判断Map类型123isMap(obj) &#123; return obj instanceof Map;&#125; 删除数组中的某个元素123const arr = [&apos;a&apos;,&apos;b&apos;,&apos;c&apos;,&apos;d&apos;];arr.splice(1,1);console.log(arr); //[&apos;a&apos;,&apos;c&apos;,&apos;d&apos;]; angular的html根据条件显示样式html：1&lt;div [class.hide]=&quot;someCondition&quot;&gt;&lt;/div&gt; css:123.hide &#123; display: none;&#125; 在父组件中直接调用子组件的函数父组件html：1&lt;app-child-form #childForm&gt;&lt;/app-child-form&gt; 父组件component：123456@ViewChild(&apos;childForm&apos;)childForm: ChildFormComponent;f(): void &#123; this.childForm.f();&#125; 子组件component：123f(): void &#123; console.log(&apos;child component&apos;);&#125; Object转成Map1const result = new Map(Object.entries(map)); 将Map的key、value转成数组12const values = Array.from(map.values());const keys = Array.from(map.keys());","categories":[],"tags":[{"name":"angular","slug":"angular","permalink":"http://yoursite.com/tags/angular/"}],"keywords":[]},{"title":"telegraf plugin inputs","slug":"telegraf_Jolokia2_Input_Plugins","date":"2019-03-14T03:55:47.594Z","updated":"2019-03-13T07:29:13.980Z","comments":true,"path":"2019/03/14/telegraf_Jolokia2_Input_Plugins/","link":"","permalink":"http://yoursite.com/2019/03/14/telegraf_Jolokia2_Input_Plugins/","excerpt":"","text":"Jolokia2 Input PluginsJolokia Proxy: 在某些情况下，不可能在目标平台上部署Jolokia代理。这可能是出于政治原因，或者是仪表化服务器上已经建立的JSR-160导出。在这些环境中，Jolokia可以作为JMX代理进行操作。在此设置中，代理部署在专用代理Java EE服务器(或其他受支持的代理平台)上。代理连接Jolokia JSON请求和对目标服务器的远程JSR-160调用的响应。 Jolokia代理是通用的，与目标服务器无关，因为它通过传入请求(与HTTP代理相同)获取目标的信息。由于需要扩展信息，所以只能使用Jolokia POST请求进行代理，因为目前还没有方法将目标信息封装在GET Url中。请求的基本Jolokia URL是代理服务器的URL，而目标参数包含在请求中。在下一个示例中，一个代理Jolokia请求通过一个代理tomcat-proxy查询服务器jboss的活动线程数，该代理在Jolokia上下文中部署了一个代理。代理URL是这样的。 1http://jolokia-proxy:8080/jolokia 请求的POST参数如下： 12345678910&#123; &quot;type&quot;:&quot;READ&quot; &quot;mbean&quot;:&quot;java.lang:type=Threading&quot;, &quot;attribute&quot;:&quot;ThreadCount&quot;, &quot;target&quot;: &#123; &quot;url&quot;:&quot;service:jmx:rmi:///jndi/rmi://jboss-as:8686/jmxrmi&quot;, &quot;password&quot;:&quot;admin&quot;, &quot;user&quot;:&quot;s!cr!t&quot; &#125;,&#125; WAR Agent: WAR代理jolokia.war在Java EE服务器中部署为常规Web归档（WAR）。 此外，这是代理模式的代理，它部署在一个简单、专用的应用服务器中，比如Tomcat或Jetty。 安装与启动步骤1. 在Tomcat服务器上安装Jolokia代理1.从以下网址下载最新版本的Jolokia.war文件：https://jolokia.org/download.html2.将文件重命名jolokia-war-X.X.X.war为jolokia.war。3.将jolokia.war文件复制到${TOMCAT_HOME}/webapps。4.添加jolokia为角色tomcat-users.xml（Jolokia 1.6或更高版本强制使用）12&lt;role rolename=&quot;jolokia&quot;/&gt;&lt;user username=&quot;jolokia&quot; password=&quot;jolokia&quot; roles=&quot;jolokia&quot;/&gt; 5.启动Tomcat服务器。6.停止Tomcat服务器并修改jolokia的web.xml，添加以下内容（自版本1.5.0起，默认情况下不启用代理模式）12345678&lt;init-param&gt; &lt;description&gt; Classnames (comma separated) of RequestDispatcher used in addition to the LocalRequestDispatcher &lt;/description&gt; &lt;param-name&gt;dispatcherClasses&lt;/param-name&gt; &lt;param-value&gt;org.jolokia.jsr160.Jsr160RequestDispatcher&lt;/param-value&gt;&lt;/init-param&gt; 7.通过访问此URL验证Jolokia代理安装：http://tomcatip:8080/jolokia/version 步骤2.配置Telegraf Jolokia2输入插件1234567891011121314151617181920212223242526272829[[inputs.jolokia2_proxy]]# # default_tag_prefix = &quot;&quot;# # default_field_prefix = &quot;&quot;# # default_field_separator = &quot;.&quot;## ## Proxy agent url = &quot;http://tomcatip:8080/jolokia&quot; username = &quot;jolokia&quot; #如果是jolokia-war-unsecured-1.6.0.war则不需要username password = &quot;jolokia&quot; #如果是jolokia-war-unsecured-1.6.0.war则不需要password response_timeout = &quot;30s&quot;## ## Optional TLS config# # tls_ca = &quot;/var/private/ca.pem&quot;# # tls_cert = &quot;/var/private/client.pem&quot;# # tls_key = &quot;/var/private/client-key.pem&quot;# # insecure_skip_verify = false## ## Add proxy targets to query# # default_target_username = &quot;&quot;# # default_target_password = &quot;&quot; [[inputs.jolokia2_proxy.target]] url = &quot;service:jmx:rmi:///jndi/rmi://ip:port/jmxrmi&quot;# # username = &quot;&quot;# # password = &quot;&quot; [[inputs.jolokia2_agent.metric]] name = &quot;jvm_runtime&quot; mbean = &quot;java.lang:type=Runtime&quot; paths = [&quot;Uptime&quot;] 参考：https://github.com/influxdata/telegraf/tree/master/plugins/inputs/jolokia2https://jolokia.org/features/proxy.htmlhttps://jolokia.org/agent.htmlhttps://jolokia.org/tutorial.htmlhttps://jolokia.org/agent/war.htmlhttp://repo1.maven.org/maven2/org/jolokia/jolokia-war-unsecured/1.6.0/https://jolokia.org/reference/html/proxy.htmlhttps://jolokia.org/reference/html/proxy.html","categories":[],"tags":[{"name":"telegraf","slug":"telegraf","permalink":"http://yoursite.com/tags/telegraf/"}],"keywords":[]},{"title":"linux常用指令","slug":"linux常用指令","date":"2019-02-19T14:08:27.826Z","updated":"2019-02-19T14:08:05.230Z","comments":true,"path":"2019/02/19/linux常用指令/","link":"","permalink":"http://yoursite.com/2019/02/19/linux常用指令/","excerpt":"","text":"1.查看目录下有什么文件/目录 ls &emsp;&emsp;&emsp;&emsp;&emsp; //list 列出目录的文件信息ls -l或ll &emsp;&emsp;&ensp; //list -list 以”详细信息”查看目录文件ls -a &ensp;&emsp;&emsp; &emsp; //list -all 查看目录”全部”（包括隐藏文件）文件ls -al &ensp;&emsp;&emsp;&emsp; //list -all list 查看目录”全部”（包括隐藏文件）文件，以”详细信息”显示ls 目录 &ensp;&emsp; &emsp; //查看指定目录下有什么文件ls -i &emsp;&emsp;&emsp;&emsp; //查看文件索引号码 2.进行目录切换 cd dirname &emsp;//进行目录切换cd .. &emsp;&emsp;&emsp;&emsp;&ensp;//想上级目录切换cd ~ 或 cd &emsp;&ensp;//直接切换到当前用户 3.查看完整的操作位置 pwd 4.用户切换 su - 或 su - root &emsp;//向root用户切换exit &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&ensp; //退回到原用户su 用户名 &emsp;&emsp;&emsp;&emsp;//普通用户切换 多次使用su指令，会造成用户的”叠加”：（su和exit最好配合使用）lcs—&gt;root—&gt;lcs—&gt;root—&gt;lcs 5.查看当前用户是谁 whoami 6.图形界面与命令界面切换root用户可以切换 #init 3 #init 5 7.查看一个指令对应的执行程序文件在哪 which 指令 8.目录相关操作1）创建目录 make directory mkdir 目录名字mkdir -p newdir/newdir/newdir //递归方式创建多个连续目录，新的多级目录数目如果大于等于2个，&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp; 就要使用-p参数mkdir dir/newdir &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;//不用-p参数mkdir -p dir/newdir/newdir &emsp;&emsp;//使用-p参数 2）移动目录 move mv dir1 dir2 &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;//把dir1移动到dir2目录下mv dir1/dir2 dir3 &emsp;&emsp;&emsp;&ensp; //把dir2移动到dir3目录下mv dir1/dir2 dir3/dir4 &emsp;&ensp;//把dir2移动到dir4目录下mv dir1/dir2 ./ &emsp;&emsp;&emsp;&emsp;&emsp;//把dir2移动到当前目录下 3）改名字 mv dir1 newdir &emsp;&emsp;&emsp;&emsp;//修改dir1的名字为newdir mv是”移动”和”改名字”合并的指令mv dir1 ./newdir &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;//dir1移动到当前目录下，并改名字为newdirmv dir1/dir2 dir3 &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&ensp; //dir2移动到dir3目录下，并改名字为”原名”mv dir1/dir2 dir3/newdir &emsp;&emsp;&emsp;&emsp;//dir2移动到dir3目录下，并改名字为newdirmv dir1/dir2 dir3/dir4 &emsp;&emsp;&emsp;&emsp;&emsp; //dir2移动到dir4目录下，并改名字为”原名”mv dir1/dir2 dir3/dir4/newdir &emsp;&ensp;//dir2移动到dir4目录下，并改名字为newdir 4）复制（文件和目录）copy ①文件的复制 cp file1 dir/newfile2 &emsp;&emsp;&emsp;&emsp;//file1被复制一份到dir目录下，并改名字为newfile2cp file1 dir &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&ensp;//file1被复制一份到dir目录下，并改名字为”原名”cp dir1/filea dir2/newfile &emsp;&ensp; //filea被复制一份到dir目录下，并改名字为newfile ②目录的复制（需要设置-r[recursive递归]参数，无视目录的层次） cp -r dir1 dir2 &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;//dir1被复制到dir2目录下，并改名字为”原名”cp -r dir1/dir2 dir3/newdir &emsp;&emsp;&emsp;//dir2被复制到dir3目录下，并改名字为newdircp -r dir1/dir2 dir3/dir4 &emsp;&emsp;&emsp;&emsp; //dir2被复制到dir4目录下，并改名字为”原名”cp -r dir1/dir2 dir3/dir4/newdir &ensp;//dir2被复制到dir4目录下，并改名字为newdircp -r dir1 ../../newdir &emsp;&emsp;&emsp;&emsp;&emsp;&ensp;//dir1被复制到上两级目录下，并改名字为newdir ③删除（文件和目录）remove rm 文件rm -r 目录 &emsp;&emsp;&emsp;&emsp;&emsp;//-r[recursive递归]递归方式删除目录rm -rf 文件/目录 &emsp;&emsp; //-r force 递归强制方式删除文件，force强制，不需要额外导入提示 9.文件操作1）查看文件内容 cat filename &emsp;&emsp;&emsp;//打印文件内容到输出终端more filename &emsp;&emsp;//通过敲回车方式逐行查看文件的各个行内容，默认从第一行开始查看，&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp; //不支持回看，q退出查看less &emsp;&emsp;&emsp; &emsp;&emsp;&emsp;&emsp;//通过”上下左右”键查看文件的各个部分内容，支持回看，q退出查看head -n filename &ensp; //查看文件的前n行内容tail -n filename &emsp;&ensp; //查看文件的最末尾n行内容wc filename &emsp;&emsp;&emsp; //查看文件的行数 2）创建文件 touch dir1/filenametouch filename 3）给文件追加内容 echo 内容 &gt; 文件名称 &emsp;&emsp;&emsp;&emsp;//把”内容”以[覆盖写]方式追加给”文件”echo 内容 &gt;&gt; 文件名称 &emsp;&emsp;&emsp; //把”内容”以[追加]方式写给”文件” （如果文件不存在会创建文件） 10.用户操作配置文件：/etc/passwd1）创建用户 user add #useradd #useradd liming &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;//创建liming用户，同时会创建一个同名的组出来 #useradd -g 组别编号 username &emsp;&emsp;&ensp;//把用户的组别设置好，避免创建同名的组出来 #useradd -g 组编号 -u 用户编号 -d 家目录 username 2）修改用户 user modify #usermod -g 组编号 -u 用户编号 -d 家目录 -l 新名字 username（修改家目录时需要手动创建之） 3）删除用户 user delete #userdel username #userdel -r username //删除用户同时删除其家目录 4）给用户设置密码，使其登录系统 passwd 用户名 11.组别操作配置文件：/etc/group1）创建组 group add #groupadd music #groupadd movie #groupadd php 2）修改组 group modify #groupmod -g gid -n 新名字 groupname 3）删除组 group delete #groupdel groupname //组下边如果有用户存在，就禁止删除 12.查看指令可设置的参数 man 指令 13.给文件设置权限1）字母相对方式设置权限// 针对一个组别设置权限，其他组别权限没有变化，称为“相对方式”权限设置chmod指令chmod u+rwx filename //给filename文件的主人增加“读、写、执行”权限chmod g-rx filename //给filename文件的同组用户 删除“读、执行”权限 chmod u+/-rwx,g+/-rwx,o+/-rwx filename说明：①每个单元“+” “-”只能使用一个②可以同时给一个组或多个组设置权限，组别之间使用“，”分割③每个单元的权限可以是“rwx”中的一个或多个 chmod u+w,g-rx,o+rw filename //给filename文件主人增加写权限，同组删除读、执行权限，其他组增加读、写权限chmod u+w,u-x filename //给filename文件主人“增加写权限”同时“删除执行权限” chmod +/-rwx filename //无视具体组别，统一给全部的组设置权限 chmod +rw filename //给filename全部用户增加“读、写”权限 2）数字绝对方式设置权限r读：4 &emsp;&emsp; w写：2 &emsp;&emsp; x执行：10：没有权限1：执行2：写3：写、执行4：读5：读、执行6：读、写7：读、写、执行 chmod ABC filename //ABC分别代表主人、同组、其他组用户的数字权限 chmod 753 filename //主人读、写、执行；同组读、执行；其他组写、执行 问：字母相对 和 数字绝对 方式权限设置取舍？答：修改的权限相对“比较少”的时候使用“字母”方式，相反，权限变动“非常多”的时候就使用“数字”方式 14.在文件中查找内容grep 被搜索内容 文件 grep hello passwd //在passwd文件中搜索hello内容，会把hello所在行的内容都打印到终端显示 15.计算文件占据磁盘空间大小 du -h 文件（目录） 16.文件查找find 查找目录 选项 选项值 选项 选项值 …1）-name选项 根据名字进行查找 find / -name passwd &emsp;&emsp;&emsp;&emsp;//“递归遍历”/根目录及其内部深层目录，寻找名称等于“passwd”的文件find / -name “pas“[模糊查找] //在系统全部目录，模糊查找一个名字是“pas”开始的文件find / -name “er*” &emsp;&emsp;&emsp;&emsp;&emsp; //文件名字有出现“er”字样即可，不要位置 2）限制查找的目录层次 -maxdepth -mindepth-maxdepth 限制查找的最深目录-mindepth 限制查找的最浅目录 find / -maxdepth 4 -name passwdfind / -maxdepth 4 -mindepth 3 -name passwd 3）根据大小为条件进行文件查找-size +/-数字+号表示大小大于某个范围-号表示大小小于某个范围大小单位：-size 5 &emsp;&emsp; //单位是“512字节” 5512字节-size 10c &emsp; //单位是“字节” 10字节-size 3k &emsp;&ensp; //单位是“千字节” 31024字节-size 6M &emsp; //单位是“1024*千字节” 6M兆字节 find ./ -size 14c &emsp;&emsp;//在当前目录查找大小等于14千字节的文件find / -size +50M &emsp;//在系统全部目录里边查找大小大于50M的文件","categories":[],"tags":[{"name":"linux","slug":"linux","permalink":"http://yoursite.com/tags/linux/"}],"keywords":[]},{"title":"通过策略模式和工厂模式减少代码中的if else","slug":"通过策略模式和工厂模式减少代码中的if else","date":"2019-02-14T13:45:23.791Z","updated":"2019-02-14T13:44:53.807Z","comments":true,"path":"2019/02/14/通过策略模式和工厂模式减少代码中的if else/","link":"","permalink":"http://yoursite.com/2019/02/14/通过策略模式和工厂模式减少代码中的if else/","excerpt":"","text":"枚举类：12345678910public enum ResourceStatus &#123; Health(1), UnHealth(0), NoAlarm(-1); @Getter private int seq; private ResourceStatus(int seq) &#123; this.seq = seq; &#125;&#125; 策略接口：12345678public interface Strategy &#123; /** *将val和状态值比较判断是否属于某种状态 * @param val 资源的健康值 * @return 是否属于某种状态 */ boolean compare(Double val);&#125; 策略具体实现类：12345678public class HealthStrategy implements Strategy&#123; private final Double healthVal = 60d; @Override public boolean compare(Double val) &#123; return val &gt;= healthVal; &#125;&#125; 12345678public class UnHealthStrategy implements Strategy&#123; private final Double healthVal = 60d; @Override public boolean compare(Double val) &#123; return val &lt; healthVal &amp;&amp; val &gt;= 0; &#125;&#125; 12345678public class NoAlarmStrategy implements Strategy&#123; private final Double healthVal = -1d; @Override public boolean compare(Double val) &#123; return val.equals(healthVal); &#125;&#125; 工厂类：1234567891011121314151617181920public class StrategyFactory &#123; private static StrategyFactory factory = new StrategyFactory(); private static Map&lt;Integer, Strategy&gt; strategyMap = new HashMap(); static&#123; strategyMap.put(ResourceStatus.Health.getSeq(), new HealthStrategy()); strategyMap.put(ResourceStatus.UnHealth.getSeq(), new UnHealthStrategy()); strategyMap.put(ResourceStatus.NoAlarm.getSeq(), new NoAlarmStrategy()); &#125; private StrategyFactory()&#123;&#125; public Strategy creator(Integer status)&#123; return strategyMap.get(status); &#125; public static StrategyFactory getInstance()&#123; return factory; &#125;&#125; 策略上下文：123456789@Datapublic class Context &#123; private Strategy strategy; public boolean compare(Double val, Integer status) &#123; strategy = StrategyFactory.getInstance().creator(status); return strategy.compare(val); &#125;&#125; 参考：https://blog.csdn.net/u011507568/article/details/70238491","categories":[],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/tags/设计模式/"}],"keywords":[]},{"title":"angular2中如何在发送delete请求时携带参数","slug":"angular发送带参数的delete请求","date":"2019-02-13T15:08:07.625Z","updated":"2019-02-13T15:07:03.434Z","comments":true,"path":"2019/02/13/angular发送带参数的delete请求/","link":"","permalink":"http://yoursite.com/2019/02/13/angular发送带参数的delete请求/","excerpt":"","text":"前端angular:1234567891011/** * 根据ids删除资源分组 */deleteResourceGroupByIds(ids: string[]) &#123; return this.http.request(&apos;DELETE&apos;, this.API + &apos;/resourceGroup&apos;, &#123; body: ids &#125;).pipe( retry(1), catchError(this.handleError.bind(this)) );&#125; 后台springboot:1234@DeleteMapping(&quot;/resourceGroup&quot;)public void deleteResourceGroupByIds(@RequestBody String[] ids) &#123; resourceGroupService.deleteResourceGroupByIds(ids);&#125; 参考：https://stackoverflow.com/questions/38819336/body-of-http-delete-request-in-angular2","categories":[],"tags":[{"name":"angular","slug":"angular","permalink":"http://yoursite.com/tags/angular/"}],"keywords":[]},{"title":"Oracle报错，ORA-28001:口令已经失效","slug":"Oracle报错ORA-28001","date":"2019-02-13T14:12:48.821Z","updated":"2019-02-13T14:12:20.345Z","comments":true,"path":"2019/02/13/Oracle报错ORA-28001/","link":"","permalink":"http://yoursite.com/2019/02/13/Oracle报错ORA-28001/","excerpt":"","text":"WINDOWS下使用DOS命令行连接oracle数据库sqlplus userName/userPassword@netServiceName 1Oracle报错，ORA-28001: 口令已经失效 cmd命令行输入：12345678910sqlplus / as sysdbaSQL*Plus: Release 11.2.0.1.0 Production on 星期二 10月 17 15:42:58 2017Copyright (c) 1982, 2010, Oracle. All rights reserved.连接到:Oracle Database 11g Enterprise Edition Release 11.2.0.1.0 - ProductionWith the Partitioning, OLAP, Data Mining and Real Application Testing optionsSQL&gt; ALTER PROFILE DEFAULT LIMIT PASSWORD_LIFE_TIME UNLIMITED;配置文件已更改SQL&gt; alter user 用户名 dentified by 密码 account unlock;用户已更改。 再次测试登录即可","categories":[],"tags":[{"name":"oracle","slug":"oracle","permalink":"http://yoursite.com/tags/oracle/"}],"keywords":[]},{"title":"加密类型及其相关算法","slug":"加密类型及其相关算法","date":"2019-02-11T16:14:46.590Z","updated":"2019-02-11T16:14:23.617Z","comments":true,"path":"2019/02/12/加密类型及其相关算法/","link":"","permalink":"http://yoursite.com/2019/02/12/加密类型及其相关算法/","excerpt":"","text":"一、数据传输安全性在TCP/IP层中不涉及安全 机密性：明文传输（ftp,smtp,talnet）别人一拦截就能看到请求的内容。 完整性：10颗原子弹（被改成100）所以数据在互联网上传播的时候，不应该也不能够被其他人非法篡改掉当收到的和发送的不一致时拒绝接受这就能保证数据的完整性。 身份验证：通过有效的手段保证所访问的对象就是我们所要的那个人。 保证数据的机密性 plaintext(明文) –&gt; 加密（转换规则）–&gt; ciphertext（密文） ciphertext –&gt; 转换规则 –&gt; plaintext 转换算法：依赖密钥（即使得到了转换规则也没用） 对称加密：加密和解密使用同一个密钥（有加密算法和解密算法，算法不同，但密钥相同）。好处是计算速度快，在一定程度上解决了机密性问题。坏处是不能解决密钥有效管理的问题。假如a跟b，c,d通信，如果密钥相同，则c只要用密钥就可以看到a发送给b的内容，显然密钥不能相同，那就得维护很多密钥。 保证数据的完整性 A：plaintext:footprint –&gt; BB使用同样的加密算法去重复计算这个明文的特征码，并跟A所发过来的特征码进行比较，如果一样，则说明没被篡改。 单项加密算法：提取数据特征码，追加到数据后面。数据的输入一样：特征码必然相同。 特点：雪崩效应（输入的微小改变，将其会引起结果的巨大改变）、定长输出（无论原始数据是多长，结果大小都是相同的）、不可逆（无法根据原始特征码还原原来的数据）。 中间人攻击问题 E(A)：plaintext2:footprint2 –&gt; BA生成一段数据，并对它计算特征码，E在中间经过的路由时拿到这个明文，并重新修改明文和再计算特征码发给B，还声称自己是A，B拿到数据之后就算使用了数据完整性的算法之后，计算特征码还是一模一样，还认为是A发过来的，所以需要借助额外的机制。 解决办法：A：plaintext:footprint(加密) –&gt; B B拿到特征码之后通过密钥进行解密，能解密说明数据没有被改过。如果E拿到plaintext并修改为plaintext2，并重新生成特征码，就没办法加密特征码或者加密后就不是A和B之间实现约定的密码。 A与B之间如何进行密码约定 假如A与B之间从未通信或从未见过面，如何进行密码约定呢？ 协商生成密码：密码交换（Internet Key Exchange / IKE）,密码交换是不让第三方得到密钥，密码交换需要特殊的互联网协议支撑。比如：Dffie-Hellman协议。 A和B事先约定两个数p(大素数)，g(生成数)。A生成一个自己知道的x，B生成一个自己知道的y。A将 g^x % p 发送给B，B将g^y % p 发送给A。A拿到之后进行计算 （g^y % p）^x = g^xy % p，B拿到之后进行计算 （g^x % p）^y = g^xy % p。这个相同的结果就是密钥。在互联网上可以看到g、p、g^x % p、g^y % p，但看不到x、y。 A和B只需要选好几个数，让这些数的计算结果作为密钥来用，使得彼此不用计算密码，只要双方生成密钥的软件一样就可以随时生成密钥。 身份验证 之前是A和B一起约定好的密码，所以身份验证没问题。但是密钥是交换生成的，事先之前谁也不知道。E跳出来，截取了数据并篡改，然后与B进行连接通信，还告诉它自己是A。 解决办法：公钥加密算法（非对称加密算法） 特点：拥有一对密钥对，分别是公钥（是从私钥中提取出来的）、私钥。用公钥加密的，只能用私钥解密，反之亦然。 结论 机密性：用B的公钥加密，B的私钥解密。发送方用对方的公钥加密数据，可以保证数据机密性。 身份验证：用A的私钥加密，A的公钥加密。发送方用自己的私钥加密数据，可以实现身份验证。 公钥加密算法很少用来加密数据：速度太慢。 二、数据传输A beautiful sunrise — — — — — — —|&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;||&emsp;&emsp;&emsp;&emsp;A&emsp;&emsp;&emsp;&ensp;&ensp; ||&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;||&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;|— — — — — — —","categories":[],"tags":[{"name":"加密","slug":"加密","permalink":"http://yoursite.com/tags/加密/"}],"keywords":[]},{"title":"pkg-config --cflags oci8, Package oci8 was not found in the pkg-config search path.","slug":"go-oracle","date":"2019-02-01T09:56:58.386Z","updated":"2019-02-01T09:56:37.529Z","comments":true,"path":"2019/02/01/go-oracle/","link":"","permalink":"http://yoursite.com/2019/02/01/go-oracle/","excerpt":"","text":"在linux下可以正常运行oracledb_exporter，在windows64下启动时报错12pkg-config --cflags oci8Package oci8 was not found in the pkg-config search path. 因为linux中已经安装了oracle客户端，所以怀疑可能是windows下没有导致的。1.go-oci8 地址：https://github.com/wendal/go-oci8 它是 https://github.com/mattn/go-oci8 的分支，增加了windows下中文的安装说明及相关文件。 从oracledb_exporter的代码中可以看到引用的是go-oci8_ &quot;github.com/mattn/go-oci8&quot;,所以需要安装windows的oracle连接。 2.安装oci 地址：https://www.oracle.com/technetwork/database/database-technologies/instant-client/downloads/index.html 我的安装目录为：F:\\instantclient_18 _3 3.安装oci-sdk 地址：同上。 我的安装目录为F:\\instantclient_18 _3\\sdk 4.安装MinGW 地址：https://sourceforge.net/projects/mingw-w64/files/ 我的安装目录为F:\\mingw-w64 配置环境变量：在系统变量path中追加 F:\\mingw-w64\\x86_64-8.1.0-posix-seh-rt_v6-rev0\\mingw64\\bin 5.下载go-oci8驱动 地址：https://github.com/wendal/go-oci8 运行命令 go get github.com/wendal/go-oci8 (报错先不管) 复制GOPATH目下的\\src\\github.com\\wendal\\go-oci8\\windows\\pkg-config.exe到到mingw的安装目录mingw64\\bin下。 复制GOPATH目下的\\src\\github.com\\wendal\\go-oci8\\windows\\oci8.pc到到mingw的安装目录mingw64\\lib\\pkg-config的下。 修改oci8.pc #Package Information for pkg-configprefix=F:/instantclient_18_3exec_prefix=F:/instantclient_18_3libdir=${exec_prefix}includedir=${prefix}/sdk/include/ Name: OCIDescription: Oracle database engineVersion: 18.3Libs: -L${libdir} -lociLibs.private:Cflags: -I${includedir} 6.环境变量配置 PATH=原有PATH;F:\\instantclient_18_3; PKG_CONFIG_PATH=F:\\mingw-w64\\x86_64-8.1.0-posix-seh-rt_v6-rev0\\mingw64\\lib\\pkg-config 启动报错1234F:\\GOENV\\src\\github.com\\wendal\\go-oci8\\oci8.go:119: cannot use (**_Ctype_struct_OCIServer)(unsafe.Pointer(&amp;conn.svc)) (type **_Ctype_struct_OCIServer) as type **_Ctype_struct_OCISvcCtx in argument to func literalF:\\GOENV\\src\\github.com\\wendal\\go-oci8\\oci8.go:136: cannot use (*_Ctype_struct_OCIServer)(c.svc) (type *_Ctype_struct_OCIServer) as type *_Ctype_struct_OCISvcCtx in argument to func literalF:\\GOENV\\src\\github.com\\wendal\\go-oci8\\oci8.go:263: cannot use (*_Ctype_struct_OCIServer)(s.c.svc) (type *_Ctype_struct_OCIServer) as type *_Ctype_struct_OCISvcCtx in argument to func literalF:\\GOENV\\src\\github.com\\wendal\\go-oci8\\oci8.go:383: cannot use (*_Ctype_struct_OCIServer)(s.c.svc) (type *_Ctype_struct_OCIServer) as type *_Ctype_struct_OCISvcCtx in argument to func literal 替换GOPATH目下的\\src\\github.com\\wendal\\go-oci8里四处OCIServer为OCISvcCtx。参考：https://www.cnblogs.com/ghj1976/p/3437250.htmlhttps://blog.csdn.net/wq57885/article/details/82841792","categories":[],"tags":[{"name":"go","slug":"go","permalink":"http://yoursite.com/tags/go/"}],"keywords":[]}]}