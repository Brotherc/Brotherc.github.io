
<!DOCTYPE html>
<html lang="zh-cn">
    
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="generator" content="Brotherc">
    <title>归档 - Brotherc</title>
    <meta name="author" content="Brotherc">
    
    
    
    <script type="application/ld+json">{}</script>
    <meta property="og:type" content="blog">
<meta property="og:title" content="Brotherc">
<meta property="og:url" content="http://yoursite.com/archives/page/2/index.html">
<meta property="og:site_name" content="Brotherc">
<meta property="og:locale" content="zh-cn">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Brotherc">
    
    
        
    
    
        <meta property="og:image" content="http://yoursite.com/assets/images/head.jpg"/>
    
    
    
    
    <!--STYLES-->
    <link rel="stylesheet" href="/assets/css/style-c4ozcsklz4kht2pebhp44xorvyverh23toayhn7i6ubrpyedak24hv1v0hyd.min.css">
    <!--STYLES END-->
    

    
</head>

    <body>
        <div id="blog">
            <!-- Define author's picture -->


    
        
            
        
    

<header id="header" data-behavior="1">
    <i id="btn-open-sidebar" class="fa fa-lg fa-bars"></i>
    <div class="header-title">
        <a class="header-title-link" href="/ ">Brotherc</a>
    </div>
    
        
            <a class="header-right-picture " href="#about">
        
        
            <img class="header-picture" src="/assets/images/head.jpg" alt="作者的图片">
        
        </a>
    
</header>

            <!-- Define author's picture -->



        
    

<nav id="sidebar" data-behavior="1">
    <div class="sidebar-container">
        
            <div class="sidebar-profile">
                <a href="/#about">
                    <img class="sidebar-profile-picture" src="/assets/images/head.jpg" alt="作者的图片">
                </a>
                <h4 class="sidebar-profile-name">Brotherc</h4>
                
                    <h5 class="sidebar-profile-bio"><p>java development</p>
</h5>
                
            </div>
        
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a class="sidebar-button-link " href="/ " title="首页">
                    
                        <i class="sidebar-button-icon fa fa-home" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">首页</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a class="sidebar-button-link " href="/all-categories" title="分类">
                    
                        <i class="sidebar-button-icon fa fa-bookmark" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">分类</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a class="sidebar-button-link " href="/all-tags" title="标签">
                    
                        <i class="sidebar-button-icon fa fa-tags" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">标签</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a class="sidebar-button-link open-algolia-search" href="/all-archives" title="归档">
                    
                        <i class="sidebar-button-icon fa fa-archive" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">归档</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a class="sidebar-button-link " href="#about" title="关于">
                    
                        <i class="sidebar-button-icon fa fa-question" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">关于</span>
                    </a>
            </li>
            
        </ul>
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a class="sidebar-button-link " href="https://github.com/Brotherc" target="_blank" rel="noopener" title="GitHub">
                    
                        <i class="sidebar-button-icon fab fa-github" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">GitHub</span>
                    </a>
            </li>
            
        </ul>
        
    </div>
</nav>

            
            <div id="main" data-behavior="1"
                 class="
                        hasCoverMetaIn
                        ">
                
    <section class="postShorten-group main-content-wrap">
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a class="link-unstyled" href="/2019/09/10/外观模式/">
                            外观模式
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2019-09-10T14:35:25+08:00">
	
		    9月 10, 2019
    	
    </time>
    
</div>

            </div>
            
                <div class="postShorten-content">
                    <div class="figure center" style="width:100%;"><a class="fancybox" href="/assets/设计模式/51.jpg" title="" data-caption="" data-fancybox="travel"><img class="fig-img" src="/assets/设计模式/51.jpg" style="width:100%;height:100%;" alt=""></a></div><div style="clear:both;"></div>
<div class="figure center" style="width:100%;"><a class="fancybox" href="/assets/设计模式/52.jpg" title="" data-caption="" data-fancybox="travel"><img class="fig-img" src="/assets/设计模式/52.jpg" style="width:100%;height:100%;" alt=""></a></div><div style="clear:both;"></div>
<div class="figure center" style="width:100%;"><a class="fancybox" href="/assets/设计模式/53.jpg" title="" data-caption="" data-fancybox="travel"><img class="fig-img" src="/assets/设计模式/53.jpg" style="width:100%;height:100%;" alt=""></a></div><div style="clear:both;"></div>
<div class="figure center" style="width:100%;"><a class="fancybox" href="/assets/设计模式/54.jpg" title="" data-caption="" data-fancybox="travel"><img class="fig-img" src="/assets/设计模式/54.jpg" style="width:100%;height:100%;" alt=""></a></div><div style="clear:both;"></div>
<div class="figure center" style="width:100%;"><a class="fancybox" href="/assets/设计模式/55.jpg" title="" data-caption="" data-fancybox="travel"><img class="fig-img" src="/assets/设计模式/55.jpg" style="width:100%;height:100%;" alt=""></a></div><div style="clear:both;"></div>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public interface 工商局  &#123;</span><br><span class="line">	void checkName();  //核名</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class 海淀区工商局 implements 工商局 &#123;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public void checkName() &#123;</span><br><span class="line">		System.out.println(&quot;检查名字是否有冲突！&quot;);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public interface 质检局 &#123;</span><br><span class="line">	void  orgCodeCertificate();  //办理组织机构代码证</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class 海淀质检局 implements 质检局 &#123;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public void orgCodeCertificate() &#123;</span><br><span class="line">		System.out.println(&quot;在海淀区质检局办理组织机构代码证！&quot;);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public interface 银行 &#123;</span><br><span class="line">	void  openAccount();  //开户</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class 中国工商银行 implements 银行 &#123;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public void openAccount() &#123;</span><br><span class="line">		System.out.println(&quot;在中国工商银行开户！&quot;);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public interface 税务局 &#123;</span><br><span class="line">	void taxCertificate();  //办理税务登记证</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class 海淀税务局 implements 税务局 &#123;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public void taxCertificate() &#123;</span><br><span class="line">		System.out.println(&quot;在海淀税务局办理税务登记证！&quot;);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 办理注册公司流程的门面对象</span><br><span class="line"> * @author Administrator</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class RegisterFacade &#123;</span><br><span class="line">	public void register()&#123;</span><br><span class="line">		工商局  a = new 海淀区工商局();</span><br><span class="line">		a.checkName();</span><br><span class="line">		质检局 b = new 海淀质检局();</span><br><span class="line">		b.orgCodeCertificate();</span><br><span class="line">		税务局  c  = new 海淀税务局();</span><br><span class="line">		c.taxCertificate();</span><br><span class="line">		银行  d = new 中国工商银行();</span><br><span class="line">		d.openAccount();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class Client1 &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">//		工商局  a = new 海淀区工商局();</span><br><span class="line">//		a.checkName();</span><br><span class="line">//		质检局 b = new 海淀质检局();</span><br><span class="line">//		b.orgCodeCertificate();</span><br><span class="line">//		税务局  c  = new 海淀税务局();</span><br><span class="line">//		c.taxCertificate();</span><br><span class="line">//		银行  d = new 中国工商银行();</span><br><span class="line">//		d.openAccount();</span><br><span class="line"></span><br><span class="line">		new RegisterFacade().register();</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

                    
                        

                    
                    
                        <p>
                            <a href="/2019/09/10/外观模式/#post-footer" class="postShorten-excerpt_link link">
                                评论和共享
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a class="link-unstyled" href="/2019/09/10/适配器模式/">
                            适配器模式
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2019-09-10T14:35:24+08:00">
	
		    9月 10, 2019
    	
    </time>
    
</div>

            </div>
            
                <div class="postShorten-content">
                    <div class="figure center" style="width:100%;"><a class="fancybox" href="/assets/设计模式/26.jpg" title="" data-caption="" data-fancybox="travel"><img class="fig-img" src="/assets/设计模式/26.jpg" style="width:100%;height:100%;" alt=""></a></div><div style="clear:both;"></div>
<div class="figure center" style="width:100%;"><a class="fancybox" href="/assets/设计模式/27.jpg" title="" data-caption="" data-fancybox="travel"><img class="fig-img" src="/assets/设计模式/27.jpg" style="width:100%;height:100%;" alt=""></a></div><div style="clear:both;"></div>
<div class="figure center" style="width:100%;"><a class="fancybox" href="/assets/设计模式/28.jpg" title="" data-caption="" data-fancybox="travel"><img class="fig-img" src="/assets/设计模式/28.jpg" style="width:100%;height:100%;" alt=""></a></div><div style="clear:both;"></div>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 被适配的类</span><br><span class="line"> */</span><br><span class="line">public class Adaptee &#123;</span><br><span class="line">	public void request()&#123;</span><br><span class="line">		System.out.println(&quot;可以完成客户请求的需要的功能！&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface Target &#123;</span><br><span class="line">	void handleReq();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 适配器 (类适配器方式)</span><br><span class="line"> */</span><br><span class="line">public class Adapter extends Adaptee implements Target &#123;</span><br><span class="line">	@Override</span><br><span class="line">	public void handleReq() &#123;</span><br><span class="line">		super.request();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 适配器 (对象适配器方式,使用了组合的方式跟被适配对象整合)</span><br><span class="line"> */</span><br><span class="line">public class Adapter2  implements Target &#123;</span><br><span class="line">	private Adaptee adaptee;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public void handleReq() &#123;</span><br><span class="line">		adaptee.request();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public Adapter2(Adaptee adaptee) &#123;</span><br><span class="line">		super();</span><br><span class="line">		this.adaptee = adaptee;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 客户端类</span><br><span class="line"> */</span><br><span class="line">public class Client &#123;</span><br><span class="line">	public void test1(Target t)&#123;</span><br><span class="line">		t.handleReq();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		Client  c = new Client();</span><br><span class="line"></span><br><span class="line">		Adaptee a = new Adaptee();</span><br><span class="line"></span><br><span class="line">//		Target t = new Adapter();</span><br><span class="line"></span><br><span class="line">		Target t = new Adapter2(a);</span><br><span class="line"></span><br><span class="line">		c.test1(t);</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<div class="figure center" style="width:100%;"><a class="fancybox" href="/assets/设计模式/29.jpg" title="" data-caption="" data-fancybox="travel"><img class="fig-img" src="/assets/设计模式/29.jpg" style="width:100%;height:100%;" alt=""></a></div><div style="clear:both;"></div>
<div class="figure center" style="width:100%;"><a class="fancybox" href="/assets/设计模式/30.jpg" title="" data-caption="" data-fancybox="travel"><img class="fig-img" src="/assets/设计模式/30.jpg" style="width:100%;height:100%;" alt=""></a></div><div style="clear:both;"></div>
<div class="figure center" style="width:100%;"><a class="fancybox" href="/assets/设计模式/31.jpg" title="" data-caption="" data-fancybox="travel"><img class="fig-img" src="/assets/设计模式/31.jpg" style="width:100%;height:100%;" alt=""></a></div><div style="clear:both;"></div>

                    
                        

                    
                    
                        <p>
                            <a href="/2019/09/10/适配器模式/#post-footer" class="postShorten-excerpt_link link">
                                评论和共享
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a class="link-unstyled" href="/2019/09/10/建造者模式/">
                            建造者模式
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2019-09-10T14:35:24+08:00">
	
		    9月 10, 2019
    	
    </time>
    
</div>

            </div>
            
                <div class="postShorten-content">
                    <div class="figure center" style="width:100%;"><a class="fancybox" href="/assets/设计模式/21.jpg" title="" data-caption="" data-fancybox="travel"><img class="fig-img" src="/assets/设计模式/21.jpg" style="width:100%;height:100%;" alt=""></a></div><div style="clear:both;"></div>
<div class="figure center" style="width:100%;"><a class="fancybox" href="/assets/设计模式/22.jpg" title="" data-caption="" data-fancybox="travel"><img class="fig-img" src="/assets/设计模式/22.jpg" style="width:100%;height:100%;" alt=""></a></div><div style="clear:both;"></div>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">public class AirShip &#123;</span><br><span class="line">	private OrbitalModule orbitalModule;  //轨道舱</span><br><span class="line">	private Engine engine; //发动机</span><br><span class="line">	private EscapeTower escapeTower;  //逃逸塔</span><br><span class="line"></span><br><span class="line">	public void launch()&#123;</span><br><span class="line">		System.out.println(&quot;发射！&quot;);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public OrbitalModule getOrbitalModule() &#123;</span><br><span class="line">		return orbitalModule;</span><br><span class="line">	&#125;</span><br><span class="line">	public void setOrbitalModule(OrbitalModule orbitalModule) &#123;</span><br><span class="line">		this.orbitalModule = orbitalModule;</span><br><span class="line">	&#125;</span><br><span class="line">	public Engine getEngine() &#123;</span><br><span class="line">		return engine;</span><br><span class="line">	&#125;</span><br><span class="line">	public void setEngine(Engine engine) &#123;</span><br><span class="line">		this.engine = engine;</span><br><span class="line">	&#125;</span><br><span class="line">	public EscapeTower getEscapeTower() &#123;</span><br><span class="line">		return escapeTower;</span><br><span class="line">	&#125;</span><br><span class="line">	public void setEscapeTower(EscapeTower escapeTower) &#123;</span><br><span class="line">		this.escapeTower = escapeTower;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class OrbitalModule&#123;</span><br><span class="line">	private String name;</span><br><span class="line"></span><br><span class="line">	public OrbitalModule(String name) &#123;</span><br><span class="line">		this.name = name;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public String getName() &#123;</span><br><span class="line">		return name;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public void setName(String name) &#123;</span><br><span class="line">		this.name = name;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Engine &#123;</span><br><span class="line">	private String name;</span><br><span class="line"></span><br><span class="line">	public Engine(String name) &#123;</span><br><span class="line">		this.name = name;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public String getName() &#123;</span><br><span class="line">		return name;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public void setName(String name) &#123;</span><br><span class="line">		this.name = name;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class EscapeTower&#123;</span><br><span class="line">	private String name;</span><br><span class="line"></span><br><span class="line">	public String getName() &#123;</span><br><span class="line">		return name;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public void setName(String name) &#123;</span><br><span class="line">		this.name = name;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public EscapeTower(String name) &#123;</span><br><span class="line">		super();</span><br><span class="line">		this.name = name;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public interface AirShipBuilder &#123;</span><br><span class="line">	Engine builderEngine();</span><br><span class="line">	OrbitalModule builderOrbitalModule();</span><br><span class="line">	EscapeTower  builderEscapeTower();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class SxtAirShipBuilder implements AirShipBuilder &#123;</span><br><span class="line">	//StringBuilder, 以后学习XML解析中，JDOM库中的类：DomBuilder,SaxBuilder</span><br><span class="line">	@Override</span><br><span class="line">	public Engine builderEngine() &#123;</span><br><span class="line">		return new Engine(&quot;构建尚学堂牌发动机！&quot;);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public EscapeTower builderEscapeTower() &#123;</span><br><span class="line">		return new EscapeTower(&quot;构建逃逸塔&quot;);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public OrbitalModule builderOrbitalModule() &#123;</span><br><span class="line">		return new OrbitalModule(&quot;构建轨道舱&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public interface AirShipDirector &#123;</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	 * 组装飞船对象</span><br><span class="line">	 * @return</span><br><span class="line">	 */</span><br><span class="line">	AirShip   directAirShip();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public class SxtAirshipDirector implements AirShipDirector &#123;</span><br><span class="line">	private AirShipBuilder builder;</span><br><span class="line"></span><br><span class="line">	public SxtAirshipDirector(AirShipBuilder builder) &#123;</span><br><span class="line">		this.builder = builder;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public AirShip directAirShip() &#123;</span><br><span class="line">		Engine e = builder.builderEngine();</span><br><span class="line">		OrbitalModule o = builder.builderOrbitalModule();</span><br><span class="line">		EscapeTower et = builder.builderEscapeTower();</span><br><span class="line"></span><br><span class="line">		//装配成飞船对象</span><br><span class="line">		AirShip ship = new AirShip();</span><br><span class="line">		ship.setEngine(e);</span><br><span class="line">		ship.setEscapeTower(et);</span><br><span class="line">		ship.setOrbitalModule(o);</span><br><span class="line"></span><br><span class="line">		return ship;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class Client &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">		AirShipDirector director = new SxtAirshipDirector(new SxtAirShipBuilder());</span><br><span class="line"></span><br><span class="line">		AirShip ship = director.directAirShip();</span><br><span class="line"></span><br><span class="line">		System.out.println(ship.getEngine().getName());</span><br><span class="line"></span><br><span class="line">		ship.launch();</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<div class="figure center" style="width:100%;"><a class="fancybox" href="/assets/设计模式/23.jpg" title="" data-caption="" data-fancybox="travel"><img class="fig-img" src="/assets/设计模式/23.jpg" style="width:100%;height:100%;" alt=""></a></div><div style="clear:both;"></div>

                    
                        

                    
                    
                        <p>
                            <a href="/2019/09/10/建造者模式/#post-footer" class="postShorten-excerpt_link link">
                                评论和共享
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a class="link-unstyled" href="/2019/09/10/工厂模式/">
                            工厂模式
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2019-09-10T14:35:24+08:00">
	
		    9月 10, 2019
    	
    </time>
    
</div>

            </div>
            
                <div class="postShorten-content">
                    <div class="figure center" style="width:100%;"><a class="fancybox" href="/assets/设计模式/11.jpg" title="" data-caption="" data-fancybox="travel"><img class="fig-img" src="/assets/设计模式/11.jpg" style="width:100%;height:100%;" alt=""></a></div><div style="clear:both;"></div>
<div class="figure center" style="width:100%;"><a class="fancybox" href="/assets/设计模式/12.jpg" title="" data-caption="" data-fancybox="travel"><img class="fig-img" src="/assets/设计模式/12.jpg" style="width:100%;height:100%;" alt=""></a></div><div style="clear:both;"></div>
<div class="figure center" style="width:100%;"><a class="fancybox" href="/assets/设计模式/13.jpg" title="" data-caption="" data-fancybox="travel"><img class="fig-img" src="/assets/设计模式/13.jpg" style="width:100%;height:100%;" alt=""></a></div><div style="clear:both;"></div>
<div class="figure center" style="width:100%;"><a class="fancybox" href="/assets/设计模式/14.jpg" title="" data-caption="" data-fancybox="travel"><img class="fig-img" src="/assets/设计模式/14.jpg" style="width:100%;height:100%;" alt=""></a></div><div style="clear:both;"></div>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface Car &#123;</span><br><span class="line">	void run();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class Audi implements Car &#123;</span><br><span class="line">	@Override</span><br><span class="line">	public void run() &#123;</span><br><span class="line">		System.out.println(&quot;奥迪再跑！&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class Byd implements Car &#123;</span><br><span class="line">	@Override</span><br><span class="line">	public void run() &#123;</span><br><span class="line">		System.out.println(&quot;比亚迪再跑！&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class CarFactory &#123;</span><br><span class="line">	public static  Car createCar(String type)&#123;</span><br><span class="line">		if(&quot;奥迪&quot;.equals(type))&#123;</span><br><span class="line">			return new Audi();</span><br><span class="line">		&#125;else if(&quot;比亚迪&quot;.equals(type))&#123;</span><br><span class="line">			return new Byd();</span><br><span class="line">		&#125;else&#123;</span><br><span class="line">			return null;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class CarFactory2 &#123;</span><br><span class="line">	public static  Car createAudi()&#123;</span><br><span class="line">		return new Audi();</span><br><span class="line">	&#125;</span><br><span class="line">	public static  Car createByd()&#123;</span><br><span class="line">		return new Byd();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class Client &#123;   //调用者</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		Car c1 =CarFactory.createCar(&quot;奥迪&quot;);</span><br><span class="line">		Car c2 = CarFactory.createCar(&quot;比亚迪&quot;);</span><br><span class="line"></span><br><span class="line">		c1.run();</span><br><span class="line">		c2.run();</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<div class="figure center" style="width:100%;"><a class="fancybox" href="/assets/设计模式/15.jpg" title="" data-caption="" data-fancybox="travel"><img class="fig-img" src="/assets/设计模式/15.jpg" style="width:100%;height:100%;" alt=""></a></div><div style="clear:both;"></div>
<div class="figure center" style="width:100%;"><a class="fancybox" href="/assets/设计模式/16.jpg" title="" data-caption="" data-fancybox="travel"><img class="fig-img" src="/assets/设计模式/16.jpg" style="width:100%;height:100%;" alt=""></a></div><div style="clear:both;"></div>
<div class="figure center" style="width:100%;"><a class="fancybox" href="/assets/设计模式/17.jpg" title="" data-caption="" data-fancybox="travel"><img class="fig-img" src="/assets/设计模式/17.jpg" style="width:100%;height:100%;" alt=""></a></div><div style="clear:both;"></div>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface CarFactory &#123;</span><br><span class="line">	Car createCar();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class AudiFactory implements CarFactory &#123;</span><br><span class="line">	@Override</span><br><span class="line">	public Car createCar() &#123;</span><br><span class="line">		return new Audi();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class BydFactory implements CarFactory &#123;</span><br><span class="line">	@Override</span><br><span class="line">	public Car createCar() &#123;</span><br><span class="line">		return new Byd();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class Client &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		Car c1 = new AudiFactory().createCar();</span><br><span class="line">		Car c2 = new BydFactory().createCar();</span><br><span class="line"></span><br><span class="line">		c1.run();</span><br><span class="line">		c2.run();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<div class="figure center" style="width:100%;"><a class="fancybox" href="/assets/设计模式/18.jpg" title="" data-caption="" data-fancybox="travel"><img class="fig-img" src="/assets/设计模式/18.jpg" style="width:100%;height:100%;" alt=""></a></div><div style="clear:both;"></div>
<div class="figure center" style="width:100%;"><a class="fancybox" href="/assets/设计模式/19.jpg" title="" data-caption="" data-fancybox="travel"><img class="fig-img" src="/assets/设计模式/19.jpg" style="width:100%;height:100%;" alt=""></a></div><div style="clear:both;"></div>
<div class="figure center" style="width:100%;"><a class="fancybox" href="/assets/设计模式/20.jpg" title="" data-caption="" data-fancybox="travel"><img class="fig-img" src="/assets/设计模式/20.jpg" style="width:100%;height:100%;" alt=""></a></div><div style="clear:both;"></div>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">public interface Engine &#123;</span><br><span class="line">	void run();</span><br><span class="line">	void start();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class LuxuryEngine implements Engine&#123;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public void run() &#123;</span><br><span class="line">		System.out.println(&quot;转的快！&quot;);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public void start() &#123;</span><br><span class="line">		System.out.println(&quot;启动快!可以自动启停！&quot;);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class LowEngine implements Engine&#123;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public void run() &#123;</span><br><span class="line">		System.out.println(&quot;转的慢！&quot;);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public void start() &#123;</span><br><span class="line">		System.out.println(&quot;启动慢!&quot;);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public interface Seat &#123;</span><br><span class="line">	void massage();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class LuxurySeat implements Seat &#123;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public void massage() &#123;</span><br><span class="line">		System.out.println(&quot;可以自动按摩！&quot;);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">class LowSeat implements Seat &#123;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public void massage() &#123;</span><br><span class="line">		System.out.println(&quot;不能按摩！&quot;);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public interface Tyre &#123;</span><br><span class="line">	void revolve();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class LuxuryTyre implements Tyre &#123;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public void revolve() &#123;</span><br><span class="line">		System.out.println(&quot;旋转不磨损！&quot;);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class LowTyre implements Tyre &#123;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public void revolve() &#123;</span><br><span class="line">		System.out.println(&quot;旋转磨损快！&quot;);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public interface CarFactory &#123;</span><br><span class="line">	Engine createEngine();</span><br><span class="line">	Seat createSeat();</span><br><span class="line">	Tyre createTyre();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class LowCarFactory implements CarFactory &#123;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public Engine createEngine() &#123;</span><br><span class="line">		return new LowEngine();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public Seat createSeat() &#123;</span><br><span class="line">		return new LowSeat();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public Tyre createTyre() &#123;</span><br><span class="line">		return new LowTyre();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class LuxuryCarFactory implements CarFactory &#123;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public Engine createEngine() &#123;</span><br><span class="line">		return new LuxuryEngine();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public Seat createSeat() &#123;</span><br><span class="line">		return new LuxurySeat();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public Tyre createTyre() &#123;</span><br><span class="line">		return new LuxuryTyre();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class Client &#123;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		CarFactory  factory = new LuxuryCarFactory();</span><br><span class="line">		Engine e = factory.createEngine();</span><br><span class="line">		e.run();</span><br><span class="line">		e.start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

                    
                        

                    
                    
                        <p>
                            <a href="/2019/09/10/工厂模式/#post-footer" class="postShorten-excerpt_link link">
                                评论和共享
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a class="link-unstyled" href="/2019/09/10/单例模式/">
                            单例模式
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2019-09-10T14:35:24+08:00">
	
		    9月 10, 2019
    	
    </time>
    
</div>

            </div>
            
                <div class="postShorten-content">
                    <div class="figure center" style="width:100%;"><a class="fancybox" href="/assets/设计模式/1.jpg" title="" data-caption="" data-fancybox="travel"><img class="fig-img" src="/assets/设计模式/1.jpg" style="width:100%;height:100%;" alt=""></a></div><div style="clear:both;"></div>
<div class="figure center" style="width:100%;"><a class="fancybox" href="/assets/设计模式/2.jpg" title="" data-caption="" data-fancybox="travel"><img class="fig-img" src="/assets/设计模式/2.jpg" style="width:100%;height:100%;" alt=""></a></div><div style="clear:both;"></div>
<div class="figure center" style="width:100%;"><a class="fancybox" href="/assets/设计模式/3.jpg" title="" data-caption="" data-fancybox="travel"><img class="fig-img" src="/assets/设计模式/3.jpg" style="width:100%;height:100%;" alt=""></a></div><div style="clear:both;"></div>
<div class="figure center" style="width:100%;"><a class="fancybox" href="/assets/设计模式/4.jpg" title="" data-caption="" data-fancybox="travel"><img class="fig-img" src="/assets/设计模式/4.jpg" style="width:100%;height:100%;" alt=""></a></div><div style="clear:both;"></div>
<div class="figure center" style="width:100%;"><a class="fancybox" href="/assets/设计模式/5.jpg" title="" data-caption="" data-fancybox="travel"><img class="fig-img" src="/assets/设计模式/5.jpg" style="width:100%;height:100%;" alt=""></a></div><div style="clear:both;"></div>
<div class="figure center" style="width:100%;"><a class="fancybox" href="/assets/设计模式/6.jpg" title="" data-caption="" data-fancybox="travel"><img class="fig-img" src="/assets/设计模式/6.jpg" style="width:100%;height:100%;" alt=""></a></div><div style="clear:both;"></div>
<div class="figure center" style="width:100%;"><a class="fancybox" href="/assets/设计模式/7.jpg" title="" data-caption="" data-fancybox="travel"><img class="fig-img" src="/assets/设计模式/7.jpg" style="width:100%;height:100%;" alt=""></a></div><div style="clear:both;"></div>
<div class="figure center" style="width:100%;"><a class="fancybox" href="/assets/设计模式/8.jpg" title="" data-caption="" data-fancybox="travel"><img class="fig-img" src="/assets/设计模式/8.jpg" style="width:100%;height:100%;" alt=""></a></div><div style="clear:both;"></div>
<div class="figure center" style="width:100%;"><a class="fancybox" href="/assets/设计模式/9.jpg" title="" data-caption="" data-fancybox="travel"><img class="fig-img" src="/assets/设计模式/9.jpg" style="width:100%;height:100%;" alt=""></a></div><div style="clear:both;"></div>
<div class="figure center" style="width:100%;"><a class="fancybox" href="/assets/设计模式/10.jpg" title="" data-caption="" data-fancybox="travel"><img class="fig-img" src="/assets/设计模式/10.jpg" style="width:100%;height:100%;" alt=""></a></div><div style="clear:both;"></div>

                    
                        

                    
                    
                        <p>
                            <a href="/2019/09/10/单例模式/#post-footer" class="postShorten-excerpt_link link">
                                评论和共享
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a class="link-unstyled" href="/2019/09/10/代理模式/">
                            代理模式
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2019-09-10T14:35:24+08:00">
	
		    9月 10, 2019
    	
    </time>
    
</div>

            </div>
            
                <div class="postShorten-content">
                    <div class="figure center" style="width:100%;"><a class="fancybox" href="/assets/设计模式/32.jpg" title="" data-caption="" data-fancybox="travel"><img class="fig-img" src="/assets/设计模式/32.jpg" style="width:100%;height:100%;" alt=""></a></div><div style="clear:both;"></div>
<div class="figure center" style="width:100%;"><a class="fancybox" href="/assets/设计模式/33.jpg" title="" data-caption="" data-fancybox="travel"><img class="fig-img" src="/assets/设计模式/33.jpg" style="width:100%;height:100%;" alt=""></a></div><div style="clear:both;"></div>
<div class="figure center" style="width:100%;"><a class="fancybox" href="/assets/设计模式/34.jpg" title="" data-caption="" data-fancybox="travel"><img class="fig-img" src="/assets/设计模式/34.jpg" style="width:100%;height:100%;" alt=""></a></div><div style="clear:both;"></div>
<div class="figure center" style="width:100%;"><a class="fancybox" href="/assets/设计模式/35.jpg" title="" data-caption="" data-fancybox="travel"><img class="fig-img" src="/assets/设计模式/35.jpg" style="width:100%;height:100%;" alt=""></a></div><div style="clear:both;"></div>
<div class="figure center" style="width:100%;"><a class="fancybox" href="/assets/设计模式/36.jpg" title="" data-caption="" data-fancybox="travel"><img class="fig-img" src="/assets/设计模式/36.jpg" style="width:100%;height:100%;" alt=""></a></div><div style="clear:both;"></div>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public interface Star &#123;</span><br><span class="line">	/**</span><br><span class="line">	 * 面谈</span><br><span class="line">	 */</span><br><span class="line">	void confer();</span><br><span class="line">	/**</span><br><span class="line">	 * 签合同</span><br><span class="line">	 */</span><br><span class="line">	void signContract();</span><br><span class="line">	/**</span><br><span class="line">	 * 订票</span><br><span class="line">	 */</span><br><span class="line">	void bookTicket();</span><br><span class="line">	/**</span><br><span class="line">	 * 唱歌</span><br><span class="line">	 */</span><br><span class="line">	void sing();</span><br><span class="line">	/**</span><br><span class="line">	 * 收钱</span><br><span class="line">	 */</span><br><span class="line">	void collectMoney();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public class RealStar implements Star &#123;</span><br><span class="line">	@Override</span><br><span class="line">	public void bookTicket() &#123;</span><br><span class="line">		System.out.println(&quot;RealStar.bookTicket()&quot;);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public void collectMoney() &#123;</span><br><span class="line">		System.out.println(&quot;RealStar.collectMoney()&quot;);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public void confer() &#123;</span><br><span class="line">		System.out.println(&quot;RealStar.confer()&quot;);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public void signContract() &#123;</span><br><span class="line">		System.out.println(&quot;RealStar.signContract()&quot;);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public void sing() &#123;</span><br><span class="line">		System.out.println(&quot;RealStar(周杰伦本人).sing()&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">public class ProxyStar implements Star &#123;</span><br><span class="line">	private Star star;</span><br><span class="line"></span><br><span class="line">	public ProxyStar(Star star) &#123;</span><br><span class="line">		super();</span><br><span class="line">		this.star = star;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public void bookTicket() &#123;</span><br><span class="line">		System.out.println(&quot;ProxyStar.bookTicket()&quot;);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public void collectMoney() &#123;</span><br><span class="line">		System.out.println(&quot;ProxyStar.collectMoney()&quot;);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public void confer() &#123;</span><br><span class="line">		System.out.println(&quot;ProxyStar.confer()&quot;);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public void signContract() &#123;</span><br><span class="line">		System.out.println(&quot;ProxyStar.signContract()&quot;);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public void sing() &#123;</span><br><span class="line">		star.sing();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class Client &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		Star real = new RealStar();</span><br><span class="line">		Star proxy = new ProxyStar(real);</span><br><span class="line"></span><br><span class="line">		proxy.confer();</span><br><span class="line">		proxy.signContract();</span><br><span class="line">		proxy.bookTicket();</span><br><span class="line">		proxy.sing();</span><br><span class="line"></span><br><span class="line">		proxy.collectMoney();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<div class="figure center" style="width:100%;"><a class="fancybox" href="/assets/设计模式/37.jpg" title="" data-caption="" data-fancybox="travel"><img class="fig-img" src="/assets/设计模式/37.jpg" style="width:100%;height:100%;" alt=""></a></div><div style="clear:both;"></div>
<div class="figure center" style="width:100%;"><a class="fancybox" href="/assets/设计模式/38.jpg" title="" data-caption="" data-fancybox="travel"><img class="fig-img" src="/assets/设计模式/38.jpg" style="width:100%;height:100%;" alt=""></a></div><div style="clear:both;"></div>
<div class="figure center" style="width:100%;"><a class="fancybox" href="/assets/设计模式/39.jpg" title="" data-caption="" data-fancybox="travel"><img class="fig-img" src="/assets/设计模式/39.jpg" style="width:100%;height:100%;" alt=""></a></div><div style="clear:both;"></div>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public interface Star &#123;</span><br><span class="line">	/**</span><br><span class="line">	 * 面谈</span><br><span class="line">	 */</span><br><span class="line">	void confer();</span><br><span class="line">	/**</span><br><span class="line">	 * 签合同</span><br><span class="line">	 */</span><br><span class="line">	void signContract();</span><br><span class="line">	/**</span><br><span class="line">	 * 订票</span><br><span class="line">	 */</span><br><span class="line">	void bookTicket();</span><br><span class="line">	/**</span><br><span class="line">	 * 唱歌</span><br><span class="line">	 */</span><br><span class="line">	void sing();</span><br><span class="line">	/**</span><br><span class="line">	 * 收钱</span><br><span class="line">	 */</span><br><span class="line">	void collectMoney();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public class RealStar implements Star &#123;</span><br><span class="line">	@Override</span><br><span class="line">	public void bookTicket() &#123;</span><br><span class="line">		System.out.println(&quot;RealStar.bookTicket()&quot;);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public void collectMoney() &#123;</span><br><span class="line">		System.out.println(&quot;RealStar.collectMoney()&quot;);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public void confer() &#123;</span><br><span class="line">		System.out.println(&quot;RealStar.confer()&quot;);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public void signContract() &#123;</span><br><span class="line">		System.out.println(&quot;RealStar.signContract()&quot;);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public void sing() &#123;</span><br><span class="line">		System.out.println(&quot;RealStar(周杰伦本人).sing()&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public class StarHandler implements InvocationHandler &#123;</span><br><span class="line">	Star realStar;</span><br><span class="line"></span><br><span class="line">	public StarHandler(Star realStar) &#123;</span><br><span class="line">		super();</span><br><span class="line">		this.realStar = realStar;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public Object invoke(Object proxy, Method method, Object[] args)</span><br><span class="line">			throws Throwable &#123;</span><br><span class="line">		Object object = null;</span><br><span class="line"></span><br><span class="line">		System.out.println(&quot;真正的方法执行前！&quot;);</span><br><span class="line">		System.out.println(&quot;面谈，签合同，预付款，订机票&quot;);</span><br><span class="line"></span><br><span class="line">		if(method.getName().equals(&quot;sing&quot;))&#123;</span><br><span class="line">			object = method.invoke(realStar, args);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		System.out.println(&quot;真正的方法执行后！&quot;);</span><br><span class="line">		System.out.println(&quot;收尾款&quot;);</span><br><span class="line">		return object;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 模拟动态生成的代理的结构</span><br><span class="line"> */</span><br><span class="line">public class ProxyStar implements Star &#123;</span><br><span class="line"></span><br><span class="line">	StarHandler handler;</span><br><span class="line"></span><br><span class="line">	public ProxyStar(StarHandler handler) &#123;</span><br><span class="line">		super();</span><br><span class="line">		this.handler = handler;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public void bookTicket() &#123;</span><br><span class="line">//		handler.invoke(this,当前方法 , args);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public void collectMoney() &#123;</span><br><span class="line">//		handler.invoke(this,当前方法 , args);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public void confer() &#123;</span><br><span class="line">//		handler.invoke(this,当前方法 , args);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public void signContract() &#123;</span><br><span class="line">//		handler.invoke(this,当前方法 , args);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public void sing() &#123;</span><br><span class="line">//		handler.invoke(this,当前方法 , args);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class Client &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">		Star realStar = new RealStar();</span><br><span class="line">		StarHandler handler = new StarHandler(realStar);</span><br><span class="line"></span><br><span class="line">		Star proxy = (Star) Proxy.newProxyInstance(ClassLoader.getSystemClassLoader(),</span><br><span class="line">				new Class[]&#123;Star.class&#125;, handler);</span><br><span class="line"></span><br><span class="line">		proxy.sing();</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

                    
                        

                    
                    
                        <p>
                            <a href="/2019/09/10/代理模式/#post-footer" class="postShorten-excerpt_link link">
                                评论和共享
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a class="link-unstyled" href="/2019/09/07/集合/">
                            集合
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2019-09-07T10:23:08+08:00">
	
		    9月 07, 2019
    	
    </time>
    
</div>

            </div>
            
                <div class="postShorten-content">
                    <h3 id="集合和数组的区别"><a href="#集合和数组的区别" class="headerlink" title="集合和数组的区别?"></a>集合和数组的区别?</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">A:长度区别</span><br><span class="line">	数组固定</span><br><span class="line">	集合可变</span><br><span class="line">B:内容区别</span><br><span class="line">	数组可以是基本类型，也可以是引用类型</span><br><span class="line">	集合只能是引用类型</span><br><span class="line">C:元素内容</span><br><span class="line">	数组只能存储同一种类型</span><br><span class="line">	集合可以存储不同类型(其实集合一般存储的也是同一种类型)</span><br></pre></td></tr></table></figure>
<h3 id="集合的继承体系结构"><a href="#集合的继承体系结构" class="headerlink" title="集合的继承体系结构"></a>集合的继承体系结构</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">由于需求不同，Java就提供了不同的集合类。这多个集合类的数据结构不同，但是它们都是要提供存储和遍历功能的，</span><br><span class="line">我们把它们的共性不断的向上提取，最终就形成了集合的继承体系结构图。</span><br><span class="line">		Collection</span><br><span class="line">			|--List</span><br><span class="line">				|--ArrayList</span><br><span class="line">				|--Vector</span><br><span class="line">				|--LinkedList</span><br><span class="line">			|--Set</span><br><span class="line">				|--HashSet</span><br><span class="line">				|--TreeSet</span><br></pre></td></tr></table></figure>
<h3 id="Collection接口"><a href="#Collection接口" class="headerlink" title="Collection接口"></a>Collection接口</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">Collection 层次结构中的根接口。Collection 表示一组对象，这些对象也称为  collection 的元素。一些 collection 允许有重复的元素，而另一些则不允许。一些   collection 是有序的，而另一些则是无序的。</span><br><span class="line">Collection接口成员方法</span><br><span class="line">	A:添加功能</span><br><span class="line">		boolean add(E e)</span><br><span class="line">		boolean addAll(collection c)</span><br><span class="line">	B:删除功能</span><br><span class="line">		boolean remove(Object o)</span><br><span class="line">		boolean removeAll(collection c)只要有一个元素被删除就返回true</span><br><span class="line">		void clear()</span><br><span class="line">	C:判断功能</span><br><span class="line">		boolean contains(Object o)</span><br><span class="line">		boolean containsAll(Collection c)只有包含所有的元素才叫包含</span><br><span class="line">	D:获取功能</span><br><span class="line">		boolean isEmpty()</span><br><span class="line">	E:长度功能</span><br><span class="line">		int size()</span><br><span class="line">	F:交集</span><br><span class="line">		boolean retainAll(Collection c)</span><br><span class="line">		假设有两个集合A,B</span><br><span class="line">		A对B做交集，最终的结果保存在A中，B不变</span><br><span class="line">		返回值表示的是A是否发生改变</span><br><span class="line">	H:Collection集合的遍历</span><br><span class="line">		A:把集合转数组</span><br><span class="line">			Object[] toArray()</span><br><span class="line">		B:迭代器(集合专用方式)</span><br><span class="line">			Iterator iterator()</span><br></pre></td></tr></table></figure>
<h3 id="Iterator接口"><a href="#Iterator接口" class="headerlink" title="Iterator接口"></a>Iterator接口</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">对 collection 进行迭代的迭代器</span><br><span class="line">		A:是集合的获取元素的方式。</span><br><span class="line">		B:是依赖于集合而存在的。</span><br><span class="line">		C:迭代器的原理和源码。</span><br><span class="line">			a:为什么定义为了一个接口而不是实现类?</span><br><span class="line">			b:看了看迭代器的内部类实现。</span><br><span class="line">Iterator接口成员方法</span><br><span class="line">boolean hasNext()如果还有元素可以迭代，则返回true</span><br><span class="line">E next() 获取元素，并返回到下一个位置</span><br></pre></td></tr></table></figure>
<h3 id="List接口"><a href="#List接口" class="headerlink" title="List接口"></a>List接口</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">(1)List是Collection的子接口</span><br><span class="line">	特点：有序(存储顺序和取出顺序一致)，可重复。</span><br><span class="line">(2)List的特有功能：(自己补齐)</span><br><span class="line">	A:添加功能     void add(int index,E element)</span><br><span class="line">	B:删除功能     E remove(int index)</span><br><span class="line">	C:获取功能     E get(int index)</span><br><span class="line">	D:迭代器功能   ListIterator listIterator()</span><br><span class="line">	E:修改功能     E set(int index,E element)</span><br><span class="line">(3)List集合的特有遍历功能</span><br><span class="line">	A:由size()和get()结合。</span><br><span class="line">	B:代码演示</span><br><span class="line">			//创建集合对象</span><br><span class="line">			List list = new ArrayList();</span><br><span class="line"></span><br><span class="line">			//创建并添加元素</span><br><span class="line">			list.add(&quot;hello&quot;);</span><br><span class="line">			list.add(&quot;world&quot;);</span><br><span class="line">			list.add(&quot;java&quot;);</span><br><span class="line"></span><br><span class="line">			//遍历集合</span><br><span class="line">			Iterator it = list.iterator();</span><br><span class="line">			while(it.hasNext()) &#123;</span><br><span class="line">				String s =(String) it.next();</span><br><span class="line">				System.out.println(s);</span><br><span class="line">			&#125;</span><br><span class="line">			System.out.println(&quot;----------&quot;);</span><br><span class="line"></span><br><span class="line">			for(int x=0; x&lt;list.size(); x++) &#123;</span><br><span class="line">				String s =(String) list.get(x);</span><br><span class="line">				System.out.println(s);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">(4)ListIterator接口的成员方法</span><br><span class="line">boolean hasPrevious()</span><br><span class="line">E previous()</span><br><span class="line"></span><br><span class="line">		可以逆向遍历，但是要先正向遍历，所以无意义，基本不使用。</span><br><span class="line">（5)并发修改异常</span><br><span class="line">ConcurrentModificationException</span><br><span class="line">当方法检测到对象的并发修改，但不允许这种修改时，抛出此异常</span><br><span class="line">		A:出现的现象</span><br><span class="line">			迭代器遍历集合，集合修改集合元素</span><br><span class="line">		B:原因</span><br><span class="line">			迭代器是依赖于集合的，而集合的改变迭代器并不知道。</span><br><span class="line">		C:解决方案</span><br><span class="line">			a:迭代器遍历，迭代器修改(ListIterator)</span><br><span class="line">				元素添加在刚才迭代的位置</span><br><span class="line">			b:集合遍历，集合修改(size()和get())</span><br><span class="line">				元素添加在集合的末尾</span><br><span class="line">(6)常见数据结构</span><br><span class="line">	A:栈 先进后出</span><br><span class="line">	B:队列 先进先出</span><br><span class="line">	C:数组 查询快，增删慢</span><br><span class="line">	D:链表 查询慢，增删快</span><br><span class="line">(7)List的子类特点(面试题)</span><br><span class="line">	ArrayList</span><br><span class="line">		底层数据结构是数组，查询快，增删慢。</span><br><span class="line">		线程不安全，效率高。</span><br><span class="line">	Vector</span><br><span class="line">		底层数据结构是数组，查询快，增删慢。</span><br><span class="line">		线程安全，效率低。</span><br><span class="line">	LinkedList</span><br><span class="line">		底层数据结构是链表，查询慢，增删快。</span><br><span class="line">		线程不安全，效率高。</span><br><span class="line"></span><br><span class="line">	到底使用谁呢?看需求?</span><br><span class="line">	分析：</span><br><span class="line">		要安全吗?</span><br><span class="line">			要：Vector(即使要，也不使用这个，后面再说)</span><br><span class="line">			不要：ArrayList或者LinkedList</span><br><span class="line">				查询多；ArrayList</span><br><span class="line">				增删多：LinkedList</span><br><span class="line"></span><br><span class="line">	什么都不知道，就用ArrayList。</span><br></pre></td></tr></table></figure>
<p>Vector:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Vector类特有功能</span><br><span class="line">public void addElement(E obj) --	add()</span><br><span class="line">public E elementAt(int index) --	get()</span><br><span class="line">public E numeration elements() --  iterator()</span><br></pre></td></tr></table></figure></p>
<p>LinkedList:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">LinkedList类特有功能</span><br><span class="line">public void addFirst(E e) 及 addLast(E e)</span><br><span class="line">public E getFirst()       及 getLast()</span><br><span class="line">public E removeFirst()    及 public E removeLast()</span><br></pre></td></tr></table></figure></p>
<h3 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h3><p>泛型类<br>格式:public class 类名&lt;泛型类型1,…&gt;<br>注意:泛型类型必须是引用类型<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * 泛型类：把泛型定义在类上</span><br><span class="line"> */</span><br><span class="line">public class ObjectTool&lt;T&gt; &#123;</span><br><span class="line">	private T obj;</span><br><span class="line"></span><br><span class="line">	public T getObj() &#123;</span><br><span class="line">		return obj;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public void setObj(T obj) &#123;</span><br><span class="line">		this.obj = obj;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * 泛型类的测试</span><br><span class="line"> */</span><br><span class="line">public class ObjectToolDemo &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">		ObjectTool&lt;String&gt; ot = new ObjectTool&lt;String&gt;();</span><br><span class="line">		ot.setObj(new String(&quot;林青霞&quot;));</span><br><span class="line">		String s = ot.getObj();</span><br><span class="line">		System.out.println(&quot;姓名是：&quot; + s);</span><br><span class="line"></span><br><span class="line">		ObjectTool&lt;Integer&gt; ot2 = new ObjectTool&lt;Integer&gt;();</span><br><span class="line">		ot2.setObj(new Integer(27));</span><br><span class="line">		Integer i = ot2.getObj();</span><br><span class="line">		System.out.println(&quot;年龄是：&quot; + i);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>泛型方法<br>格式:public &lt;泛型类型&gt; 返回类型 方法名(泛型类型 .)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * 泛型方法：把泛型定义在方法上</span><br><span class="line"> */</span><br><span class="line">public class ObjectTool &#123;</span><br><span class="line">	public &lt;T&gt; void show(T t) &#123;</span><br><span class="line">		System.out.println(t);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class ObjectToolDemo &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		ObjectTool ot = new ObjectTool();</span><br><span class="line">		ot.show(&quot;hello&quot;);</span><br><span class="line">		ot.show(100);</span><br><span class="line">		ot.show(true);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>泛型接口<br>格式:public  interface 接口名&lt;泛型类型1…&gt;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * 泛型接口：把泛型定义在接口上</span><br><span class="line"> */</span><br><span class="line">public interface Inter&lt;T&gt; &#123;</span><br><span class="line">	public abstract void show(T t);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class InterImpl&lt;T&gt; implements Inter&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public void show(T t) &#123;</span><br><span class="line">		System.out.println(t);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class InterDemo &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">		Inter&lt;String&gt; i = new InterImpl&lt;String&gt;();</span><br><span class="line">		i.show(&quot;hello&quot;);</span><br><span class="line"></span><br><span class="line">		Inter&lt;Integer&gt; ii = new InterImpl&lt;Integer&gt;();</span><br><span class="line">		ii.show(100);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="泛型高级-通配符"><a href="#泛型高级-通配符" class="headerlink" title="泛型高级(通配符)"></a>泛型高级(通配符)</h3><p>泛型通配符<br>&lt;?&gt;<br>任意类型，如果没有明确，那么就是Object以及任意的Java类了<br>? extends E<br>向下限定，E及其子类<br>? super E<br>向上限定，E及其父类<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Animal &#123;&#125;</span><br><span class="line">class Dog extends Animal &#123;&#125;</span><br><span class="line">class Cat extends Animal &#123;&#125;</span><br><span class="line">public class CollectionDemo &#123;</span><br><span class="line">  public static void main(String[] args) &#123;</span><br><span class="line">    Collection&lt;?&gt; c1 = new ArrayList&lt;Animal&gt;();</span><br><span class="line">    Collection&lt;?&gt; c2 = new ArrayList&lt;Dog&gt;();</span><br><span class="line">    Collection&lt;?&gt; c3 = new ArrayList&lt;Cat&gt;();</span><br><span class="line">    Collection&lt;?&gt; c4 = new ArrayList&lt;Object&gt;();</span><br><span class="line"></span><br><span class="line">    Collection&lt;? extends Animal&gt; c5 = new ArrayList&lt;Animal&gt;();</span><br><span class="line">    Collection&lt;? extends Animal&gt; c6 = new ArrayList&lt;Dog&gt;();</span><br><span class="line">    Collection&lt;? extends Animal&gt; c7 = new ArrayList&lt;Cat&gt;();</span><br><span class="line">    // Collection&lt;? extends Animal&gt; c8 = new ArrayList&lt;Object&gt;();</span><br><span class="line"></span><br><span class="line">    Collection&lt;? super Animal&gt; c9 = new ArrayList&lt;Animal&gt;();</span><br><span class="line">    // Collection&lt;? super Animal&gt; c10 = new ArrayList&lt;Dog&gt;();</span><br><span class="line">    // Collection&lt;? super Animal&gt; c11 = new ArrayList&lt;Cat&gt;();</span><br><span class="line">    Collection&lt;? super Animal&gt; c12 = new ArrayList&lt;Object&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

                    
                        

                    
                    
                        <p>
                            <a href="/2019/09/07/集合/#post-footer" class="postShorten-excerpt_link link">
                                评论和共享
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a class="link-unstyled" href="/2019/09/07/多线程3/">
                            多线程3
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2019-09-07T10:23:08+08:00">
	
		    9月 07, 2019
    	
    </time>
    
</div>

            </div>
            
                <div class="postShorten-content">
                    <h3 id="java并发包介绍"><a href="#java并发包介绍" class="headerlink" title="java并发包介绍"></a>java并发包介绍</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">JDK5.0 以后的版本都引入了高级并发特性，大多数的特性在java.util.concurrent 包中，是专门用于多线程发编程的，充分利用了现代多处理器和多核心系统的功能以编写大规模并发应用程序。</span><br><span class="line">主要包含原子量、并发集合、同步器、可重入锁，并对线程池的构造提供了强力的支持。</span><br></pre></td></tr></table></figure>
<h4 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h4><p>1、Single Thread Executor : 只有一个线程的线程池，因此所有提交的任务是顺序执行，<br>Executors.newSingleThreadExecutor()</p>
<p>2、Cached Thread Pool : 线程池里有很多线程需要同时执行，老的可用线程将被新的任务触发重新执行，如果线程超过60秒内没执行，那么将被终止并从池中删除，<br>Executors.newCachedThreadPool()</p>
<p>3、Fixed Thread Pool : 拥有固定线程数的线程池，如果没有任务执行，那么线程会一直等待，<br>Executors.newFixedThreadPool(4)<br>在构造函数中的参数4是线程池的大小，你可以随意设置，也可以和cpu的数量保持一致，获取cpu的数量int cpuNums = Runtime.getRuntime().availableProcessors();</p>
<p>4、Scheduled Thread Pool : 用来调度即将执行的任务的线程池，<br>Executors.newScheduledThreadPool()</p>
<p>5、Single Thread Scheduled Pool : 只有一个线程，用来调度执行将来的任务，<br>Executors.newSingleThreadScheduledExecutor()</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">import java.util.concurrent.ExecutorService;</span><br><span class="line">import java.util.concurrent.Executors;</span><br><span class="line">import java.util.concurrent.ScheduledExecutorService;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 列出并发包中的各种线程池</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">public class ExecutorDemo &#123;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		ExecutorService newSingleThreadExecutor = Executors.newSingleThreadExecutor();</span><br><span class="line">		ExecutorService newCachedThreadPool = Executors.newCachedThreadPool();</span><br><span class="line"></span><br><span class="line">		int cpuNums = Runtime.getRuntime().availableProcessors();</span><br><span class="line">		System.out.println(cpuNums);</span><br><span class="line">		ExecutorService newFixedThreadPool = Executors.newFixedThreadPool(cpuNums);</span><br><span class="line">		ScheduledExecutorService newScheduledThreadPool = Executors.newScheduledThreadPool(8);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		ScheduledExecutorService newSingleThreadScheduledExecutor = Executors.newSingleThreadScheduledExecutor();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>提交 Runnable ，任务完成后 Future 对象返回 null<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">import java.util.concurrent.ExecutorService;</span><br><span class="line">import java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line">public class ThreadPoolWithRunable &#123;</span><br><span class="line">	/**</span><br><span class="line">	 * 通过线程池执行线程</span><br><span class="line">	 * @param args</span><br><span class="line">	 */</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		//创建一个线程池</span><br><span class="line">		ExecutorService pool = Executors.newCachedThreadPool();</span><br><span class="line">		for(int i = 1; i &lt; 5; i++)&#123;</span><br><span class="line">			pool.execute(new Runnable() &#123;</span><br><span class="line">				@Override</span><br><span class="line">				public void run() &#123;</span><br><span class="line">					System.out.println(&quot;thread name: &quot; + Thread.currentThread().getName());</span><br><span class="line">					try &#123;</span><br><span class="line">						Thread.sleep(1000);</span><br><span class="line">					&#125; catch (InterruptedException e) &#123;</span><br><span class="line">						e.printStackTrace();</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;);</span><br><span class="line">		&#125;</span><br><span class="line">		pool.shutdown();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>提交 Callable，该方法返回一个 Future 实例表示任务的状态<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.List;</span><br><span class="line">import java.util.concurrent.Callable;</span><br><span class="line">import java.util.concurrent.ExecutionException;</span><br><span class="line">import java.util.concurrent.ExecutorService;</span><br><span class="line">import java.util.concurrent.Executors;</span><br><span class="line">import java.util.concurrent.Future;</span><br><span class="line">/**</span><br><span class="line"> * callable 跟runnable的区别：</span><br><span class="line"> * runnable的run方法不会有任何返回结果，所以主线程无法获得任务线程的返回值</span><br><span class="line"> *</span><br><span class="line"> * callable的call方法可以返回结果，但是主线程在获取时是被阻塞，需要等待任务线程返回才能拿到结果</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class ThreadPoolWithcallable &#123;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) throws InterruptedException, ExecutionException &#123;</span><br><span class="line">		ExecutorService pool = Executors.newFixedThreadPool(4);</span><br><span class="line"></span><br><span class="line">		for(int i = 0; i &lt; 10; i++)&#123;</span><br><span class="line">			Future&lt;String&gt; submit = pool.submit(new Callable&lt;String&gt;()&#123;</span><br><span class="line">				@Override</span><br><span class="line">				public String call() throws Exception &#123;</span><br><span class="line">					//System.out.println(&quot;a&quot;);</span><br><span class="line">					Thread.sleep(5000);</span><br><span class="line">					return &quot;b--&quot;+Thread.currentThread().getName();</span><br><span class="line">				&#125;</span><br><span class="line">			   &#125;);</span><br><span class="line">			//从Future中get结果，这个方法是会被阻塞的，一直要等到线程任务返回结果</span><br><span class="line">			System.out.println(submit.get());</span><br><span class="line">		&#125;</span><br><span class="line">			pool.shutdown();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Random;</span><br><span class="line">import java.util.concurrent.Callable;</span><br><span class="line"></span><br><span class="line">public class TaskCallable implements Callable&lt;String&gt;&#123;</span><br><span class="line"></span><br><span class="line">	private int s;</span><br><span class="line">	Random r = new Random();</span><br><span class="line">	public TaskCallable(int s)&#123;</span><br><span class="line">		this.s = s;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public String call() throws Exception &#123;</span><br><span class="line">		String name = Thread.currentThread().getName();</span><br><span class="line">		long currentTimeMillis = System.currentTimeMillis();</span><br><span class="line">		System.out.println(name+&quot; 启动时间：&quot; + currentTimeMillis/1000);</span><br><span class="line"></span><br><span class="line">		int rint = r.nextInt(3);</span><br><span class="line">		try &#123;</span><br><span class="line">			Thread.sleep(rint*1000);</span><br><span class="line">		&#125; catch (InterruptedException e) &#123;</span><br><span class="line"></span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(name + &quot; is working...&quot;+s);</span><br><span class="line">		return s+&quot;&quot;;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Random;</span><br><span class="line"></span><br><span class="line">public class TaskRunnable implements Runnable&#123;</span><br><span class="line">	private int s;</span><br><span class="line"></span><br><span class="line">	public TaskRunnable(int s)&#123;</span><br><span class="line">		this.s = s;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	Random r = new Random();</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public void run() &#123;</span><br><span class="line">		String name = Thread.currentThread().getName();</span><br><span class="line">		long currentTimeMillis = System.currentTimeMillis();</span><br><span class="line">		System.out.println(name+&quot; 启动时间：&quot; + currentTimeMillis/1000);</span><br><span class="line"></span><br><span class="line">		int rint = r.nextInt(3);</span><br><span class="line">		try &#123;</span><br><span class="line">			Thread.sleep(rint*1000);</span><br><span class="line">		&#125; catch (InterruptedException e) &#123;</span><br><span class="line"></span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(name + &quot; is working...&quot;+s);</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.HashMap;</span><br><span class="line">import java.util.Random;</span><br><span class="line">import java.util.concurrent.ExecutorService;</span><br><span class="line">import java.util.concurrent.Executors;</span><br><span class="line">import java.util.concurrent.Future;</span><br><span class="line">import java.util.concurrent.ScheduledExecutorService;</span><br><span class="line">import java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line">public class TestPool &#123;</span><br><span class="line">	public static void main(String[] args) throws Exception &#123;</span><br><span class="line">		Future&lt;?&gt; submit = null;</span><br><span class="line">		Random random = new Random();</span><br><span class="line"></span><br><span class="line">		//创建固定数量线程池</span><br><span class="line">//		ExecutorService exec = Executors.newFixedThreadPool(4);</span><br><span class="line"></span><br><span class="line">		//创建调度线程池</span><br><span class="line">		ScheduledExecutorService exec = Executors.newScheduledThreadPool(4);</span><br><span class="line"></span><br><span class="line">		//用来记录各线程的返回结果</span><br><span class="line">		ArrayList&lt;Future&lt;?&gt;&gt; results = new ArrayList&lt;Future&lt;?&gt;&gt;();</span><br><span class="line"></span><br><span class="line">		for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">			//fixedPool提交线程，runnable无返回值，callable有返回值</span><br><span class="line">			/*submit = exec.submit(new TaskRunnable(i));*/</span><br><span class="line">			/*submit = exec.submit(new TaskCallable(i));*/</span><br><span class="line"></span><br><span class="line">			//对于schedulerPool来说，调用submit提交任务时，跟普通pool效果一致</span><br><span class="line">			/*submit = exec.submit(new TaskCallable(i));*/</span><br><span class="line">			//对于schedulerPool来说，调用schedule提交任务时，则可按延迟，按间隔时长来调度线程的运行</span><br><span class="line">			submit = exec.schedule(new TaskCallable(i), random.nextInt(10), TimeUnit.SECONDS);</span><br><span class="line">			//存储线程执行结果</span><br><span class="line">			results.add(submit);</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		//打印结果</span><br><span class="line">		for(Future f: results)&#123;</span><br><span class="line">			boolean done = f.isDone();</span><br><span class="line">			System.out.println(done?&quot;已完成&quot;:&quot;未完成&quot;);  //从结果的打印顺序可以看到，即使未完成，也会阻塞等待</span><br><span class="line">			System.out.println(&quot;线程返回future结果： &quot; + f.get());</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		exec.shutdown();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="同步容器类"><a href="#同步容器类" class="headerlink" title="同步容器类"></a>同步容器类</h4><p>同步类容器都是线程安全的,但在某些场景下可能需要加锁来保护复合操作,复合类操作如选代(反复访问元素,遍历完容器中所有的元素)、跳转(根据指定的顺序找到当前元素的下一个元素)、以及条件运算,这些复合操作在多线程并发地修改容器时,可能会表现出意外的行为,最经典的便是ConcurrengModificationException,原因是当容器迭代的过程中,被井发的修改了内容,<br>这是由于早期达代器设计的时候并没有考虑并发修改的问题。<br>同步类容器:如古老的Vector, Hash Table.这些容器的同步功能其实是在JDK的Collections.synchronized**等工厂方法去创建实现的,其底层的机制无非就是用传统的synchronized关键字对每个公用的方法都进行同步,使得每次只能有一个线程访问容器的状态,这很明显不满足我们今天互联网时代高并发的需求,在保证线程安全的同时,他必续要有足够好的性能</p>
<h4 id="并发类容器"><a href="#并发类容器" class="headerlink" title="并发类容器"></a>并发类容器</h4><p>jak5.0以后提供了多种并发类容器来替代同步类容器从而改善性能.同步类容器的状态都是串行化的,他们虽然实现了线程安全,但是严重降低了并发性,在多线程环境时,严重降低了应用程序的吞吐量。<br>并发类容器是专门针对并发设计的,使用ConcurrentHashMap来代替给子散列的传统的HashTable,而且在ConcurrentHashMap中,添加了一些常见复合操作的支持,以及使用了CopyOnWriteArrayList代替Voctor,并发的CopyonWriteArraySet,以及并发的Queue, ConcurrentLinkedQueue和LinkedBlockingQueue,前者是高性能的队列,后者是以阻塞形式的队列,具体实现Queue还有很多,例如ArrayBlockingQueue.<br>PriorityBlockingQueue. Synchronous Queue等</p>
<p>ConcurrntMap:<br>ConcurrentMap接口下有俩个重要的实现<br>ConcurrentHashap<br>ConcurentSkipListMap (支持并发排序功能,弥补ConcurrentHashMap)<br>ConcurrentHashMap内部使用段(Segmen)未表示这些不同的部分,每个段其实就是一个小的Hash Table,它们有自己的锁.只要多个修改操作发生在不同的段上,它们就可以并发进行,把一个整体分成了16个段(Segment).<br>也就是最高支持16个线程的并发修改操作,这也是在多线程场景时减小锁的粒度从面降低锁竞争的一种方案。并且代码中大多共享变量使用volatile关键字声明,目的是第一时间获取修改的内容,性能非常好.</p>
<p>Copy-On-Write容器:<br>Copy-on-Write简称cow,是种用于程序设计中的优化策略。<br>JDK里的CoW容器有两种: CopyOnWriteArrayList和CopyOnWriteArraySet,Cow容器非常有用,可以在非常多的并发场景中使用到<br>什么是CopyOnWrite容器?<br>CopyOnWrite容器即写时复制的容器,通俗的理解是当我们往一个容器添加元素的时候,不直接往当前容器添加,而是先将当前容器进行Copy,复制出一个新的容器,然后新的容器里添加元素,添加完元素之后,再将原容器的引用指向新的容器。这样放的好处是我们可以对CopyOnWrite容器进行并发的读,而不需要加锁,因为当前容器不会添加任何元素,所以CopyOnWrite容器也是一种读写分离的思想,读和写不同<br>的容器。</p>
<h4 id="并发Queue"><a href="#并发Queue" class="headerlink" title="并发Queue"></a>并发Queue</h4><p>在并发队列上JDK提供了两套实现,一个是以ConcurrentLinkedQueue为代表的高性能队列,一个是以BlockingQueue接口为代表的阻塞队列,无论哪种都维承自Queue<br><img src="queue.png" alt="queue"></p>
<p>ConcurrentLinkedQueue:<br>ConcurrentLinkedQueue:是一个适用于高并发场景下的队列,通过无锁的方式,实现了高并发状态下的高性能,通常ConcurrentLinkedQueue性能好于BlockingQueue.它是一个基于链接节点的无界线程安全队列,该队列的元素遵循先进先出的原则,头是最先加入的,尾是最近加入的,该队列不允许null元素。<br>ConcurrentLinkedQueue重要方法:<br>add()和 ofter()都是加入元素的方法(在ConcurrentLinkedaueue中,这两个方法没有任何区别)<br>pol()和peek()都是取头元素节点,区别在于前者会删除元素,后者不会.</p>
<p>ClockingQueue接口:<br>ArrayBlockingQueue:基于数组的阻塞队列实现,在ArrayBlockingQueue内部,维护了一个定长数组,以便缓存队列中的数据对象,其内部没实现读写分离,也就意味着生产和消费不能完全并行,长度是需要定义的,可以指定先进先出或者先进后出,也叫有界队列,在很多场合非常适合使用.<br>LinkedBlockingQueue:基于链表的阻塞队列,同ArrayBlockingQueue类似,其内部也维持着一个数据缓冲队列(该队列由一个链表构成) , LinkedBlockingQueue之所以能够高效的处理并发数据,是因为其内部实现采用分离锁(读写分离两个锁) ,从而实现生产者和消费者操作的完全并行运行。他是一个无界队列。<br>SynchronousQueue :一种没有缓冲的队列,生产者产生的数据直接会被消费者获取并消费。<br>PriorityBlockingQueue:基于优先级的阻塞队列(优先级的判断通过构造函数传入的Compator对象来决定,也就是说传入队列的对象必须实现Comparable接口) ,在实现PriorityBlockingQueue时,内部控制线程同步的锁采用的是公平锁,他也是一个无界的队列。<br>DelayQueue:带有延迟时间的Queue,其中的元素只有当其指定的延迟时间到了,才能够从队列中获取到该元素. Delayqueue中的元素必须实现Delayed接口, Delayqueue是一个没有大小限制的队列,应用场景很多,比如对缓存超时的数据进行移除、任务超时处理、空闲连接的关闭等等.</p>
<p>生产消费模型应用:<br>客户端服务器端数据传输，可能我们没有使用什么消息中间件，通过直连的手段，比如tcp, netty等。<br>客服端与服务器直连进行数据传输，我们发现使用netty一般都会与队列结合使用，可能有一个客户端每秒发送10条数据到服务器端，但是处理的速度与生产的步伐不一致，服务器每秒只能消费1条。<br>如果我们用netty,在业务高峰期，把这10条数据直接放到队列中，但是要有限制，使用有界队列，防止服务器内存溢出，非高峰期，用一些无界队列。或者有些在不同时间段使用不同类型队列。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line">import java.util.concurrent.SynchronousQueue;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class UseQueue &#123;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">		//高性能无阻塞无界队列：ConcurrentLinkedQueue</span><br><span class="line">		/**</span><br><span class="line">		ConcurrentLinkedQueue&lt;String&gt; q = new ConcurrentLinkedQueue&lt;String&gt;();</span><br><span class="line">		q.offer(&quot;a&quot;);</span><br><span class="line">		q.offer(&quot;b&quot;);</span><br><span class="line">		q.offer(&quot;c&quot;);</span><br><span class="line">		q.offer(&quot;d&quot;);</span><br><span class="line">		q.add(&quot;e&quot;);</span><br><span class="line"></span><br><span class="line">		System.out.println(q.poll());	//a 从头部取出元素，并从队列里删除</span><br><span class="line">		System.out.println(q.size());	//4</span><br><span class="line">		System.out.println(q.peek());	//b</span><br><span class="line">		System.out.println(q.size());	//4</span><br><span class="line">		*/</span><br><span class="line"></span><br><span class="line">		/**</span><br><span class="line">		ArrayBlockingQueue&lt;String&gt; array = new ArrayBlockingQueue&lt;String&gt;(5);</span><br><span class="line">		array.put(&quot;a&quot;);</span><br><span class="line">		array.put(&quot;b&quot;);</span><br><span class="line">		array.add(&quot;c&quot;);</span><br><span class="line">		array.add(&quot;d&quot;);</span><br><span class="line">		array.add(&quot;e&quot;);</span><br><span class="line">		array.add(&quot;f&quot;);</span><br><span class="line">		//System.out.println(array.offer(&quot;a&quot;, 3, TimeUnit.SECONDS));</span><br><span class="line">		*/</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		/**</span><br><span class="line">		//阻塞队列</span><br><span class="line">		LinkedBlockingQueue&lt;String&gt; q = new LinkedBlockingQueue&lt;String&gt;();</span><br><span class="line">		q.offer(&quot;a&quot;);</span><br><span class="line">		q.offer(&quot;b&quot;);</span><br><span class="line">		q.offer(&quot;c&quot;);</span><br><span class="line">		q.offer(&quot;d&quot;);</span><br><span class="line">		q.offer(&quot;e&quot;);</span><br><span class="line">		q.add(&quot;f&quot;);</span><br><span class="line">		//System.out.println(q.size());</span><br><span class="line"></span><br><span class="line">//		for (Iterator iterator = q.iterator(); iterator.hasNext();) &#123;</span><br><span class="line">//			String string = (String) iterator.next();</span><br><span class="line">//			System.out.println(string);</span><br><span class="line">//		&#125;</span><br><span class="line"></span><br><span class="line">		List&lt;String&gt; list = new ArrayList&lt;String&gt;();</span><br><span class="line">		System.out.println(q.drainTo(list, 3));</span><br><span class="line">		System.out.println(list.size());</span><br><span class="line">		for (String string : list) &#123;</span><br><span class="line">			System.out.println(string);</span><br><span class="line">		&#125;</span><br><span class="line">		*/</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		final SynchronousQueue&lt;String&gt; q = new SynchronousQueue&lt;String&gt;();</span><br><span class="line">		Thread t1 = new Thread(new Runnable() &#123;</span><br><span class="line">			@Override</span><br><span class="line">			public void run() &#123;</span><br><span class="line">				try &#123;</span><br><span class="line">					System.out.println(q.take());</span><br><span class="line">				&#125; catch (InterruptedException e) &#123;</span><br><span class="line">					e.printStackTrace();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line">		t1.start();</span><br><span class="line">		Thread t2 = new Thread(new Runnable() &#123;</span><br><span class="line"></span><br><span class="line">			@Override</span><br><span class="line">			public void run() &#123;</span><br><span class="line">				q.add(&quot;asdasd&quot;);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line">		t2.start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>PriorityBlockingQueue:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public class Task implements Comparable&lt;Task&gt;&#123;</span><br><span class="line"></span><br><span class="line">	private int id ;</span><br><span class="line">	private String name;</span><br><span class="line">	public int getId() &#123;</span><br><span class="line">		return id;</span><br><span class="line">	&#125;</span><br><span class="line">	public void setId(int id) &#123;</span><br><span class="line">		this.id = id;</span><br><span class="line">	&#125;</span><br><span class="line">	public String getName() &#123;</span><br><span class="line">		return name;</span><br><span class="line">	&#125;</span><br><span class="line">	public void setName(String name) &#123;</span><br><span class="line">		this.name = name;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public int compareTo(Task task) &#123;</span><br><span class="line">		return this.id &gt; task.id ? 1 : (this.id &lt; task.id ? -1 : 0);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public String toString()&#123;</span><br><span class="line">		return this.id + &quot;,&quot; + this.name;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">import java.util.concurrent.PriorityBlockingQueue;</span><br><span class="line"></span><br><span class="line">public class UsePriorityBlockingQueue &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) throws Exception&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		PriorityBlockingQueue&lt;Task&gt; q = new PriorityBlockingQueue&lt;Task&gt;();</span><br><span class="line"></span><br><span class="line">		Task t1 = new Task();</span><br><span class="line">		t1.setId(3);</span><br><span class="line">		t1.setName(&quot;id为3&quot;);</span><br><span class="line">		Task t2 = new Task();</span><br><span class="line">		t2.setId(4);</span><br><span class="line">		t2.setName(&quot;id为4&quot;);</span><br><span class="line">		Task t3 = new Task();</span><br><span class="line">		t3.setId(1);</span><br><span class="line">		t3.setName(&quot;id为1&quot;);</span><br><span class="line"></span><br><span class="line">		//return this.id &gt; task.id ? 1 : 0;</span><br><span class="line">		q.add(t1);	//3</span><br><span class="line">		q.add(t2);	//4</span><br><span class="line">		q.add(t3);  //1</span><br><span class="line"></span><br><span class="line">		// 1 3 4</span><br><span class="line">		System.out.println(&quot;容器：&quot; + q);</span><br><span class="line">		System.out.println(q.take().getId());</span><br><span class="line">		System.out.println(&quot;容器：&quot; + q);</span><br><span class="line">//		System.out.println(q.take().getId());</span><br><span class="line">//		System.out.println(q.take().getId());</span><br><span class="line"></span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>take的时候才排序，放的时候不排序<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">容器：[1,id为1, 4,id为4, 3,id为3]</span><br><span class="line">1</span><br><span class="line">容器：[3,id为3, 4,id为4]</span><br></pre></td></tr></table></figure></p>
<p>DelayQueue:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">import java.util.concurrent.Delayed;</span><br><span class="line">import java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line">public class Wangmin implements Delayed &#123;</span><br><span class="line"></span><br><span class="line">    private String name;</span><br><span class="line">    //身份证</span><br><span class="line">    private String id;</span><br><span class="line">    //截止时间</span><br><span class="line">    private long endTime;</span><br><span class="line">    //定义时间工具类</span><br><span class="line">    private TimeUnit timeUnit = TimeUnit.SECONDS;</span><br><span class="line"></span><br><span class="line">    public Wangmin(String name,String id,long endTime)&#123;</span><br><span class="line">        this.name=name;</span><br><span class="line">        this.id=id;</span><br><span class="line">        this.endTime = endTime;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getName()&#123;</span><br><span class="line">        return this.name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getId()&#123;</span><br><span class="line">        return this.id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 用来判断是否到了截止时间</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    public long getDelay(TimeUnit unit) &#123;</span><br><span class="line">        //return unit.convert(endTime, TimeUnit.MILLISECONDS) - unit.convert(System.currentTimeMillis(), TimeUnit.MILLISECONDS);</span><br><span class="line">    	return endTime - System.currentTimeMillis();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 相互批较排序用</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    public int compareTo(Delayed delayed) &#123;</span><br><span class="line">    	Wangmin w = (Wangmin)delayed;</span><br><span class="line">        return this.getDelay(this.timeUnit) - w.getDelay(this.timeUnit) &gt; 0 ? 1:0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">import java.util.concurrent.DelayQueue;</span><br><span class="line"></span><br><span class="line">public class WangBa implements Runnable &#123;</span><br><span class="line"></span><br><span class="line">    private DelayQueue&lt;Wangmin&gt; queue = new DelayQueue&lt;Wangmin&gt;();</span><br><span class="line"></span><br><span class="line">    public boolean yinye =true;</span><br><span class="line"></span><br><span class="line">    public void shangji(String name,String id,int money)&#123;</span><br><span class="line">        Wangmin man = new Wangmin(name, id, 1000 * money + System.currentTimeMillis());</span><br><span class="line">        System.out.println(&quot;网名&quot;+man.getName()+&quot; 身份证&quot;+man.getId()+&quot;交钱&quot;+money+&quot;块,开始上机...&quot;);</span><br><span class="line">        this.queue.add(man);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void xiaji(Wangmin man)&#123;</span><br><span class="line">        System.out.println(&quot;网名&quot;+man.getName()+&quot; 身份证&quot;+man.getId()+&quot;时间到下机...&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        while(yinye)&#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                Wangmin man = queue.take();</span><br><span class="line">                xiaji(man);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String args[])&#123;</span><br><span class="line">        try&#123;</span><br><span class="line">            System.out.println(&quot;网吧开始营业&quot;);</span><br><span class="line">            WangBa siyu = new WangBa();</span><br><span class="line">            Thread shangwang = new Thread(siyu);</span><br><span class="line">            shangwang.start();</span><br><span class="line"></span><br><span class="line">            siyu.shangji(&quot;路人甲&quot;, &quot;123&quot;, 1);</span><br><span class="line">            siyu.shangji(&quot;路人乙&quot;, &quot;234&quot;, 10);</span><br><span class="line">            siyu.shangji(&quot;路人丙&quot;, &quot;345&quot;, 5);</span><br><span class="line">        &#125;</span><br><span class="line">        catch(Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">网吧开始营业</span><br><span class="line">网名路人甲 身份证123交钱1块,开始上机...</span><br><span class="line">网名路人乙 身份证234交钱10块,开始上机...</span><br><span class="line">网名路人丙 身份证345交钱5块,开始上机...</span><br><span class="line">网名路人甲 身份证123时间到下机...</span><br><span class="line">网名路人丙 身份证345时间到下机...</span><br><span class="line">网名路人乙 身份证234时间到下机...</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">BlockingQueue也是java.util.concurrent下的主要用来控制线程同步的工具。</span><br><span class="line">主要的方法是：put、take一对阻塞存取；add、poll一对非阻塞存取。</span><br><span class="line">	插入:</span><br><span class="line">		1)add(anObject):把anObject加到BlockingQueue里,即如果BlockingQueue可以容纳,则返回true,否则抛出</span><br><span class="line">        2)offer(anObject):表示如果可能的话,将anObject加到BlockingQueue里,即如果BlockingQueue可以容纳,则返回true,否则返回false.</span><br><span class="line">        3)put(anObject):把anObject加到BlockingQueue里,如果BlockQueue没有空间,则调用此方法的线程被阻断直到BlockingQueue里面有空间再继续.</span><br><span class="line">	读取：</span><br><span class="line">        4)poll(time):取走BlockingQueue里排在首位的对象,若不能立即取出,则可以等time参数规定的时间,取不到时返回null</span><br><span class="line">        5)take():取走BlockingQueue里排在首位的对象,若BlockingQueue为空,阻断进入等待状态直到Blocking有新的对象被加入为止</span><br><span class="line">	其他</span><br><span class="line">int remainingCapacity();返回队列剩余的容量，在队列插入和获取的时候，不要瞎搞，数	据可能不准</span><br><span class="line">boolean remove(Object o); 从队列移除元素，如果存在，即移除一个或者更多，队列改	变了返回true</span><br><span class="line">public boolean contains(Object o); 查看队列是否存在这个元素，存在返回true</span><br><span class="line">int drainTo(Collection&lt;? super E&gt; c); 移除此队列中所有可用的元素，并将它们添加到给定collection中</span><br><span class="line">int drainTo(Collection&lt;? super E&gt; c, int maxElements); 和上面方法的区别在于，制定了移动的数量</span><br><span class="line"></span><br><span class="line">BlockingQueue有四个具体的实现类,常用的两种实现类为：</span><br><span class="line"></span><br><span class="line">1、ArrayBlockingQueue：一个由数组支持的有界阻塞队列，规定大小的BlockingQueue,其构造函数必须带一个int参数来指明其大小.其所含的对象是以FIFO(先入先出)顺序排序的。</span><br><span class="line"></span><br><span class="line">2、LinkedBlockingQueue：大小不定的BlockingQueue,若其构造函数带一个规定大小的参数,生成的BlockingQueue有大小限制,若不带大小参数,所生成的BlockingQueue的大小由Integer.MAX_VALUE来决定.其所含的对象是以FIFO(先入先出)顺序排序的。</span><br><span class="line">	LinkedBlockingQueue 可以指定容量，也可以不指定，不指定的话，默认最大是Integer.MAX_VALUE,其中主要用到put和take方法，put方法在队列满的时候会阻塞直到有队列成员被消费，take方法在队列空的时候会阻塞，直到有队列成员被放进来。</span><br><span class="line"></span><br><span class="line">LinkedBlockingQueue和ArrayBlockingQueue区别：</span><br><span class="line"></span><br><span class="line">LinkedBlockingQueue和ArrayBlockingQueue比较起来,它们背后所用的数据结构不一样,导致LinkedBlockingQueue的数据吞吐量要大于ArrayBlockingQueue,但在线程数量很大时其性能的可预见性低于ArrayBlockingQueue.</span><br></pre></td></tr></table></figure>
<h3 id="java并发编程的一些总结"><a href="#java并发编程的一些总结" class="headerlink" title="java并发编程的一些总结"></a>java并发编程的一些总结</h3><p>1.不应用线程池的缺点<br>有些开发者图省事，遇到需要多线程处理的地方，直接new Thread(…).start()，对于一般场景是没问题的，但如果是在并发请求很高的情况下，就会有些隐患：<br>新建线程的开销。线程虽然比进程要轻量许多，但对于JVM来说，新建一个线程的代价还是挺大的，决不同于新建一个对象<br>资源消耗量。没有一个池来限制线程的数量，会导致线程的数量直接取决于应用的并发量，这样有潜在的线程数据巨大的可能，那么资源消耗量将是巨大的<br>稳定性。当线程数量超过系统资源所能承受的程度，稳定性就会成问题<br>2.制定执行策略<br>在每个需要多线程处理的地方，不管并发量有多大，需要考虑线程的执行策略<br>任务以什么顺序执行<br>可以有多少个任何并发执行<br>可以有多少个任务进入等待执行队列<br>系统过载的时候，应该放弃哪些任务？如何通知到应用程序？<br>一个任务的执行前后应该做什么处理<br>3.线程池的类型<br>不管是通过Executors创建线程池，还是通过Spring来管理，都得清楚知道有哪几种线程池：<br>FixedThreadPool：定长线程池，提交任务时创建线程，直到池的最大容量，如果有线程非预期结束，会补充新线程<br>CachedThreadPool：可变线程池，它犹如一个弹簧，如果没有任务需求时，它回收空闲线程，如果需求增加，则按需增加线程，不对池的大小做限制<br>SingleThreadExecutor：单线程。处理不过来的任务会进入FIFO队列等待执行<br>SecheduledThreadPool：周期性线程池。支持执行周期性线程任务<br>其实，这些不同类型的线程池都是通过构建一个ThreadPoolExecutor来完成的，所不同的是corePoolSize,maximumPoolSize,keepAliveTime,unit,workQueue,threadFactory这么几个参数。具体可以参见JDK DOC。<br>4.线程池饱和策略<br>由以上线程池类型可知，除了CachedThreadPool其他线程池都有饱和的可能，当饱和以后就需要相应的策略处理请求线程的任务，ThreadPoolExecutor采取的方式通过队列来存储这些任务，当然会根据池类型不同选择不同的队列，比如FixedThreadPool和SingleThreadExecutor默认采用的是无限长度的LinkedBlockingQueue。但从系统可控性讲，最好的做法是使用定长的ArrayBlockingQueue或有限的LinkedBlockingQueue，并且当达到上限时通过ThreadPoolExecutor.setRejectedExecutionHandler方法设置一个拒绝任务的策略，JDK提供了AbortPolicy、CallerRunsPolicy、DiscardPolicy、DiscardOldestPolicy几种策略，具体差异可见JDK DOC<br>5.线程无依赖性<br>多线程任务设计上尽量使得各任务是独立无依赖的，所谓依赖性可两个方面：<br>线程之间的依赖性。如果线程有依赖可能会造成死锁或饥饿<br>调用者与线程的依赖性。调用者得监视线程的完成情况，影响可并发量<br>当然，在有些业务里确实需要一定的依赖性，比如调用者需要得到线程完成后结果，传统的Thread是不便完成的，因为run方法无返回值，只能通过一些共享的变量来传递结果，但在Executor框架里可以通过Future和Callable实现需要有返回值的任务，当然线程的异步性导致需要有相应机制来保证调用者能等待任务完成。</p>
<h3 id="多线程的设计模式"><a href="#多线程的设计模式" class="headerlink" title="多线程的设计模式"></a>多线程的设计模式</h3><p>并行设计模式属于设计优化的一部分,它是对一些常用的多线程结构的总结和抽象与串行程序相比,并行程序的结构通常更为复杂。因此合理的使用并行模式在多线程开发中更具有意义,在这里主要介绍Future, Master-Worker和生产者-消费者模型。</p>
<h4 id="Future模式"><a href="#Future模式" class="headerlink" title="Future模式"></a>Future模式</h4><p>Future模式有点类似于商品订单。比如在网购时,当看重某一件商品事,就可以提交订 ,当订单处理完成后,在家里等待商品送货上门即可。或者说更形象的我们发送Ajax请求的时候,页面是异步的进行后台处理,用户无须一直等待请求的结果,可以继续浏览或操作其他内容。<br><img src="Future模式.png" alt="Future模式"></p>
<p>Data:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface Data &#123;</span><br><span class="line">	String getRequest();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>RealData:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class RealData implements Data&#123;</span><br><span class="line"></span><br><span class="line">	private String result ;</span><br><span class="line"></span><br><span class="line">	public RealData (String queryStr)&#123;</span><br><span class="line">		System.out.println(&quot;根据&quot; + queryStr + &quot;进行查询，这是一个很耗时的操作..&quot;);</span><br><span class="line">		try &#123;</span><br><span class="line">			Thread.sleep(5000);</span><br><span class="line">		&#125; catch (InterruptedException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(&quot;操作完毕，获取结果&quot;);</span><br><span class="line">		result = &quot;查询结果&quot;;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public String getRequest() &#123;</span><br><span class="line">		return result;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>FutureData:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">public class FutureData implements Data&#123;</span><br><span class="line"></span><br><span class="line">	private RealData realData ;</span><br><span class="line">	private boolean isReady = false;</span><br><span class="line"></span><br><span class="line">	public synchronized void setRealData(RealData realData) &#123;</span><br><span class="line">		//如果已经装载完毕了，就直接返回</span><br><span class="line">		if(isReady)&#123;</span><br><span class="line">			return;</span><br><span class="line">		&#125;</span><br><span class="line">		//如果没装载，进行装载真实对象</span><br><span class="line">		this.realData = realData;</span><br><span class="line">		isReady = true;</span><br><span class="line">		//进行通知</span><br><span class="line">		notify();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public synchronized String getRequest() &#123;</span><br><span class="line">		//如果没装载好 程序就一直处于阻塞状态</span><br><span class="line">		while(!isReady)&#123;</span><br><span class="line">			try &#123;</span><br><span class="line">				wait();</span><br><span class="line">			&#125; catch (InterruptedException e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		//装载好直接获取数据即可</span><br><span class="line">		return this.realData.getRequest();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>FutureClient:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class FutureClient &#123;</span><br><span class="line"></span><br><span class="line">	public Data request(final String queryStr)&#123;</span><br><span class="line">		//1 我想要一个代理对象（Data接口的实现类）先返回给发送请求的客户端，告诉他请求已经接收到，可以做其他的事情</span><br><span class="line">		final FutureData futureData = new FutureData();</span><br><span class="line">		//2 启动一个新的线程，去加载真实的数据，传递给这个代理对象</span><br><span class="line">		new Thread(new Runnable() &#123;</span><br><span class="line">			@Override</span><br><span class="line">			public void run() &#123;</span><br><span class="line">				//3 这个新的线程可以去慢慢的加载真实对象，然后传递给代理对象</span><br><span class="line">				RealData realData = new RealData(queryStr);</span><br><span class="line">				futureData.setRealData(realData);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;).start();</span><br><span class="line"></span><br><span class="line">		return futureData;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Main:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class Main &#123;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">		FutureClient fc = new FutureClient();</span><br><span class="line">		Data data = fc.request(&quot;请求参数&quot;);</span><br><span class="line">		System.out.println(&quot;请求发送成功!&quot;);</span><br><span class="line">		System.out.println(&quot;做其他的事情...&quot;);</span><br><span class="line"></span><br><span class="line">		String result = data.getRequest();</span><br><span class="line">		System.out.println(result);</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="Master-Worker模式"><a href="#Master-Worker模式" class="headerlink" title="Master-Worker模式"></a>Master-Worker模式</h4><p>Master-Worker模式是常用的并行计算模式。<br>它的核心思想是系统由两类进程协作工作: Master进程和Worker进程。Master负责接收和分配任务,Worker负责处理子任务。当各个Worker子进程处理完成后,会将结果返回给Master, 由Master做归纳和总结。<br>其好处是能将一个大任务分解成若干个小任务,并行执行,从而提高系统的吞吐量。<br><img src="master-worker.png" alt="master-worker"><br><img src="master-worker2.png" alt="master-worker2"><br>Task:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class Task &#123;</span><br><span class="line"></span><br><span class="line">	private int id;</span><br><span class="line">	private int price ;</span><br><span class="line">	public int getId() &#123;</span><br><span class="line">		return id;</span><br><span class="line">	&#125;</span><br><span class="line">	public void setId(int id) &#123;</span><br><span class="line">		this.id = id;</span><br><span class="line">	&#125;</span><br><span class="line">	public int getPrice() &#123;</span><br><span class="line">		return price;</span><br><span class="line">	&#125;</span><br><span class="line">	public void setPrice(int price) &#123;</span><br><span class="line">		this.price = price;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Master:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">import java.util.HashMap;</span><br><span class="line">import java.util.Map;</span><br><span class="line">import java.util.concurrent.ConcurrentHashMap;</span><br><span class="line">import java.util.concurrent.ConcurrentLinkedQueue;</span><br><span class="line"></span><br><span class="line">public class Master &#123;</span><br><span class="line"></span><br><span class="line">	//1 有一个盛放任务的容器</span><br><span class="line">	private ConcurrentLinkedQueue&lt;Task&gt; workQueue = new ConcurrentLinkedQueue&lt;Task&gt;();</span><br><span class="line"></span><br><span class="line">	//2 需要有一个盛放worker的集合</span><br><span class="line">	private HashMap&lt;String, Thread&gt; workers = new HashMap&lt;String, Thread&gt;();</span><br><span class="line"></span><br><span class="line">	//3 需要有一个盛放每一个worker执行任务的结果集合</span><br><span class="line">	private ConcurrentHashMap&lt;String, Object&gt; resultMap = new ConcurrentHashMap&lt;String, Object&gt;();</span><br><span class="line"></span><br><span class="line">	//4 构造方法</span><br><span class="line">	public Master(Worker worker , int workerCount)&#123;</span><br><span class="line">		worker.setWorkQueue(this.workQueue);</span><br><span class="line">		worker.setResultMap(this.resultMap);</span><br><span class="line"></span><br><span class="line">		for(int i = 0; i &lt; workerCount; i ++)&#123;</span><br><span class="line">			this.workers.put(Integer.toString(i), new Thread(worker));</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	//5 需要一个提交任务的方法</span><br><span class="line">	public void submit(Task task)&#123;</span><br><span class="line">		this.workQueue.add(task);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	//6 需要有一个执行的方法，启动所有的worker方法去执行任务</span><br><span class="line">	public void execute()&#123;</span><br><span class="line">		for(Map.Entry&lt;String, Thread&gt; me : workers.entrySet())&#123;</span><br><span class="line">			me.getValue().start();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	//7 判断是否运行结束的方法</span><br><span class="line">	public boolean isComplete() &#123;</span><br><span class="line">		for(Map.Entry&lt;String, Thread&gt; me : workers.entrySet())&#123;</span><br><span class="line">			if(me.getValue().getState() != Thread.State.TERMINATED)&#123;</span><br><span class="line">				return false;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		return true;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	//8 计算结果方法</span><br><span class="line">	public int getResult() &#123;</span><br><span class="line">		int priceResult = 0;</span><br><span class="line">		for(Map.Entry&lt;String, Object&gt; me : resultMap.entrySet())&#123;</span><br><span class="line">			priceResult += (Integer)me.getValue();</span><br><span class="line">		&#125;</span><br><span class="line">		return priceResult;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Worker:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">import java.util.concurrent.ConcurrentHashMap;</span><br><span class="line">import java.util.concurrent.ConcurrentLinkedQueue;</span><br><span class="line"></span><br><span class="line">public class Worker implements Runnable &#123;</span><br><span class="line"></span><br><span class="line">	private ConcurrentLinkedQueue&lt;Task&gt; workQueue;</span><br><span class="line">	private ConcurrentHashMap&lt;String, Object&gt; resultMap;</span><br><span class="line"></span><br><span class="line">	public void setWorkQueue(ConcurrentLinkedQueue&lt;Task&gt; workQueue) &#123;</span><br><span class="line">		this.workQueue = workQueue;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public void setResultMap(ConcurrentHashMap&lt;String, Object&gt; resultMap) &#123;</span><br><span class="line">		this.resultMap = resultMap;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public void run() &#123;</span><br><span class="line">		while(true)&#123;</span><br><span class="line">			Task input = this.workQueue.poll();</span><br><span class="line">			if(input == null) break;</span><br><span class="line">			Object output = handle(input);</span><br><span class="line">			this.resultMap.put(Integer.toString(input.getId()), output);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	private Object handle(Task input) &#123;</span><br><span class="line">		Object output = null;</span><br><span class="line">		try &#123;</span><br><span class="line">			//处理任务的耗时。。 比如说进行操作数据库。。。</span><br><span class="line">			Thread.sleep(500);</span><br><span class="line">			output = input.getPrice();</span><br><span class="line">		&#125; catch (InterruptedException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">		return output;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Main:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Random;</span><br><span class="line"></span><br><span class="line">public class Main &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">		Master master = new Master(new Worker(), 20);</span><br><span class="line"></span><br><span class="line">		Random r = new Random();</span><br><span class="line">		for(int i = 1; i &lt;= 100; i++)&#123;</span><br><span class="line">			Task t = new Task();</span><br><span class="line">			t.setId(i);</span><br><span class="line">			t.setPrice(r.nextInt(1000));</span><br><span class="line">			master.submit(t);</span><br><span class="line">		&#125;</span><br><span class="line">		master.execute();</span><br><span class="line">		long start = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">		while(true)&#123;</span><br><span class="line">			if(master.isComplete())&#123;</span><br><span class="line">				long end = System.currentTimeMillis() - start;</span><br><span class="line">				int priceResult = master.getResult();</span><br><span class="line">				System.out.println(&quot;最终结果：&quot; + priceResult + &quot;, 执行时间：&quot; + end);</span><br><span class="line">				break;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="生产者-消费者"><a href="#生产者-消费者" class="headerlink" title="生产者-消费者"></a>生产者-消费者</h4><p>生产者和消费者也是一个非常经典的多线程模式,我们在实际开发中应用非常广泛的思想理念。在生产-消费模式中:通常由两类线程,即若干个生产者的线程和若干个消费者的线程。生产者线程负责提交用户请求,消费者线程则负责具体处理生产者提交的任务,在生产者和消费者之间通过共享内存缓存区进行通信。<br>Data:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">public final class Data &#123;</span><br><span class="line"></span><br><span class="line">	private String id;</span><br><span class="line">	private String name;</span><br><span class="line"></span><br><span class="line">	public Data(String id, String name)&#123;</span><br><span class="line">		this.id = id;</span><br><span class="line">		this.name = name;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public String getId() &#123;</span><br><span class="line">		return id;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public void setId(String id) &#123;</span><br><span class="line">		this.id = id;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public String getName() &#123;</span><br><span class="line">		return name;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public void setName(String name) &#123;</span><br><span class="line">		this.name = name;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public String toString()&#123;</span><br><span class="line">		return &quot;&#123;id: &quot; + id + &quot;, name: &quot; + name + &quot;&#125;&quot;;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Provider:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Random;</span><br><span class="line">import java.util.concurrent.BlockingQueue;</span><br><span class="line">import java.util.concurrent.TimeUnit;</span><br><span class="line">import java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"></span><br><span class="line">public class Provider implements Runnable&#123;</span><br><span class="line"></span><br><span class="line">	//共享缓存区</span><br><span class="line">	private BlockingQueue&lt;Data&gt; queue;</span><br><span class="line">	//多线程间是否启动变量，有强制从主内存中刷新的功能。即时返回线程的状态</span><br><span class="line">	private volatile boolean isRunning = true;</span><br><span class="line">	//id生成器</span><br><span class="line">	private static AtomicInteger count = new AtomicInteger();</span><br><span class="line">	//随机对象</span><br><span class="line">	private static Random r = new Random();</span><br><span class="line"></span><br><span class="line">	public Provider(BlockingQueue queue)&#123;</span><br><span class="line">		this.queue = queue;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public void run() &#123;</span><br><span class="line">		while(isRunning)&#123;</span><br><span class="line">			try &#123;</span><br><span class="line">				//随机休眠0 - 1000 毫秒 表示获取数据(产生数据的耗时)</span><br><span class="line">				Thread.sleep(r.nextInt(1000));</span><br><span class="line">				//获取的数据进行累计...</span><br><span class="line">				int id = count.incrementAndGet();</span><br><span class="line">				//比如通过一个getData方法获取了</span><br><span class="line">				Data data = new Data(Integer.toString(id), &quot;数据&quot; + id);</span><br><span class="line">				System.out.println(&quot;当前线程:&quot; + Thread.currentThread().getName() + &quot;, 获取了数据，id为:&quot; + id + &quot;, 进行装载到公共缓冲区中...&quot;);</span><br><span class="line">				if(!this.queue.offer(data, 2, TimeUnit.SECONDS))&#123;</span><br><span class="line">					System.out.println(&quot;提交缓冲区数据失败....&quot;);</span><br><span class="line">					//do something... 比如重新提交</span><br><span class="line">				&#125;</span><br><span class="line">			&#125; catch (InterruptedException e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public void stop()&#123;</span><br><span class="line">		this.isRunning = false;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Consumer:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public class Consumer implements Runnable&#123;</span><br><span class="line"></span><br><span class="line">	private BlockingQueue&lt;Data&gt; queue;</span><br><span class="line"></span><br><span class="line">	public Consumer(BlockingQueue queue)&#123;</span><br><span class="line">		this.queue = queue;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	//随机对象</span><br><span class="line">	private static Random r = new Random();</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public void run() &#123;</span><br><span class="line">		while(true)&#123;</span><br><span class="line">			try &#123;</span><br><span class="line">				//获取数据</span><br><span class="line">				Data data = this.queue.take();</span><br><span class="line">				//进行数据处理。休眠0 - 1000毫秒模拟耗时</span><br><span class="line">				Thread.sleep(r.nextInt(1000));</span><br><span class="line">				System.out.println(&quot;当前消费线程：&quot; + Thread.currentThread().getName() + &quot;， 消费成功，消费数据为id: &quot; + data.getId());</span><br><span class="line">			&#125; catch (InterruptedException e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Main:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">import java.util.concurrent.BlockingQueue;</span><br><span class="line">import java.util.concurrent.ExecutorService;</span><br><span class="line">import java.util.concurrent.Executors;</span><br><span class="line">import java.util.concurrent.LinkedBlockingQueue;</span><br><span class="line"></span><br><span class="line">public class Main &#123;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) throws Exception &#123;</span><br><span class="line">		//内存缓冲区</span><br><span class="line">		BlockingQueue&lt;Data&gt; queue = new LinkedBlockingQueue&lt;Data&gt;(10);</span><br><span class="line">		//生产者</span><br><span class="line">		Provider p1 = new Provider(queue);</span><br><span class="line"></span><br><span class="line">		Provider p2 = new Provider(queue);</span><br><span class="line">		Provider p3 = new Provider(queue);</span><br><span class="line">		//消费者</span><br><span class="line">		Consumer c1 = new Consumer(queue);</span><br><span class="line">		Consumer c2 = new Consumer(queue);</span><br><span class="line">		Consumer c3 = new Consumer(queue);</span><br><span class="line">		//创建线程池运行,这是一个缓存的线程池，可以创建无穷大的线程，没有任务的时候不创建线程。空闲线程存活时间为60s（默认值）</span><br><span class="line"></span><br><span class="line">		ExecutorService cachePool = Executors.newCachedThreadPool();</span><br><span class="line">		cachePool.execute(p1);</span><br><span class="line">		cachePool.execute(p2);</span><br><span class="line">		cachePool.execute(p3);</span><br><span class="line">		cachePool.execute(c1);</span><br><span class="line">		cachePool.execute(c2);</span><br><span class="line">		cachePool.execute(c3);</span><br><span class="line"></span><br><span class="line">		try &#123;</span><br><span class="line">			Thread.sleep(3000);</span><br><span class="line">		&#125; catch (InterruptedException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">		p1.stop();</span><br><span class="line">		p2.stop();</span><br><span class="line">		p3.stop();</span><br><span class="line">		try &#123;</span><br><span class="line">			Thread.sleep(2000);</span><br><span class="line">		&#125; catch (InterruptedException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">//		cachePool.shutdown();</span><br><span class="line">//		cachePool.shutdownNow();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="Executor框架"><a href="#Executor框架" class="headerlink" title="Executor框架"></a>Executor框架</h4><p>为了更好的控制多线程, JDK提供了一套线程框架Executor,帮助开发人员有效地进行线程控制。它们都在java.util.concurrent包中,是JDK并发包的核心。其中有一个比较重要的类: Executors,他扮演这线程工厂的角色,我们通过Executors可以创建特定功能的线程池。<br>Executors创建线程池方法:<br>newFixedThreadPool)方法,该方法返回一个固定数量的线程池,该方法的线程数始终不变,当有一个任务提交时,若线程池中空闲,则立即执行,若没有,则会被暂缓在一个任务队列中等待有空闲的线程去执行。<br>newSingleThreadExecutor()方法,创建一个线程的线程池,若空闲则执行,若没有空闲线程则暂缓在任务列队中。<br>newCachedThreadPool)方法,返回一个可根据实际情况调整线程个数的线程池,不限制最大线程数量,若有任务,则创建线程,若无任务则不创建线程。如果没有任务则线程在60s后自动回收(空闲时间60s) .<br>newScheduled ThreadPool)方法,该方法返回一个SchededExecutorService对象,但该线程池可以指定线程的数量</p>
<h4 id="自定义线程池"><a href="#自定义线程池" class="headerlink" title="自定义线程池"></a>自定义线程池</h4><p>若Executors工厂类无法满足我们的需求,可以自己去创建自定义的线程池,其实Executors工广类里面的创建线程方法其内部实现均是用了ThreadPoolExecutor这个类,这个类可以自定义线程。构造方法如下:<br>public ThreadPoolExecutor(int corePoolSize,<br>                  int maximumPoolSize，<br>                  long keepAliveTime,<br>                  TimeUnit unit,<br>                  BlockingQueue<runnable> workQueue,<br>                  ThreadFactory ThreadFactory,<br>                  RejectedExecutionHandler handler) {…}</runnable></p>
<p>比如：maximumPoolSize=2，maximumPoolSize=10，ArrayBlockingqueue=10<br>当一次性来了30个任务，放到这个线程池里，肯定会有一堆任务被拒绝，首先，corePoolSize有2个，还有28个任务待处理，我们可以根据上限maximumPoolSize再去提高8个线程去处理，还剩20个，再往队列里扔10个，最后还剩10个，这10个就会去走RejectedExecutionHandler<br>任务过多的时候会导致内存溢出，队列会逐渐变大。</p>
<h4 id="自定义线程池使用详细"><a href="#自定义线程池使用详细" class="headerlink" title="自定义线程池使用详细"></a>自定义线程池使用详细</h4><p>这个构造方法对于队列是什么类型的比较关键:<br>在使用有界队列时: 若有新的任务需要执行,如果线程池实际线程数小于corePoolSize,则优先创建线程,若大于corePoolsize,则会将任务加入队列，若队列已满，<br>则在总线程数不大于maximumPoolSize的前提下创建新的线程，若线程数大于maximumPoolsize,则执行拒绝策略。或其他自定义方式。<br>无界的任务队列时: LinkedBlockingQueue,与有界队列相比,除非系统资源耗尽,否则无界的任务队列<br>不存在任务入队失败的情况。当有新在务到来,系统的线程数小于corePoolsize时,则新建线程执行任务,当达到orePoolSize后,就不会继续增加。若后续仍有新的在务加入,而有没有<br>闲的线程资源，则任务直接进入队列等待。若任务创建和处理的速度差异很大,无界队列会保持快速增长,直到耗尽系统内存。<br>JDK拒绝策略:<br>AbortPolicy:直接抛出异常组织系统正常工作<br>CallerRunsPolicy:只要线程池未关闭,该策略直接在调用者线程中,运行当前被丢弃的任务。<br>DiscardoldestPolicy:丢弃最老的一个请求,尝试再次提交当前任务。<br>DiscardPolicy:丢弃无法处理的任务,不给予任何处理。<br>如果需要自定义拒绝策略可以实现RejectedExecutionHandler接口。</p>

                    
                        

                    
                    
                        <p>
                            <a href="/2019/09/07/多线程3/#post-footer" class="postShorten-excerpt_link link">
                                评论和共享
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a class="link-unstyled" href="/2019/09/07/多线程2/">
                            多线程2
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2019-09-07T10:23:08+08:00">
	
		    9月 07, 2019
    	
    </time>
    
</div>

            </div>
            
                <div class="postShorten-content">
                    <h3 id="线程之间通信"><a href="#线程之间通信" class="headerlink" title="线程之间通信"></a>线程之间通信</h3><p>线程通信概念 线程是操作系统中独立的个体,但这些个体如果不经过特殊的处理就不能成为一个整体,线程间的通信就成为整体的必用方式之一,当线程存在通信指挥,系统间的交互性会更强大,在提高CPU利用率的同时还会使开发人员对线程任务在处理的过程中进行有效的把控与监督.<br>使用wait notily方法实现线程间的通信。 (注意这两个方法都是object的类的方法,换句话说java为所有的对象都提供了这两个方法)<br>1 wait和 notify 必须配合synchronized关键字使用<br>2 wait方法释放锁, notify方法不释放锁.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.List;</span><br><span class="line">/**</span><br><span class="line"> * wait notfiy 方法，wait释放锁，notfiy不释放锁</span><br><span class="line"> */</span><br><span class="line">public class ListAdd2 &#123;</span><br><span class="line">	private volatile static List list = new ArrayList();</span><br><span class="line"></span><br><span class="line">	public void add()&#123;</span><br><span class="line">		list.add(&quot;bjsxt&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	public int size()&#123;</span><br><span class="line">		return list.size();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		final ListAdd2 list2 = new ListAdd2();</span><br><span class="line"></span><br><span class="line">		// 1 实例化出来一个 lock</span><br><span class="line">		// 当使用wait 和 notify 的时候 ， 一定要配合着synchronized关键字去使用</span><br><span class="line">		final Object lock = new Object();</span><br><span class="line">		// final CountDownLatch countDownLatch = new CountDownLatch(1);</span><br><span class="line"></span><br><span class="line">		Thread t1 = new Thread(new Runnable() &#123;</span><br><span class="line">			@Override</span><br><span class="line">			public void run() &#123;</span><br><span class="line">				try &#123;</span><br><span class="line">					synchronized (lock) &#123;</span><br><span class="line">						for(int i = 0; i &lt;10; i++)&#123;</span><br><span class="line">							list2.add();</span><br><span class="line">							System.out.println(&quot;当前线程：&quot; + Thread.currentThread().getName() + &quot;添加了一个元素..&quot;);</span><br><span class="line">							Thread.sleep(500);</span><br><span class="line">							if(list2.size() == 5)&#123;</span><br><span class="line">								System.out.println(&quot;已经发出通知..&quot;);</span><br><span class="line">								//countDownLatch.countDown();</span><br><span class="line">								lock.notify();</span><br><span class="line">							&#125;</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125; catch (InterruptedException e) &#123;</span><br><span class="line">					e.printStackTrace();</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;, &quot;t1&quot;);</span><br><span class="line"></span><br><span class="line">		Thread t2 = new Thread(new Runnable() &#123;</span><br><span class="line">			@Override</span><br><span class="line">			public void run() &#123;</span><br><span class="line">				synchronized (lock) &#123;</span><br><span class="line">					if(list2.size() != 5)&#123;</span><br><span class="line">						try &#123;</span><br><span class="line">							//System.out.println(&quot;t2进入...&quot;);</span><br><span class="line">							lock.wait();</span><br><span class="line">							// countDownLatch.await();</span><br><span class="line">						&#125; catch (InterruptedException e) &#123;</span><br><span class="line">							e.printStackTrace();</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">					System.out.println(&quot;当前线程：&quot; + Thread.currentThread().getName() + &quot;收到通知线程停止..&quot;);</span><br><span class="line">					throw new RuntimeException();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;, &quot;t2&quot;);</span><br><span class="line"></span><br><span class="line">		t2.start();</span><br><span class="line">		t1.start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">当前线程：t1添加了一个元素..</span><br><span class="line">当前线程：t1添加了一个元素..</span><br><span class="line">当前线程：t1添加了一个元素..</span><br><span class="line">当前线程：t1添加了一个元素..</span><br><span class="line">当前线程：t1添加了一个元素..</span><br><span class="line">已经发出通知..</span><br><span class="line">当前线程：t1添加了一个元素..</span><br><span class="line">当前线程：t1添加了一个元素..</span><br><span class="line">当前线程：t1添加了一个元素..</span><br><span class="line">当前线程：t1添加了一个元素..</span><br><span class="line">当前线程：t1添加了一个元素..</span><br><span class="line">当前线程：t2收到通知线程停止..</span><br><span class="line">Exception in thread &quot;t2&quot; java.lang.RuntimeException</span><br><span class="line">	at com.bjsxt.base.conn008.ListAdd2$2.run(ListAdd2.java:65)</span><br><span class="line">	at java.lang.Thread.run(Thread.java:745)</span><br></pre></td></tr></table></figure>
<p>上述方式需要等到notify所在代码全部执行完毕，其它方式CountDownLatch（跟锁没有关系）<br>countdownlatch同样拥有wait和notify功能，对应的是await和countDown,不过它是即时的，不需要等待notify代码块执行完毕后才释放锁，只要执行了notify函数后，其他线程就能拿到锁，不过countdownlatch不具备锁的功能<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.List;</span><br><span class="line">import java.util.concurrent.CountDownLatch;</span><br><span class="line">/**</span><br><span class="line"> * wait notfiy 方法，wait释放锁，notfiy不释放锁</span><br><span class="line"> */</span><br><span class="line">public class ListAdd2 &#123;</span><br><span class="line">	private volatile static List list = new ArrayList();</span><br><span class="line"></span><br><span class="line">	public void add()&#123;</span><br><span class="line">		list.add(&quot;bjsxt&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	public int size()&#123;</span><br><span class="line">		return list.size();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		final ListAdd2 list2 = new ListAdd2();</span><br><span class="line"></span><br><span class="line">		// 1 实例化出来一个 lock</span><br><span class="line">		// 当使用wait 和 notify 的时候 ， 一定要配合着synchronized关键字去使用</span><br><span class="line">		//final Object lock = new Object();</span><br><span class="line"></span><br><span class="line">		final CountDownLatch countDownLatch = new CountDownLatch(1);</span><br><span class="line"></span><br><span class="line">		Thread t1 = new Thread(new Runnable() &#123;</span><br><span class="line">			@Override</span><br><span class="line">			public void run() &#123;</span><br><span class="line">				try &#123;</span><br><span class="line">					//synchronized (lock) &#123;</span><br><span class="line">						for(int i = 0; i &lt;10; i++)&#123;</span><br><span class="line">							list2.add();</span><br><span class="line">							System.out.println(&quot;当前线程：&quot; + Thread.currentThread().getName() + &quot;添加了一个元素..&quot;);</span><br><span class="line">							Thread.sleep(500);</span><br><span class="line">							if(list2.size() == 5)&#123;</span><br><span class="line">								System.out.println(&quot;已经发出通知..&quot;);</span><br><span class="line">								countDownLatch.countDown();</span><br><span class="line">								//lock.notify();</span><br><span class="line">							&#125;</span><br><span class="line">						&#125;</span><br><span class="line">					//&#125;</span><br><span class="line">				&#125; catch (InterruptedException e) &#123;</span><br><span class="line">					e.printStackTrace();</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;, &quot;t1&quot;);</span><br><span class="line"></span><br><span class="line">		Thread t2 = new Thread(new Runnable() &#123;</span><br><span class="line">			@Override</span><br><span class="line">			public void run() &#123;</span><br><span class="line">				//synchronized (lock) &#123;</span><br><span class="line">					if(list2.size() != 5)&#123;</span><br><span class="line">						try &#123;</span><br><span class="line">							//System.out.println(&quot;t2进入...&quot;);</span><br><span class="line">							//lock.wait();</span><br><span class="line">							countDownLatch.await();</span><br><span class="line">						&#125; catch (InterruptedException e) &#123;</span><br><span class="line">							e.printStackTrace();</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">					System.out.println(&quot;当前线程：&quot; + Thread.currentThread().getName() + &quot;收到通知线程停止..&quot;);</span><br><span class="line">					throw new RuntimeException();</span><br><span class="line">				//&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;, &quot;t2&quot;);</span><br><span class="line"></span><br><span class="line">		t2.start();</span><br><span class="line">		t1.start();</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">当前线程：t1添加了一个元素..</span><br><span class="line">当前线程：t1添加了一个元素..</span><br><span class="line">当前线程：t1添加了一个元素..</span><br><span class="line">当前线程：t1添加了一个元素..</span><br><span class="line">当前线程：t1添加了一个元素..</span><br><span class="line">已经发出通知..</span><br><span class="line">Exception in thread &quot;t2&quot; 当前线程：t1添加了一个元素..</span><br><span class="line">当前线程：t2收到通知线程停止..</span><br><span class="line">java.lang.RuntimeException</span><br><span class="line">	at com.bjsxt.base.conn008.ListAdd2$2.run(ListAdd2.java:68)</span><br><span class="line">	at java.lang.Thread.run(Thread.java:745)</span><br><span class="line">当前线程：t1添加了一个元素..</span><br><span class="line">当前线程：t1添加了一个元素..</span><br><span class="line">当前线程：t1添加了一个元素..</span><br><span class="line">当前线程：t1添加了一个元素..</span><br></pre></td></tr></table></figure>
<p>应用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">有一个client去连接zk,去连接的时候需要耗时1~2秒，但是主程序是不阻塞的一直往下走，这就会导致可能返回的zk还没有值，但是主线程已经拿着zk进行操作，就会出现空指针</span><br><span class="line">所以我们需要在主线程countDownLatch.await(),在zk连接成功返回时countDownLatch.countDown()</span><br></pre></td></tr></table></figure></p>
<h3 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h3><p>ThreadLocal概念:线程局部变量,是一种多线程间并发访问变量的解决方案.与其synchronized等加锁的方式不同, ThreadlLocal完全不提供锁,而使用以空问换时间的手段,为每个线程提供变量的独立副本,以保障线程安全<br>从性能上说, ThreadLocal不具有绝对的优势,在并发不是很高的时候,加锁的性能会更好,但作为一套与镇完全无关的线程安全解决方案,在高并发或者竞争激烈的场景,用ThreadLocal可以在一定程度上减少锁竞争。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">public class ConnThreadLocal &#123;</span><br><span class="line">	public static ThreadLocal&lt;String&gt; th = new ThreadLocal&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">	public void setTh(String value)&#123;</span><br><span class="line">		th.set(value);</span><br><span class="line">	&#125;</span><br><span class="line">	public void getTh()&#123;</span><br><span class="line">		System.out.println(Thread.currentThread().getName() + &quot;:&quot; + this.th.get());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">		final ConnThreadLocal ct = new ConnThreadLocal();</span><br><span class="line">		Thread t1 = new Thread(new Runnable() &#123;</span><br><span class="line">			@Override</span><br><span class="line">			public void run() &#123;</span><br><span class="line">				ct.setTh(&quot;张三&quot;);</span><br><span class="line">				ct.getTh();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;, &quot;t1&quot;);</span><br><span class="line"></span><br><span class="line">		Thread t2 = new Thread(new Runnable() &#123;</span><br><span class="line">			@Override</span><br><span class="line">			public void run() &#123;</span><br><span class="line">				try &#123;</span><br><span class="line">					Thread.sleep(1000);</span><br><span class="line">					ct.getTh();</span><br><span class="line">				&#125; catch (InterruptedException e) &#123;</span><br><span class="line">					e.printStackTrace();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;, &quot;t2&quot;);</span><br><span class="line"></span><br><span class="line">		t1.start();</span><br><span class="line">		t2.start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">t1:张三</span><br><span class="line">t2:null</span><br></pre></td></tr></table></figure>

                    
                        

                    
                    
                        <p>
                            <a href="/2019/09/07/多线程2/#post-footer" class="postShorten-excerpt_link link">
                                评论和共享
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a class="link-unstyled" href="/2019/09/07/多线程/">
                            多线程1
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2019-09-07T10:23:08+08:00">
	
		    9月 07, 2019
    	
    </time>
    
</div>

            </div>
            
                <div class="postShorten-content">
                    <h3 id="java多线程基本知识"><a href="#java多线程基本知识" class="headerlink" title="java多线程基本知识"></a>java多线程基本知识</h3><h4 id="进程介绍"><a href="#进程介绍" class="headerlink" title="进程介绍"></a>进程介绍</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">不管是我们开发的应用程序，还是我们运行的其他的应用程序，都需要先把程序安装在本地的硬盘上。然后找到这个程序的启动文件，启动程序的时候，其实是电脑把当前的这个程序加载到内存中，在内存中需要给当前的程序分配一段独立的运行空间。这片空间就专门负责当前这个程序的运行。</span><br><span class="line">不同的应用程序运行的过程中都需要在内存中分配自己独立的运行空间，彼此之间不会相互的影响。我们把每个独立应用程序在内存的独立空间称为当前应用程序运行的一个进程。</span><br><span class="line">进程：它是内存中的一段独立的空间，可以负责当前应用程序的运行。当前这个进程负责调度当前程序中的所有运行细节。</span><br></pre></td></tr></table></figure>
<h4 id="线程介绍"><a href="#线程介绍" class="headerlink" title="线程介绍"></a>线程介绍</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">启动的QQ聊天软件，需要和多个人进行聊天。这时多个人之间是不能相互影响，但是它们都位于当前QQ这个软件运行时所分配的内容的独立空间中。</span><br><span class="line">	在一个进程中，每个独立的功能都需要独立的去运行，这时又需要把当前这个进程划分成多个运行区域，每个独立的小区域（小单元）称为一个线程。</span><br><span class="line">线程：它是位于进程中，负责当前进程中的某个具备独立运行资格的空间。</span><br><span class="line">进程是负责整个程序的运行，而线程是程序中具体的某个独立功能的运行。一个进程中至少应该有一个线程。</span><br></pre></td></tr></table></figure>
<h4 id="多线程介绍"><a href="#多线程介绍" class="headerlink" title="多线程介绍"></a>多线程介绍</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">现在的操作系统基本都是多用户，多任务的操作系统。每个任务就是一个进程。而在这个进程中就会有线程。</span><br><span class="line">真正可以完成程序运行和功能的实现靠的是进程中的线程。</span><br><span class="line">多线程：在一个进程中，我们同时开启多个线程，让多个线程同时去完成某些任务（功能）。</span><br><span class="line">多线程的目的：提高程序的运行效率。</span><br></pre></td></tr></table></figure>
<h4 id="多线程运行的原理"><a href="#多线程运行的原理" class="headerlink" title="多线程运行的原理"></a>多线程运行的原理</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cpu在线程中做时间片的切换。</span><br><span class="line">其实真正电脑中的程序的运行不是同时在运行的。CPU负责程序的运行，而CPU在运行程序的过程中某个时刻点上，它其实只能运行一个程序。而不是多个程序。而CPU它可以在多个程序之间进行高速的切换。而切换频率和速度太快，导致人的肉看看不到。</span><br><span class="line">每个程序就是进程， 而每个进程中会有多个线程，而CPU是在这些线程之间进行切换。</span><br><span class="line">了解了CPU对一个任务的执行过程，我们就必须知道，多线程可以提高程序的运行效率，但不能无限制的开线程。</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">多进程的意义?</span><br><span class="line">	提高CPU的使用率</span><br><span class="line">多线程的意义?</span><br><span class="line">	提高应用程序的使用率</span><br><span class="line"></span><br><span class="line">Java程序的运行原理及JVM的启动是多线程的吗?</span><br><span class="line">		A:Java命令去启动JVM，JVM会启动一个进程，该进程会启动一个主线程。</span><br><span class="line">		B:JVM的启动是多线程的，因为它最低有两个线程启动了，主线程和垃圾回收线程。</span><br></pre></td></tr></table></figure>
<h4 id="实现线程的两种方式"><a href="#实现线程的两种方式" class="headerlink" title="实现线程的两种方式"></a>实现线程的两种方式</h4><p>1、继承Thread的原理<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Random;</span><br><span class="line"></span><br><span class="line">public class MyThreadWithExtends extends Thread &#123;</span><br><span class="line">	String flag;</span><br><span class="line"></span><br><span class="line">	public MyThreadWithExtends(String flag)&#123;</span><br><span class="line">		this.flag = flag;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public void run() &#123;</span><br><span class="line">		String tname = Thread.currentThread().getName();</span><br><span class="line">		System.out.println(tname+&quot;线程的run方法被调用……&quot;);</span><br><span class="line">		Random random = new Random();</span><br><span class="line">		for(int i=0;i&lt;20;i++)&#123;</span><br><span class="line">			try &#123;</span><br><span class="line">				Thread.sleep(random.nextInt(10)*100);</span><br><span class="line">				System.out.println(tname+ &quot;....&quot;+ flag);</span><br><span class="line">			&#125; catch (InterruptedException e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		Thread thread1 = new MyThreadWithExtends(&quot;a&quot;);</span><br><span class="line">		Thread thread2 = new MyThreadWithExtends(&quot;b&quot;);</span><br><span class="line">		thread1.start();</span><br><span class="line">		thread2.start();</span><br><span class="line">		/**</span><br><span class="line">		 * 如果是调用thread的run方法，则只是一个普通的方法调用，不会开启新的线程</span><br><span class="line">		 */</span><br><span class="line">//		thread1.run();</span><br><span class="line">//		thread2.run();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>2、声明实现 Runnable 接口的类<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">public class MyThreadWithImpliment implements Runnable &#123;</span><br><span class="line">	int x;</span><br><span class="line"></span><br><span class="line">	public MyThreadWithImpliment(int x) &#123;</span><br><span class="line">		this.x = x;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public void run() &#123;</span><br><span class="line">		String name = Thread.currentThread().getName();</span><br><span class="line">		System.out.println(&quot;线程&quot; + name + &quot;的run方法被调用……&quot;);</span><br><span class="line">		for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">			System.out.println(x);</span><br><span class="line">			try &#123;</span><br><span class="line">				Thread.sleep(100);</span><br><span class="line"></span><br><span class="line">			&#125; catch (InterruptedException e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		Thread thread1 = new Thread(new MyThreadWithImpliment(1), &quot;thread-1&quot;);</span><br><span class="line">		Thread thread2 = new Thread(new MyThreadWithImpliment(2), &quot;thread-2&quot;);</span><br><span class="line">		 thread1.start();</span><br><span class="line">		 thread2.start();</span><br><span class="line">		// 注意调用run和调用start的区别,直接调用run，则都运行在main线程中</span><br><span class="line">//		thread1.run();</span><br><span class="line">//		thread2.run();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">public class MySynchronized &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		final MySynchronized mySynchronized = new MySynchronized();</span><br><span class="line">		final MySynchronized mySynchronized2 = new MySynchronized();</span><br><span class="line">		new Thread(&quot;thread1&quot;) &#123;</span><br><span class="line">			public void run() &#123;</span><br><span class="line">				synchronized (mySynchronized) &#123;</span><br><span class="line">				try &#123;</span><br><span class="line">					System.out.println(this.getName()+&quot; start&quot;);</span><br><span class="line">					int i =1/0;   //如果发生异常，jvm会将锁释放</span><br><span class="line">					Thread.sleep(5000);</span><br><span class="line">					System.out.println(this.getName()+&quot;醒了&quot;);</span><br><span class="line">					System.out.println(this.getName()+&quot; end&quot;);</span><br><span class="line">				&#125; catch (InterruptedException e) &#123;</span><br><span class="line">					e.printStackTrace();</span><br><span class="line">				&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;.start();</span><br><span class="line">		new Thread(&quot;thread2&quot;) &#123;</span><br><span class="line">			public void run() &#123;</span><br><span class="line">				synchronized (mySynchronized) &#123;         //争抢同一把锁时，线程1没释放之前，线程2只能等待</span><br><span class="line">//					synchronized (mySynchronized2) &#123;    //如果不是一把锁，可以看到两句话同时打印</span><br><span class="line">					System.out.println(this.getName()+&quot; start&quot;);</span><br><span class="line">					System.out.println(this.getName()+&quot; end&quot;);</span><br><span class="line"></span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;.start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="线程的调度和优先级问题"><a href="#线程的调度和优先级问题" class="headerlink" title="线程的调度和优先级问题"></a>线程的调度和优先级问题</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">A:线程的调度</span><br><span class="line">	a:分时调度</span><br><span class="line">	b:抢占式调度 (Java采用的是该调度方式)</span><br><span class="line">B:获取和设置线程优先级</span><br><span class="line">public final int getPriority():返回线程对象的优先级</span><br><span class="line">public final void setPriority(int newPriority)：更改线程的优先级。</span><br><span class="line">	a:默认是5</span><br><span class="line">	b:范围是1-10</span><br></pre></td></tr></table></figure>
<h3 id="线程的控制-常见方法"><a href="#线程的控制-常见方法" class="headerlink" title="线程的控制(常见方法)"></a>线程的控制(常见方法)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public final String getName():获取线程的名称。</span><br><span class="line">public final void setName(String name):设置线程的名称</span><br><span class="line">public static Thread currentThread():返回当前正在执行的线程对象</span><br><span class="line">Thread.currentThread().getName()</span><br><span class="line"></span><br><span class="line">A:休眠线程</span><br><span class="line">	public static void sleep(long millis)  在run方法中调用Thread.sleep()</span><br><span class="line">B:加入线程</span><br><span class="line">	 public final void join():等待该线程终止。</span><br><span class="line">C:礼让线程</span><br><span class="line">	public static void yield():暂停当前正在执行的线程对象，并执行其他线程。在run方法中调用Thread.yield()</span><br><span class="line">D:后台线程</span><br><span class="line">	public final void setDaemon(boolean on):</span><br><span class="line">将该线程标记为守护线程或用户线程。当正在运行的线程都是守护线程时，Java虚拟机退出。该方法必须在启动线程前调用。</span><br><span class="line">E:终止线程(掌握)</span><br><span class="line">public final void stop():让线程停止，太暴力，过时了，但是还可以使用。</span><br><span class="line">public void interrupt():中断线程。 把线程的状态终止，并抛出一个InterruptedException。</span><br></pre></td></tr></table></figure>
<h3 id="线程组"><a href="#线程组" class="headerlink" title="线程组"></a>线程组</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">把多个线程组合到一起。</span><br><span class="line">它可以对一批线程进行分类管理，Java允许程序直接对线程组进行控制。</span><br><span class="line"></span><br><span class="line">线程默认情况下属于main线程组</span><br><span class="line">线程类里面的方法：public final ThreadGroup getThreadGroup()</span><br><span class="line">		  Thread(ThreadGroup group, Runnable target, String name)</span><br><span class="line">线程组里面的方法：public final String getName()</span><br><span class="line">线程组的构造方法：ThreadGroup(String name)</span><br><span class="line">		  ThreadGroup tg = new ThreadGroup(&quot;这是一个新的组&quot;);</span><br><span class="line"></span><br><span class="line">//通过组名称设置后台线程，表示该组的线程都是后台线程</span><br><span class="line">tg.setDaemon(true);</span><br></pre></td></tr></table></figure>
<h3 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">import java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 线程安全概念：当多个线程访问某一个类（对象或方法）时，这个对象始终都能表现出正确的行为，那么这个类（对象或方法）就是线程安全的。</span><br><span class="line"> * synchronized：可以在任意对象及方法上加锁，而加锁的这段代码称为&quot;互斥区&quot;或&quot;临界区&quot;</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class MyThread extends Thread&#123;</span><br><span class="line"></span><br><span class="line">	private int count = 5 ;</span><br><span class="line"></span><br><span class="line">	//synchronized加锁</span><br><span class="line">	public void run()&#123;</span><br><span class="line">		count--;</span><br><span class="line">		System.out.println(this.currentThread().getName() + &quot; count = &quot;+ count);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		/**</span><br><span class="line">		 * 分析：当多个线程访问myThread的run方法时，以排队的方式进行处理（这里排对是按照CPU分配的先后顺序而定的），</span><br><span class="line">		 * 		一个线程想要执行synchronized修饰的方法里的代码：</span><br><span class="line">		 * 		1 尝试获得锁</span><br><span class="line">		 * 		2 如果拿到锁，执行synchronized代码体内容；拿不到锁，这个线程就会不断的尝试获得这把锁，直到拿到为止，</span><br><span class="line">		 * 		   而且是多个线程同时去竞争这把锁。（也就是会有锁竞争的问题）</span><br><span class="line">		 */</span><br><span class="line">		MyThread myThread = new MyThread();</span><br><span class="line">		Thread t1 = new Thread(myThread,&quot;t1&quot;);</span><br><span class="line">		Thread t2 = new Thread(myThread,&quot;t2&quot;);</span><br><span class="line">		Thread t3 = new Thread(myThread,&quot;t3&quot;);</span><br><span class="line">		Thread t4 = new Thread(myThread,&quot;t4&quot;);</span><br><span class="line">		Thread t5 = new Thread(myThread,&quot;t5&quot;);</span><br><span class="line">		t1.start();</span><br><span class="line">		t2.start();</span><br><span class="line">		t3.start();</span><br><span class="line">		t4.start();</span><br><span class="line">		t5.start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">t1 count = 2</span><br><span class="line">t5 count = 0</span><br><span class="line">t4 count = 1</span><br><span class="line">t3 count = 2</span><br><span class="line">t2 count = 2</span><br></pre></td></tr></table></figure>
<h3 id="多个线程多个锁"><a href="#多个线程多个锁" class="headerlink" title="多个线程多个锁"></a>多个线程多个锁</h3><p>多个线程多个锁，多个线程，每个线程都可以拿到自己指定的锁，分别获得锁之后，执行synchronized方法体的内容。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 关键字synchronized取得的锁都是对象锁，而不是把一段代码（方法）当做锁，</span><br><span class="line"> * 所以代码中哪个线程先执行synchronized关键字的方法，哪个线程就持有该方法所属对象的锁（Lock），</span><br><span class="line"> * 两个对象，线程获得的就是两个不同的锁，他们互不影响。</span><br><span class="line"> *</span><br><span class="line"> * 在静态方法上加synchronized关键字，表示锁定.class类，类一级别的锁（独占.class类）。</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class MultiThread &#123;</span><br><span class="line"></span><br><span class="line">	private int num = 0;</span><br><span class="line"></span><br><span class="line">	/** static */</span><br><span class="line">	public synchronized void printNum(String tag)&#123;</span><br><span class="line">		try &#123;</span><br><span class="line"></span><br><span class="line">			if(tag.equals(&quot;a&quot;))&#123;</span><br><span class="line">				num = 100;</span><br><span class="line">				System.out.println(&quot;tag a, set num over!&quot;);</span><br><span class="line">				Thread.sleep(1000);</span><br><span class="line">			&#125; else &#123;</span><br><span class="line">				num = 200;</span><br><span class="line">				System.out.println(&quot;tag b, set num over!&quot;);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			System.out.println(&quot;tag &quot; + tag + &quot;, num = &quot; + num);</span><br><span class="line"></span><br><span class="line">		&#125; catch (InterruptedException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	//注意观察run方法输出顺序</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">		//俩个不同的对象</span><br><span class="line">		final MultiThread m1 = new MultiThread();</span><br><span class="line">		final MultiThread m2 = new MultiThread();</span><br><span class="line"></span><br><span class="line">		Thread t1 = new Thread(new Runnable() &#123;</span><br><span class="line">			@Override</span><br><span class="line">			public void run() &#123;</span><br><span class="line">				m1.printNum(&quot;a&quot;);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line"></span><br><span class="line">		Thread t2 = new Thread(new Runnable() &#123;</span><br><span class="line">			@Override</span><br><span class="line">			public void run() &#123;</span><br><span class="line">				m2.printNum(&quot;b&quot;);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line"></span><br><span class="line">		t1.start();</span><br><span class="line">		t2.start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">tag a, set num over!</span><br><span class="line">tag b, set num over!</span><br><span class="line">tag b, num = 200</span><br><span class="line">tag a, num = 100</span><br></pre></td></tr></table></figure>
<h3 id="对象锁的同步和异步"><a href="#对象锁的同步和异步" class="headerlink" title="对象锁的同步和异步"></a>对象锁的同步和异步</h3><p>同步：synchronized<br>同步的概念就是共享，我们要牢牢记住“共享”这两个字，如果不是共享的资源，就没有必要进行同步。<br>异步：asynchronized<br>异步的概念就是独立，相互之间不受任何制约。就好像我们学习http的时候，在页面发起的ajax请求，我们还可以继续浏览<br>或操作页面的内容，二者之间没有任何关系。<br>同步的目的就是为了线程安全，其实对于线程安全来说，需要猫满足两个特性。<br>原子性（同步）<br>可见性<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 对象锁的同步和异步问题</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class MyObject &#123;</span><br><span class="line">	public synchronized void method1()&#123;</span><br><span class="line">		try &#123;</span><br><span class="line">			System.out.println(Thread.currentThread().getName());</span><br><span class="line">			Thread.sleep(4000);</span><br><span class="line">		&#125; catch (InterruptedException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/** synchronized */</span><br><span class="line">	public void method2()&#123;</span><br><span class="line">			System.out.println(Thread.currentThread().getName());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		final MyObject mo = new MyObject();</span><br><span class="line"></span><br><span class="line">		/**</span><br><span class="line">		 * 分析：</span><br><span class="line">		 * t1线程先持有object对象的Lock锁，t2线程可以以异步的方式调用对象中的非synchronized修饰的方法</span><br><span class="line">		 * t1线程先持有object对象的Lock锁，t2线程如果在这个时候调用对象中的同步（synchronized）方法则需等待，也就是同步</span><br><span class="line">		 */</span><br><span class="line">		Thread t1 = new Thread(new Runnable() &#123;</span><br><span class="line">			@Override</span><br><span class="line">			public void run() &#123;</span><br><span class="line">				mo.method1();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;,&quot;t1&quot;);</span><br><span class="line"></span><br><span class="line">		Thread t2 = new Thread(new Runnable() &#123;</span><br><span class="line">			@Override</span><br><span class="line">			public void run() &#123;</span><br><span class="line">				mo.method2();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;,&quot;t2&quot;);</span><br><span class="line"></span><br><span class="line">		t1.start();</span><br><span class="line">		t2.start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">t1</span><br><span class="line">t2 （立即打印）</span><br></pre></td></tr></table></figure>
<h3 id="脏读"><a href="#脏读" class="headerlink" title="脏读"></a>脏读</h3><p>对于对象的同步和异步的方法,我们在设计自己的程序的时候,一定要考虑问题的整体,不然就会出现数据不一致的错误,很经典的错误藏是讲读(dirtyread)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 在我们对一个对象的方法加锁的时候,需要考虑业务的整体性,即为setValueigetvalue方法同时加链synchronized同步关键字,</span><br><span class="line"> * 保证业务(service)的原子性,不然会出现业务错误(也从侧面保证业务的一致性) .</span><br><span class="line"> */</span><br><span class="line">public class DirtyRead &#123;</span><br><span class="line">	private String username = &quot;bjsxt&quot;;</span><br><span class="line">	private String password = &quot;123&quot;;</span><br><span class="line"></span><br><span class="line">	public synchronized void setValue(String username, String password)&#123;</span><br><span class="line">		this.username = username;</span><br><span class="line"></span><br><span class="line">		try &#123;</span><br><span class="line">			Thread.sleep(2000);</span><br><span class="line">		&#125; catch (InterruptedException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		this.password = password;</span><br><span class="line">		System.out.println(&quot;setValue最终结果：username = &quot; + username + &quot; , password = &quot; + password);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public void getValue()&#123;</span><br><span class="line">		System.out.println(&quot;getValue方法得到：username = &quot; + this.username + &quot; , password = &quot; + this.password);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) throws Exception&#123;</span><br><span class="line">		final DirtyRead dr = new DirtyRead();</span><br><span class="line">		Thread t1 = new Thread(new Runnable() &#123;</span><br><span class="line">			@Override</span><br><span class="line">			public void run() &#123;</span><br><span class="line">				dr.setValue(&quot;z3&quot;, &quot;456&quot;);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line">		t1.start();</span><br><span class="line">		Thread.sleep(1000);</span><br><span class="line"></span><br><span class="line">		dr.getValue();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">getValue方法得到：username = z3 , password = 123</span><br><span class="line">setValue最终结果：username = z3 , password = 456</span><br></pre></td></tr></table></figure>
<h3 id="synchronized锁重入"><a href="#synchronized锁重入" class="headerlink" title="synchronized锁重入:"></a>synchronized锁重入:</h3><p>关键字synchronized拥有锁重入的功能,也就是在使用synchronized时,当一个线程得到了一个对象的锁后,<br>再次请求此对象时是可以再次得到该对象的锁。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * synchronized的重入</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class SyncDubbo1 &#123;</span><br><span class="line">	public synchronized void method1()&#123;</span><br><span class="line">		System.out.println(&quot;method1..&quot;);</span><br><span class="line">		method2();</span><br><span class="line">	&#125;</span><br><span class="line">	public synchronized void method2()&#123;</span><br><span class="line">		System.out.println(&quot;method2..&quot;);</span><br><span class="line">		method3();</span><br><span class="line">	&#125;</span><br><span class="line">	public synchronized void method3()&#123;</span><br><span class="line">		System.out.println(&quot;method3..&quot;);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		final SyncDubbo1 sd = new SyncDubbo1();</span><br><span class="line">		Thread t1 = new Thread(new Runnable() &#123;</span><br><span class="line">			@Override</span><br><span class="line">			public void run() &#123;</span><br><span class="line">				sd.method1();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line">		t1.start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * synchronized的重入</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class SyncDubbo2 &#123;</span><br><span class="line">	static class Main &#123;</span><br><span class="line">		public int i = 10;</span><br><span class="line">		public synchronized void operationSup()&#123;</span><br><span class="line">			try &#123;</span><br><span class="line">				i--;</span><br><span class="line">				System.out.println(&quot;Main print i = &quot; + i);</span><br><span class="line">				Thread.sleep(100);</span><br><span class="line">			&#125; catch (InterruptedException e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	static class Sub extends Main &#123;</span><br><span class="line">		public synchronized void operationSub()&#123;</span><br><span class="line">			try &#123;</span><br><span class="line">				while(i &gt; 0) &#123;</span><br><span class="line">					i--;</span><br><span class="line">					System.out.println(&quot;Sub print i = &quot; + i);</span><br><span class="line">					Thread.sleep(100);</span><br><span class="line">					this.operationSup();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125; catch (InterruptedException e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		Thread t1 = new Thread(new Runnable() &#123;</span><br><span class="line">			@Override</span><br><span class="line">			public void run() &#123;</span><br><span class="line">				Sub sub = new Sub();</span><br><span class="line">				sub.operationSub();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line">		t1.start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于web应用程序,异常释放锁的情况,如果不及时处理,很可能对你的应用程序业务逻辑产生严重的错误,<br>比如你现在执行一个队列任务,很多对象都去在等特第一个对象正确执行完毕再去释放锁,但是第一个对象由于异常的出现,<br>导致业务逻辑没有正常执行完毕,就释放了锁,那么可把而知后续的对象执行的都是错误的逻钱.<br>所以这一点一定要引起注意,在编写代码的时候,一定要考虑剧全.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * synchronized异常</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class SyncException &#123;</span><br><span class="line">	private int i = 0;</span><br><span class="line">	public synchronized void operation()&#123;</span><br><span class="line">		while(true)&#123;</span><br><span class="line">			try &#123;</span><br><span class="line">				i++;</span><br><span class="line">				Thread.sleep(100);</span><br><span class="line">				System.out.println(Thread.currentThread().getName() + &quot; , i = &quot; + i);</span><br><span class="line">				if(i == 20)&#123;</span><br><span class="line">					//Integer.parseInt(&quot;a&quot;);</span><br><span class="line">					throw new RuntimeException();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125; catch (InterruptedException e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		final SyncException se = new SyncException();</span><br><span class="line">		Thread t1 = new Thread(new Runnable() &#123;</span><br><span class="line">			@Override</span><br><span class="line">			public void run() &#123;</span><br><span class="line">				se.operation();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;,&quot;t1&quot;);</span><br><span class="line">		t1.start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="synchronized代码块"><a href="#synchronized代码块" class="headerlink" title="synchronized代码块"></a>synchronized代码块</h3><p>使用syhchronized声明的方法在某些情况下是有弊端的,比如A线程调用同步的方法执行一个很长时间的任务,<br>那么B找程就必须等待比较长的时间才能执行,这样的情况下可以使用synchronized代码块去优化代码执行时间,<br>也就是通常所说的减小锁的粒度。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 使用synchronized代码块减小锁的粒度，提高性能</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class Optimize &#123;</span><br><span class="line">	public void doLongTimeTask()&#123;</span><br><span class="line">		try &#123;</span><br><span class="line">			System.out.println(&quot;当前线程开始：&quot; + Thread.currentThread().getName() +</span><br><span class="line">					&quot;, 正在执行一个较长时间的业务操作，其内容不需要同步&quot;);</span><br><span class="line">			Thread.sleep(2000);</span><br><span class="line"></span><br><span class="line">			synchronized(this)&#123;</span><br><span class="line">				System.out.println(&quot;当前线程：&quot; + Thread.currentThread().getName() +</span><br><span class="line">					&quot;, 执行同步代码块，对其同步变量进行操作&quot;);</span><br><span class="line">				Thread.sleep(1000);</span><br><span class="line">			&#125;</span><br><span class="line">			System.out.println(&quot;当前线程结束：&quot; + Thread.currentThread().getName() +</span><br><span class="line">					&quot;, 执行完毕&quot;);</span><br><span class="line"></span><br><span class="line">		&#125; catch (InterruptedException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		final Optimize otz = new Optimize();</span><br><span class="line">		Thread t1 = new Thread(new Runnable() &#123;</span><br><span class="line">			@Override</span><br><span class="line">			public void run() &#123;</span><br><span class="line">				otz.doLongTimeTask();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;,&quot;t1&quot;);</span><br><span class="line">		Thread t2 = new Thread(new Runnable() &#123;</span><br><span class="line">			@Override</span><br><span class="line">			public void run() &#123;</span><br><span class="line">				otz.doLongTimeTask();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;,&quot;t2&quot;);</span><br><span class="line">		t1.start();</span><br><span class="line">		t2.start();</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>synchronized可以使用任意的Object进行加锁,用法比较灵活.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 使用synchronized代码块加锁,比较灵活</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class ObjectLock &#123;</span><br><span class="line">	public void method1()&#123;</span><br><span class="line">		synchronized (this) &#123;	//对象锁</span><br><span class="line">			try &#123;</span><br><span class="line">				System.out.println(&quot;do method1..&quot;);</span><br><span class="line">				Thread.sleep(2000);</span><br><span class="line">			&#125; catch (InterruptedException e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public void method2()&#123;		//类锁</span><br><span class="line">		synchronized (ObjectLock.class) &#123;</span><br><span class="line">			try &#123;</span><br><span class="line">				System.out.println(&quot;do method2..&quot;);</span><br><span class="line">				Thread.sleep(2000);</span><br><span class="line">			&#125; catch (InterruptedException e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	private Object lock = new Object();</span><br><span class="line">	public void method3()&#123;		//任何对象锁</span><br><span class="line">		synchronized (lock) &#123;</span><br><span class="line">			try &#123;</span><br><span class="line">				System.out.println(&quot;do method3..&quot;);</span><br><span class="line">				Thread.sleep(2000);</span><br><span class="line">			&#125; catch (InterruptedException e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		final ObjectLock objLock = new ObjectLock();</span><br><span class="line">		Thread t1 = new Thread(new Runnable() &#123;</span><br><span class="line">			@Override</span><br><span class="line">			public void run() &#123;</span><br><span class="line">				objLock.method1();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line">		Thread t2 = new Thread(new Runnable() &#123;</span><br><span class="line">			@Override</span><br><span class="line">			public void run() &#123;</span><br><span class="line">				objLock.method2();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line">		Thread t3 = new Thread(new Runnable() &#123;</span><br><span class="line">			@Override</span><br><span class="line">			public void run() &#123;</span><br><span class="line">				objLock.method3();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line"></span><br><span class="line">		t1.start();</span><br><span class="line">		t2.start();</span><br><span class="line">		t3.start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>另外特别注意一个问题,就是不要使用String的常量加锁,会出现死循环问题<br>因为在JVM中具有String常量池(如果两个String具有相同的值，那么他们的地址是相同的，都保存在这个常量池中)。<br>当以String作为锁的时候，如果值相同则，那么线程持有相同的锁。这样就造成了另外一个线程不能执行</p>
<p>锁对象的改变问题,当使用一个对象进行加锁的时候,<br>要注意对象本身发生改变的时候那么持有的镜就不同,如果对象本身不发生改变,那么依然是同步的,即使是对象的属性发生了改变。</p>
<p>死锁问题<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 死锁问题，在设计程序时就应该避免双方相互持有对方的锁的情况</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class DeadLock implements Runnable&#123;</span><br><span class="line">	private String tag;</span><br><span class="line">	private static Object lock1 = new Object();</span><br><span class="line">	private static Object lock2 = new Object();</span><br><span class="line"></span><br><span class="line">	public void setTag(String tag)&#123;</span><br><span class="line">		this.tag = tag;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public void run() &#123;</span><br><span class="line">		if(tag.equals(&quot;a&quot;))&#123;</span><br><span class="line">			synchronized (lock1) &#123;</span><br><span class="line">				try &#123;</span><br><span class="line">					System.out.println(&quot;当前线程 : &quot;  + Thread.currentThread().getName() + &quot; 进入lock1执行&quot;);</span><br><span class="line">					Thread.sleep(2000);</span><br><span class="line">				&#125; catch (InterruptedException e) &#123;</span><br><span class="line">					e.printStackTrace();</span><br><span class="line">				&#125;</span><br><span class="line">				synchronized (lock2) &#123;</span><br><span class="line">					System.out.println(&quot;当前线程 : &quot;  + Thread.currentThread().getName() + &quot; 进入lock2执行&quot;);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		if(tag.equals(&quot;b&quot;))&#123;</span><br><span class="line">			synchronized (lock2) &#123;</span><br><span class="line">				try &#123;</span><br><span class="line">					System.out.println(&quot;当前线程 : &quot;  + Thread.currentThread().getName() + &quot; 进入lock2执行&quot;);</span><br><span class="line">					Thread.sleep(2000);</span><br><span class="line">				&#125; catch (InterruptedException e) &#123;</span><br><span class="line">					e.printStackTrace();</span><br><span class="line">				&#125;</span><br><span class="line">				synchronized (lock1) &#123;</span><br><span class="line">					System.out.println(&quot;当前线程 : &quot;  + Thread.currentThread().getName() + &quot; 进入lock1执行&quot;);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		DeadLock d1 = new DeadLock();</span><br><span class="line">		d1.setTag(&quot;a&quot;);</span><br><span class="line">		DeadLock d2 = new DeadLock();</span><br><span class="line">		d2.setTag(&quot;b&quot;);</span><br><span class="line"></span><br><span class="line">		Thread t1 = new Thread(d1, &quot;t1&quot;);</span><br><span class="line">		Thread t2 = new Thread(d2, &quot;t2&quot;);</span><br><span class="line"></span><br><span class="line">		t1.start();</span><br><span class="line">		try &#123;</span><br><span class="line">			Thread.sleep(500);</span><br><span class="line">		&#125; catch (InterruptedException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">		t2.start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="synchronized的缺陷"><a href="#synchronized的缺陷" class="headerlink" title="synchronized的缺陷"></a>synchronized的缺陷</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">synchronized是java中的一个关键字，也就是说是Java语言内置的特性。</span><br><span class="line">如果一个代码块被synchronized修饰了，当一个线程获取了对应的锁，并执行该代码块时，其他线程便只能一直等待，等待获取锁的线程释放锁，而这里获取锁的线程释放锁只会有两种情况：</span><br><span class="line">1）获取锁的线程执行完了该代码块，然后线程释放对锁的占有；</span><br><span class="line">2）线程执行发生异常，此时JVM会让线程自动释放锁。</span><br><span class="line"></span><br><span class="line">例子1：</span><br><span class="line">　　如果这个获取锁的线程由于要等待IO或者其他原因（比如调用sleep方法）被阻塞了，但是又没有释放锁，其他线程便只能干巴巴地等待，试想一下，这多么影响程序执行效率。</span><br><span class="line">　　因此就需要有一种机制可以不让等待的线程一直无期限地等待下去（比如只等待一定的时间或者能够响应中断），通过Lock就可以办到。</span><br><span class="line">例子2：</span><br><span class="line">当有多个线程读写文件时，读操作和写操作会发生冲突现象，写操作和写操作会发生冲突现象，但是读操作和读操作不会发生冲突现象。</span><br><span class="line">　　但是采用synchronized关键字来实现同步的话，就会导致一个问题：</span><br><span class="line">如果多个线程都只是进行读操作，当一个线程在进行读操作时，其他线程只能等待无法进行读操作。</span><br><span class="line"></span><br><span class="line">因此就需要一种机制来使得多个线程都只是进行读操作时，线程之间不会发生冲突，通过Lock就可以办到。</span><br><span class="line">另外，通过Lock可以知道线程有没有成功获取到锁。这个是synchronized无法办到的。</span><br><span class="line">总的来说，也就是说Lock提供了比synchronized更多的功能。</span><br></pre></td></tr></table></figure>
<h3 id="lock"><a href="#lock" class="headerlink" title="lock"></a>lock</h3><h4 id="lock和synchronized的区别"><a href="#lock和synchronized的区别" class="headerlink" title="lock和synchronized的区别"></a>lock和synchronized的区别</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1）Lock不是Java语言内置的，synchronized是Java语言的关键字，因此是内置特性。Lock是一个类，通过这个类可以实现同步访问；</span><br><span class="line">2）Lock和synchronized有一点非常大的不同，采用synchronized不需要用户去手动释放锁，当synchronized方法或者synchronized代码块执行完之后，系统会自动让线程释放对锁的占用；而Lock则必须要用户去手动释放锁，如果没有主动释放锁，就有可能导致出现死锁现象。</span><br></pre></td></tr></table></figure>
<h4 id="lock-1"><a href="#lock-1" class="headerlink" title="lock"></a>lock</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public interface Lock &#123;</span><br><span class="line">    void lock();</span><br><span class="line">    void lockInterruptibly() throws InterruptedException;</span><br><span class="line">    boolean tryLock();</span><br><span class="line">    boolean tryLock(long time, TimeUnit unit) throws InterruptedException;</span><br><span class="line">    void unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Lock接口中每个方法的使用：<br>lock()、tryLock()、tryLock(long time, TimeUnit unit)、lockInterruptibly()是用来获取锁的。unLock()方法是用来释放锁的。<br>四个获取锁方法的区别：<br>lock()方法是平常使用得最多的一个方法，就是用来获取锁。如果锁已被其他线程获取，则进行等待。<br>由于在前面讲到如果采用Lock，必须主动去释放锁，并且在发生异常时，不会自动释放锁。因此一般来说，使用Lock必须在try{}catch{}块中进行，并且将释放锁的操作放在finally块中进行，以保证锁一定被被释放，防止死锁的发生。<br>tryLock()方法是有返回值的，它表示用来尝试获取锁，如果获取成功，则返回true，如果获取失败（即锁已被其他线程获取），则返回false，也就说这个方法无论如何都会立即返回。在拿不到锁时不会一直在那等待。<br>tryLock(long time, TimeUnit unit)方法和tryLock()方法是类似的，只不过区别在于这个方法在拿不到锁时会等待一定的时间，在时间期限之内如果还拿不到锁，就返回false。如果如果一开始拿到锁或者在等待期间内拿到了锁，则返回true。<br>lockInterruptibly()方法比较特殊，当通过这个方法去获取锁时，如果线程正在等待获取锁，则这个线程能够响应中断，即中断线程的等待状态。也就使说，当两个线程同时通过lock.lockInterruptibly()想获取某个锁时，假若此时线程A获取到了锁，而线程B只有在等待，那么对线程B调用threadB.interrupt()方法能够中断线程B的等待过程。<br>注意，当一个线程获取了锁之后，是不会被interrupt()方法中断的。<br>因此当通过lockInterruptibly()方法获取某个锁时，如果不能获取到，只有进行等待的情况下，是可以响应中断的。<br>而用synchronized修饰的话，当一个线程处于等待某个锁的状态，是无法被中断的，只有一直等待下去。</p>
<h4 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h4><p>直接使用lock接口的话，我们需要实现很多方法，不太方便，ReentrantLock是唯一实现了Lock接口的类，并且ReentrantLock提供了更多的方法，ReentrantLock，意思是“可重入锁”。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.concurrent.locks.Lock;</span><br><span class="line">import java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line">public class MyLockTest &#123;</span><br><span class="line">	private static ArrayList&lt;Integer&gt; arrayList = new ArrayList&lt;Integer&gt;();</span><br><span class="line">	static Lock lock = new ReentrantLock(); // 注意这个地方</span><br><span class="line">	public static &lt;E&gt; void main(String[] args) &#123;</span><br><span class="line">		new Thread() &#123;</span><br><span class="line">			public void run() &#123;</span><br><span class="line">				Thread thread = Thread.currentThread();</span><br><span class="line"></span><br><span class="line">				lock.lock();</span><br><span class="line">				try &#123;</span><br><span class="line">					System.out.println(thread.getName() + &quot;得到了锁&quot;);</span><br><span class="line">					for (int i = 0; i &lt; 5; i++) &#123;</span><br><span class="line">						arrayList.add(i);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125; catch (Exception e) &#123;</span><br><span class="line">					// TODO: handle exception</span><br><span class="line">				&#125; finally &#123;</span><br><span class="line">					System.out.println(thread.getName() + &quot;释放了锁&quot;);</span><br><span class="line">					lock.unlock();</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">			&#125;;</span><br><span class="line">		&#125;.start();</span><br><span class="line"></span><br><span class="line">		new Thread() &#123;</span><br><span class="line">			public void run() &#123;</span><br><span class="line">				Thread thread = Thread.currentThread();</span><br><span class="line">				lock.lock();</span><br><span class="line">				try &#123;</span><br><span class="line">					System.out.println(thread.getName() + &quot;得到了锁&quot;);</span><br><span class="line">					for (int i = 0; i &lt; 5; i++) &#123;</span><br><span class="line">						arrayList.add(i);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125; catch (Exception e) &#123;</span><br><span class="line">					// TODO: handle exception</span><br><span class="line">				&#125; finally &#123;</span><br><span class="line">					System.out.println(thread.getName() + &quot;释放了锁&quot;);</span><br><span class="line">					lock.unlock();</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">			&#125;;</span><br><span class="line">		&#125;.start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.concurrent.locks.Lock;</span><br><span class="line">import java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 观察现象：一个线程获得锁后，另一个线程取不到锁，不会一直等待</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class MyTryLock &#123;</span><br><span class="line">	private static ArrayList&lt;Integer&gt; arrayList = new ArrayList&lt;Integer&gt;();</span><br><span class="line">	static Lock lock = new ReentrantLock(); // 注意这个地方</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">		new Thread() &#123;</span><br><span class="line">			public void run() &#123;</span><br><span class="line">				Thread thread = Thread.currentThread();</span><br><span class="line">				boolean tryLock = lock.tryLock();</span><br><span class="line">				System.out.println(thread.getName()+&quot; &quot;+tryLock);</span><br><span class="line">				if (tryLock) &#123;</span><br><span class="line">					try &#123;</span><br><span class="line">						System.out.println(thread.getName() + &quot;得到了锁&quot;);</span><br><span class="line">						for (int i = 0; i &lt; 5; i++) &#123;</span><br><span class="line">							arrayList.add(i);</span><br><span class="line">						&#125;</span><br><span class="line">					&#125; catch (Exception e) &#123;</span><br><span class="line">						// TODO: handle exception</span><br><span class="line">					&#125; finally &#123;</span><br><span class="line">						System.out.println(thread.getName() + &quot;释放了锁&quot;);</span><br><span class="line">						lock.unlock();</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;;</span><br><span class="line">		&#125;.start();</span><br><span class="line"></span><br><span class="line">		new Thread() &#123;</span><br><span class="line">			public void run() &#123;</span><br><span class="line">				Thread thread = Thread.currentThread();</span><br><span class="line">				boolean tryLock = lock.tryLock();</span><br><span class="line">				System.out.println(thread.getName()+&quot; &quot;+tryLock);</span><br><span class="line">				if (tryLock) &#123;</span><br><span class="line">					try &#123;</span><br><span class="line">						System.out.println(thread.getName() + &quot;得到了锁&quot;);</span><br><span class="line">						for (int i = 0; i &lt; 5; i++) &#123;</span><br><span class="line">							arrayList.add(i);</span><br><span class="line">						&#125;</span><br><span class="line">					&#125; catch (Exception e) &#123;</span><br><span class="line">						// TODO: handle exception</span><br><span class="line">					&#125; finally &#123;</span><br><span class="line">						System.out.println(thread.getName() + &quot;释放了锁&quot;);</span><br><span class="line">						lock.unlock();</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">			&#125;;</span><br><span class="line">		&#125;.start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">import java.util.concurrent.locks.Lock;</span><br><span class="line">import java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 观察现象：如果thread-0得到了锁，阻塞。。。thread-1尝试获取锁，如果拿不到，则可以被中断等待</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class MyInterruptibly &#123;</span><br><span class="line">	 private Lock lock = new ReentrantLock();</span><br><span class="line">	    public static void main(String[] args)  &#123;</span><br><span class="line">	    	MyInterruptibly test = new MyInterruptibly();</span><br><span class="line">	        MyThread thread0 = new MyThread(test);</span><br><span class="line">	        MyThread thread1 = new MyThread(test);</span><br><span class="line">	        thread0.start();</span><br><span class="line">	        thread1.start();</span><br><span class="line"></span><br><span class="line">	        try &#123;</span><br><span class="line">	            Thread.sleep(2000);</span><br><span class="line">	        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">	            e.printStackTrace();</span><br><span class="line">	        &#125;</span><br><span class="line">	        thread1.interrupt();</span><br><span class="line">	        System.out.println(&quot;=====================&quot;);</span><br><span class="line">	    &#125;</span><br><span class="line"></span><br><span class="line">	    public void insert(Thread thread) throws InterruptedException&#123;</span><br><span class="line">	        lock.lockInterruptibly();   //注意，如果需要正确中断等待锁的线程，必须将获取锁放在外面，然后将InterruptedException抛出</span><br><span class="line">	        try &#123;</span><br><span class="line">	            System.out.println(thread.getName()+&quot;得到了锁&quot;);</span><br><span class="line">	            long startTime = System.currentTimeMillis();</span><br><span class="line">	            for(    ;     ;) &#123;</span><br><span class="line">	                if(System.currentTimeMillis() - startTime &gt;= Integer.MAX_VALUE)</span><br><span class="line">	                    break;</span><br><span class="line">	                //插入数据</span><br><span class="line">	            &#125;</span><br><span class="line">	        &#125;</span><br><span class="line">	        finally &#123;</span><br><span class="line">	            System.out.println(Thread.currentThread().getName()+&quot;执行finally&quot;);</span><br><span class="line">	            lock.unlock();</span><br><span class="line">	            System.out.println(thread.getName()+&quot;释放了锁&quot;);</span><br><span class="line">	        &#125;</span><br><span class="line">	    &#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	class MyThread extends Thread &#123;</span><br><span class="line">	    private MyInterruptibly test = null;</span><br><span class="line">	    public MyThread(MyInterruptibly test) &#123;</span><br><span class="line">	        this.test = test;</span><br><span class="line">	    &#125;</span><br><span class="line">	    @Override</span><br><span class="line">	    public void run() &#123;</span><br><span class="line"></span><br><span class="line">	        try &#123;</span><br><span class="line">	            test.insert(Thread.currentThread());</span><br><span class="line">	        &#125; catch (Exception e) &#123;</span><br><span class="line">	            System.out.println(Thread.currentThread().getName()+&quot;被中断&quot;);</span><br><span class="line">	        &#125;</span><br><span class="line">	    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="ReadWriteLock"><a href="#ReadWriteLock" class="headerlink" title="ReadWriteLock"></a>ReadWriteLock</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public interface ReadWriteLock &#123;</span><br><span class="line">    /**</span><br><span class="line">     * Returns the lock used for reading.</span><br><span class="line">     *</span><br><span class="line">     * @return the lock used for reading.</span><br><span class="line">     */</span><br><span class="line">    Lock readLock();</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Returns the lock used for writing.</span><br><span class="line">     *</span><br><span class="line">     * @return the lock used for writing.</span><br><span class="line">     */</span><br><span class="line">    Lock writeLock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一个用来获取读锁，一个用来获取写锁。也就是说将文件的读写操作分开，分成2个锁来分配给线程，从而使得多个线程可以同时进行读操作。下面的ReentrantReadWriteLock实现了ReadWriteLock接口。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 一个线程又要读又要写，用synchronize来实现的话，读写操作都只能锁住后一个线程一个线程地进行</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class MySynchronizedReadWrite &#123;</span><br><span class="line">    public static void main(String[] args)  &#123;</span><br><span class="line">        final MySynchronizedReadWrite test = new MySynchronizedReadWrite();</span><br><span class="line"></span><br><span class="line">        new Thread()&#123;</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                test.get(Thread.currentThread());</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;.start();</span><br><span class="line"></span><br><span class="line">        new Thread()&#123;</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                test.get(Thread.currentThread());</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;.start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public synchronized void get(Thread thread) &#123;</span><br><span class="line">        long start = System.currentTimeMillis();</span><br><span class="line">        int i=0;</span><br><span class="line">        while(System.currentTimeMillis() - start &lt;= 1) &#123;</span><br><span class="line">        	i++;</span><br><span class="line">        	if(i%4==0)&#123;</span><br><span class="line">            System.out.println(thread.getName()+&quot;正在进行写操作&quot;);</span><br><span class="line">        	&#125;else &#123;</span><br><span class="line">        		System.out.println(thread.getName()+&quot;正在进行读操作&quot;);</span><br><span class="line">			&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(thread.getName()+&quot;读写操作完毕&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">import java.util.concurrent.locks.ReentrantReadWriteLock;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 使用读写锁，可以实现读写分离锁定，读操作并发进行，写操作锁定单个线程</span><br><span class="line"> *</span><br><span class="line"> * 如果有一个线程已经占用了读锁，则此时其他线程如果要申请写锁，则申请写锁的线程会一直等待释放读锁。</span><br><span class="line"> * 如果有一个线程已经占用了写锁，则此时其他线程如果申请写锁或者读锁，则申请的线程会一直等待释放写锁。</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class MyReentrantReadWriteLock &#123;</span><br><span class="line">	 private ReentrantReadWriteLock rwl = new ReentrantReadWriteLock();</span><br><span class="line"></span><br><span class="line">	    public static void main(String[] args)  &#123;</span><br><span class="line">	        final MyReentrantReadWriteLock test = new MyReentrantReadWriteLock();</span><br><span class="line"></span><br><span class="line">	        new Thread()&#123;</span><br><span class="line">	            public void run() &#123;</span><br><span class="line">	                test.get(Thread.currentThread());</span><br><span class="line">	                test.write(Thread.currentThread());</span><br><span class="line">	            &#125;;</span><br><span class="line">	        &#125;.start();</span><br><span class="line"></span><br><span class="line">	        new Thread()&#123;</span><br><span class="line">	            public void run() &#123;</span><br><span class="line">	                test.get(Thread.currentThread());</span><br><span class="line">	                test.write(Thread.currentThread());</span><br><span class="line">	            &#125;;</span><br><span class="line">	        &#125;.start();</span><br><span class="line"></span><br><span class="line">	    &#125;</span><br><span class="line"></span><br><span class="line">	    /**</span><br><span class="line">	     * 读操作,用读锁来锁定</span><br><span class="line">	     * @param thread</span><br><span class="line">	     */</span><br><span class="line">	    public void get(Thread thread) &#123;</span><br><span class="line">	        rwl.readLock().lock();</span><br><span class="line">	        try &#123;</span><br><span class="line">	            long start = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">	            while(System.currentTimeMillis() - start &lt;= 1) &#123;</span><br><span class="line">	                System.out.println(thread.getName()+&quot;正在进行读操作&quot;);</span><br><span class="line">	            &#125;</span><br><span class="line">	            System.out.println(thread.getName()+&quot;读操作完毕&quot;);</span><br><span class="line">	        &#125; finally &#123;</span><br><span class="line">	            rwl.readLock().unlock();</span><br><span class="line">	        &#125;</span><br><span class="line">	    &#125;</span><br><span class="line"></span><br><span class="line">	    /**</span><br><span class="line">	     * 写操作，用写锁来锁定</span><br><span class="line">	     * @param thread</span><br><span class="line">	     */</span><br><span class="line">	    public void write(Thread thread) &#123;</span><br><span class="line">	        rwl.writeLock().lock();;</span><br><span class="line">	        try &#123;</span><br><span class="line">	            long start = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">	            while(System.currentTimeMillis() - start &lt;= 1) &#123;</span><br><span class="line">	                System.out.println(thread.getName()+&quot;正在进行写操作&quot;);</span><br><span class="line">	            &#125;</span><br><span class="line">	            System.out.println(thread.getName()+&quot;写操作完毕&quot;);</span><br><span class="line">	        &#125; finally &#123;</span><br><span class="line">	            rwl.writeLock().unlock();</span><br><span class="line">	        &#125;</span><br><span class="line">	    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意：<br>不过要注意的是，如果有一个线程已经占用了读锁，则此时其他线程如果要申请写锁，则申请写锁的线程会一直等待释放读锁。<br>如果有一个线程已经占用了写锁，则此时其他线程如果申请写锁或者读锁，则申请的线程会一直等待释放写锁。</p>
<h4 id="Lock和synchronized的选择"><a href="#Lock和synchronized的选择" class="headerlink" title="Lock和synchronized的选择"></a>Lock和synchronized的选择</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1）Lock是一个接口，而synchronized是Java中的关键字，synchronized是内置的语言实现；</span><br><span class="line">2）synchronized在发生异常时，会自动释放线程占有的锁，因此不会导致死锁现象发生；而Lock在发生异常时，如果没有主动通过unLock()去释放锁，则很可能造成死锁现象，因此使用Lock时需要在finally块中释放锁；</span><br><span class="line">3）Lock可以让等待锁的线程响应中断，而synchronized却不行，使用synchronized时，等待的线程会一直等待下去，不能够响应中断；</span><br><span class="line">4）通过Lock可以知道有没有成功获取锁，而synchronized却无法办到。</span><br><span class="line">5）Lock可以提高多个线程进行读操作的效率。</span><br><span class="line">在性能上来说，如果竞争资源不激烈，两者的性能是差不多的，而当竞争资源非常激烈时（即有大量线程同时竞争），此时Lock的性能要远远优于synchronized。所以说，在具体使用时要根据适当情况选择。</span><br></pre></td></tr></table></figure>
<h3 id="volatile关键字的概念"><a href="#volatile关键字的概念" class="headerlink" title="volatile关键字的概念"></a>volatile关键字的概念</h3><p>volatile 概念: atile关键字的主要作用是使变量在多个线程同可见.<br>在java中,每一个线程都会有一块工作内存区,其中存放着所有线程共享的主内存中的变量值的拷贝。当线程执行时,他在自己的工作内存区中操作这些变量,为了存取一个共享的变量,一个线程通常先获取镇定并去清除它的内存工作区,把这些共享变量从所有线程的共享内存区中正确的装入到他自己所在的工作内存区中,当线程解锁时保证该工作内存区中变量的值写回到共享内存中.<br>一个线程可以执行的操作有使用(use) 、赋值(assign) 、装载(load)、存储(store) 、锁定(lock) 、解镇(unlock) .<br>而主内存可以执行的操作有读(read)、写(wrte) 、锁定(lock)、解镇(unlock) ,每个操作都是原子的。<br>volatile作用就是强制线程到主内存(共享内存)里去读取变量,而不去线程工作内存区里去读取,从而实现了多个线程间的变量可见。也就是满足线程安全的可见性。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public class RunThread extends Thread&#123;</span><br><span class="line">	private volatile boolean isRunning = true;</span><br><span class="line">	private void setRunning(boolean isRunning)&#123;</span><br><span class="line">		this.isRunning = isRunning;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public void run()&#123;</span><br><span class="line">		System.out.println(&quot;进入run方法..&quot;);</span><br><span class="line">		int i = 0;</span><br><span class="line">		while(isRunning == true)&#123;</span><br><span class="line">			//..</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(&quot;线程停止&quot;);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">		RunThread rt = new RunThread();</span><br><span class="line">		rt.start();</span><br><span class="line">		Thread.sleep(1000);</span><br><span class="line">		rt.setRunning(false);</span><br><span class="line">		System.out.println(&quot;isRunning的值已经被设置了false&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">进入run方法..</span><br><span class="line">isRunning的值已经被设置了false</span><br><span class="line">线程停止</span><br></pre></td></tr></table></figure>
<p>不加volatile<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">进入run方法..</span><br><span class="line">isRunning的值已经被设置了false</span><br></pre></td></tr></table></figure></p>
<p><img src="volatile关键字.jpg" alt="1"></p>
<h3 id="volatile关键字的非原子性"><a href="#volatile关键字的非原子性" class="headerlink" title="volatile关键字的非原子性"></a>volatile关键字的非原子性</h3><p>volatile关键字虽然拥有多个线程之间的可见性,但是却不具备同步性(也就是原子性) ,可以算上是一个轻量级的synchronized,性能要比synchronized强很多,不会造成阻塞<br>(在很多开源的架构里,比如netty的底层代码就大量使用volatile, 可见netty性能一定是非常不错的。)<br>这里需要注意:一般volatile用于只针对于多个线程可见的变量操作,并不能代替synchronized的同步功能.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">import java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * volatile关键字不具备synchronized关键字的原子性（同步）</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class VolatileNoAtomic extends Thread&#123;</span><br><span class="line">	private static volatile int count;</span><br><span class="line">	//private static AtomicInteger count = new AtomicInteger(0);</span><br><span class="line">	private static void addCount()&#123;</span><br><span class="line">		for (int i = 0; i &lt; 1000; i++) &#123;</span><br><span class="line">			count++ ;</span><br><span class="line">			// count.incrementAndGet();</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(count);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public void run()&#123;</span><br><span class="line">		addCount();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">		VolatileNoAtomic[] arr = new VolatileNoAtomic[100];</span><br><span class="line">		for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">			arr[i] = new VolatileNoAtomic();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">			arr[i].start();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1948</span><br><span class="line">3948</span><br><span class="line">2948</span><br><span class="line">1948</span><br><span class="line">5315</span><br><span class="line">6039</span><br><span class="line">6401</span><br><span class="line">7401</span><br><span class="line">8401</span><br><span class="line">9401</span><br></pre></td></tr></table></figure>
<p>AtomicInteger<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">2000</span><br><span class="line">2000</span><br><span class="line">3419</span><br><span class="line">4672</span><br><span class="line">5000</span><br><span class="line">6000</span><br><span class="line">7000</span><br><span class="line">9000</span><br><span class="line">8000</span><br><span class="line">10000</span><br></pre></td></tr></table></figure></p>
<p>volatie关键字只具有可见性,没有原子性,要实现原子性建议使用atomic类的系列对象,<br>支持原子性操作(注童atomic类只保证本身方法原子性,并不保证多次操作的原子性)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.List;</span><br><span class="line">import java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"></span><br><span class="line">public class AtomicUse &#123;</span><br><span class="line">	private static AtomicInteger count = new AtomicInteger(0);</span><br><span class="line"></span><br><span class="line">	//多个addAndGet在一个方法内是非原子性的，需要加synchronized进行修饰，保证4个addAndGet整体原子性</span><br><span class="line">	/**synchronized*/</span><br><span class="line">	public synchronized int multiAdd()&#123;</span><br><span class="line">			try &#123;</span><br><span class="line">				Thread.sleep(100);</span><br><span class="line">			&#125; catch (InterruptedException e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">			count.addAndGet(1);</span><br><span class="line">			count.addAndGet(2);</span><br><span class="line">			count.addAndGet(3);</span><br><span class="line">			count.addAndGet(4); //+10</span><br><span class="line">			return count.get();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		final AtomicUse au = new AtomicUse();</span><br><span class="line"></span><br><span class="line">		List&lt;Thread&gt; ts = new ArrayList&lt;Thread&gt;();</span><br><span class="line">		for (int i = 0; i &lt; 100; i++) &#123;</span><br><span class="line">			ts.add(new Thread(new Runnable() &#123;</span><br><span class="line">				@Override</span><br><span class="line">				public void run() &#123;</span><br><span class="line">					System.out.println(au.multiAdd());</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;));</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		for(Thread t : ts)&#123;</span><br><span class="line">			t.start();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

                    
                        

                    
                    
                        <p>
                            <a href="/2019/09/07/多线程/#post-footer" class="postShorten-excerpt_link link">
                                评论和共享
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    <div class="pagination-bar">
    <ul class="pagination">
        
          <li class="pagination-prev">
            <a class="btn btn--default btn--small" href="/archives/">
              <i class="fa fa-angle-left text-base icon-mr"></i>
              <span>上一页</span>
            </a>
          </li>
        
        
          <li class="pagination-next">
            <a class="btn btn--default btn--small" href="/archives/page/3/">
              <span>下一页</span>
              <i class="fa fa-angle-right text-base icon-ml"></i>
            </a>
          </li>
        
        <li class="pagination-number">第 2 页 共 6 页</li>
    </ul>
</div>

</section>



                <footer id="footer" class="main-content-wrap">
    <span class="copyrights">
        Copyrights &copy; 2019 Brotherc. All Rights Reserved.
    </span>
</footer>

            </div>
            
        </div>
        


    
        
    

<div id="about">
    <div id="about-card">
        <div id="about-btn-close">
            <i class="fa fa-times"></i>
        </div>
        
            <img id="about-card-picture" src="/assets/images/head.jpg" alt="作者的图片">
        
            <h4 id="about-card-name">Brotherc</h4>
        
            <div id="about-card-bio"><p>java development</p>
</div>
        
        
            <div id="about-card-job">
                <i class="fa fa-briefcase"></i>
                <br>
                <p>java</p>

            </div>
        
        
            <div id="about-card-location">
                <i class="fa fa-map-marker-alt"></i>
                <br>
                zhuhai
            </div>
        
    </div>
</div>

        
        
<div id="cover" style="background-image:url('/assets/images/cover.jpg');"></div>
        <!--SCRIPTS-->
<script src="/assets/js/script-dbd16rvloemmuxdzniplmnxxvwoz24eya9wol0b7vvmlokgqsjivmb8dnscy.min.js"></script>
<!--SCRIPTS END-->



    </body>
</html>
