
<!DOCTYPE html>
<html lang="zh-cn">
    
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="generator" content="Brotherc">
    <title>归档 - Brotherc</title>
    <meta name="author" content="Brotherc">
    
    
    
    <script type="application/ld+json">{}</script>
    <meta property="og:type" content="blog">
<meta property="og:title" content="Brotherc">
<meta property="og:url" content="http://yoursite.com/archives/page/6/index.html">
<meta property="og:site_name" content="Brotherc">
<meta property="og:locale" content="zh-cn">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Brotherc">
    
    
        
    
    
        <meta property="og:image" content="http://yoursite.com/assets/images/head.jpg"/>
    
    
    
    
    <!--STYLES-->
    <link rel="stylesheet" href="/assets/css/style-c4ozcsklz4kht2pebhp44xorvyverh23toayhn7i6ubrpyedak24hv1v0hyd.min.css">
    <!--STYLES END-->
    

    
</head>

    <body>
        <div id="blog">
            <!-- Define author's picture -->


    
        
            
        
    

<header id="header" data-behavior="1">
    <i id="btn-open-sidebar" class="fa fa-lg fa-bars"></i>
    <div class="header-title">
        <a class="header-title-link" href="/ ">Brotherc</a>
    </div>
    
        
            <a class="header-right-picture " href="#about">
        
        
            <img class="header-picture" src="/assets/images/head.jpg" alt="作者的图片">
        
        </a>
    
</header>

            <!-- Define author's picture -->



        
    

<nav id="sidebar" data-behavior="1">
    <div class="sidebar-container">
        
            <div class="sidebar-profile">
                <a href="/#about">
                    <img class="sidebar-profile-picture" src="/assets/images/head.jpg" alt="作者的图片">
                </a>
                <h4 class="sidebar-profile-name">Brotherc</h4>
                
                    <h5 class="sidebar-profile-bio"><p>java development</p>
</h5>
                
            </div>
        
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a class="sidebar-button-link " href="/ " title="首页">
                    
                        <i class="sidebar-button-icon fa fa-home" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">首页</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a class="sidebar-button-link " href="/all-categories" title="分类">
                    
                        <i class="sidebar-button-icon fa fa-bookmark" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">分类</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a class="sidebar-button-link " href="/all-tags" title="标签">
                    
                        <i class="sidebar-button-icon fa fa-tags" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">标签</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a class="sidebar-button-link open-algolia-search" href="/all-archives" title="归档">
                    
                        <i class="sidebar-button-icon fa fa-archive" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">归档</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a class="sidebar-button-link " href="#about" title="关于">
                    
                        <i class="sidebar-button-icon fa fa-question" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">关于</span>
                    </a>
            </li>
            
        </ul>
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a class="sidebar-button-link " href="https://github.com/Brotherc" target="_blank" rel="noopener" title="GitHub">
                    
                        <i class="sidebar-button-icon fab fa-github" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">GitHub</span>
                    </a>
            </li>
            
        </ul>
        
    </div>
</nav>

            
            <div id="main" data-behavior="1"
                 class="
                        hasCoverMetaIn
                        ">
                
    <section class="postShorten-group main-content-wrap">
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a class="link-unstyled" href="/2019/09/07/集合/">
                            集合
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2019-09-07T10:23:08+08:00">
	
		    9月 07, 2019
    	
    </time>
    
</div>

            </div>
            
                <div class="postShorten-content">
                    <h3 id="集合和数组的区别"><a href="#集合和数组的区别" class="headerlink" title="集合和数组的区别?"></a>集合和数组的区别?</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">A:长度区别</span><br><span class="line">	数组固定</span><br><span class="line">	集合可变</span><br><span class="line">B:内容区别</span><br><span class="line">	数组可以是基本类型，也可以是引用类型</span><br><span class="line">	集合只能是引用类型</span><br><span class="line">C:元素内容</span><br><span class="line">	数组只能存储同一种类型</span><br><span class="line">	集合可以存储不同类型(其实集合一般存储的也是同一种类型)</span><br></pre></td></tr></table></figure>
<h3 id="集合的继承体系结构"><a href="#集合的继承体系结构" class="headerlink" title="集合的继承体系结构"></a>集合的继承体系结构</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">由于需求不同，Java就提供了不同的集合类。这多个集合类的数据结构不同，但是它们都是要提供存储和遍历功能的，</span><br><span class="line">我们把它们的共性不断的向上提取，最终就形成了集合的继承体系结构图。</span><br><span class="line">		Collection</span><br><span class="line">			|--List</span><br><span class="line">				|--ArrayList</span><br><span class="line">				|--Vector</span><br><span class="line">				|--LinkedList</span><br><span class="line">			|--Set</span><br><span class="line">				|--HashSet</span><br><span class="line">				|--TreeSet</span><br></pre></td></tr></table></figure>
<h3 id="Collection接口"><a href="#Collection接口" class="headerlink" title="Collection接口"></a>Collection接口</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">Collection 层次结构中的根接口。Collection 表示一组对象，这些对象也称为  collection 的元素。一些 collection 允许有重复的元素，而另一些则不允许。一些   collection 是有序的，而另一些则是无序的。</span><br><span class="line">Collection接口成员方法</span><br><span class="line">	A:添加功能</span><br><span class="line">		boolean add(E e)</span><br><span class="line">		boolean addAll(collection c)</span><br><span class="line">	B:删除功能</span><br><span class="line">		boolean remove(Object o)</span><br><span class="line">		boolean removeAll(collection c)只要有一个元素被删除就返回true</span><br><span class="line">		void clear()</span><br><span class="line">	C:判断功能</span><br><span class="line">		boolean contains(Object o)</span><br><span class="line">		boolean containsAll(Collection c)只有包含所有的元素才叫包含</span><br><span class="line">	D:获取功能</span><br><span class="line">		boolean isEmpty()</span><br><span class="line">	E:长度功能</span><br><span class="line">		int size()</span><br><span class="line">	F:交集</span><br><span class="line">		boolean retainAll(Collection c)</span><br><span class="line">		假设有两个集合A,B</span><br><span class="line">		A对B做交集，最终的结果保存在A中，B不变</span><br><span class="line">		返回值表示的是A是否发生改变</span><br><span class="line">	H:Collection集合的遍历</span><br><span class="line">		A:把集合转数组</span><br><span class="line">			Object[] toArray()</span><br><span class="line">		B:迭代器(集合专用方式)</span><br><span class="line">			Iterator iterator()</span><br></pre></td></tr></table></figure>
<h3 id="Iterator接口"><a href="#Iterator接口" class="headerlink" title="Iterator接口"></a>Iterator接口</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">对 collection 进行迭代的迭代器</span><br><span class="line">		A:是集合的获取元素的方式。</span><br><span class="line">		B:是依赖于集合而存在的。</span><br><span class="line">		C:迭代器的原理和源码。</span><br><span class="line">			a:为什么定义为了一个接口而不是实现类?</span><br><span class="line">			b:看了看迭代器的内部类实现。</span><br><span class="line">Iterator接口成员方法</span><br><span class="line">boolean hasNext()如果还有元素可以迭代，则返回true</span><br><span class="line">E next() 获取元素，并返回到下一个位置</span><br></pre></td></tr></table></figure>
<h3 id="List接口"><a href="#List接口" class="headerlink" title="List接口"></a>List接口</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">(1)List是Collection的子接口</span><br><span class="line">	特点：有序(存储顺序和取出顺序一致)，可重复。</span><br><span class="line">(2)List的特有功能：(自己补齐)</span><br><span class="line">	A:添加功能     void add(int index,E element)</span><br><span class="line">	B:删除功能     E remove(int index)</span><br><span class="line">	C:获取功能     E get(int index)</span><br><span class="line">	D:迭代器功能   ListIterator listIterator()</span><br><span class="line">	E:修改功能     E set(int index,E element)</span><br><span class="line">(3)List集合的特有遍历功能</span><br><span class="line">	A:由size()和get()结合。</span><br><span class="line">	B:代码演示</span><br><span class="line">			//创建集合对象</span><br><span class="line">			List list = new ArrayList();</span><br><span class="line"></span><br><span class="line">			//创建并添加元素</span><br><span class="line">			list.add(&quot;hello&quot;);</span><br><span class="line">			list.add(&quot;world&quot;);</span><br><span class="line">			list.add(&quot;java&quot;);</span><br><span class="line"></span><br><span class="line">			//遍历集合</span><br><span class="line">			Iterator it = list.iterator();</span><br><span class="line">			while(it.hasNext()) &#123;</span><br><span class="line">				String s =(String) it.next();</span><br><span class="line">				System.out.println(s);</span><br><span class="line">			&#125;</span><br><span class="line">			System.out.println(&quot;----------&quot;);</span><br><span class="line"></span><br><span class="line">			for(int x=0; x&lt;list.size(); x++) &#123;</span><br><span class="line">				String s =(String) list.get(x);</span><br><span class="line">				System.out.println(s);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">(4)ListIterator接口的成员方法</span><br><span class="line">boolean hasPrevious()</span><br><span class="line">E previous()</span><br><span class="line"></span><br><span class="line">		可以逆向遍历，但是要先正向遍历，所以无意义，基本不使用。</span><br><span class="line">（5)并发修改异常</span><br><span class="line">ConcurrentModificationException</span><br><span class="line">当方法检测到对象的并发修改，但不允许这种修改时，抛出此异常</span><br><span class="line">		A:出现的现象</span><br><span class="line">			迭代器遍历集合，集合修改集合元素</span><br><span class="line">		B:原因</span><br><span class="line">			迭代器是依赖于集合的，而集合的改变迭代器并不知道。</span><br><span class="line">		C:解决方案</span><br><span class="line">			a:迭代器遍历，迭代器修改(ListIterator)</span><br><span class="line">				元素添加在刚才迭代的位置</span><br><span class="line">			b:集合遍历，集合修改(size()和get())</span><br><span class="line">				元素添加在集合的末尾</span><br><span class="line">(6)常见数据结构</span><br><span class="line">	A:栈 先进后出</span><br><span class="line">	B:队列 先进先出</span><br><span class="line">	C:数组 查询快，增删慢</span><br><span class="line">	D:链表 查询慢，增删快</span><br><span class="line">(7)List的子类特点(面试题)</span><br><span class="line">	ArrayList</span><br><span class="line">		底层数据结构是数组，查询快，增删慢。</span><br><span class="line">		线程不安全，效率高。</span><br><span class="line">	Vector</span><br><span class="line">		底层数据结构是数组，查询快，增删慢。</span><br><span class="line">		线程安全，效率低。</span><br><span class="line">	LinkedList</span><br><span class="line">		底层数据结构是链表，查询慢，增删快。</span><br><span class="line">		线程不安全，效率高。</span><br><span class="line"></span><br><span class="line">	到底使用谁呢?看需求?</span><br><span class="line">	分析：</span><br><span class="line">		要安全吗?</span><br><span class="line">			要：Vector(即使要，也不使用这个，后面再说)</span><br><span class="line">			不要：ArrayList或者LinkedList</span><br><span class="line">				查询多；ArrayList</span><br><span class="line">				增删多：LinkedList</span><br><span class="line"></span><br><span class="line">	什么都不知道，就用ArrayList。</span><br></pre></td></tr></table></figure>
<p>Vector:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Vector类特有功能</span><br><span class="line">public void addElement(E obj) --	add()</span><br><span class="line">public E elementAt(int index) --	get()</span><br><span class="line">public E numeration elements() --  iterator()</span><br></pre></td></tr></table></figure></p>
<p>LinkedList:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">LinkedList类特有功能</span><br><span class="line">public void addFirst(E e) 及 addLast(E e)</span><br><span class="line">public E getFirst()       及 getLast()</span><br><span class="line">public E removeFirst()    及 public E removeLast()</span><br></pre></td></tr></table></figure></p>
<h3 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h3><p>泛型类<br>格式:public class 类名&lt;泛型类型1,…&gt;<br>注意:泛型类型必须是引用类型<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * 泛型类：把泛型定义在类上</span><br><span class="line"> */</span><br><span class="line">public class ObjectTool&lt;T&gt; &#123;</span><br><span class="line">	private T obj;</span><br><span class="line"></span><br><span class="line">	public T getObj() &#123;</span><br><span class="line">		return obj;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public void setObj(T obj) &#123;</span><br><span class="line">		this.obj = obj;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * 泛型类的测试</span><br><span class="line"> */</span><br><span class="line">public class ObjectToolDemo &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">		ObjectTool&lt;String&gt; ot = new ObjectTool&lt;String&gt;();</span><br><span class="line">		ot.setObj(new String(&quot;林青霞&quot;));</span><br><span class="line">		String s = ot.getObj();</span><br><span class="line">		System.out.println(&quot;姓名是：&quot; + s);</span><br><span class="line"></span><br><span class="line">		ObjectTool&lt;Integer&gt; ot2 = new ObjectTool&lt;Integer&gt;();</span><br><span class="line">		ot2.setObj(new Integer(27));</span><br><span class="line">		Integer i = ot2.getObj();</span><br><span class="line">		System.out.println(&quot;年龄是：&quot; + i);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>泛型方法<br>格式:public &lt;泛型类型&gt; 返回类型 方法名(泛型类型 .)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * 泛型方法：把泛型定义在方法上</span><br><span class="line"> */</span><br><span class="line">public class ObjectTool &#123;</span><br><span class="line">	public &lt;T&gt; void show(T t) &#123;</span><br><span class="line">		System.out.println(t);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class ObjectToolDemo &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		ObjectTool ot = new ObjectTool();</span><br><span class="line">		ot.show(&quot;hello&quot;);</span><br><span class="line">		ot.show(100);</span><br><span class="line">		ot.show(true);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>泛型接口<br>格式:public  interface 接口名&lt;泛型类型1…&gt;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * 泛型接口：把泛型定义在接口上</span><br><span class="line"> */</span><br><span class="line">public interface Inter&lt;T&gt; &#123;</span><br><span class="line">	public abstract void show(T t);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class InterImpl&lt;T&gt; implements Inter&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public void show(T t) &#123;</span><br><span class="line">		System.out.println(t);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class InterDemo &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">		Inter&lt;String&gt; i = new InterImpl&lt;String&gt;();</span><br><span class="line">		i.show(&quot;hello&quot;);</span><br><span class="line"></span><br><span class="line">		Inter&lt;Integer&gt; ii = new InterImpl&lt;Integer&gt;();</span><br><span class="line">		ii.show(100);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="泛型高级-通配符"><a href="#泛型高级-通配符" class="headerlink" title="泛型高级(通配符)"></a>泛型高级(通配符)</h3><p>泛型通配符<br>&lt;?&gt;<br>任意类型，如果没有明确，那么就是Object以及任意的Java类了<br>? extends E<br>向下限定，E及其子类<br>? super E<br>向上限定，E及其父类<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Animal &#123;&#125;</span><br><span class="line">class Dog extends Animal &#123;&#125;</span><br><span class="line">class Cat extends Animal &#123;&#125;</span><br><span class="line">public class CollectionDemo &#123;</span><br><span class="line">  public static void main(String[] args) &#123;</span><br><span class="line">    Collection&lt;?&gt; c1 = new ArrayList&lt;Animal&gt;();</span><br><span class="line">    Collection&lt;?&gt; c2 = new ArrayList&lt;Dog&gt;();</span><br><span class="line">    Collection&lt;?&gt; c3 = new ArrayList&lt;Cat&gt;();</span><br><span class="line">    Collection&lt;?&gt; c4 = new ArrayList&lt;Object&gt;();</span><br><span class="line"></span><br><span class="line">    Collection&lt;? extends Animal&gt; c5 = new ArrayList&lt;Animal&gt;();</span><br><span class="line">    Collection&lt;? extends Animal&gt; c6 = new ArrayList&lt;Dog&gt;();</span><br><span class="line">    Collection&lt;? extends Animal&gt; c7 = new ArrayList&lt;Cat&gt;();</span><br><span class="line">    // Collection&lt;? extends Animal&gt; c8 = new ArrayList&lt;Object&gt;();</span><br><span class="line"></span><br><span class="line">    Collection&lt;? super Animal&gt; c9 = new ArrayList&lt;Animal&gt;();</span><br><span class="line">    // Collection&lt;? super Animal&gt; c10 = new ArrayList&lt;Dog&gt;();</span><br><span class="line">    // Collection&lt;? super Animal&gt; c11 = new ArrayList&lt;Cat&gt;();</span><br><span class="line">    Collection&lt;? super Animal&gt; c12 = new ArrayList&lt;Object&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

                    
                        

                    
                    
                        <p>
                            <a href="/2019/09/07/集合/#post-footer" class="postShorten-excerpt_link link">
                                评论和共享
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a class="link-unstyled" href="/2019/09/07/多线程3/">
                            多线程3
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2019-09-07T10:23:08+08:00">
	
		    9月 07, 2019
    	
    </time>
    
</div>

            </div>
            
                <div class="postShorten-content">
                    <h3 id="java并发包介绍"><a href="#java并发包介绍" class="headerlink" title="java并发包介绍"></a>java并发包介绍</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">JDK5.0 以后的版本都引入了高级并发特性，大多数的特性在java.util.concurrent 包中，是专门用于多线程发编程的，充分利用了现代多处理器和多核心系统的功能以编写大规模并发应用程序。</span><br><span class="line">主要包含原子量、并发集合、同步器、可重入锁，并对线程池的构造提供了强力的支持。</span><br></pre></td></tr></table></figure>
<h4 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h4><p>1、Single Thread Executor : 只有一个线程的线程池，因此所有提交的任务是顺序执行，<br>Executors.newSingleThreadExecutor()</p>
<p>2、Cached Thread Pool : 线程池里有很多线程需要同时执行，老的可用线程将被新的任务触发重新执行，如果线程超过60秒内没执行，那么将被终止并从池中删除，<br>Executors.newCachedThreadPool()</p>
<p>3、Fixed Thread Pool : 拥有固定线程数的线程池，如果没有任务执行，那么线程会一直等待，<br>Executors.newFixedThreadPool(4)<br>在构造函数中的参数4是线程池的大小，你可以随意设置，也可以和cpu的数量保持一致，获取cpu的数量int cpuNums = Runtime.getRuntime().availableProcessors();</p>
<p>4、Scheduled Thread Pool : 用来调度即将执行的任务的线程池，<br>Executors.newScheduledThreadPool()</p>
<p>5、Single Thread Scheduled Pool : 只有一个线程，用来调度执行将来的任务，<br>Executors.newSingleThreadScheduledExecutor()</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">import java.util.concurrent.ExecutorService;</span><br><span class="line">import java.util.concurrent.Executors;</span><br><span class="line">import java.util.concurrent.ScheduledExecutorService;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 列出并发包中的各种线程池</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">public class ExecutorDemo &#123;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		ExecutorService newSingleThreadExecutor = Executors.newSingleThreadExecutor();</span><br><span class="line">		ExecutorService newCachedThreadPool = Executors.newCachedThreadPool();</span><br><span class="line"></span><br><span class="line">		int cpuNums = Runtime.getRuntime().availableProcessors();</span><br><span class="line">		System.out.println(cpuNums);</span><br><span class="line">		ExecutorService newFixedThreadPool = Executors.newFixedThreadPool(cpuNums);</span><br><span class="line">		ScheduledExecutorService newScheduledThreadPool = Executors.newScheduledThreadPool(8);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		ScheduledExecutorService newSingleThreadScheduledExecutor = Executors.newSingleThreadScheduledExecutor();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>提交 Runnable ，任务完成后 Future 对象返回 null<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">import java.util.concurrent.ExecutorService;</span><br><span class="line">import java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line">public class ThreadPoolWithRunable &#123;</span><br><span class="line">	/**</span><br><span class="line">	 * 通过线程池执行线程</span><br><span class="line">	 * @param args</span><br><span class="line">	 */</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		//创建一个线程池</span><br><span class="line">		ExecutorService pool = Executors.newCachedThreadPool();</span><br><span class="line">		for(int i = 1; i &lt; 5; i++)&#123;</span><br><span class="line">			pool.execute(new Runnable() &#123;</span><br><span class="line">				@Override</span><br><span class="line">				public void run() &#123;</span><br><span class="line">					System.out.println(&quot;thread name: &quot; + Thread.currentThread().getName());</span><br><span class="line">					try &#123;</span><br><span class="line">						Thread.sleep(1000);</span><br><span class="line">					&#125; catch (InterruptedException e) &#123;</span><br><span class="line">						e.printStackTrace();</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;);</span><br><span class="line">		&#125;</span><br><span class="line">		pool.shutdown();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>提交 Callable，该方法返回一个 Future 实例表示任务的状态<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.List;</span><br><span class="line">import java.util.concurrent.Callable;</span><br><span class="line">import java.util.concurrent.ExecutionException;</span><br><span class="line">import java.util.concurrent.ExecutorService;</span><br><span class="line">import java.util.concurrent.Executors;</span><br><span class="line">import java.util.concurrent.Future;</span><br><span class="line">/**</span><br><span class="line"> * callable 跟runnable的区别：</span><br><span class="line"> * runnable的run方法不会有任何返回结果，所以主线程无法获得任务线程的返回值</span><br><span class="line"> *</span><br><span class="line"> * callable的call方法可以返回结果，但是主线程在获取时是被阻塞，需要等待任务线程返回才能拿到结果</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class ThreadPoolWithcallable &#123;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) throws InterruptedException, ExecutionException &#123;</span><br><span class="line">		ExecutorService pool = Executors.newFixedThreadPool(4);</span><br><span class="line"></span><br><span class="line">		for(int i = 0; i &lt; 10; i++)&#123;</span><br><span class="line">			Future&lt;String&gt; submit = pool.submit(new Callable&lt;String&gt;()&#123;</span><br><span class="line">				@Override</span><br><span class="line">				public String call() throws Exception &#123;</span><br><span class="line">					//System.out.println(&quot;a&quot;);</span><br><span class="line">					Thread.sleep(5000);</span><br><span class="line">					return &quot;b--&quot;+Thread.currentThread().getName();</span><br><span class="line">				&#125;</span><br><span class="line">			   &#125;);</span><br><span class="line">			//从Future中get结果，这个方法是会被阻塞的，一直要等到线程任务返回结果</span><br><span class="line">			System.out.println(submit.get());</span><br><span class="line">		&#125;</span><br><span class="line">			pool.shutdown();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Random;</span><br><span class="line">import java.util.concurrent.Callable;</span><br><span class="line"></span><br><span class="line">public class TaskCallable implements Callable&lt;String&gt;&#123;</span><br><span class="line"></span><br><span class="line">	private int s;</span><br><span class="line">	Random r = new Random();</span><br><span class="line">	public TaskCallable(int s)&#123;</span><br><span class="line">		this.s = s;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public String call() throws Exception &#123;</span><br><span class="line">		String name = Thread.currentThread().getName();</span><br><span class="line">		long currentTimeMillis = System.currentTimeMillis();</span><br><span class="line">		System.out.println(name+&quot; 启动时间：&quot; + currentTimeMillis/1000);</span><br><span class="line"></span><br><span class="line">		int rint = r.nextInt(3);</span><br><span class="line">		try &#123;</span><br><span class="line">			Thread.sleep(rint*1000);</span><br><span class="line">		&#125; catch (InterruptedException e) &#123;</span><br><span class="line"></span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(name + &quot; is working...&quot;+s);</span><br><span class="line">		return s+&quot;&quot;;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Random;</span><br><span class="line"></span><br><span class="line">public class TaskRunnable implements Runnable&#123;</span><br><span class="line">	private int s;</span><br><span class="line"></span><br><span class="line">	public TaskRunnable(int s)&#123;</span><br><span class="line">		this.s = s;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	Random r = new Random();</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public void run() &#123;</span><br><span class="line">		String name = Thread.currentThread().getName();</span><br><span class="line">		long currentTimeMillis = System.currentTimeMillis();</span><br><span class="line">		System.out.println(name+&quot; 启动时间：&quot; + currentTimeMillis/1000);</span><br><span class="line"></span><br><span class="line">		int rint = r.nextInt(3);</span><br><span class="line">		try &#123;</span><br><span class="line">			Thread.sleep(rint*1000);</span><br><span class="line">		&#125; catch (InterruptedException e) &#123;</span><br><span class="line"></span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(name + &quot; is working...&quot;+s);</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.HashMap;</span><br><span class="line">import java.util.Random;</span><br><span class="line">import java.util.concurrent.ExecutorService;</span><br><span class="line">import java.util.concurrent.Executors;</span><br><span class="line">import java.util.concurrent.Future;</span><br><span class="line">import java.util.concurrent.ScheduledExecutorService;</span><br><span class="line">import java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line">public class TestPool &#123;</span><br><span class="line">	public static void main(String[] args) throws Exception &#123;</span><br><span class="line">		Future&lt;?&gt; submit = null;</span><br><span class="line">		Random random = new Random();</span><br><span class="line"></span><br><span class="line">		//创建固定数量线程池</span><br><span class="line">//		ExecutorService exec = Executors.newFixedThreadPool(4);</span><br><span class="line"></span><br><span class="line">		//创建调度线程池</span><br><span class="line">		ScheduledExecutorService exec = Executors.newScheduledThreadPool(4);</span><br><span class="line"></span><br><span class="line">		//用来记录各线程的返回结果</span><br><span class="line">		ArrayList&lt;Future&lt;?&gt;&gt; results = new ArrayList&lt;Future&lt;?&gt;&gt;();</span><br><span class="line"></span><br><span class="line">		for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">			//fixedPool提交线程，runnable无返回值，callable有返回值</span><br><span class="line">			/*submit = exec.submit(new TaskRunnable(i));*/</span><br><span class="line">			/*submit = exec.submit(new TaskCallable(i));*/</span><br><span class="line"></span><br><span class="line">			//对于schedulerPool来说，调用submit提交任务时，跟普通pool效果一致</span><br><span class="line">			/*submit = exec.submit(new TaskCallable(i));*/</span><br><span class="line">			//对于schedulerPool来说，调用schedule提交任务时，则可按延迟，按间隔时长来调度线程的运行</span><br><span class="line">			submit = exec.schedule(new TaskCallable(i), random.nextInt(10), TimeUnit.SECONDS);</span><br><span class="line">			//存储线程执行结果</span><br><span class="line">			results.add(submit);</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		//打印结果</span><br><span class="line">		for(Future f: results)&#123;</span><br><span class="line">			boolean done = f.isDone();</span><br><span class="line">			System.out.println(done?&quot;已完成&quot;:&quot;未完成&quot;);  //从结果的打印顺序可以看到，即使未完成，也会阻塞等待</span><br><span class="line">			System.out.println(&quot;线程返回future结果： &quot; + f.get());</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		exec.shutdown();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="同步容器类"><a href="#同步容器类" class="headerlink" title="同步容器类"></a>同步容器类</h4><p>同步类容器都是线程安全的,但在某些场景下可能需要加锁来保护复合操作,复合类操作如选代(反复访问元素,遍历完容器中所有的元素)、跳转(根据指定的顺序找到当前元素的下一个元素)、以及条件运算,这些复合操作在多线程并发地修改容器时,可能会表现出意外的行为,最经典的便是ConcurrengModificationException,原因是当容器迭代的过程中,被井发的修改了内容,<br>这是由于早期达代器设计的时候并没有考虑并发修改的问题。<br>同步类容器:如古老的Vector, Hash Table.这些容器的同步功能其实是在JDK的Collections.synchronized**等工厂方法去创建实现的,其底层的机制无非就是用传统的synchronized关键字对每个公用的方法都进行同步,使得每次只能有一个线程访问容器的状态,这很明显不满足我们今天互联网时代高并发的需求,在保证线程安全的同时,他必续要有足够好的性能</p>
<h4 id="并发类容器"><a href="#并发类容器" class="headerlink" title="并发类容器"></a>并发类容器</h4><p>jak5.0以后提供了多种并发类容器来替代同步类容器从而改善性能.同步类容器的状态都是串行化的,他们虽然实现了线程安全,但是严重降低了并发性,在多线程环境时,严重降低了应用程序的吞吐量。<br>并发类容器是专门针对并发设计的,使用ConcurrentHashMap来代替给子散列的传统的HashTable,而且在ConcurrentHashMap中,添加了一些常见复合操作的支持,以及使用了CopyOnWriteArrayList代替Voctor,并发的CopyonWriteArraySet,以及并发的Queue, ConcurrentLinkedQueue和LinkedBlockingQueue,前者是高性能的队列,后者是以阻塞形式的队列,具体实现Queue还有很多,例如ArrayBlockingQueue.<br>PriorityBlockingQueue. Synchronous Queue等</p>
<p>ConcurrntMap:<br>ConcurrentMap接口下有俩个重要的实现<br>ConcurrentHashap<br>ConcurentSkipListMap (支持并发排序功能,弥补ConcurrentHashMap)<br>ConcurrentHashMap内部使用段(Segmen)未表示这些不同的部分,每个段其实就是一个小的Hash Table,它们有自己的锁.只要多个修改操作发生在不同的段上,它们就可以并发进行,把一个整体分成了16个段(Segment).<br>也就是最高支持16个线程的并发修改操作,这也是在多线程场景时减小锁的粒度从面降低锁竞争的一种方案。并且代码中大多共享变量使用volatile关键字声明,目的是第一时间获取修改的内容,性能非常好.</p>
<p>Copy-On-Write容器:<br>Copy-on-Write简称cow,是种用于程序设计中的优化策略。<br>JDK里的CoW容器有两种: CopyOnWriteArrayList和CopyOnWriteArraySet,Cow容器非常有用,可以在非常多的并发场景中使用到<br>什么是CopyOnWrite容器?<br>CopyOnWrite容器即写时复制的容器,通俗的理解是当我们往一个容器添加元素的时候,不直接往当前容器添加,而是先将当前容器进行Copy,复制出一个新的容器,然后新的容器里添加元素,添加完元素之后,再将原容器的引用指向新的容器。这样放的好处是我们可以对CopyOnWrite容器进行并发的读,而不需要加锁,因为当前容器不会添加任何元素,所以CopyOnWrite容器也是一种读写分离的思想,读和写不同<br>的容器。</p>
<h4 id="并发Queue"><a href="#并发Queue" class="headerlink" title="并发Queue"></a>并发Queue</h4><p>在并发队列上JDK提供了两套实现,一个是以ConcurrentLinkedQueue为代表的高性能队列,一个是以BlockingQueue接口为代表的阻塞队列,无论哪种都维承自Queue<br><img src="queue.png" alt="queue"></p>
<p>ConcurrentLinkedQueue:<br>ConcurrentLinkedQueue:是一个适用于高并发场景下的队列,通过无锁的方式,实现了高并发状态下的高性能,通常ConcurrentLinkedQueue性能好于BlockingQueue.它是一个基于链接节点的无界线程安全队列,该队列的元素遵循先进先出的原则,头是最先加入的,尾是最近加入的,该队列不允许null元素。<br>ConcurrentLinkedQueue重要方法:<br>add()和 ofter()都是加入元素的方法(在ConcurrentLinkedaueue中,这两个方法没有任何区别)<br>pol()和peek()都是取头元素节点,区别在于前者会删除元素,后者不会.</p>
<p>ClockingQueue接口:<br>ArrayBlockingQueue:基于数组的阻塞队列实现,在ArrayBlockingQueue内部,维护了一个定长数组,以便缓存队列中的数据对象,其内部没实现读写分离,也就意味着生产和消费不能完全并行,长度是需要定义的,可以指定先进先出或者先进后出,也叫有界队列,在很多场合非常适合使用.<br>LinkedBlockingQueue:基于链表的阻塞队列,同ArrayBlockingQueue类似,其内部也维持着一个数据缓冲队列(该队列由一个链表构成) , LinkedBlockingQueue之所以能够高效的处理并发数据,是因为其内部实现采用分离锁(读写分离两个锁) ,从而实现生产者和消费者操作的完全并行运行。他是一个无界队列。<br>SynchronousQueue :一种没有缓冲的队列,生产者产生的数据直接会被消费者获取并消费。<br>PriorityBlockingQueue:基于优先级的阻塞队列(优先级的判断通过构造函数传入的Compator对象来决定,也就是说传入队列的对象必须实现Comparable接口) ,在实现PriorityBlockingQueue时,内部控制线程同步的锁采用的是公平锁,他也是一个无界的队列。<br>DelayQueue:带有延迟时间的Queue,其中的元素只有当其指定的延迟时间到了,才能够从队列中获取到该元素. Delayqueue中的元素必须实现Delayed接口, Delayqueue是一个没有大小限制的队列,应用场景很多,比如对缓存超时的数据进行移除、任务超时处理、空闲连接的关闭等等.</p>
<p>生产消费模型应用:<br>客户端服务器端数据传输，可能我们没有使用什么消息中间件，通过直连的手段，比如tcp, netty等。<br>客服端与服务器直连进行数据传输，我们发现使用netty一般都会与队列结合使用，可能有一个客户端每秒发送10条数据到服务器端，但是处理的速度与生产的步伐不一致，服务器每秒只能消费1条。<br>如果我们用netty,在业务高峰期，把这10条数据直接放到队列中，但是要有限制，使用有界队列，防止服务器内存溢出，非高峰期，用一些无界队列。或者有些在不同时间段使用不同类型队列。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line">import java.util.concurrent.SynchronousQueue;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class UseQueue &#123;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">		//高性能无阻塞无界队列：ConcurrentLinkedQueue</span><br><span class="line">		/**</span><br><span class="line">		ConcurrentLinkedQueue&lt;String&gt; q = new ConcurrentLinkedQueue&lt;String&gt;();</span><br><span class="line">		q.offer(&quot;a&quot;);</span><br><span class="line">		q.offer(&quot;b&quot;);</span><br><span class="line">		q.offer(&quot;c&quot;);</span><br><span class="line">		q.offer(&quot;d&quot;);</span><br><span class="line">		q.add(&quot;e&quot;);</span><br><span class="line"></span><br><span class="line">		System.out.println(q.poll());	//a 从头部取出元素，并从队列里删除</span><br><span class="line">		System.out.println(q.size());	//4</span><br><span class="line">		System.out.println(q.peek());	//b</span><br><span class="line">		System.out.println(q.size());	//4</span><br><span class="line">		*/</span><br><span class="line"></span><br><span class="line">		/**</span><br><span class="line">		ArrayBlockingQueue&lt;String&gt; array = new ArrayBlockingQueue&lt;String&gt;(5);</span><br><span class="line">		array.put(&quot;a&quot;);</span><br><span class="line">		array.put(&quot;b&quot;);</span><br><span class="line">		array.add(&quot;c&quot;);</span><br><span class="line">		array.add(&quot;d&quot;);</span><br><span class="line">		array.add(&quot;e&quot;);</span><br><span class="line">		array.add(&quot;f&quot;);</span><br><span class="line">		//System.out.println(array.offer(&quot;a&quot;, 3, TimeUnit.SECONDS));</span><br><span class="line">		*/</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		/**</span><br><span class="line">		//阻塞队列</span><br><span class="line">		LinkedBlockingQueue&lt;String&gt; q = new LinkedBlockingQueue&lt;String&gt;();</span><br><span class="line">		q.offer(&quot;a&quot;);</span><br><span class="line">		q.offer(&quot;b&quot;);</span><br><span class="line">		q.offer(&quot;c&quot;);</span><br><span class="line">		q.offer(&quot;d&quot;);</span><br><span class="line">		q.offer(&quot;e&quot;);</span><br><span class="line">		q.add(&quot;f&quot;);</span><br><span class="line">		//System.out.println(q.size());</span><br><span class="line"></span><br><span class="line">//		for (Iterator iterator = q.iterator(); iterator.hasNext();) &#123;</span><br><span class="line">//			String string = (String) iterator.next();</span><br><span class="line">//			System.out.println(string);</span><br><span class="line">//		&#125;</span><br><span class="line"></span><br><span class="line">		List&lt;String&gt; list = new ArrayList&lt;String&gt;();</span><br><span class="line">		System.out.println(q.drainTo(list, 3));</span><br><span class="line">		System.out.println(list.size());</span><br><span class="line">		for (String string : list) &#123;</span><br><span class="line">			System.out.println(string);</span><br><span class="line">		&#125;</span><br><span class="line">		*/</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		final SynchronousQueue&lt;String&gt; q = new SynchronousQueue&lt;String&gt;();</span><br><span class="line">		Thread t1 = new Thread(new Runnable() &#123;</span><br><span class="line">			@Override</span><br><span class="line">			public void run() &#123;</span><br><span class="line">				try &#123;</span><br><span class="line">					System.out.println(q.take());</span><br><span class="line">				&#125; catch (InterruptedException e) &#123;</span><br><span class="line">					e.printStackTrace();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line">		t1.start();</span><br><span class="line">		Thread t2 = new Thread(new Runnable() &#123;</span><br><span class="line"></span><br><span class="line">			@Override</span><br><span class="line">			public void run() &#123;</span><br><span class="line">				q.add(&quot;asdasd&quot;);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line">		t2.start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>PriorityBlockingQueue:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public class Task implements Comparable&lt;Task&gt;&#123;</span><br><span class="line"></span><br><span class="line">	private int id ;</span><br><span class="line">	private String name;</span><br><span class="line">	public int getId() &#123;</span><br><span class="line">		return id;</span><br><span class="line">	&#125;</span><br><span class="line">	public void setId(int id) &#123;</span><br><span class="line">		this.id = id;</span><br><span class="line">	&#125;</span><br><span class="line">	public String getName() &#123;</span><br><span class="line">		return name;</span><br><span class="line">	&#125;</span><br><span class="line">	public void setName(String name) &#123;</span><br><span class="line">		this.name = name;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public int compareTo(Task task) &#123;</span><br><span class="line">		return this.id &gt; task.id ? 1 : (this.id &lt; task.id ? -1 : 0);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public String toString()&#123;</span><br><span class="line">		return this.id + &quot;,&quot; + this.name;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">import java.util.concurrent.PriorityBlockingQueue;</span><br><span class="line"></span><br><span class="line">public class UsePriorityBlockingQueue &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) throws Exception&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		PriorityBlockingQueue&lt;Task&gt; q = new PriorityBlockingQueue&lt;Task&gt;();</span><br><span class="line"></span><br><span class="line">		Task t1 = new Task();</span><br><span class="line">		t1.setId(3);</span><br><span class="line">		t1.setName(&quot;id为3&quot;);</span><br><span class="line">		Task t2 = new Task();</span><br><span class="line">		t2.setId(4);</span><br><span class="line">		t2.setName(&quot;id为4&quot;);</span><br><span class="line">		Task t3 = new Task();</span><br><span class="line">		t3.setId(1);</span><br><span class="line">		t3.setName(&quot;id为1&quot;);</span><br><span class="line"></span><br><span class="line">		//return this.id &gt; task.id ? 1 : 0;</span><br><span class="line">		q.add(t1);	//3</span><br><span class="line">		q.add(t2);	//4</span><br><span class="line">		q.add(t3);  //1</span><br><span class="line"></span><br><span class="line">		// 1 3 4</span><br><span class="line">		System.out.println(&quot;容器：&quot; + q);</span><br><span class="line">		System.out.println(q.take().getId());</span><br><span class="line">		System.out.println(&quot;容器：&quot; + q);</span><br><span class="line">//		System.out.println(q.take().getId());</span><br><span class="line">//		System.out.println(q.take().getId());</span><br><span class="line"></span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>take的时候才排序，放的时候不排序<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">容器：[1,id为1, 4,id为4, 3,id为3]</span><br><span class="line">1</span><br><span class="line">容器：[3,id为3, 4,id为4]</span><br></pre></td></tr></table></figure></p>
<p>DelayQueue:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">import java.util.concurrent.Delayed;</span><br><span class="line">import java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line">public class Wangmin implements Delayed &#123;</span><br><span class="line"></span><br><span class="line">    private String name;</span><br><span class="line">    //身份证</span><br><span class="line">    private String id;</span><br><span class="line">    //截止时间</span><br><span class="line">    private long endTime;</span><br><span class="line">    //定义时间工具类</span><br><span class="line">    private TimeUnit timeUnit = TimeUnit.SECONDS;</span><br><span class="line"></span><br><span class="line">    public Wangmin(String name,String id,long endTime)&#123;</span><br><span class="line">        this.name=name;</span><br><span class="line">        this.id=id;</span><br><span class="line">        this.endTime = endTime;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getName()&#123;</span><br><span class="line">        return this.name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getId()&#123;</span><br><span class="line">        return this.id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 用来判断是否到了截止时间</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    public long getDelay(TimeUnit unit) &#123;</span><br><span class="line">        //return unit.convert(endTime, TimeUnit.MILLISECONDS) - unit.convert(System.currentTimeMillis(), TimeUnit.MILLISECONDS);</span><br><span class="line">    	return endTime - System.currentTimeMillis();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 相互批较排序用</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    public int compareTo(Delayed delayed) &#123;</span><br><span class="line">    	Wangmin w = (Wangmin)delayed;</span><br><span class="line">        return this.getDelay(this.timeUnit) - w.getDelay(this.timeUnit) &gt; 0 ? 1:0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">import java.util.concurrent.DelayQueue;</span><br><span class="line"></span><br><span class="line">public class WangBa implements Runnable &#123;</span><br><span class="line"></span><br><span class="line">    private DelayQueue&lt;Wangmin&gt; queue = new DelayQueue&lt;Wangmin&gt;();</span><br><span class="line"></span><br><span class="line">    public boolean yinye =true;</span><br><span class="line"></span><br><span class="line">    public void shangji(String name,String id,int money)&#123;</span><br><span class="line">        Wangmin man = new Wangmin(name, id, 1000 * money + System.currentTimeMillis());</span><br><span class="line">        System.out.println(&quot;网名&quot;+man.getName()+&quot; 身份证&quot;+man.getId()+&quot;交钱&quot;+money+&quot;块,开始上机...&quot;);</span><br><span class="line">        this.queue.add(man);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void xiaji(Wangmin man)&#123;</span><br><span class="line">        System.out.println(&quot;网名&quot;+man.getName()+&quot; 身份证&quot;+man.getId()+&quot;时间到下机...&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        while(yinye)&#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                Wangmin man = queue.take();</span><br><span class="line">                xiaji(man);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String args[])&#123;</span><br><span class="line">        try&#123;</span><br><span class="line">            System.out.println(&quot;网吧开始营业&quot;);</span><br><span class="line">            WangBa siyu = new WangBa();</span><br><span class="line">            Thread shangwang = new Thread(siyu);</span><br><span class="line">            shangwang.start();</span><br><span class="line"></span><br><span class="line">            siyu.shangji(&quot;路人甲&quot;, &quot;123&quot;, 1);</span><br><span class="line">            siyu.shangji(&quot;路人乙&quot;, &quot;234&quot;, 10);</span><br><span class="line">            siyu.shangji(&quot;路人丙&quot;, &quot;345&quot;, 5);</span><br><span class="line">        &#125;</span><br><span class="line">        catch(Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">网吧开始营业</span><br><span class="line">网名路人甲 身份证123交钱1块,开始上机...</span><br><span class="line">网名路人乙 身份证234交钱10块,开始上机...</span><br><span class="line">网名路人丙 身份证345交钱5块,开始上机...</span><br><span class="line">网名路人甲 身份证123时间到下机...</span><br><span class="line">网名路人丙 身份证345时间到下机...</span><br><span class="line">网名路人乙 身份证234时间到下机...</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">BlockingQueue也是java.util.concurrent下的主要用来控制线程同步的工具。</span><br><span class="line">主要的方法是：put、take一对阻塞存取；add、poll一对非阻塞存取。</span><br><span class="line">	插入:</span><br><span class="line">		1)add(anObject):把anObject加到BlockingQueue里,即如果BlockingQueue可以容纳,则返回true,否则抛出</span><br><span class="line">        2)offer(anObject):表示如果可能的话,将anObject加到BlockingQueue里,即如果BlockingQueue可以容纳,则返回true,否则返回false.</span><br><span class="line">        3)put(anObject):把anObject加到BlockingQueue里,如果BlockQueue没有空间,则调用此方法的线程被阻断直到BlockingQueue里面有空间再继续.</span><br><span class="line">	读取：</span><br><span class="line">        4)poll(time):取走BlockingQueue里排在首位的对象,若不能立即取出,则可以等time参数规定的时间,取不到时返回null</span><br><span class="line">        5)take():取走BlockingQueue里排在首位的对象,若BlockingQueue为空,阻断进入等待状态直到Blocking有新的对象被加入为止</span><br><span class="line">	其他</span><br><span class="line">int remainingCapacity();返回队列剩余的容量，在队列插入和获取的时候，不要瞎搞，数	据可能不准</span><br><span class="line">boolean remove(Object o); 从队列移除元素，如果存在，即移除一个或者更多，队列改	变了返回true</span><br><span class="line">public boolean contains(Object o); 查看队列是否存在这个元素，存在返回true</span><br><span class="line">int drainTo(Collection&lt;? super E&gt; c); 移除此队列中所有可用的元素，并将它们添加到给定collection中</span><br><span class="line">int drainTo(Collection&lt;? super E&gt; c, int maxElements); 和上面方法的区别在于，制定了移动的数量</span><br><span class="line"></span><br><span class="line">BlockingQueue有四个具体的实现类,常用的两种实现类为：</span><br><span class="line"></span><br><span class="line">1、ArrayBlockingQueue：一个由数组支持的有界阻塞队列，规定大小的BlockingQueue,其构造函数必须带一个int参数来指明其大小.其所含的对象是以FIFO(先入先出)顺序排序的。</span><br><span class="line"></span><br><span class="line">2、LinkedBlockingQueue：大小不定的BlockingQueue,若其构造函数带一个规定大小的参数,生成的BlockingQueue有大小限制,若不带大小参数,所生成的BlockingQueue的大小由Integer.MAX_VALUE来决定.其所含的对象是以FIFO(先入先出)顺序排序的。</span><br><span class="line">	LinkedBlockingQueue 可以指定容量，也可以不指定，不指定的话，默认最大是Integer.MAX_VALUE,其中主要用到put和take方法，put方法在队列满的时候会阻塞直到有队列成员被消费，take方法在队列空的时候会阻塞，直到有队列成员被放进来。</span><br><span class="line"></span><br><span class="line">LinkedBlockingQueue和ArrayBlockingQueue区别：</span><br><span class="line"></span><br><span class="line">LinkedBlockingQueue和ArrayBlockingQueue比较起来,它们背后所用的数据结构不一样,导致LinkedBlockingQueue的数据吞吐量要大于ArrayBlockingQueue,但在线程数量很大时其性能的可预见性低于ArrayBlockingQueue.</span><br></pre></td></tr></table></figure>
<h3 id="java并发编程的一些总结"><a href="#java并发编程的一些总结" class="headerlink" title="java并发编程的一些总结"></a>java并发编程的一些总结</h3><p>1.不应用线程池的缺点<br>有些开发者图省事，遇到需要多线程处理的地方，直接new Thread(…).start()，对于一般场景是没问题的，但如果是在并发请求很高的情况下，就会有些隐患：<br>新建线程的开销。线程虽然比进程要轻量许多，但对于JVM来说，新建一个线程的代价还是挺大的，决不同于新建一个对象<br>资源消耗量。没有一个池来限制线程的数量，会导致线程的数量直接取决于应用的并发量，这样有潜在的线程数据巨大的可能，那么资源消耗量将是巨大的<br>稳定性。当线程数量超过系统资源所能承受的程度，稳定性就会成问题<br>2.制定执行策略<br>在每个需要多线程处理的地方，不管并发量有多大，需要考虑线程的执行策略<br>任务以什么顺序执行<br>可以有多少个任何并发执行<br>可以有多少个任务进入等待执行队列<br>系统过载的时候，应该放弃哪些任务？如何通知到应用程序？<br>一个任务的执行前后应该做什么处理<br>3.线程池的类型<br>不管是通过Executors创建线程池，还是通过Spring来管理，都得清楚知道有哪几种线程池：<br>FixedThreadPool：定长线程池，提交任务时创建线程，直到池的最大容量，如果有线程非预期结束，会补充新线程<br>CachedThreadPool：可变线程池，它犹如一个弹簧，如果没有任务需求时，它回收空闲线程，如果需求增加，则按需增加线程，不对池的大小做限制<br>SingleThreadExecutor：单线程。处理不过来的任务会进入FIFO队列等待执行<br>SecheduledThreadPool：周期性线程池。支持执行周期性线程任务<br>其实，这些不同类型的线程池都是通过构建一个ThreadPoolExecutor来完成的，所不同的是corePoolSize,maximumPoolSize,keepAliveTime,unit,workQueue,threadFactory这么几个参数。具体可以参见JDK DOC。<br>4.线程池饱和策略<br>由以上线程池类型可知，除了CachedThreadPool其他线程池都有饱和的可能，当饱和以后就需要相应的策略处理请求线程的任务，ThreadPoolExecutor采取的方式通过队列来存储这些任务，当然会根据池类型不同选择不同的队列，比如FixedThreadPool和SingleThreadExecutor默认采用的是无限长度的LinkedBlockingQueue。但从系统可控性讲，最好的做法是使用定长的ArrayBlockingQueue或有限的LinkedBlockingQueue，并且当达到上限时通过ThreadPoolExecutor.setRejectedExecutionHandler方法设置一个拒绝任务的策略，JDK提供了AbortPolicy、CallerRunsPolicy、DiscardPolicy、DiscardOldestPolicy几种策略，具体差异可见JDK DOC<br>5.线程无依赖性<br>多线程任务设计上尽量使得各任务是独立无依赖的，所谓依赖性可两个方面：<br>线程之间的依赖性。如果线程有依赖可能会造成死锁或饥饿<br>调用者与线程的依赖性。调用者得监视线程的完成情况，影响可并发量<br>当然，在有些业务里确实需要一定的依赖性，比如调用者需要得到线程完成后结果，传统的Thread是不便完成的，因为run方法无返回值，只能通过一些共享的变量来传递结果，但在Executor框架里可以通过Future和Callable实现需要有返回值的任务，当然线程的异步性导致需要有相应机制来保证调用者能等待任务完成。</p>
<h3 id="多线程的设计模式"><a href="#多线程的设计模式" class="headerlink" title="多线程的设计模式"></a>多线程的设计模式</h3><p>并行设计模式属于设计优化的一部分,它是对一些常用的多线程结构的总结和抽象与串行程序相比,并行程序的结构通常更为复杂。因此合理的使用并行模式在多线程开发中更具有意义,在这里主要介绍Future, Master-Worker和生产者-消费者模型。</p>
<h4 id="Future模式"><a href="#Future模式" class="headerlink" title="Future模式"></a>Future模式</h4><p>Future模式有点类似于商品订单。比如在网购时,当看重某一件商品事,就可以提交订 ,当订单处理完成后,在家里等待商品送货上门即可。或者说更形象的我们发送Ajax请求的时候,页面是异步的进行后台处理,用户无须一直等待请求的结果,可以继续浏览或操作其他内容。<br><img src="Future模式.png" alt="Future模式"></p>
<p>Data:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface Data &#123;</span><br><span class="line">	String getRequest();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>RealData:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class RealData implements Data&#123;</span><br><span class="line"></span><br><span class="line">	private String result ;</span><br><span class="line"></span><br><span class="line">	public RealData (String queryStr)&#123;</span><br><span class="line">		System.out.println(&quot;根据&quot; + queryStr + &quot;进行查询，这是一个很耗时的操作..&quot;);</span><br><span class="line">		try &#123;</span><br><span class="line">			Thread.sleep(5000);</span><br><span class="line">		&#125; catch (InterruptedException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(&quot;操作完毕，获取结果&quot;);</span><br><span class="line">		result = &quot;查询结果&quot;;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public String getRequest() &#123;</span><br><span class="line">		return result;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>FutureData:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">public class FutureData implements Data&#123;</span><br><span class="line"></span><br><span class="line">	private RealData realData ;</span><br><span class="line">	private boolean isReady = false;</span><br><span class="line"></span><br><span class="line">	public synchronized void setRealData(RealData realData) &#123;</span><br><span class="line">		//如果已经装载完毕了，就直接返回</span><br><span class="line">		if(isReady)&#123;</span><br><span class="line">			return;</span><br><span class="line">		&#125;</span><br><span class="line">		//如果没装载，进行装载真实对象</span><br><span class="line">		this.realData = realData;</span><br><span class="line">		isReady = true;</span><br><span class="line">		//进行通知</span><br><span class="line">		notify();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public synchronized String getRequest() &#123;</span><br><span class="line">		//如果没装载好 程序就一直处于阻塞状态</span><br><span class="line">		while(!isReady)&#123;</span><br><span class="line">			try &#123;</span><br><span class="line">				wait();</span><br><span class="line">			&#125; catch (InterruptedException e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		//装载好直接获取数据即可</span><br><span class="line">		return this.realData.getRequest();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>FutureClient:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class FutureClient &#123;</span><br><span class="line"></span><br><span class="line">	public Data request(final String queryStr)&#123;</span><br><span class="line">		//1 我想要一个代理对象（Data接口的实现类）先返回给发送请求的客户端，告诉他请求已经接收到，可以做其他的事情</span><br><span class="line">		final FutureData futureData = new FutureData();</span><br><span class="line">		//2 启动一个新的线程，去加载真实的数据，传递给这个代理对象</span><br><span class="line">		new Thread(new Runnable() &#123;</span><br><span class="line">			@Override</span><br><span class="line">			public void run() &#123;</span><br><span class="line">				//3 这个新的线程可以去慢慢的加载真实对象，然后传递给代理对象</span><br><span class="line">				RealData realData = new RealData(queryStr);</span><br><span class="line">				futureData.setRealData(realData);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;).start();</span><br><span class="line"></span><br><span class="line">		return futureData;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Main:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class Main &#123;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">		FutureClient fc = new FutureClient();</span><br><span class="line">		Data data = fc.request(&quot;请求参数&quot;);</span><br><span class="line">		System.out.println(&quot;请求发送成功!&quot;);</span><br><span class="line">		System.out.println(&quot;做其他的事情...&quot;);</span><br><span class="line"></span><br><span class="line">		String result = data.getRequest();</span><br><span class="line">		System.out.println(result);</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="Master-Worker模式"><a href="#Master-Worker模式" class="headerlink" title="Master-Worker模式"></a>Master-Worker模式</h4><p>Master-Worker模式是常用的并行计算模式。<br>它的核心思想是系统由两类进程协作工作: Master进程和Worker进程。Master负责接收和分配任务,Worker负责处理子任务。当各个Worker子进程处理完成后,会将结果返回给Master, 由Master做归纳和总结。<br>其好处是能将一个大任务分解成若干个小任务,并行执行,从而提高系统的吞吐量。<br><img src="master-worker.png" alt="master-worker"><br><img src="master-worker2.png" alt="master-worker2"><br>Task:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class Task &#123;</span><br><span class="line"></span><br><span class="line">	private int id;</span><br><span class="line">	private int price ;</span><br><span class="line">	public int getId() &#123;</span><br><span class="line">		return id;</span><br><span class="line">	&#125;</span><br><span class="line">	public void setId(int id) &#123;</span><br><span class="line">		this.id = id;</span><br><span class="line">	&#125;</span><br><span class="line">	public int getPrice() &#123;</span><br><span class="line">		return price;</span><br><span class="line">	&#125;</span><br><span class="line">	public void setPrice(int price) &#123;</span><br><span class="line">		this.price = price;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Master:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">import java.util.HashMap;</span><br><span class="line">import java.util.Map;</span><br><span class="line">import java.util.concurrent.ConcurrentHashMap;</span><br><span class="line">import java.util.concurrent.ConcurrentLinkedQueue;</span><br><span class="line"></span><br><span class="line">public class Master &#123;</span><br><span class="line"></span><br><span class="line">	//1 有一个盛放任务的容器</span><br><span class="line">	private ConcurrentLinkedQueue&lt;Task&gt; workQueue = new ConcurrentLinkedQueue&lt;Task&gt;();</span><br><span class="line"></span><br><span class="line">	//2 需要有一个盛放worker的集合</span><br><span class="line">	private HashMap&lt;String, Thread&gt; workers = new HashMap&lt;String, Thread&gt;();</span><br><span class="line"></span><br><span class="line">	//3 需要有一个盛放每一个worker执行任务的结果集合</span><br><span class="line">	private ConcurrentHashMap&lt;String, Object&gt; resultMap = new ConcurrentHashMap&lt;String, Object&gt;();</span><br><span class="line"></span><br><span class="line">	//4 构造方法</span><br><span class="line">	public Master(Worker worker , int workerCount)&#123;</span><br><span class="line">		worker.setWorkQueue(this.workQueue);</span><br><span class="line">		worker.setResultMap(this.resultMap);</span><br><span class="line"></span><br><span class="line">		for(int i = 0; i &lt; workerCount; i ++)&#123;</span><br><span class="line">			this.workers.put(Integer.toString(i), new Thread(worker));</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	//5 需要一个提交任务的方法</span><br><span class="line">	public void submit(Task task)&#123;</span><br><span class="line">		this.workQueue.add(task);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	//6 需要有一个执行的方法，启动所有的worker方法去执行任务</span><br><span class="line">	public void execute()&#123;</span><br><span class="line">		for(Map.Entry&lt;String, Thread&gt; me : workers.entrySet())&#123;</span><br><span class="line">			me.getValue().start();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	//7 判断是否运行结束的方法</span><br><span class="line">	public boolean isComplete() &#123;</span><br><span class="line">		for(Map.Entry&lt;String, Thread&gt; me : workers.entrySet())&#123;</span><br><span class="line">			if(me.getValue().getState() != Thread.State.TERMINATED)&#123;</span><br><span class="line">				return false;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		return true;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	//8 计算结果方法</span><br><span class="line">	public int getResult() &#123;</span><br><span class="line">		int priceResult = 0;</span><br><span class="line">		for(Map.Entry&lt;String, Object&gt; me : resultMap.entrySet())&#123;</span><br><span class="line">			priceResult += (Integer)me.getValue();</span><br><span class="line">		&#125;</span><br><span class="line">		return priceResult;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Worker:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">import java.util.concurrent.ConcurrentHashMap;</span><br><span class="line">import java.util.concurrent.ConcurrentLinkedQueue;</span><br><span class="line"></span><br><span class="line">public class Worker implements Runnable &#123;</span><br><span class="line"></span><br><span class="line">	private ConcurrentLinkedQueue&lt;Task&gt; workQueue;</span><br><span class="line">	private ConcurrentHashMap&lt;String, Object&gt; resultMap;</span><br><span class="line"></span><br><span class="line">	public void setWorkQueue(ConcurrentLinkedQueue&lt;Task&gt; workQueue) &#123;</span><br><span class="line">		this.workQueue = workQueue;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public void setResultMap(ConcurrentHashMap&lt;String, Object&gt; resultMap) &#123;</span><br><span class="line">		this.resultMap = resultMap;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public void run() &#123;</span><br><span class="line">		while(true)&#123;</span><br><span class="line">			Task input = this.workQueue.poll();</span><br><span class="line">			if(input == null) break;</span><br><span class="line">			Object output = handle(input);</span><br><span class="line">			this.resultMap.put(Integer.toString(input.getId()), output);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	private Object handle(Task input) &#123;</span><br><span class="line">		Object output = null;</span><br><span class="line">		try &#123;</span><br><span class="line">			//处理任务的耗时。。 比如说进行操作数据库。。。</span><br><span class="line">			Thread.sleep(500);</span><br><span class="line">			output = input.getPrice();</span><br><span class="line">		&#125; catch (InterruptedException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">		return output;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Main:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Random;</span><br><span class="line"></span><br><span class="line">public class Main &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">		Master master = new Master(new Worker(), 20);</span><br><span class="line"></span><br><span class="line">		Random r = new Random();</span><br><span class="line">		for(int i = 1; i &lt;= 100; i++)&#123;</span><br><span class="line">			Task t = new Task();</span><br><span class="line">			t.setId(i);</span><br><span class="line">			t.setPrice(r.nextInt(1000));</span><br><span class="line">			master.submit(t);</span><br><span class="line">		&#125;</span><br><span class="line">		master.execute();</span><br><span class="line">		long start = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">		while(true)&#123;</span><br><span class="line">			if(master.isComplete())&#123;</span><br><span class="line">				long end = System.currentTimeMillis() - start;</span><br><span class="line">				int priceResult = master.getResult();</span><br><span class="line">				System.out.println(&quot;最终结果：&quot; + priceResult + &quot;, 执行时间：&quot; + end);</span><br><span class="line">				break;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="生产者-消费者"><a href="#生产者-消费者" class="headerlink" title="生产者-消费者"></a>生产者-消费者</h4><p>生产者和消费者也是一个非常经典的多线程模式,我们在实际开发中应用非常广泛的思想理念。在生产-消费模式中:通常由两类线程,即若干个生产者的线程和若干个消费者的线程。生产者线程负责提交用户请求,消费者线程则负责具体处理生产者提交的任务,在生产者和消费者之间通过共享内存缓存区进行通信。<br>Data:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">public final class Data &#123;</span><br><span class="line"></span><br><span class="line">	private String id;</span><br><span class="line">	private String name;</span><br><span class="line"></span><br><span class="line">	public Data(String id, String name)&#123;</span><br><span class="line">		this.id = id;</span><br><span class="line">		this.name = name;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public String getId() &#123;</span><br><span class="line">		return id;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public void setId(String id) &#123;</span><br><span class="line">		this.id = id;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public String getName() &#123;</span><br><span class="line">		return name;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public void setName(String name) &#123;</span><br><span class="line">		this.name = name;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public String toString()&#123;</span><br><span class="line">		return &quot;&#123;id: &quot; + id + &quot;, name: &quot; + name + &quot;&#125;&quot;;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Provider:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Random;</span><br><span class="line">import java.util.concurrent.BlockingQueue;</span><br><span class="line">import java.util.concurrent.TimeUnit;</span><br><span class="line">import java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"></span><br><span class="line">public class Provider implements Runnable&#123;</span><br><span class="line"></span><br><span class="line">	//共享缓存区</span><br><span class="line">	private BlockingQueue&lt;Data&gt; queue;</span><br><span class="line">	//多线程间是否启动变量，有强制从主内存中刷新的功能。即时返回线程的状态</span><br><span class="line">	private volatile boolean isRunning = true;</span><br><span class="line">	//id生成器</span><br><span class="line">	private static AtomicInteger count = new AtomicInteger();</span><br><span class="line">	//随机对象</span><br><span class="line">	private static Random r = new Random();</span><br><span class="line"></span><br><span class="line">	public Provider(BlockingQueue queue)&#123;</span><br><span class="line">		this.queue = queue;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public void run() &#123;</span><br><span class="line">		while(isRunning)&#123;</span><br><span class="line">			try &#123;</span><br><span class="line">				//随机休眠0 - 1000 毫秒 表示获取数据(产生数据的耗时)</span><br><span class="line">				Thread.sleep(r.nextInt(1000));</span><br><span class="line">				//获取的数据进行累计...</span><br><span class="line">				int id = count.incrementAndGet();</span><br><span class="line">				//比如通过一个getData方法获取了</span><br><span class="line">				Data data = new Data(Integer.toString(id), &quot;数据&quot; + id);</span><br><span class="line">				System.out.println(&quot;当前线程:&quot; + Thread.currentThread().getName() + &quot;, 获取了数据，id为:&quot; + id + &quot;, 进行装载到公共缓冲区中...&quot;);</span><br><span class="line">				if(!this.queue.offer(data, 2, TimeUnit.SECONDS))&#123;</span><br><span class="line">					System.out.println(&quot;提交缓冲区数据失败....&quot;);</span><br><span class="line">					//do something... 比如重新提交</span><br><span class="line">				&#125;</span><br><span class="line">			&#125; catch (InterruptedException e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public void stop()&#123;</span><br><span class="line">		this.isRunning = false;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Consumer:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public class Consumer implements Runnable&#123;</span><br><span class="line"></span><br><span class="line">	private BlockingQueue&lt;Data&gt; queue;</span><br><span class="line"></span><br><span class="line">	public Consumer(BlockingQueue queue)&#123;</span><br><span class="line">		this.queue = queue;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	//随机对象</span><br><span class="line">	private static Random r = new Random();</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public void run() &#123;</span><br><span class="line">		while(true)&#123;</span><br><span class="line">			try &#123;</span><br><span class="line">				//获取数据</span><br><span class="line">				Data data = this.queue.take();</span><br><span class="line">				//进行数据处理。休眠0 - 1000毫秒模拟耗时</span><br><span class="line">				Thread.sleep(r.nextInt(1000));</span><br><span class="line">				System.out.println(&quot;当前消费线程：&quot; + Thread.currentThread().getName() + &quot;， 消费成功，消费数据为id: &quot; + data.getId());</span><br><span class="line">			&#125; catch (InterruptedException e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Main:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">import java.util.concurrent.BlockingQueue;</span><br><span class="line">import java.util.concurrent.ExecutorService;</span><br><span class="line">import java.util.concurrent.Executors;</span><br><span class="line">import java.util.concurrent.LinkedBlockingQueue;</span><br><span class="line"></span><br><span class="line">public class Main &#123;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) throws Exception &#123;</span><br><span class="line">		//内存缓冲区</span><br><span class="line">		BlockingQueue&lt;Data&gt; queue = new LinkedBlockingQueue&lt;Data&gt;(10);</span><br><span class="line">		//生产者</span><br><span class="line">		Provider p1 = new Provider(queue);</span><br><span class="line"></span><br><span class="line">		Provider p2 = new Provider(queue);</span><br><span class="line">		Provider p3 = new Provider(queue);</span><br><span class="line">		//消费者</span><br><span class="line">		Consumer c1 = new Consumer(queue);</span><br><span class="line">		Consumer c2 = new Consumer(queue);</span><br><span class="line">		Consumer c3 = new Consumer(queue);</span><br><span class="line">		//创建线程池运行,这是一个缓存的线程池，可以创建无穷大的线程，没有任务的时候不创建线程。空闲线程存活时间为60s（默认值）</span><br><span class="line"></span><br><span class="line">		ExecutorService cachePool = Executors.newCachedThreadPool();</span><br><span class="line">		cachePool.execute(p1);</span><br><span class="line">		cachePool.execute(p2);</span><br><span class="line">		cachePool.execute(p3);</span><br><span class="line">		cachePool.execute(c1);</span><br><span class="line">		cachePool.execute(c2);</span><br><span class="line">		cachePool.execute(c3);</span><br><span class="line"></span><br><span class="line">		try &#123;</span><br><span class="line">			Thread.sleep(3000);</span><br><span class="line">		&#125; catch (InterruptedException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">		p1.stop();</span><br><span class="line">		p2.stop();</span><br><span class="line">		p3.stop();</span><br><span class="line">		try &#123;</span><br><span class="line">			Thread.sleep(2000);</span><br><span class="line">		&#125; catch (InterruptedException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">//		cachePool.shutdown();</span><br><span class="line">//		cachePool.shutdownNow();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="Executor框架"><a href="#Executor框架" class="headerlink" title="Executor框架"></a>Executor框架</h4><p>为了更好的控制多线程, JDK提供了一套线程框架Executor,帮助开发人员有效地进行线程控制。它们都在java.util.concurrent包中,是JDK并发包的核心。其中有一个比较重要的类: Executors,他扮演这线程工厂的角色,我们通过Executors可以创建特定功能的线程池。<br>Executors创建线程池方法:<br>newFixedThreadPool)方法,该方法返回一个固定数量的线程池,该方法的线程数始终不变,当有一个任务提交时,若线程池中空闲,则立即执行,若没有,则会被暂缓在一个任务队列中等待有空闲的线程去执行。<br>newSingleThreadExecutor()方法,创建一个线程的线程池,若空闲则执行,若没有空闲线程则暂缓在任务列队中。<br>newCachedThreadPool)方法,返回一个可根据实际情况调整线程个数的线程池,不限制最大线程数量,若有任务,则创建线程,若无任务则不创建线程。如果没有任务则线程在60s后自动回收(空闲时间60s) .<br>newScheduled ThreadPool)方法,该方法返回一个SchededExecutorService对象,但该线程池可以指定线程的数量</p>
<h4 id="自定义线程池"><a href="#自定义线程池" class="headerlink" title="自定义线程池"></a>自定义线程池</h4><p>若Executors工厂类无法满足我们的需求,可以自己去创建自定义的线程池,其实Executors工广类里面的创建线程方法其内部实现均是用了ThreadPoolExecutor这个类,这个类可以自定义线程。构造方法如下:<br>public ThreadPoolExecutor(int corePoolSize,<br>                  int maximumPoolSize，<br>                  long keepAliveTime,<br>                  TimeUnit unit,<br>                  BlockingQueue<runnable> workQueue,<br>                  ThreadFactory ThreadFactory,<br>                  RejectedExecutionHandler handler) {…}</runnable></p>
<p>比如：maximumPoolSize=2，maximumPoolSize=10，ArrayBlockingqueue=10<br>当一次性来了30个任务，放到这个线程池里，肯定会有一堆任务被拒绝，首先，corePoolSize有2个，还有28个任务待处理，我们可以根据上限maximumPoolSize再去提高8个线程去处理，还剩20个，再往队列里扔10个，最后还剩10个，这10个就会去走RejectedExecutionHandler<br>任务过多的时候会导致内存溢出，队列会逐渐变大。</p>
<h4 id="自定义线程池使用详细"><a href="#自定义线程池使用详细" class="headerlink" title="自定义线程池使用详细"></a>自定义线程池使用详细</h4><p>这个构造方法对于队列是什么类型的比较关键:<br>在使用有界队列时: 若有新的任务需要执行,如果线程池实际线程数小于corePoolSize,则优先创建线程,若大于corePoolsize,则会将任务加入队列，若队列已满，<br>则在总线程数不大于maximumPoolSize的前提下创建新的线程，若线程数大于maximumPoolsize,则执行拒绝策略。或其他自定义方式。<br>无界的任务队列时: LinkedBlockingQueue,与有界队列相比,除非系统资源耗尽,否则无界的任务队列<br>不存在任务入队失败的情况。当有新在务到来,系统的线程数小于corePoolsize时,则新建线程执行任务,当达到orePoolSize后,就不会继续增加。若后续仍有新的在务加入,而有没有<br>闲的线程资源，则任务直接进入队列等待。若任务创建和处理的速度差异很大,无界队列会保持快速增长,直到耗尽系统内存。<br>JDK拒绝策略:<br>AbortPolicy:直接抛出异常组织系统正常工作<br>CallerRunsPolicy:只要线程池未关闭,该策略直接在调用者线程中,运行当前被丢弃的任务。<br>DiscardoldestPolicy:丢弃最老的一个请求,尝试再次提交当前任务。<br>DiscardPolicy:丢弃无法处理的任务,不给予任何处理。<br>如果需要自定义拒绝策略可以实现RejectedExecutionHandler接口。</p>

                    
                        

                    
                    
                        <p>
                            <a href="/2019/09/07/多线程3/#post-footer" class="postShorten-excerpt_link link">
                                评论和共享
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a class="link-unstyled" href="/2019/09/07/多线程2/">
                            多线程2
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2019-09-07T10:23:08+08:00">
	
		    9月 07, 2019
    	
    </time>
    
</div>

            </div>
            
                <div class="postShorten-content">
                    <h3 id="线程之间通信"><a href="#线程之间通信" class="headerlink" title="线程之间通信"></a>线程之间通信</h3><p>线程通信概念 线程是操作系统中独立的个体,但这些个体如果不经过特殊的处理就不能成为一个整体,线程间的通信就成为整体的必用方式之一,当线程存在通信指挥,系统间的交互性会更强大,在提高CPU利用率的同时还会使开发人员对线程任务在处理的过程中进行有效的把控与监督.<br>使用wait notily方法实现线程间的通信。 (注意这两个方法都是object的类的方法,换句话说java为所有的对象都提供了这两个方法)<br>1 wait和 notify 必须配合synchronized关键字使用<br>2 wait方法释放锁, notify方法不释放锁.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.List;</span><br><span class="line">/**</span><br><span class="line"> * wait notfiy 方法，wait释放锁，notfiy不释放锁</span><br><span class="line"> */</span><br><span class="line">public class ListAdd2 &#123;</span><br><span class="line">	private volatile static List list = new ArrayList();</span><br><span class="line"></span><br><span class="line">	public void add()&#123;</span><br><span class="line">		list.add(&quot;bjsxt&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	public int size()&#123;</span><br><span class="line">		return list.size();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		final ListAdd2 list2 = new ListAdd2();</span><br><span class="line"></span><br><span class="line">		// 1 实例化出来一个 lock</span><br><span class="line">		// 当使用wait 和 notify 的时候 ， 一定要配合着synchronized关键字去使用</span><br><span class="line">		final Object lock = new Object();</span><br><span class="line">		// final CountDownLatch countDownLatch = new CountDownLatch(1);</span><br><span class="line"></span><br><span class="line">		Thread t1 = new Thread(new Runnable() &#123;</span><br><span class="line">			@Override</span><br><span class="line">			public void run() &#123;</span><br><span class="line">				try &#123;</span><br><span class="line">					synchronized (lock) &#123;</span><br><span class="line">						for(int i = 0; i &lt;10; i++)&#123;</span><br><span class="line">							list2.add();</span><br><span class="line">							System.out.println(&quot;当前线程：&quot; + Thread.currentThread().getName() + &quot;添加了一个元素..&quot;);</span><br><span class="line">							Thread.sleep(500);</span><br><span class="line">							if(list2.size() == 5)&#123;</span><br><span class="line">								System.out.println(&quot;已经发出通知..&quot;);</span><br><span class="line">								//countDownLatch.countDown();</span><br><span class="line">								lock.notify();</span><br><span class="line">							&#125;</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125; catch (InterruptedException e) &#123;</span><br><span class="line">					e.printStackTrace();</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;, &quot;t1&quot;);</span><br><span class="line"></span><br><span class="line">		Thread t2 = new Thread(new Runnable() &#123;</span><br><span class="line">			@Override</span><br><span class="line">			public void run() &#123;</span><br><span class="line">				synchronized (lock) &#123;</span><br><span class="line">					if(list2.size() != 5)&#123;</span><br><span class="line">						try &#123;</span><br><span class="line">							//System.out.println(&quot;t2进入...&quot;);</span><br><span class="line">							lock.wait();</span><br><span class="line">							// countDownLatch.await();</span><br><span class="line">						&#125; catch (InterruptedException e) &#123;</span><br><span class="line">							e.printStackTrace();</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">					System.out.println(&quot;当前线程：&quot; + Thread.currentThread().getName() + &quot;收到通知线程停止..&quot;);</span><br><span class="line">					throw new RuntimeException();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;, &quot;t2&quot;);</span><br><span class="line"></span><br><span class="line">		t2.start();</span><br><span class="line">		t1.start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">当前线程：t1添加了一个元素..</span><br><span class="line">当前线程：t1添加了一个元素..</span><br><span class="line">当前线程：t1添加了一个元素..</span><br><span class="line">当前线程：t1添加了一个元素..</span><br><span class="line">当前线程：t1添加了一个元素..</span><br><span class="line">已经发出通知..</span><br><span class="line">当前线程：t1添加了一个元素..</span><br><span class="line">当前线程：t1添加了一个元素..</span><br><span class="line">当前线程：t1添加了一个元素..</span><br><span class="line">当前线程：t1添加了一个元素..</span><br><span class="line">当前线程：t1添加了一个元素..</span><br><span class="line">当前线程：t2收到通知线程停止..</span><br><span class="line">Exception in thread &quot;t2&quot; java.lang.RuntimeException</span><br><span class="line">	at com.bjsxt.base.conn008.ListAdd2$2.run(ListAdd2.java:65)</span><br><span class="line">	at java.lang.Thread.run(Thread.java:745)</span><br></pre></td></tr></table></figure>
<p>上述方式需要等到notify所在代码全部执行完毕，其它方式CountDownLatch（跟锁没有关系）<br>countdownlatch同样拥有wait和notify功能，对应的是await和countDown,不过它是即时的，不需要等待notify代码块执行完毕后才释放锁，只要执行了notify函数后，其他线程就能拿到锁，不过countdownlatch不具备锁的功能<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.List;</span><br><span class="line">import java.util.concurrent.CountDownLatch;</span><br><span class="line">/**</span><br><span class="line"> * wait notfiy 方法，wait释放锁，notfiy不释放锁</span><br><span class="line"> */</span><br><span class="line">public class ListAdd2 &#123;</span><br><span class="line">	private volatile static List list = new ArrayList();</span><br><span class="line"></span><br><span class="line">	public void add()&#123;</span><br><span class="line">		list.add(&quot;bjsxt&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	public int size()&#123;</span><br><span class="line">		return list.size();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		final ListAdd2 list2 = new ListAdd2();</span><br><span class="line"></span><br><span class="line">		// 1 实例化出来一个 lock</span><br><span class="line">		// 当使用wait 和 notify 的时候 ， 一定要配合着synchronized关键字去使用</span><br><span class="line">		//final Object lock = new Object();</span><br><span class="line"></span><br><span class="line">		final CountDownLatch countDownLatch = new CountDownLatch(1);</span><br><span class="line"></span><br><span class="line">		Thread t1 = new Thread(new Runnable() &#123;</span><br><span class="line">			@Override</span><br><span class="line">			public void run() &#123;</span><br><span class="line">				try &#123;</span><br><span class="line">					//synchronized (lock) &#123;</span><br><span class="line">						for(int i = 0; i &lt;10; i++)&#123;</span><br><span class="line">							list2.add();</span><br><span class="line">							System.out.println(&quot;当前线程：&quot; + Thread.currentThread().getName() + &quot;添加了一个元素..&quot;);</span><br><span class="line">							Thread.sleep(500);</span><br><span class="line">							if(list2.size() == 5)&#123;</span><br><span class="line">								System.out.println(&quot;已经发出通知..&quot;);</span><br><span class="line">								countDownLatch.countDown();</span><br><span class="line">								//lock.notify();</span><br><span class="line">							&#125;</span><br><span class="line">						&#125;</span><br><span class="line">					//&#125;</span><br><span class="line">				&#125; catch (InterruptedException e) &#123;</span><br><span class="line">					e.printStackTrace();</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;, &quot;t1&quot;);</span><br><span class="line"></span><br><span class="line">		Thread t2 = new Thread(new Runnable() &#123;</span><br><span class="line">			@Override</span><br><span class="line">			public void run() &#123;</span><br><span class="line">				//synchronized (lock) &#123;</span><br><span class="line">					if(list2.size() != 5)&#123;</span><br><span class="line">						try &#123;</span><br><span class="line">							//System.out.println(&quot;t2进入...&quot;);</span><br><span class="line">							//lock.wait();</span><br><span class="line">							countDownLatch.await();</span><br><span class="line">						&#125; catch (InterruptedException e) &#123;</span><br><span class="line">							e.printStackTrace();</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">					System.out.println(&quot;当前线程：&quot; + Thread.currentThread().getName() + &quot;收到通知线程停止..&quot;);</span><br><span class="line">					throw new RuntimeException();</span><br><span class="line">				//&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;, &quot;t2&quot;);</span><br><span class="line"></span><br><span class="line">		t2.start();</span><br><span class="line">		t1.start();</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">当前线程：t1添加了一个元素..</span><br><span class="line">当前线程：t1添加了一个元素..</span><br><span class="line">当前线程：t1添加了一个元素..</span><br><span class="line">当前线程：t1添加了一个元素..</span><br><span class="line">当前线程：t1添加了一个元素..</span><br><span class="line">已经发出通知..</span><br><span class="line">Exception in thread &quot;t2&quot; 当前线程：t1添加了一个元素..</span><br><span class="line">当前线程：t2收到通知线程停止..</span><br><span class="line">java.lang.RuntimeException</span><br><span class="line">	at com.bjsxt.base.conn008.ListAdd2$2.run(ListAdd2.java:68)</span><br><span class="line">	at java.lang.Thread.run(Thread.java:745)</span><br><span class="line">当前线程：t1添加了一个元素..</span><br><span class="line">当前线程：t1添加了一个元素..</span><br><span class="line">当前线程：t1添加了一个元素..</span><br><span class="line">当前线程：t1添加了一个元素..</span><br></pre></td></tr></table></figure>
<p>应用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">有一个client去连接zk,去连接的时候需要耗时1~2秒，但是主程序是不阻塞的一直往下走，这就会导致可能返回的zk还没有值，但是主线程已经拿着zk进行操作，就会出现空指针</span><br><span class="line">所以我们需要在主线程countDownLatch.await(),在zk连接成功返回时countDownLatch.countDown()</span><br></pre></td></tr></table></figure></p>
<h3 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h3><p>ThreadLocal概念:线程局部变量,是一种多线程间并发访问变量的解决方案.与其synchronized等加锁的方式不同, ThreadlLocal完全不提供锁,而使用以空问换时间的手段,为每个线程提供变量的独立副本,以保障线程安全<br>从性能上说, ThreadLocal不具有绝对的优势,在并发不是很高的时候,加锁的性能会更好,但作为一套与镇完全无关的线程安全解决方案,在高并发或者竞争激烈的场景,用ThreadLocal可以在一定程度上减少锁竞争。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">public class ConnThreadLocal &#123;</span><br><span class="line">	public static ThreadLocal&lt;String&gt; th = new ThreadLocal&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">	public void setTh(String value)&#123;</span><br><span class="line">		th.set(value);</span><br><span class="line">	&#125;</span><br><span class="line">	public void getTh()&#123;</span><br><span class="line">		System.out.println(Thread.currentThread().getName() + &quot;:&quot; + this.th.get());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">		final ConnThreadLocal ct = new ConnThreadLocal();</span><br><span class="line">		Thread t1 = new Thread(new Runnable() &#123;</span><br><span class="line">			@Override</span><br><span class="line">			public void run() &#123;</span><br><span class="line">				ct.setTh(&quot;张三&quot;);</span><br><span class="line">				ct.getTh();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;, &quot;t1&quot;);</span><br><span class="line"></span><br><span class="line">		Thread t2 = new Thread(new Runnable() &#123;</span><br><span class="line">			@Override</span><br><span class="line">			public void run() &#123;</span><br><span class="line">				try &#123;</span><br><span class="line">					Thread.sleep(1000);</span><br><span class="line">					ct.getTh();</span><br><span class="line">				&#125; catch (InterruptedException e) &#123;</span><br><span class="line">					e.printStackTrace();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;, &quot;t2&quot;);</span><br><span class="line"></span><br><span class="line">		t1.start();</span><br><span class="line">		t2.start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">t1:张三</span><br><span class="line">t2:null</span><br></pre></td></tr></table></figure>

                    
                        

                    
                    
                        <p>
                            <a href="/2019/09/07/多线程2/#post-footer" class="postShorten-excerpt_link link">
                                评论和共享
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a class="link-unstyled" href="/2019/09/07/常用类/">
                            常用类
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2019-09-07T10:23:08+08:00">
	
		    9月 07, 2019
    	
    </time>
    
</div>

            </div>
            
                <div class="postShorten-content">
                    <h3 id="Object类概述及其构造方法"><a href="#Object类概述及其构造方法" class="headerlink" title="Object类概述及其构造方法"></a>Object类概述及其构造方法</h3><h4 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h4><p>public Object()</p>
<h4 id="成员方法"><a href="#成员方法" class="headerlink" title="成员方法"></a>成员方法</h4><p>public int hashCode()<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A:返回该对象的哈希码值。默认情况下，该方法会根据对象的地址来计算</span><br><span class="line">B:不是实际地址值，可以理解为逻辑地址值。</span><br></pre></td></tr></table></figure></p>
<p>public final Class getClass()<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">A:返回对象的字节码文件对象，反射中我们会详细讲解</span><br><span class="line">B:可以通过Class类中的一个方法，获取对象的真实类的全名称。</span><br><span class="line">	public String getName()</span><br></pre></td></tr></table></figure></p>
<p>public String toString()<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">A:返回该对象的字符串表示。</span><br><span class="line">	底层源码。</span><br><span class="line">	public static String valueOf(Object obj) &#123;</span><br><span class="line">    return (obj == null) ? &quot;null&quot; : obj.toString();</span><br><span class="line">  &#125;</span><br><span class="line">B:它的值等于：</span><br><span class="line">	getClass().getName() + &apos;@&apos; + Integer.toHexString(hashCode())</span><br><span class="line">C:由于默认情况下的数据对我们来说没有意义，一般建议重写该方法，但是最终还是自动生成。</span><br></pre></td></tr></table></figure></p>
<p>public boolean equals(Object?obj)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">A:指示其他某个对象是否与此对象“相等”。</span><br><span class="line">B:默认情况下比较的是对象的引用是否相同。</span><br><span class="line">C:由于比较对象的引用没有意义，一般建议重写该方法，但是最终还是自动生成。</span><br><span class="line">D:两个注意问题:</span><br><span class="line">	·直接输出一个对象名称，其实默认调用了该对象的toString()方法。</span><br><span class="line">	·==和equals()的区别。(面试题)</span><br><span class="line">	A:==</span><br><span class="line">		基本类型：比较的是值是否相同</span><br><span class="line">		引用类型：比较的是地址值是否相同</span><br><span class="line">	B:equals()</span><br><span class="line">		只能比较引用类型。默认情况下，比较的是地址值是否相同。</span><br><span class="line">		但是，我们可以根据自己的需要重写该方法。</span><br></pre></td></tr></table></figure></p>
<p>protected void finalize()<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">A:当垃圾回收器确定不存在对该对象的更多引用时，由对象的垃圾回收器调用此方法。</span><br><span class="line">B:垃圾回收器不会马上回收垃圾，但是我们可以建议它尽快回收垃圾。(System.gc()方法)</span><br><span class="line">C:主要针对堆内存。</span><br></pre></td></tr></table></figure></p>
<p>protected Object clone()<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">创建并返回此对象的一个副本，这种克隆机制十分高效，而且二者之间完全隔离。</span><br><span class="line">自定义类实现克隆步骤：</span><br><span class="line">	A:自定义类实现Cloneable接口，这是个标记性接口，实现这个接口的类的对象可实现自我克隆。</span><br><span class="line">	B:自定义类中重写Object类的clone()方法。</span><br><span class="line">	C:重写clone()方法时通过super.clone()调用Object类的clone()方法来得到该对象的副本，并返回该副本。</span><br><span class="line"></span><br><span class="line">注意：A:克隆和两个引用指向同一个对象的区别?</span><br><span class="line">      B:Object类clone()方法虽然简单，易用，但仅仅是一种”浅克隆”,它只克隆该对象所有的Field值，        不会对引用类型的Field所引用的对象进行克隆。开发中，我们也可以实现对象的”深度克隆”。</span><br><span class="line"></span><br><span class="line">public class Student implements cloneable&#123;</span><br><span class="line">	...</span><br><span class="line">	@Override</span><br><span class="line">	protected Object clone()&#123;</span><br><span class="line">		return super.clone();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">public class StudentDemo&#123;</span><br><span class="line">	public static void main(String[] args)&#123;</span><br><span class="line">		Student s=new Student();</span><br><span class="line">		Object obj=s.clone();</span><br><span class="line">		Student s2=(Student)obj;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="Scanner类概述及其构造方法"><a href="#Scanner类概述及其构造方法" class="headerlink" title="Scanner类概述及其构造方法"></a>Scanner类概述及其构造方法</h3><h4 id="构造方法-1"><a href="#构造方法-1" class="headerlink" title="构造方法"></a>构造方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">A:讲解了System.in这个东西。</span><br><span class="line">	它其实是标准的输入流,对应于键盘录入</span><br><span class="line">B:构造方法</span><br><span class="line">	InputStream is = System.in;</span><br><span class="line"></span><br><span class="line">	Scanner(InputStream is)</span><br><span class="line">C:常用的格式</span><br><span class="line">	Scanner sc = new Scanner(System.in);</span><br></pre></td></tr></table></figure>
<h4 id="基本方法格式"><a href="#基本方法格式" class="headerlink" title="基本方法格式"></a>基本方法格式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A:hasNextXxx() 判断是否是某种类型的</span><br><span class="line">B:nextXxx()	返回某种类型的元素</span><br></pre></td></tr></table></figure>
<h4 id="掌握的两个方法"><a href="#掌握的两个方法" class="headerlink" title="掌握的两个方法"></a>掌握的两个方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A:public int nextInt()</span><br><span class="line">B:public String nextLine()</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">需要注意的小问题</span><br><span class="line">A:同一个Scanner对象，先获取数值，再获取字符串会出现一个小问题。</span><br><span class="line">B:解决方案：</span><br><span class="line">	a:重新定义一个Scanner对象</span><br><span class="line">	b:把所有的数据都用字符串获取，然后再进行相应的转换</span><br></pre></td></tr></table></figure>
<h3 id="String类概述及其构造方法"><a href="#String类概述及其构造方法" class="headerlink" title="String类概述及其构造方法"></a>String类概述及其构造方法</h3><h4 id="构造方法-2"><a href="#构造方法-2" class="headerlink" title="构造方法"></a>构造方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public String()</span><br><span class="line">public String(byte[] bytes)</span><br><span class="line">public String(byte[] bytes,int offset,int length)</span><br><span class="line">public String(char[] value)</span><br><span class="line">public String(char[] value,int offset,int count)</span><br><span class="line">public String(String original)</span><br><span class="line">·注意：</span><br><span class="line">  String s = “helloworld”;</span><br><span class="line">  s也是一个对象。</span><br></pre></td></tr></table></figure>
<h4 id="String类的特点及面试题"><a href="#String类的特点及面试题" class="headerlink" title="String类的特点及面试题"></a>String类的特点及面试题</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">·字符串一旦被赋值，就不能改变。（这里指的是字符串的内容不能改变，而不是引用不能改变。）</span><br><span class="line">·String s = new String(&quot;hello&quot;);和String s = &quot;hello&quot;的区别?</span><br><span class="line">  前者创建2个对象，后者创建1个对象。</span><br><span class="line"></span><br><span class="line">说一下字符串中的equals()方法重写了Object()的方法，比较的是内容。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">A:==和equals()</span><br><span class="line">		String s1 = new String(&quot;hello&quot;);</span><br><span class="line">		String s2 = new String(&quot;hello&quot;);</span><br><span class="line">		System.out.println(s1 == s2);// false</span><br><span class="line">		System.out.println(s1.equals(s2));// true</span><br><span class="line"></span><br><span class="line">		String s3 = new String(&quot;hello&quot;);</span><br><span class="line">		String s4 = &quot;hello&quot;;</span><br><span class="line">		System.out.println(s3 == s4);// false</span><br><span class="line">		System.out.println(s3.equals(s4));// true</span><br><span class="line"></span><br><span class="line">		String s5 = &quot;hello&quot;;</span><br><span class="line">		String s6 = &quot;hello&quot;;</span><br><span class="line">		System.out.println(s5 == s6);// true</span><br><span class="line">		System.out.println(s5.equals(s6));// true</span><br><span class="line">B:字符串的拼接</span><br><span class="line">		String s1 = &quot;hello&quot;;</span><br><span class="line">		String s2 = &quot;world&quot;;</span><br><span class="line">		String s3 = &quot;helloworld&quot;;</span><br><span class="line">		System.out.println(s3 == s1 + s2);// false</span><br><span class="line">		System.out.println(s3.equals((s1 + s2)));// true</span><br><span class="line"></span><br><span class="line">		System.out.println(s3 == &quot;hello&quot; + &quot;world&quot;);// true</span><br><span class="line">		System.out.println(s3.equals(&quot;hello&quot; + &quot;world&quot;));// true</span><br><span class="line"></span><br><span class="line">字符串如果是变量相加，先开空间，再拼接。</span><br><span class="line">字符串如果是常量相加，是先加，然后在常量池找，如果有就直接返回，否则，就创建。</span><br></pre></td></tr></table></figure>
<h4 id="String类的判断功能"><a href="#String类的判断功能" class="headerlink" title="String类的判断功能"></a>String类的判断功能</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">boolean equals(Object obj)：区分大小写</span><br><span class="line">boolean equalsIgnoreCase(String str)：忽略大小写</span><br><span class="line">boolean contains(String str)：判断大字符串中是否包含小字符串</span><br><span class="line">boolean startsWith(String str)：判断字符串是否以某个指定的字符串开头</span><br><span class="line">boolean endsWith(String str)：</span><br><span class="line">boolean isEmpty()判断字符串内容是否为空</span><br></pre></td></tr></table></figure>
<h4 id="String类的获取功能"><a href="#String类的获取功能" class="headerlink" title="String类的获取功能"></a>String类的获取功能</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int length()</span><br><span class="line">char charAt(int index)</span><br><span class="line">int indexOf(int ch)</span><br><span class="line">int indexOf(String str)</span><br><span class="line">int indexOf(int ch,int fromIndex)</span><br><span class="line">int indexOf(String str,int fromIndex)</span><br><span class="line">String substring(int start)</span><br><span class="line">String substring(int start,int end)（包start不包end）</span><br></pre></td></tr></table></figure>
<h4 id="String类的转换功能"><a href="#String类的转换功能" class="headerlink" title="String类的转换功能"></a>String类的转换功能</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">byte[] getBytes()</span><br><span class="line">char[] toCharArray()</span><br><span class="line">static String valueOf(char[] chs)</span><br><span class="line">static String valueOf(int i)</span><br><span class="line">String toLowerCase()</span><br><span class="line">String toUpperCase()</span><br><span class="line">String concat(String str）</span><br></pre></td></tr></table></figure>
<h4 id="String类的其他功能"><a href="#String类的其他功能" class="headerlink" title="String类的其他功能"></a>String类的其他功能</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">·替换功能</span><br><span class="line">  String replace(char old,char new)</span><br><span class="line">  String replace(String old,String new)</span><br><span class="line">·去除字符串两空格</span><br><span class="line">  String trim()</span><br><span class="line">·按字典顺序比较两个字符串</span><br><span class="line">  int compareTo(String str)</span><br><span class="line">  int compareToIgnoreCase(String str)</span><br></pre></td></tr></table></figure>
<h3 id="StringBuffer类概述"><a href="#StringBuffer类概述" class="headerlink" title="StringBuffer类概述"></a>StringBuffer类概述</h3><p>用字符串做拼接，比较耗时并且也耗内存，而这种拼接操作又是比较常见的，为   了解决这个问题，Java就提供了一个字符串缓冲区类。StringBuffer供我们使用</p>
<h4 id="构造方法-3"><a href="#构造方法-3" class="headerlink" title="构造方法"></a>构造方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">StringBuffer()</span><br><span class="line">StringBuffer(int size)</span><br><span class="line">StringBuffer(String str)</span><br></pre></td></tr></table></figure>
<h4 id="成员方法-1"><a href="#成员方法-1" class="headerlink" title="成员方法"></a>成员方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">·添加功能</span><br><span class="line">  public StringBuffer append(String str)</span><br><span class="line">  public StringBuffer insert(int offset,String str)</span><br><span class="line">·删除功能</span><br><span class="line">  public StringBuffer deleteCharAt(int index)</span><br><span class="line">  public StringBuffer delete(int start,int end)</span><br><span class="line">·替换功能</span><br><span class="line">  public StringBuffer replace(int start,int end,String str)</span><br><span class="line">·反转功能</span><br><span class="line">  public StringBuffer reverse()</span><br><span class="line">·截取功能</span><br><span class="line">  public String substring(int start)</span><br><span class="line">  public String substring(int start,int end)</span><br><span class="line">  截取功能和前面几个功能的不同</span><br><span class="line">  返回值类型是String类型，本身没有发生改变</span><br></pre></td></tr></table></figure>
<h4 id="StringBuffer和String的区别"><a href="#StringBuffer和String的区别" class="headerlink" title="StringBuffer和String的区别?"></a>StringBuffer和String的区别?</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">前者长度和内容可变，后者不可变</span><br><span class="line">如果使用前者做字符串的拼接，不会浪费太多的资源</span><br></pre></td></tr></table></figure>
<h4 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">小细节：</span><br><span class="line">	StringBuffer：同步的，数据安全，效率低。</span><br><span class="line">	StringBuilder：不同步的，数据不安全，效率高。</span><br><span class="line">A:String,StringBuffer,StringBuilder的区别</span><br><span class="line">B:StringBuffer和数组的区别?</span><br><span class="line">	二者都可以看做是一个容器，装其他的数据，</span><br><span class="line">	但是，StringBuffer的数据最终是一个字符串数据</span><br><span class="line">	而数组可以放置多种数据，但必须是同一种类型</span><br></pre></td></tr></table></figure>
<h4 id="String作为形式参数，StringBuffer作为形式参数。"><a href="#String作为形式参数，StringBuffer作为形式参数。" class="headerlink" title="String作为形式参数，StringBuffer作为形式参数。"></a>String作为形式参数，StringBuffer作为形式参数。</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    String s1=&quot;hello&quot;;</span><br><span class="line">    String s2=&quot;world&quot;;</span><br><span class="line">    System.out.println(s1+&quot;---&quot;+s2);</span><br><span class="line">    change(s1,s2);</span><br><span class="line">    System.out.println(s1+&quot;---&quot;+s2);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    StringBuffer sb1=new StringBuffer(&quot;hello&quot;);</span><br><span class="line">    StringBuffer sb2=new StringBuffer(&quot;world&quot;);</span><br><span class="line">    System.out.println(sb1+&quot;---&quot;+sb2);</span><br><span class="line">    change(sb1,sb2);</span><br><span class="line">    System.out.println(sb1+&quot;---&quot;+sb2);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">private static void change(String s1,String s2)&#123;</span><br><span class="line">    s1 = s2;</span><br><span class="line">    s2 = s1 + s2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static void change(StringBuffer sb1,StringBuffer sb2)&#123;</span><br><span class="line">    sb1 = sb2;</span><br><span class="line">    sb1.append(sb2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hello---world</span><br><span class="line">hello---world</span><br><span class="line">hello---world</span><br><span class="line">hello---worldworld</span><br></pre></td></tr></table></figure>
<h3 id="数组高级"><a href="#数组高级" class="headerlink" title="数组高级"></a>数组高级</h3><h4 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h4><p>相邻元素两两比较，大的往后放，第一次完毕，最大值出现在了最大索引处。同理，其他的元素就可以排好。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public static void bubbleSort(int[] arr) &#123;</span><br><span class="line">	for(int x=0; x&lt;arr.length-1; x++) &#123;</span><br><span class="line">		for(int y=0; y&lt;arr.length-1-x; y++) &#123;</span><br><span class="line">			if(arr[y] &gt; arr[y+1]) &#123;</span><br><span class="line">				int temp = arr[y];</span><br><span class="line">				arr[y] = arr[y+1];</span><br><span class="line">				arr[y+1] = temp;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h4><p>把0索引的元素，和索引1以后的元素都进行比较，第一次完毕，最小值出现在了0索引。同理，其他的元素就可以排好。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public static void selectSort(int[] arr) &#123;</span><br><span class="line">	for(int x=0; x&lt;arr.length-1; x++) &#123;</span><br><span class="line">		for(int y=x+1; y&lt;arr.length; y++) &#123;</span><br><span class="line">			if(arr[y] &lt; arr[x]) &#123;</span><br><span class="line">				int temp = arr[x];</span><br><span class="line">				arr[x] = arr[y];</span><br><span class="line">				arr[y] = temp;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="基本查找"><a href="#基本查找" class="headerlink" title="基本查找"></a>基本查找</h4><p>针对数组无序的情况<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public static int getIndex(int[] arr,int value) &#123;</span><br><span class="line">	int index = -1;</span><br><span class="line"></span><br><span class="line">	for(int x=0; x&lt;arr.length; x++) &#123;</span><br><span class="line">		if(arr[x] == value) &#123;</span><br><span class="line">			index = x;</span><br><span class="line">			break;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	return index;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="二分查找-折半查找"><a href="#二分查找-折半查找" class="headerlink" title="二分查找(折半查找)"></a>二分查找(折半查找)</h4><p>针对数组有序的情况(千万不要先排序，在查找)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public static int binarySearch(int[] arr,int value) &#123;</span><br><span class="line">	int min = 0;</span><br><span class="line">	int max = arr.length-1;</span><br><span class="line">	int mid = (min+max)/2;</span><br><span class="line"></span><br><span class="line">	while(arr[mid] != value) &#123;</span><br><span class="line">		if(arr[mid] &gt; value) &#123;</span><br><span class="line">			max = mid - 1;</span><br><span class="line">		&#125;else if(arr[mid] &lt; value) &#123;</span><br><span class="line">			min = mid + 1;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		if(min &gt; max) &#123;</span><br><span class="line">			return -1;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		mid = (min+max)/2;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	return mid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="Arrays类概述及其常用方法"><a href="#Arrays类概述及其常用方法" class="headerlink" title="Arrays类概述及其常用方法"></a>Arrays类概述及其常用方法</h3><h4 id="Arrays类概述"><a href="#Arrays类概述" class="headerlink" title="Arrays类概述"></a>Arrays类概述</h4><p>针对数组进行操作的工具类。<br>提供了排序，查找等功能。</p>
<h4 id="成员方法-2"><a href="#成员方法-2" class="headerlink" title="成员方法"></a>成员方法</h4><p>  public static String toString(int[] a)<br>  public static void sort(int[] a)<br>  public static int binarySearch(int[] a,int key)</p>
<h3 id="基本类型包装类概述"><a href="#基本类型包装类概述" class="headerlink" title="基本类型包装类概述"></a>基本类型包装类概述</h3><p>·常用的操作之一：用于基本数据类型与字符串之间的转换。<br>·基本类型和包装类的对应<br>  Byte,Short,Integer,Long,Float,Double，Character,Boolean</p>
<h4 id="Integer类概述及其构造方法"><a href="#Integer类概述及其构造方法" class="headerlink" title="Integer类概述及其构造方法"></a>Integer类概述及其构造方法</h4><h5 id="构造方法-4"><a href="#构造方法-4" class="headerlink" title="构造方法"></a>构造方法</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  public Integer(int value)</span><br><span class="line">  public Integer(String s)</span><br><span class="line">	A:Integer i = new Integer(100);</span><br><span class="line">	B:Integer i = new Integer(&quot;100&quot;);</span><br><span class="line">·注意：这里的字符串必须是由数字字符组成</span><br></pre></td></tr></table></figure>
<h5 id="成员方法-3"><a href="#成员方法-3" class="headerlink" title="成员方法"></a>成员方法</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">·int类型和String类型的相互转换</span><br><span class="line">A:String -- int</span><br><span class="line">	Integer.parseInt(&quot;100&quot;);</span><br><span class="line">B:int -- String</span><br><span class="line">	String.valueOf(100);</span><br><span class="line"></span><br><span class="line">public int intValue()</span><br><span class="line">public static int parseInt(String s)</span><br><span class="line">public static String toString(int i)</span><br><span class="line">public static Integer valueOf(int i)</span><br><span class="line">public static Integer valueOf(String s)</span><br><span class="line"></span><br><span class="line">·常用的基本进制转换</span><br><span class="line">  public static String toBinaryString(int i)</span><br><span class="line">  public static String toOctalString(int i)</span><br><span class="line">  public static String toHexString(int i)</span><br><span class="line">·十进制到其他进制</span><br><span class="line">  public static String toString(int i,int radix)</span><br><span class="line">·其他进制到十进制</span><br><span class="line">  public static int parseInt(String s,int radix)</span><br><span class="line">·Java程序中的进制范围</span><br><span class="line">	2-36</span><br></pre></td></tr></table></figure>
<h5 id="JDK5的新特性"><a href="#JDK5的新特性" class="headerlink" title="JDK5的新特性"></a>JDK5的新特性</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">·JDK1.5以后，简化了定义方式。</span><br><span class="line">  Integer x = new Integer(4);可以直接写成</span><br><span class="line">  Integer x = 4;//自动装箱。</span><br><span class="line">  x  = x + 5;//自动拆箱。通过intValue方法。</span><br><span class="line">·需要注意：</span><br><span class="line">  在使用时，Integer  x = null;上面的代码就会出现NullPointerException。</span><br></pre></td></tr></table></figure>
<h5 id="面试题-1"><a href="#面试题-1" class="headerlink" title="面试题"></a>面试题</h5><p>缓冲池(看程序写结果)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Integer i1 = new Integer(127);</span><br><span class="line">Integer i2 = new Integer(127);</span><br><span class="line">System.out.println(i1 == i2);</span><br><span class="line">System.out.println(i1.equals(i2));</span><br><span class="line"></span><br><span class="line">Integer i3 = new Integer(128);</span><br><span class="line">Integer i4 = new Integer(128);</span><br><span class="line">System.out.println(i3 == i4);</span><br><span class="line">System.out.println(i3.equals(i4));</span><br><span class="line"></span><br><span class="line">Integer i5 = 127;</span><br><span class="line">Integer i6 = 127;</span><br><span class="line">System.out.println(i5 == i6);</span><br><span class="line">System.out.println(i5.equals(i6));</span><br><span class="line"></span><br><span class="line">Integer.valueOf(127);</span><br><span class="line"></span><br><span class="line">Integer i7 = 128;</span><br><span class="line">Integer i8 = 128;</span><br><span class="line">System.out.println(i7 == i8);</span><br><span class="line">System.out.println(i7.equals(i8));</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">false</span><br><span class="line">true</span><br><span class="line">false</span><br><span class="line">true</span><br><span class="line">true</span><br><span class="line">true</span><br><span class="line">false</span><br><span class="line">true</span><br></pre></td></tr></table></figure>
<p>注意：Integer的数据直接赋值，如果在-128到127之间，会直接从缓冲池里去取数据<br>针对-128到127之间的数据，做了一个数据缓冲池。</p>
<h4 id="Character类概述及其构造方法"><a href="#Character类概述及其构造方法" class="headerlink" title="Character类概述及其构造方法"></a>Character类概述及其构造方法</h4><h5 id="构造方法-5"><a href="#构造方法-5" class="headerlink" title="构造方法"></a>构造方法</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> public Character(char value)</span><br><span class="line">Character ch = new Character(&apos;a&apos;);</span><br></pre></td></tr></table></figure>
<h5 id="成员方法-4"><a href="#成员方法-4" class="headerlink" title="成员方法"></a>成员方法</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">  public static boolean isUpperCase(char ch)</span><br><span class="line">  public static boolean isLowerCase(char ch)</span><br><span class="line">  public static boolean isDigit(char ch)</span><br><span class="line">  public static char toUpperCase(char ch)</span><br><span class="line">  public static char toLowerCase(char ch)</span><br><span class="line"></span><br><span class="line">A:判断给定的字符是否是大写</span><br><span class="line">B:判断给定的字符是否是小写</span><br><span class="line">C:判断给定的字符是否是数字字符</span><br><span class="line">D:把给定的字符转成大写</span><br><span class="line">E:把给定的字符转成小写</span><br></pre></td></tr></table></figure>
<h3 id="正则表达式概述及基本使用"><a href="#正则表达式概述及基本使用" class="headerlink" title="正则表达式概述及基本使用"></a>正则表达式概述及基本使用</h3><p>正则表达式：是指一个用来描述或者匹配一系列符合某个句法规则的字符串的单个字符串。其实就是一种规则。有自己特殊的应用。</p>
<h4 id="常见规则"><a href="#常见规则" class="headerlink" title="常见规则"></a>常见规则</h4><p>字符:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x 字符 x。举例：&apos;a&apos;表示字符a</span><br><span class="line">\\ 反斜线字符。</span><br><span class="line">\n 新行（换行）符 (&apos;\u000A&apos;)</span><br><span class="line">\r 回车符 (&apos;\u000D&apos;)</span><br></pre></td></tr></table></figure></p>
<p>字符类:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[abc] a、b 或 c（简单类）</span><br><span class="line">[^abc] 任何字符，除了 a、b 或 c（否定）</span><br><span class="line">[a-zA-Z] a到 z 或 A到 Z，两头的字母包括在内（范围）</span><br><span class="line">[0-9] 0到9的字符都包括</span><br></pre></td></tr></table></figure></p>
<p>预定义字符类:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">. 任何字符。我的就是.字符本身，怎么表示呢? \.</span><br><span class="line">\d 数字：[0-9]</span><br><span class="line">\w 单词字符：[a-zA-Z_0-9]</span><br><span class="line">	在正则表达式里面组成单词的东西必须有这些东西组成</span><br></pre></td></tr></table></figure></p>
<p>边界匹配器:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">^ 行的开头</span><br><span class="line">$ 行的结尾</span><br><span class="line">\b 单词边界</span><br><span class="line">	就是不是单词字符的地方。</span><br><span class="line">	举例：hello world?haha;xixi</span><br></pre></td></tr></table></figure></p>
<p>Greedy 数量词:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">X? X，一次或一次也没有</span><br><span class="line">X* X，零次或多次</span><br><span class="line">X+ X，一次或多次</span><br><span class="line">X&#123;n&#125; X，恰好 n 次</span><br><span class="line">X&#123;n,&#125; X，至少 n 次</span><br><span class="line">X&#123;n,m&#125; X，至少 n 次，但是不超过 m 次</span><br></pre></td></tr></table></figure></p>
<h4 id="常见功能：-分别用的是谁呢"><a href="#常见功能：-分别用的是谁呢" class="headerlink" title="常见功能：(分别用的是谁呢?)"></a>常见功能：(分别用的是谁呢?)</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">A:判断功能</span><br><span class="line">	String类的public boolean matches(String regex)</span><br><span class="line">B:分割功能</span><br><span class="line">	String类的public String[] split(String regex)</span><br><span class="line">C:替换功能</span><br><span class="line">	String类的public String replaceAll(String regex,String replacement)</span><br><span class="line">D:获取功能</span><br><span class="line">	Pattern和Matcher</span><br><span class="line">		Pattern p = Pattern.compile(&quot;a*b&quot;);</span><br><span class="line">		Matcher m = p.matcher(&quot;aaaaab&quot;);</span><br><span class="line"></span><br><span class="line">		find():查找存不存在</span><br><span class="line">		group():获取刚才查找过的数据</span><br></pre></td></tr></table></figure>
<p>判断:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public static booleam chackQQ(String qq)&#123;</span><br><span class="line">	String reqex=&quot;[1-9][0-9]&#123;4,14&#125;&quot;;</span><br><span class="line">	booleam flag=qq.matches(reqex);</span><br><span class="line">	return flag;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static booleam chackEmail(String email)&#123;</span><br><span class="line">	String reqex=&quot;[a-zA-Z_0-9]+@[a-zA-Z_0-9]&#123;2,6&#125;(\\.[a-zA-Z-0-9]&#123;2,3&#125;)+&quot;;</span><br><span class="line">//	String reqex=&quot;\\w+@\\w&#123;2,6&#125;(\\.\\w&#123;2,3&#125;)+&quot;;</span><br><span class="line">	booleam flag=email.matches(reqex);</span><br><span class="line">	return flag;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>分割:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">String ages = &quot;18-24&quot;;</span><br><span class="line"></span><br><span class="line">String regex = &quot;-&quot;;</span><br><span class="line"></span><br><span class="line">String[] strArray = ages.split(regex);</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">	// 定义一个字符串</span><br><span class="line">	String s1 = &quot;aa,bb,cc&quot;;</span><br><span class="line">	// 直接分割</span><br><span class="line">	String[] str1Array = s1.split(&quot;,&quot;);</span><br><span class="line">	for (int x = 0; x &lt; str1Array.length; x++) &#123;</span><br><span class="line">		System.out.println(str1Array[x]);</span><br><span class="line">	&#125;</span><br><span class="line">	System.out.println(&quot;---------------------&quot;);</span><br><span class="line"></span><br><span class="line">	String s2 = &quot;aa.bb.cc&quot;;</span><br><span class="line">	String[] str2Array = s2.split(&quot;\\.&quot;);</span><br><span class="line">	for (int x = 0; x &lt; str2Array.length; x++) &#123;</span><br><span class="line">		System.out.println(str2Array[x]);</span><br><span class="line">	&#125;</span><br><span class="line">	System.out.println(&quot;---------------------&quot;);</span><br><span class="line"></span><br><span class="line">	String s3 = &quot;aa    bb                cc&quot;;</span><br><span class="line">	String[] str3Array = s3.split(&quot; +&quot;);</span><br><span class="line">	for (int x = 0; x &lt; str3Array.length; x++) &#123;</span><br><span class="line">		System.out.println(str3Array[x]);</span><br><span class="line">	&#125;</span><br><span class="line">	System.out.println(&quot;---------------------&quot;);</span><br><span class="line"></span><br><span class="line">	//硬盘上的路径，我们应该用\\替代\</span><br><span class="line">	String s4 = &quot;E:\\JavaSE\\day14\\avi&quot;;</span><br><span class="line">	String[] str4Array = s4.split(&quot;\\\\&quot;);</span><br><span class="line">	for (int x = 0; x &lt; str4Array.length; x++) &#123;</span><br><span class="line">		System.out.println(str4Array[x]);</span><br><span class="line">	&#125;</span><br><span class="line">	System.out.println(&quot;---------------------&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>替换:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"> 	String类的public String replaceAll(String regex,String replacement)</span><br><span class="line"> 	使用给定的 replacement 替换此字符串所有匹配给定的正则表达式的子字符串。</span><br><span class="line">public class RegexDemo &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		// 定义一个字符串</span><br><span class="line">		String s = &quot;helloqq12345worldkh622112345678java&quot;;</span><br><span class="line"></span><br><span class="line">		// 我要去除所有的数字,用*给替换掉</span><br><span class="line">		// String regex = &quot;\\d+&quot;;</span><br><span class="line">		// String regex = &quot;\\d&quot;;</span><br><span class="line">		//String ss = &quot;*&quot;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		// 直接把数字干掉</span><br><span class="line">		String regex = &quot;\\d+&quot;;</span><br><span class="line">		String ss = &quot;&quot;;</span><br><span class="line"></span><br><span class="line">		String result = s.replaceAll(regex, ss);</span><br><span class="line">		System.out.println(result);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>获取:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">		Pattern和Matcher类的使用</span><br><span class="line"></span><br><span class="line">		模式和匹配器的基本使用顺序</span><br><span class="line"></span><br><span class="line">public class RegexDemo &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		// 模式和匹配器的典型调用顺序</span><br><span class="line">		// 把正则表达式编译成模式对象</span><br><span class="line">		Pattern p = Pattern.compile(&quot;a*b&quot;);</span><br><span class="line">		// 通过模式对象得到匹配器对象，这个时候需要的是被匹配的字符串</span><br><span class="line">		Matcher m = p.matcher(&quot;aaaaab&quot;);</span><br><span class="line">		// 调用匹配器对象的功能</span><br><span class="line">		boolean b = m.matches();</span><br><span class="line">		System.out.println(b);</span><br><span class="line"></span><br><span class="line">		//这个是判断功能，但是如果做判断，这样做就有点麻烦了，我们直接用字符串的方法做</span><br><span class="line">		String s = &quot;aaaaab&quot;;</span><br><span class="line">		String regex = &quot;a*b&quot;;</span><br><span class="line">		boolean bb = s.matches(regex);</span><br><span class="line">		System.out.println(bb);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">				find():查找存不存在</span><br><span class="line">				group():获取刚才查找过的数据</span><br></pre></td></tr></table></figure></p>
<h3 id="Math类概述"><a href="#Math类概述" class="headerlink" title="Math类概述"></a>Math类概述</h3><p>Math 类包含用于执行基本数学运算的方法，如初等指数、对数、平方根和三角函数。</p>
<h4 id="成员方法-5"><a href="#成员方法-5" class="headerlink" title="成员方法"></a>成员方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public static int abs(int a)绝对值</span><br><span class="line">public static double ceil(double a)向上取整</span><br><span class="line">public static double floor(double a)向下取整</span><br><span class="line">public static int max(int a,int b) 两个数据中的大值  min自学</span><br><span class="line">public static double pow(double a,double b)a的b次幂</span><br><span class="line">public static double random()随机数</span><br><span class="line">public static int round(float a)  四舍五入  参数为double的自学</span><br><span class="line">public static double sqrt(double a)正平方根</span><br></pre></td></tr></table></figure>
<h3 id="Random类概述及其构造方法"><a href="#Random类概述及其构造方法" class="headerlink" title="Random类概述及其构造方法"></a>Random类概述及其构造方法</h3><p>Random:产生随机数的类</p>
<h4 id="构造方法-6"><a href="#构造方法-6" class="headerlink" title="构造方法"></a>构造方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public Random():没有给种子，用的是默认种子，是当前时间的毫秒值</span><br><span class="line">public Random(long seed):给出指定的种子</span><br><span class="line"></span><br><span class="line">给定种子后，每次得到的随机数是相同的。</span><br></pre></td></tr></table></figure>
<h4 id="成员方法-6"><a href="#成员方法-6" class="headerlink" title="成员方法"></a>成员方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public int nextInt()：返回的是int范围内的随机数</span><br><span class="line">public int nextInt(int n):返回的是[0,n)范围的内随机数</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class RandomDemo &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		// 创建对象</span><br><span class="line">		// Random r = new Random();</span><br><span class="line">		Random r = new Random(1111);</span><br><span class="line"></span><br><span class="line">		for (int x = 0; x &lt; 10; x++) &#123;</span><br><span class="line">			// int num = r.nextInt();</span><br><span class="line">			int num = r.nextInt(100) + 1;</span><br><span class="line">			System.out.println(num);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="System类概述及其成员方法"><a href="#System类概述及其成员方法" class="headerlink" title="System类概述及其成员方法"></a>System类概述及其成员方法</h3><h4 id="System类概述"><a href="#System类概述" class="headerlink" title="System类概述"></a>System类概述</h4><p>System 类包含一些有用的类字段和方法。它不能被实例化。</p>
<h4 id="成员方法-7"><a href="#成员方法-7" class="headerlink" title="成员方法"></a>成员方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public static void gc()运行垃圾回收器</span><br><span class="line">public static void exit(int status)终止当前正在运行的 Java 虚拟机。参数用作状态码；根据惯例，非 0 的状态码表示异常终止。</span><br><span class="line">public static long currentTimeMillis()返回以毫秒为单位的当前时间</span><br><span class="line">public static void arraycopy(Object src,int srcPos,Object dest,int destPos,int length)数组复制</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class Person &#123;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	protected void finalize() throws Throwable &#123;</span><br><span class="line">		System.out.println(&quot;当前的对象被回收了&quot; + this);</span><br><span class="line">		super.finalize();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class SystemDemo &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		Person p = new Person(&quot;赵雅芝&quot;, 60);</span><br><span class="line">		System.out.println(p);</span><br><span class="line"></span><br><span class="line">		p = null; // 让p不再指定堆内存</span><br><span class="line">		System.gc();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class SystemDemo &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		// 定义数组</span><br><span class="line">		int[] arr = &#123; 11, 22, 33, 44, 55 &#125;;</span><br><span class="line">		int[] arr2 = &#123; 6, 7, 8, 9, 10 &#125;;</span><br><span class="line"></span><br><span class="line">		// 请大家看这个代码的意思</span><br><span class="line">		System.arraycopy(arr, 1, arr2, 2, 2);</span><br><span class="line"></span><br><span class="line">		System.out.println(Arrays.toString(arr));</span><br><span class="line">		System.out.println(Arrays.toString(arr2));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[11, 22, 33, 44, 55]</span><br><span class="line">[6, 7, 22, 33, 10]</span><br></pre></td></tr></table></figure>
<h3 id="BigInteger类概述及其构造方法"><a href="#BigInteger类概述及其构造方法" class="headerlink" title="BigInteger类概述及其构造方法"></a>BigInteger类概述及其构造方法</h3><p>BigInteger:可以让超过Integer范围内的数据进行运算</p>
<h4 id="构造方法-7"><a href="#构造方法-7" class="headerlink" title="构造方法"></a>构造方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BigInteger(String val)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class BigIntegerDemo &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		// 这几个测试，是为了简单超过int范围内，Integer就不能再表示，所以就更谈不上计算了。</span><br><span class="line">		// Integer i = new Integer(100);</span><br><span class="line">		// System.out.println(i);</span><br><span class="line">		// // System.out.println(Integer.MAX_VALUE);</span><br><span class="line">		// Integer ii = new Integer(&quot;2147483647&quot;);</span><br><span class="line">		// System.out.println(ii);</span><br><span class="line">		// // NumberFormatException</span><br><span class="line">		// Integer iii = new Integer(&quot;2147483648&quot;);</span><br><span class="line">		// System.out.println(iii);</span><br><span class="line"></span><br><span class="line">		// 通过大整数来创建对象</span><br><span class="line">		BigInteger bi = new BigInteger(&quot;2147483648&quot;);</span><br><span class="line">		System.out.println(&quot;bi:&quot; + bi);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="成员方法-8"><a href="#成员方法-8" class="headerlink" title="成员方法"></a>成员方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public BigInteger add(BigInteger val):加</span><br><span class="line">public BigInteger subtract(BigInteger val):减</span><br><span class="line">public BigInteger multiply(BigInteger val):乘</span><br><span class="line">public BigInteger divide(BigInteger val):除</span><br><span class="line">public BigInteger[] divideAndRemainder(BigInteger val):返回商和余数的数组</span><br></pre></td></tr></table></figure>
<h3 id="BigDecimal类概述及其构造方法"><a href="#BigDecimal类概述及其构造方法" class="headerlink" title="BigDecimal类概述及其构造方法"></a>BigDecimal类概述及其构造方法</h3><p>因为float类型的数据存储和整数不一样导致的。它们大部分的时候，都是带有有效数字位。<br>由于在运算的时候，float类型和double很容易丢失精度，演示案例。所以，为了能精确的表示、计算浮点数，Java提供了BigDecimal<br>BigDecimal类：不可变的、任意精度的有符号十进制数,可以解决数据丢失问题。</p>
<h4 id="成员方法-9"><a href="#成员方法-9" class="headerlink" title="成员方法"></a>成员方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public BigDecimal add(BigDecimal augend)</span><br><span class="line">public BigDecimal subtract(BigDecimal subtrahend)</span><br><span class="line">public BigDecimal multiply(BigDecimal multiplicand)</span><br><span class="line">public BigDecimal divide(BigDecimal divisor)</span><br><span class="line">public BigDecimal divide(BigDecimal divisor,int scale,int roundingMode):商，几位小数，如何舍取</span><br></pre></td></tr></table></figure>
<h3 id="Date类概述及其方法"><a href="#Date类概述及其方法" class="headerlink" title="Date类概述及其方法"></a>Date类概述及其方法</h3><h4 id="Date类概述"><a href="#Date类概述" class="headerlink" title="Date类概述"></a>Date类概述</h4><p>类 Date 表示特定的瞬间，精确到毫秒。</p>
<h4 id="构造方法-8"><a href="#构造方法-8" class="headerlink" title="构造方法"></a>构造方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Date():根据当前的默认毫秒值创建日期对象</span><br><span class="line">Date(long date)：根据给定的毫秒值创建日期对象</span><br></pre></td></tr></table></figure>
<h4 id="成员方法-10"><a href="#成员方法-10" class="headerlink" title="成员方法"></a>成员方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public long getTime():获取时间，以毫秒为单位</span><br><span class="line">public void setTime(long time):设置时间</span><br></pre></td></tr></table></figure>
<h3 id="DateFormat类概述及其方法"><a href="#DateFormat类概述及其方法" class="headerlink" title="DateFormat类概述及其方法"></a>DateFormat类概述及其方法</h3><p>DateForamt:可以进行日期和字符串的格式化和解析，但是由于是抽象类，所以使用具体子类SimpleDateFormat。</p>
<h4 id="构造方法-9"><a href="#构造方法-9" class="headerlink" title="构造方法"></a>构造方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public SimpleDateFormat():默认模式</span><br><span class="line">public SimpleDateFormat(String pattern):给定的模式</span><br></pre></td></tr></table></figure>
<h4 id="成员方法-11"><a href="#成员方法-11" class="headerlink" title="成员方法"></a>成员方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public final String format(Date date)  Date	 --	 String(格式化)</span><br><span class="line">public Date parse(String source)       String -- Date(解析)</span><br><span class="line">年 y</span><br><span class="line">月 M</span><br><span class="line">日 d</span><br><span class="line">时 H</span><br><span class="line">分 m</span><br><span class="line">秒 s</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class DateFormatDemo &#123;</span><br><span class="line">	public static void main(String[] args) throws ParseException &#123;</span><br><span class="line"></span><br><span class="line">		Date d = new Date();</span><br><span class="line"></span><br><span class="line">		SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy年MM月dd日 HH:mm:ss&quot;);</span><br><span class="line">		String s = sdf.format(d);</span><br><span class="line">		System.out.println(s);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		String str = &quot;2008-08-08 12:12:12&quot;;</span><br><span class="line">		//在把一个字符串解析为日期的时候，请注意格式必须和给定的字符串格式匹配</span><br><span class="line">		SimpleDateFormat sdf2 = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);</span><br><span class="line">		Date dd = sdf2.parse(str);</span><br><span class="line">		System.out.println(dd);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Calendar类概述及其方法"><a href="#Calendar类概述及其方法" class="headerlink" title="Calendar类概述及其方法"></a>Calendar类概述及其方法</h3><p>Calendar:它为特定瞬间与一组诸如 YEAR、MONTH、DAY_OF_MONTH、HOUR 等 日历字段之间的转换提供了一些方法，并为操作日历字段（例如获得下星期的日期）提供了一些方法。</p>
<h4 id="成员方法-12"><a href="#成员方法-12" class="headerlink" title="成员方法"></a>成员方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public static Calendar getInstance()本质返回的是子类对象</span><br><span class="line">public int get(int field)</span><br><span class="line">public void add(int field,int amount):根据给定的日历字段和对应的时间，来对当前的日历进行操作。</span><br><span class="line">public final void set(int year,int month,int date)设置当前日历的年月日</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">public class CalendarDemo &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		// 获取当前的日历时间</span><br><span class="line">		Calendar c = Calendar.getInstance();</span><br><span class="line"></span><br><span class="line">		// 获取年</span><br><span class="line">		int year = c.get(Calendar.YEAR);</span><br><span class="line">		// 获取月</span><br><span class="line">		int month = c.get(Calendar.MONTH);</span><br><span class="line">		// 获取日</span><br><span class="line">		int date = c.get(Calendar.DATE);</span><br><span class="line">		System.out.println(year + &quot;年&quot; + (month + 1) + &quot;月&quot; + date + &quot;日&quot;);</span><br><span class="line"></span><br><span class="line">		// 5年后的10天前</span><br><span class="line">		c.add(Calendar.YEAR, 5);</span><br><span class="line">		c.add(Calendar.DATE, -10);</span><br><span class="line">		// 获取年</span><br><span class="line">		year = c.get(Calendar.YEAR);</span><br><span class="line">		// 获取月</span><br><span class="line">		month = c.get(Calendar.MONTH);</span><br><span class="line">		// 获取日</span><br><span class="line">		date = c.get(Calendar.DATE);</span><br><span class="line">		System.out.println(year + &quot;年&quot; + (month + 1) + &quot;月&quot; + date + &quot;日&quot;);</span><br><span class="line">		System.out.println(&quot;--------------&quot;);</span><br><span class="line"></span><br><span class="line">		c.set(2011, 11, 11);</span><br><span class="line">		// 获取年</span><br><span class="line">		year = c.get(Calendar.YEAR);</span><br><span class="line">		// 获取月</span><br><span class="line">		month = c.get(Calendar.MONTH);</span><br><span class="line">		// 获取日</span><br><span class="line">		date = c.get(Calendar.DATE);</span><br><span class="line">		System.out.println(year + &quot;年&quot; + (month + 1) + &quot;月&quot; + date + &quot;日&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Runtime类"><a href="#Runtime类" class="headerlink" title="Runtime类"></a>Runtime类</h3><p>Runtime:每个 Java 应用程序都有一个 Runtime 类实例，使应用程序能够与其运行的环境相连接。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">exec(String command)</span><br><span class="line"></span><br><span class="line">public class RuntimeDemo &#123;</span><br><span class="line">	public static void main(String[] args) throws IOException &#123;</span><br><span class="line">		Runtime r = Runtime.getRuntime();</span><br><span class="line">//		r.exec(&quot;winmine&quot;);</span><br><span class="line">		// r.exec(&quot;notepad&quot;);</span><br><span class="line">		// r.exec(&quot;calc&quot;);</span><br><span class="line">//		r.exec(&quot;shutdown -s -t 10000&quot;);</span><br><span class="line">		r.exec(&quot;shutdown -a&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Runtime &#123;</span><br><span class="line">	private Runtime() &#123;&#125;</span><br><span class="line">	private static Runtime currentRuntime = new Runtime();</span><br><span class="line">	public static Runtime getRuntime() &#123;</span><br><span class="line">      		return currentRuntime;</span><br><span class="line">   	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

                    
                        

                    
                    
                        <p>
                            <a href="/2019/09/07/常用类/#post-footer" class="postShorten-excerpt_link link">
                                评论和共享
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a class="link-unstyled" href="/2019/09/03/位运算/">
                            位运算
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2019-09-03T18:35:53+08:00">
	
		    9月 03, 2019
    	
    </time>
    
</div>

            </div>
            
                <div class="postShorten-content">
                    <p>Demo1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">	位运算符：</span><br><span class="line">		&amp;,|,^,~</span><br><span class="line">		&lt;&lt;,&gt;&gt;,&gt;&gt;&gt;</span><br><span class="line"></span><br><span class="line">	注意：</span><br><span class="line">		要做位运算，首先要把数据转换为二进制。</span><br><span class="line">*/</span><br><span class="line">class OperatorDemo &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		//&amp;,|,^,~</span><br><span class="line"></span><br><span class="line">		int a = 3;</span><br><span class="line">		int b = 4;</span><br><span class="line"></span><br><span class="line">		System.out.println(3 &amp; 4);</span><br><span class="line">		System.out.println(3 | 4);</span><br><span class="line">		System.out.println(3 ^ 4);</span><br><span class="line">		System.out.println(~3);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">/*</span><br><span class="line">	分析：因为是位运算，所以我们必须先把数据换算成二进制。</span><br><span class="line"></span><br><span class="line">	3的二进制：11</span><br><span class="line">		00000000 00000000 00000000 00000011</span><br><span class="line">	4的二进制：100</span><br><span class="line">		00000000 00000000 00000000 00000100</span><br><span class="line"></span><br><span class="line">	&amp;位与运算：有0则0。</span><br><span class="line">		00000000 00000000 00000000 00000011</span><br><span class="line">	   &amp;00000000 00000000 00000000 00000100</span><br><span class="line">		-----------------------------------</span><br><span class="line">		00000000 00000000 00000000 00000000</span><br><span class="line">		结果是：0</span><br><span class="line"></span><br><span class="line">	|位或运算：有1则1。</span><br><span class="line">		00000000 00000000 00000000 00000011</span><br><span class="line">	   |00000000 00000000 00000000 00000100</span><br><span class="line">		-----------------------------------</span><br><span class="line">		00000000 00000000 00000000 00000111</span><br><span class="line">		结果是：7</span><br><span class="line"></span><br><span class="line">	^位异或运算：相同则0，不同则1。</span><br><span class="line">		00000000 00000000 00000000 00000011</span><br><span class="line">	   &amp;00000000 00000000 00000000 00000100</span><br><span class="line">		-----------------------------------</span><br><span class="line">		00000000 00000000 00000000 00000111</span><br><span class="line">		结果是：7</span><br><span class="line"></span><br><span class="line">	~按位取反运算符：0变1，1变0</span><br><span class="line">		00000000 00000000 00000000 00000011</span><br><span class="line">	   ~11111111 11111111 11111111 11111100 (补码)</span><br><span class="line"></span><br><span class="line">	   补码：11111111 11111111 11111111 11111100</span><br><span class="line">	   反码：11111111 11111111 11111111 11111011</span><br><span class="line">	   原码：10000000 00000000 00000000 00000100</span><br><span class="line">		结果是：-4</span><br><span class="line">*/</span><br></pre></td></tr></table></figure></p>
<p>Demo2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">	^的特点：一个数据对另一个数据位异或两次，该数本身不变。</span><br><span class="line">*/</span><br><span class="line">class OperatorDemo2 &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		int a = 10;</span><br><span class="line">		int b = 20;</span><br><span class="line"></span><br><span class="line">		System.out.println(a ^ b ^ b); //10</span><br><span class="line">		System.out.println(a ^ b ^ a); //20</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Demo3:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">	&lt;&lt;:左移	左边最高位丢弃，右边补齐0</span><br><span class="line">	&gt;&gt;:右移	最高位是0，左边补齐0；最高为是1，左边补齐1</span><br><span class="line">	&gt;&gt;&gt;:无符号右移 无论最高位是0还是1，左边补齐0</span><br><span class="line"></span><br><span class="line">	面试题：</span><br><span class="line">		请用最有效率的方式写出计算2乘以8的结果?</span><br><span class="line">			2 * 8</span><br><span class="line"></span><br><span class="line">			2 &lt;&lt; 3</span><br><span class="line"></span><br><span class="line">*/</span><br><span class="line">class OperatorDemo3 &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		//&lt;&lt; 把&lt;&lt;左边的数据乘以2的移动次幂</span><br><span class="line">		System.out.println(3 &lt;&lt; 2); //3*2^2 = 3*4 = 12;</span><br><span class="line"></span><br><span class="line">		//&gt;&gt; 把&gt;&gt;左边的数据除以2的移动次幂</span><br><span class="line">		System.out.println(24 &gt;&gt; 2); //24 / 2^2 = 24 / 4 = 6</span><br><span class="line">		System.out.println(24 &gt;&gt;&gt; 2);</span><br><span class="line"></span><br><span class="line">		System.out.println(-24 &gt;&gt; 2);</span><br><span class="line">		System.out.println(-24 &gt;&gt;&gt; 2);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">/*</span><br><span class="line">	计算出3的二进制：11</span><br><span class="line">		00000000 00000000 00000000 00000011</span><br><span class="line">	(00)000000 00000000 00000000 0000001100</span><br><span class="line"></span><br><span class="line">	&gt;&gt;的移动：</span><br><span class="line">	计算出24的二进制：11000</span><br><span class="line">		原码：10000000 00000000 00000000 00011000</span><br><span class="line">		反码：11111111 11111111 11111111 11100111</span><br><span class="line">		补码：11111111 11111111 11111111 11101000</span><br><span class="line"></span><br><span class="line">		11111111 11111111 11111111 11101000</span><br><span class="line">		1111111111 11111111 11111111 111010(00) 补码</span><br><span class="line"></span><br><span class="line">		补码：1111111111 11111111 11111111 111010</span><br><span class="line">		反码：1111111111 11111111 11111111 111001</span><br><span class="line">		原码：1000000000 00000000 00000000 000110</span><br><span class="line"></span><br><span class="line">		结果：-6</span><br><span class="line"></span><br><span class="line">	&gt;&gt;&gt;的移动：</span><br><span class="line">		计算出24的二进制：11000</span><br><span class="line">		原码：10000000 00000000 00000000 00011000</span><br><span class="line">		反码：11111111 11111111 11111111 11100111</span><br><span class="line">		补码：11111111 11111111 11111111 11101000</span><br><span class="line"></span><br><span class="line">		11111111 11111111 11111111 11101000</span><br><span class="line">		0011111111 11111111 11111111 111010(00)</span><br><span class="line"></span><br><span class="line">		结果：</span><br><span class="line">*/</span><br></pre></td></tr></table></figure></p>
<p>Demo4:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">		实现两个整数变量的交换</span><br><span class="line">*/</span><br><span class="line">class OperatorTest &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		int a = 10;</span><br><span class="line">		int b = 20;</span><br><span class="line"></span><br><span class="line">		System.out.println(&quot;a:&quot;+a+&quot;,b:&quot;+b);</span><br><span class="line"></span><br><span class="line">		//方式1：使用第三方变量(开发中用的)</span><br><span class="line">		/*</span><br><span class="line">		int c = a;</span><br><span class="line">		a = b;</span><br><span class="line">		b = c;</span><br><span class="line">		System.out.println(&quot;a:&quot;+a+&quot;,b:&quot;+b);</span><br><span class="line">		System.out.println(&quot;------------&quot;);</span><br><span class="line">		*/</span><br><span class="line"></span><br><span class="line">		//方式2：用位异或实现</span><br><span class="line">		//左边：a,b,a</span><br><span class="line">		//右边：a ^ b</span><br><span class="line">		/*</span><br><span class="line">		a = a ^ b;</span><br><span class="line">		b = a ^ b; //a ^ b ^ b = a</span><br><span class="line">		a = a ^ b; //a ^ b ^ a = b</span><br><span class="line">		System.out.println(&quot;a:&quot;+a+&quot;,b:&quot;+b);</span><br><span class="line">		*/</span><br><span class="line"></span><br><span class="line">		//方式3：用变量相加的做法</span><br><span class="line">		/*</span><br><span class="line">		a = a + b; //a=30</span><br><span class="line">		b = a - b; //b=10</span><br><span class="line">		a = a - b; //a=20</span><br><span class="line">		System.out.println(&quot;a:&quot;+a+&quot;,b:&quot;+b);</span><br><span class="line">		*/</span><br><span class="line"></span><br><span class="line">		//方式4：一句话搞定</span><br><span class="line">		b = (a+b) - (a=b); //b=30-20=10,a=20</span><br><span class="line">		System.out.println(&quot;a:&quot;+a+&quot;,b:&quot;+b);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

                    
                        

                    
                    
                        <p>
                            <a href="/2019/09/03/位运算/#post-footer" class="postShorten-excerpt_link link">
                                评论和共享
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a class="link-unstyled" href="/2019/08/25/高并发解决方案/">
                            高并发解决方案
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2019-08-25T18:31:43+08:00">
	
		    8月 25, 2019
    	
    </time>
    
</div>

            </div>
            
                <div class="postShorten-content">
                    <h3 id="高并发处理思路与手段"><a href="#高并发处理思路与手段" class="headerlink" title="高并发处理思路与手段"></a>高并发处理思路与手段</h3><h4 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h4><div class="figure center" style="width:100%;"><a class="fancybox" href="/assets/并发编程与高并发解决方案/96.jpg" title="" data-caption="" data-fancybox="travel"><img class="fig-img" src="/assets/并发编程与高并发解决方案/96.jpg" style="width:100%;height:100%;" alt=""></a></div><div style="clear:both;"></div>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">随着并发线程的增加，从几十到几百，几千，几万</span><br><span class="line">垂直扩展：可能就得考虑给系统增内存</span><br><span class="line">水平扩展：复杂一点可能要增服务器来分担压力</span><br></pre></td></tr></table></figure>
<div class="figure center" style="width:100%;"><a class="fancybox" href="/assets/并发编程与高并发解决方案/97.jpg" title="" data-caption="" data-fancybox="travel"><img class="fig-img" src="/assets/并发编程与高并发解决方案/97.jpg" style="width:100%;height:100%;" alt=""></a></div><div style="clear:both;"></div>
<h4 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h4><h5 id="特征、场景及组件介绍"><a href="#特征、场景及组件介绍" class="headerlink" title="特征、场景及组件介绍"></a>特征、场景及组件介绍</h5><div class="figure center" style="width:100%;"><a class="fancybox" href="/assets/并发编程与高并发解决方案/98.jpg" title="" data-caption="" data-fancybox="travel"><img class="fig-img" src="/assets/并发编程与高并发解决方案/98.jpg" style="width:100%;height:100%;" alt=""></a></div><div style="clear:both;"></div>
<div class="figure center" style="width:100%;"><a class="fancybox" href="/assets/并发编程与高并发解决方案/99.jpg" title="" data-caption="" data-fancybox="travel"><img class="fig-img" src="/assets/并发编程与高并发解决方案/99.jpg" style="width:100%;height:100%;" alt=""></a></div><div style="clear:both;"></div>
<div class="figure center" style="width:100%;"><a class="fancybox" href="/assets/并发编程与高并发解决方案/100.jpg" title="" data-caption="" data-fancybox="travel"><img class="fig-img" src="/assets/并发编程与高并发解决方案/100.jpg" style="width:100%;height:100%;" alt=""></a></div><div style="clear:both;"></div>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">适合读多写少的场景，实时性越低越适合缓存</span><br><span class="line"></span><br><span class="line">在相同key和请求数的情况下，缓存的时间越长命中率越高。缓存的粒度越小，命中率越高。</span><br><span class="line">当缓存当个对象时，比如单个用户信息，只有当该对象对应的数据发生变化的时候我们才要更新缓存或者移除缓存。</span><br><span class="line">而当缓存一个集合时，例如我们要缓存所有用户数据，期中任何一个对象当中的数据发生变化时，我们都要更新或移除缓存。</span><br><span class="line">还有另一种情况，假设其他地方也要获取该对象对应的数据时，比如也要获取单个用户信息，如果缓存的是单个对象，那么就可以直接命中缓存，否则就无法直接命中。</span><br><span class="line"></span><br><span class="line">此外，缓存的更新过期策略也直接影响到缓存的命中率，当数据发生变化时，直接更新缓存的值会比移除缓存或让缓存过期的命中率更高，当然这个时候的系统复杂度也会变得更高。</span><br><span class="line"></span><br><span class="line">缓存的容量有限，就容易引起缓存失效和被淘汰，目前多数的缓存框架或中间件都采用LRU算法。</span><br><span class="line">同时缓存的技术选型也是至关重要的，比如采用应用内置的本地缓存，比较容易出现单机瓶颈，而采用分布式缓存则容易拓展，所以需要做好系统容量规划，并考虑是否可拓展。</span><br><span class="line">此外，不同的缓存框架和中间件的效率和稳定性也是存在一定的差异，还有一些会影响到缓存命中率的因素，</span><br><span class="line">比如当缓存节点发生故障时，需要避免缓存失效并最大化程度降低影响，业内比较典型的做法就是通过一致性哈希算法或者节点冗余的方式来避免这个问题，并发越高，缓存的收益越高，即使缓存的时间很短。</span><br><span class="line">需要应用尽可能的通过缓存来直接获取数据并避免缓存失效，尽可能的聚集在高频访问且时效性不高的热点业务上，通过缓存预加载，增加存储容量，调整缓存粒度，更新缓存等手段来提高命中率。</span><br><span class="line">对于时效性很高或缓存空间有限的情况下内容跨度越大或者访问很随机并且访问量不高的业务来说，缓存命中率可能会长期的很低，可能预热后的缓存还没来得及访问就过期了。</span><br></pre></td></tr></table></figure>
<div class="figure center" style="width:100%;"><a class="fancybox" href="/assets/并发编程与高并发解决方案/101.jpg" title="" data-caption="" data-fancybox="travel"><img class="fig-img" src="/assets/并发编程与高并发解决方案/101.jpg" style="width:100%;height:100%;" alt=""></a></div><div style="clear:both;"></div>
<div class="figure center" style="width:100%;"><a class="fancybox" href="/assets/并发编程与高并发解决方案/102.jpg" title="" data-caption="" data-fancybox="travel"><img class="fig-img" src="/assets/并发编程与高并发解决方案/102.jpg" style="width:100%;height:100%;" alt=""></a></div><div style="clear:both;"></div>
<div class="figure center" style="width:100%;"><a class="fancybox" href="/assets/并发编程与高并发解决方案/103.jpg" title="" data-caption="" data-fancybox="travel"><img class="fig-img" src="/assets/并发编程与高并发解决方案/103.jpg" style="width:100%;height:100%;" alt=""></a></div><div style="clear:both;"></div>
<div class="figure center" style="width:100%;"><a class="fancybox" href="/assets/并发编程与高并发解决方案/104.jpg" title="" data-caption="" data-fancybox="travel"><img class="fig-img" src="/assets/并发编程与高并发解决方案/104.jpg" style="width:100%;height:100%;" alt=""></a></div><div style="clear:both;"></div>
<div class="figure center" style="width:100%;"><a class="fancybox" href="/assets/并发编程与高并发解决方案/105.jpg" title="" data-caption="" data-fancybox="travel"><img class="fig-img" src="/assets/并发编程与高并发解决方案/105.jpg" style="width:100%;height:100%;" alt=""></a></div><div style="clear:both;"></div>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">redis是远程内存数据库，非关系型数据库，性能强劲，具有复制特性，解决问题而生的独一无二的数据模型，存储键值对与5种不同类型的值之间的映射，可以将存储在内存的键值对数据持久化到硬盘，可以使用复制特性来拓展读性能，还可以使用客户端分片来拓展写性能。</span><br><span class="line"></span><br><span class="line">特点：</span><br><span class="line">支持数据的持久化，可以将数据保存到磁盘里，重启的时候可以再次加载进行使用，redis不仅支持简单的key,value数据，同时它还提供特殊类型的存储如：list，hash</span><br><span class="line">支持数据的备份，即master slave模式（主从数据备份）</span><br><span class="line">性能极高：读的速度 11万次/s  写的速度  81000次/s</span><br><span class="line">丰富的数据类型</span><br><span class="line">原子性</span><br><span class="line">支持对多个操作后的原子性执行</span><br><span class="line">支持publish,subscribe，key过期等等特性</span><br><span class="line"></span><br><span class="line">场景：</span><br><span class="line">取最新n个操作；排行榜（取top N 操作）精准设置过期的应用；应用于计数器；做唯一性检查的操作；实时系统；队列系统</span><br></pre></td></tr></table></figure>
<h4 id="高并发场景问题及实战讲解"><a href="#高并发场景问题及实战讲解" class="headerlink" title="高并发场景问题及实战讲解"></a>高并发场景问题及实战讲解</h4><div class="figure center" style="width:100%;"><a class="fancybox" href="/assets/并发编程与高并发解决方案/106.jpg" title="" data-caption="" data-fancybox="travel"><img class="fig-img" src="/assets/并发编程与高并发解决方案/106.jpg" style="width:100%;height:100%;" alt=""></a></div><div style="clear:both;"></div>
<div class="figure center" style="width:100%;"><a class="fancybox" href="/assets/并发编程与高并发解决方案/107.jpg" title="" data-caption="" data-fancybox="travel"><img class="fig-img" src="/assets/并发编程与高并发解决方案/107.jpg" style="width:100%;height:100%;" alt=""></a></div><div style="clear:both;"></div>
<div class="figure center" style="width:100%;"><a class="fancybox" href="/assets/并发编程与高并发解决方案/108.jpg" title="" data-caption="" data-fancybox="travel"><img class="fig-img" src="/assets/并发编程与高并发解决方案/108.jpg" style="width:100%;height:100%;" alt=""></a></div><div style="clear:both;"></div>
<div class="figure center" style="width:100%;"><a class="fancybox" href="/assets/并发编程与高并发解决方案/109.jpg" title="" data-caption="" data-fancybox="travel"><img class="fig-img" src="/assets/并发编程与高并发解决方案/109.jpg" style="width:100%;height:100%;" alt=""></a></div><div style="clear:both;"></div>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">在高并发的场景下，如果某个key被高并发的访问，没有被命中，出于对容错性的考虑，可以尝试去后端数据库获取，从而达到了大量请求到达数据库，而当该key对应的数据本身就是空的情况下，这就导致数据库中并发的执行了很多不必要的查询操作，从而导致了巨大的冲击和压力。</span><br><span class="line">我们可以缓存空对象，对查询结果为空的对象也进行缓存，如果是集合的话，可以缓存一个空的集合，但不是null，如果是缓存单个对象，则可以通过字段标识来区分，避免请求穿透到后端数据库，同时也需要保证缓存数据的时效性，这种方式实现起来成本较低，比较适合命中不高，但比较频繁更新的数据。</span><br><span class="line">单独过滤处理，对所有可能对应数据为空的key进行统一的存放，并在请求前做拦截，这样避免请求穿透到后端的数据库，这种方式实现起来相对复杂一些，比较适合命中不高但是更新不频繁的数据。</span><br></pre></td></tr></table></figure>
<div class="figure center" style="width:100%;"><a class="fancybox" href="/assets/并发编程与高并发解决方案/110.jpg" title="" data-caption="" data-fancybox="travel"><img class="fig-img" src="/assets/并发编程与高并发解决方案/110.jpg" style="width:100%;height:100%;" alt=""></a></div><div style="clear:both;"></div>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">由于缓存的原因导致大量的请求到达后端数据库而导致数据库奔溃整个系统奔溃发生灾难。</span><br><span class="line">导致的原因有很多种，比如提到的缓存并发，缓存穿透，缓存抖动，都有可能造成缓存雪崩的现象。</span><br><span class="line">这些问题也可能被恶意攻击者利用，还有一种情况，例如某个时间点内，系统预加载的缓存周期性的集中失效了，也有可能导致雪崩。</span><br><span class="line">为了避免这种周期性的失效，可以通过设置不同的过期时间来错开他们的缓存过期时间，从而避免缓存集中失效。</span><br><span class="line">从应用架构角度，我们可以通过限流，降级，熔断等手段来降低影响，也可以通过多级缓存来避免这种灾难。</span><br><span class="line">此外，从整个研发体系流程角度，应该多加强压力测试，尽量模拟真实场景，尽早暴露问题，从而进行防范。</span><br></pre></td></tr></table></figure>
<div class="figure center" style="width:100%;"><a class="fancybox" href="/assets/并发编程与高并发解决方案/111.jpg" title="" data-caption="" data-fancybox="travel"><img class="fig-img" src="/assets/并发编程与高并发解决方案/111.jpg" style="width:100%;height:100%;" alt=""></a></div><div style="clear:both;"></div>
<p>参考:<br><a href="http://www.imooc.com/article/20918" target="_blank" rel="noopener">http://www.imooc.com/article/20918</a></p>
<h4 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h4><div class="figure center" style="width:100%;"><a class="fancybox" href="/assets/并发编程与高并发解决方案/112.jpg" title="" data-caption="" data-fancybox="travel"><img class="fig-img" src="/assets/并发编程与高并发解决方案/112.jpg" style="width:100%;height:100%;" alt=""></a></div><div style="clear:both;"></div>
<div class="figure center" style="width:100%;"><a class="fancybox" href="/assets/并发编程与高并发解决方案/113.jpg" title="" data-caption="" data-fancybox="travel"><img class="fig-img" src="/assets/并发编程与高并发解决方案/113.jpg" style="width:100%;height:100%;" alt=""></a></div><div style="clear:both;"></div>
<div class="figure center" style="width:100%;"><a class="fancybox" href="/assets/并发编程与高并发解决方案/114.jpg" title="" data-caption="" data-fancybox="travel"><img class="fig-img" src="/assets/并发编程与高并发解决方案/114.jpg" style="width:100%;height:100%;" alt=""></a></div><div style="clear:both;"></div>
<div class="figure center" style="width:100%;"><a class="fancybox" href="/assets/并发编程与高并发解决方案/134.png" title="" data-caption="" data-fancybox="travel"><img class="fig-img" src="/assets/并发编程与高并发解决方案/134.png" style="width:100%;height:100%;" alt=""></a></div><div style="clear:both;"></div>
<div class="figure center" style="width:100%;"><a class="fancybox" href="/assets/并发编程与高并发解决方案/115.jpg" title="" data-caption="" data-fancybox="travel"><img class="fig-img" src="/assets/并发编程与高并发解决方案/115.jpg" style="width:100%;height:100%;" alt=""></a></div><div style="clear:both;"></div>
<h5 id="业务解耦"><a href="#业务解耦" class="headerlink" title="业务解耦"></a>业务解耦</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">所谓解耦，本质上讲的就是一个事务只关心简单的流程，而需要依赖其它的系统但不那么重要的事情，有通知即可无需等待结果。</span><br><span class="line">基于消息的模型关心的是通知，不是处理。</span><br><span class="line">如：对于订单系统，用户支付成功之后，我们可能需要给用户发送一条短信通知。但其实呢，这已经不是系统的核心流程了。</span><br><span class="line">如果外部系统偏慢，比如短信网关速度不好，那么主流程的时间就会加强很多，用户肯定不想点击支付之后几分钟才看到结果，那么我们只需通知短信系统我们支付成功了，去发送短信通知就好了，并不一定要等待它处理完成才结束。</span><br></pre></td></tr></table></figure>
<h5 id="最终一致性"><a href="#最终一致性" class="headerlink" title="最终一致性"></a>最终一致性</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">指的是两个系统的状态保持一致，要么都成功，要么都失败。当然了，有个时间限制，理论上是越快越好。但实际上各种异常的情况下，可能会有一定的延迟达到最终的一致状态。</span><br><span class="line">但最后两个系统的状态还是要一样的。</span><br><span class="line">如：转账功能，A系统扣钱成功，B系统加钱一定也要成功。反之，它们就一起回滚，像什么都没发生一样，然而这个过程中存在很多可能的意外，比如：</span><br><span class="line">1.A系统扣钱成功，调用B系统加钱失效</span><br><span class="line">2.A扣钱成功，调用B系统加钱接口虽然成功，但是获取最终结果的时候网络异常引起的超时</span><br><span class="line">3.A扣钱成功，但B系统加钱失效了，A系统想回滚刚才扣除的钱，但是系统宕机了，无法回滚</span><br><span class="line">通过这三个场景，我们看出了想把这件看似简单的事情做成真的不容易，所有跨JVM一致性的问题，从技术的角度讲，通用的解决方法包括两个：</span><br><span class="line">1.强一致性</span><br><span class="line">分布式事务，落地太难，而且成本太高，我们就不做具体介绍了。</span><br><span class="line">2.最终一致性</span><br><span class="line">也是消息队列可以使用的场景，主要是用记录和补偿的方式来处理，在做所有的不确定事情之前，先把事情记录下来，然后去做不确定的事，它的结果通常分三种：成功/失败/不确定（超时等等可以等价为失败）</span><br><span class="line">如果是成功的话，就可以把我们记录的东西清理掉，对于失败和不确定，我们可以依靠定时任务等方式把所有失败的事情重新做一遍，知道成功为止。</span><br><span class="line">系统在A扣钱成功的情况下，需要给B通知的这件事情记录在库中，为了保证最高的可靠性，也可以把通知B系统加钱和扣钱成功这两件事情维护在一个本地事务里面。</span><br><span class="line">通知成功，则删除这条记录，通知失败或不确定则依靠定时任务可尝试地通知我们，直到我们把状态更加为正确的为止。这时，可能会遇到重复消息的问题，需要处理消息的地方做好幂等操作。</span><br><span class="line">最终一致性不是消息队列必备的特性。但确实可以依靠队列来做最终一致性的事情。需要注意的是，像kafka等消息队列，它的设计层面上有丢消息的可能，比如定时刷盘，如果掉列会丢消息的可能等等。</span><br><span class="line">哪怕只丢千分之一的消息，业务也要通过其它手段来保证结果的正确。</span><br></pre></td></tr></table></figure>
<h5 id="广播"><a href="#广播" class="headerlink" title="广播"></a>广播</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">如果没有队列，每当一个新的业务方介入，我们都要联调一次新接口，有了消息队列，我们只需要关心消息是否达到消息队列，新接入的接口订阅相关的消息，自己去做处理就可以了。</span><br></pre></td></tr></table></figure>
<h5 id="错峰和流控"><a href="#错峰和流控" class="headerlink" title="错峰和流控"></a>错峰和流控</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">上下游对性能处理能力是不同的，比如：Web前端每秒承受上千万的请求并不是什么神奇的事情，只需要多加一点机器，再搭建一些LVS负载均衡设备和nginx服务器即可。</span><br><span class="line">但是，数据库处理却是十分有限，即使使用了SSD加上分库分表单机处理能力仍然有限，出于成本考虑，我们不能奢求数据库的机器数量追上前端。这种问题同样出现于系统和系统之间，</span><br><span class="line">比如短信系统可能由于短板效应，速度卡在网关上，比如每秒几百次请求，它跟前端的并发量不是一个数量级的，但是，用户晚个半分钟左右收到短信一般也不会有太大问题，如果没有消息队列，</span><br><span class="line">两个系统之间通过协商，滑动窗口等方案也不是不能实现。但是，系统的复杂性将会成指数性增长。势必在上游或下游做些存储，并且要处理定时、阻塞等一些列问题，</span><br><span class="line">而且每当处理能力有些差异的时候，都需要单独开发一套逻辑来维护这套逻辑。所以，利用中间系统，如消息队列转储两个系统的消息内容，并在下游系统有能力处理这些消息的时候再处理，是一套相对比较通用的方式。</span><br><span class="line">总而言之，对于需要强事务保证，而且延迟很敏感的，RPC是优于队列的，对于一些无关痛痒或者一些对于别人很重要，但对于自己不是那么关心的事情可以利用消息队列去做。</span><br><span class="line">支持最终一致性的消息队列能够用来处理延迟不那么敏感的分布式事务场景，而且相对于笨重的分布式事务可能是更优的处理方式。</span><br></pre></td></tr></table></figure>
<div class="figure center" style="width:100%;"><a class="fancybox" href="/assets/并发编程与高并发解决方案/116.jpg" title="" data-caption="" data-fancybox="travel"><img class="fig-img" src="/assets/并发编程与高并发解决方案/116.jpg" style="width:100%;height:100%;" alt=""></a></div><div style="clear:both;"></div>
<div class="figure center" style="width:100%;"><a class="fancybox" href="/assets/并发编程与高并发解决方案/117.jpg" title="" data-caption="" data-fancybox="travel"><img class="fig-img" src="/assets/并发编程与高并发解决方案/117.jpg" style="width:100%;height:100%;" alt=""></a></div><div style="clear:both;"></div>
<div class="figure center" style="width:100%;"><a class="fancybox" href="/assets/并发编程与高并发解决方案/118.jpg" title="" data-caption="" data-fancybox="travel"><img class="fig-img" src="/assets/并发编程与高并发解决方案/118.jpg" style="width:100%;height:100%;" alt=""></a></div><div style="clear:both;"></div>
<h5 id="应用拆分"><a href="#应用拆分" class="headerlink" title="应用拆分"></a>应用拆分</h5><div class="figure center" style="width:100%;"><a class="fancybox" href="/assets/并发编程与高并发解决方案/119.jpg" title="" data-caption="" data-fancybox="travel"><img class="fig-img" src="/assets/并发编程与高并发解决方案/119.jpg" style="width:100%;height:100%;" alt=""></a></div><div style="clear:both;"></div>
<div class="figure center" style="width:100%;"><a class="fancybox" href="/assets/并发编程与高并发解决方案/120.jpg" title="" data-caption="" data-fancybox="travel"><img class="fig-img" src="/assets/并发编程与高并发解决方案/120.jpg" style="width:100%;height:100%;" alt=""></a></div><div style="clear:both;"></div>
<div class="figure center" style="width:100%;"><a class="fancybox" href="/assets/并发编程与高并发解决方案/121.jpg" title="" data-caption="" data-fancybox="travel"><img class="fig-img" src="/assets/并发编程与高并发解决方案/121.jpg" style="width:100%;height:100%;" alt=""></a></div><div style="clear:both;"></div>
<div class="figure center" style="width:100%;"><a class="fancybox" href="/assets/并发编程与高并发解决方案/122.jpg" title="" data-caption="" data-fancybox="travel"><img class="fig-img" src="/assets/并发编程与高并发解决方案/122.jpg" style="width:100%;height:100%;" alt=""></a></div><div style="clear:both;"></div>
<div class="figure center" style="width:100%;"><a class="fancybox" href="/assets/并发编程与高并发解决方案/123.jpg" title="" data-caption="" data-fancybox="travel"><img class="fig-img" src="/assets/并发编程与高并发解决方案/123.jpg" style="width:100%;height:100%;" alt=""></a></div><div style="clear:both;"></div>
<div class="figure center" style="width:100%;"><a class="fancybox" href="/assets/并发编程与高并发解决方案/124.jpg" title="" data-caption="" data-fancybox="travel"><img class="fig-img" src="/assets/并发编程与高并发解决方案/124.jpg" style="width:100%;height:100%;" alt=""></a></div><div style="clear:both;"></div>
<div class="figure center" style="width:100%;"><a class="fancybox" href="/assets/并发编程与高并发解决方案/125.jpg" title="" data-caption="" data-fancybox="travel"><img class="fig-img" src="/assets/并发编程与高并发解决方案/125.jpg" style="width:100%;height:100%;" alt=""></a></div><div style="clear:both;"></div>
<h5 id="应用限流"><a href="#应用限流" class="headerlink" title="应用限流"></a>应用限流</h5><div class="figure center" style="width:100%;"><a class="fancybox" href="/assets/并发编程与高并发解决方案/126.jpg" title="" data-caption="" data-fancybox="travel"><img class="fig-img" src="/assets/并发编程与高并发解决方案/126.jpg" style="width:100%;height:100%;" alt=""></a></div><div style="clear:both;"></div>
<div class="figure center" style="width:100%;"><a class="fancybox" href="/assets/并发编程与高并发解决方案/127.jpg" title="" data-caption="" data-fancybox="travel"><img class="fig-img" src="/assets/并发编程与高并发解决方案/127.jpg" style="width:100%;height:100%;" alt=""></a></div><div style="clear:both;"></div>
<div class="figure center" style="width:100%;"><a class="fancybox" href="/assets/并发编程与高并发解决方案/128.jpg" title="" data-caption="" data-fancybox="travel"><img class="fig-img" src="/assets/并发编程与高并发解决方案/128.jpg" style="width:100%;height:100%;" alt=""></a></div><div style="clear:both;"></div>
<div class="figure center" style="width:100%;"><a class="fancybox" href="/assets/并发编程与高并发解决方案/129.jpg" title="" data-caption="" data-fancybox="travel"><img class="fig-img" src="/assets/并发编程与高并发解决方案/129.jpg" style="width:100%;height:100%;" alt=""></a></div><div style="clear:both;"></div>
<div class="figure center" style="width:100%;"><a class="fancybox" href="/assets/并发编程与高并发解决方案/130.jpg" title="" data-caption="" data-fancybox="travel"><img class="fig-img" src="/assets/并发编程与高并发解决方案/130.jpg" style="width:100%;height:100%;" alt=""></a></div><div style="clear:both;"></div>
<div class="figure center" style="width:100%;"><a class="fancybox" href="/assets/并发编程与高并发解决方案/131.jpg" title="" data-caption="" data-fancybox="travel"><img class="fig-img" src="/assets/并发编程与高并发解决方案/131.jpg" style="width:100%;height:100%;" alt=""></a></div><div style="clear:both;"></div>
<div class="figure center" style="width:100%;"><a class="fancybox" href="/assets/并发编程与高并发解决方案/132.jpg" title="" data-caption="" data-fancybox="travel"><img class="fig-img" src="/assets/并发编程与高并发解决方案/132.jpg" style="width:100%;height:100%;" alt=""></a></div><div style="clear:both;"></div>
<h5 id="服务降级与服务熔断"><a href="#服务降级与服务熔断" class="headerlink" title="服务降级与服务熔断"></a>服务降级与服务熔断</h5><div class="figure center" style="width:100%;"><a class="fancybox" href="/assets/并发编程与高并发解决方案/135.jpg" title="" data-caption="" data-fancybox="travel"><img class="fig-img" src="/assets/并发编程与高并发解决方案/135.jpg" style="width:100%;height:100%;" alt=""></a></div><div style="clear:both;"></div>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">对一些服务，界面有策略地降级以此缓解保证了部分甚至大部分客户能得到正确的响应，</span><br><span class="line">简单来说，如果当前请求处理不了了或者出错了，我给一个默认的返回，根据不同的接口做不同的默认返回和定制</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">熔断是指软件系统里由于某些原因使得服务出现了过载的现象，为了防止整个系统出现故障，从而采用的一种保护措施，所以很多地方也把熔断称为过载保护</span><br></pre></td></tr></table></figure>
<div class="figure center" style="width:100%;"><a class="fancybox" href="/assets/并发编程与高并发解决方案/136.jpg" title="" data-caption="" data-fancybox="travel"><img class="fig-img" src="/assets/并发编程与高并发解决方案/136.jpg" style="width:100%;height:100%;" alt=""></a></div><div style="clear:both;"></div>
<div class="figure center" style="width:100%;"><a class="fancybox" href="/assets/并发编程与高并发解决方案/137.jpg" title="" data-caption="" data-fancybox="travel"><img class="fig-img" src="/assets/并发编程与高并发解决方案/137.jpg" style="width:100%;height:100%;" alt=""></a></div><div style="clear:both;"></div>
<div class="figure center" style="width:100%;"><a class="fancybox" href="/assets/并发编程与高并发解决方案/138.jpg" title="" data-caption="" data-fancybox="travel"><img class="fig-img" src="/assets/并发编程与高并发解决方案/138.jpg" style="width:100%;height:100%;" alt=""></a></div><div style="clear:both;"></div>
<div class="figure center" style="width:100%;"><a class="fancybox" href="/assets/并发编程与高并发解决方案/139.jpg" title="" data-caption="" data-fancybox="travel"><img class="fig-img" src="/assets/并发编程与高并发解决方案/139.jpg" style="width:100%;height:100%;" alt=""></a></div><div style="clear:both;"></div>
<div class="figure center" style="width:100%;"><a class="fancybox" href="/assets/并发编程与高并发解决方案/140.jpg" title="" data-caption="" data-fancybox="travel"><img class="fig-img" src="/assets/并发编程与高并发解决方案/140.jpg" style="width:100%;height:100%;" alt=""></a></div><div style="clear:both;"></div>
<div class="figure center" style="width:100%;"><a class="fancybox" href="/assets/并发编程与高并发解决方案/141.jpg" title="" data-caption="" data-fancybox="travel"><img class="fig-img" src="/assets/并发编程与高并发解决方案/141.jpg" style="width:100%;height:100%;" alt=""></a></div><div style="clear:both;"></div>
<div class="figure center" style="width:100%;"><a class="fancybox" href="/assets/并发编程与高并发解决方案/142.jpg" title="" data-caption="" data-fancybox="travel"><img class="fig-img" src="/assets/并发编程与高并发解决方案/142.jpg" style="width:100%;height:100%;" alt=""></a></div><div style="clear:both;"></div>
<h5 id="数据库切库、分库、分表"><a href="#数据库切库、分库、分表" class="headerlink" title="数据库切库、分库、分表"></a>数据库切库、分库、分表</h5><div class="figure center" style="width:100%;"><a class="fancybox" href="/assets/并发编程与高并发解决方案/143.jpg" title="" data-caption="" data-fancybox="travel"><img class="fig-img" src="/assets/并发编程与高并发解决方案/143.jpg" style="width:100%;height:100%;" alt=""></a></div><div style="clear:both;"></div>
<div class="figure center" style="width:100%;"><a class="fancybox" href="/assets/并发编程与高并发解决方案/144.jpg" title="" data-caption="" data-fancybox="travel"><img class="fig-img" src="/assets/并发编程与高并发解决方案/144.jpg" style="width:100%;height:100%;" alt=""></a></div><div style="clear:both;"></div>
<div class="figure center" style="width:100%;"><a class="fancybox" href="/assets/并发编程与高并发解决方案/145.jpg" title="" data-caption="" data-fancybox="travel"><img class="fig-img" src="/assets/并发编程与高并发解决方案/145.jpg" style="width:100%;height:100%;" alt=""></a></div><div style="clear:both;"></div>
<div class="figure center" style="width:100%;"><a class="fancybox" href="/assets/并发编程与高并发解决方案/146.jpg" title="" data-caption="" data-fancybox="travel"><img class="fig-img" src="/assets/并发编程与高并发解决方案/146.jpg" style="width:100%;height:100%;" alt=""></a></div><div style="clear:both;"></div>

                    
                        

                    
                    
                        <p>
                            <a href="/2019/08/25/高并发解决方案/#post-footer" class="postShorten-excerpt_link link">
                                评论和共享
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a class="link-unstyled" href="/2019/08/25/并发编程与高并发解决方案/">
                            并发编程
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2019-08-25T11:46:27+08:00">
	
		    8月 25, 2019
    	
    </time>
    
</div>

            </div>
            
                <div class="postShorten-content">
                    <h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><div class="figure center" style="width:100%;"><a class="fancybox" href="/assets/并发编程与高并发解决方案/1.jpg" title="" data-caption="" data-fancybox="travel"><img class="fig-img" src="/assets/并发编程与高并发解决方案/1.jpg" style="width:100%;height:100%;" alt=""></a></div><div style="clear:both;"></div>
<div class="figure center" style="width:100%;"><a class="fancybox" href="/assets/并发编程与高并发解决方案/2.jpg" title="" data-caption="" data-fancybox="travel"><img class="fig-img" src="/assets/并发编程与高并发解决方案/2.jpg" style="width:100%;height:100%;" alt=""></a></div><div style="clear:both;"></div>
<div class="figure center" style="width:100%;"><a class="fancybox" href="/assets/并发编程与高并发解决方案/3.jpg" title="" data-caption="" data-fancybox="travel"><img class="fig-img" src="/assets/并发编程与高并发解决方案/3.jpg" style="width:100%;height:100%;" alt=""></a></div><div style="clear:both;"></div>
<div class="figure center" style="width:100%;"><a class="fancybox" href="/assets/并发编程与高并发解决方案/54.jpg" title="" data-caption="" data-fancybox="travel"><img class="fig-img" src="/assets/并发编程与高并发解决方案/54.jpg" style="width:100%;height:100%;" alt=""></a></div><div style="clear:both;"></div>
<h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><div class="figure center" style="width:100%;"><a class="fancybox" href="/assets/并发编程与高并发解决方案/4.jpg" title="" data-caption="" data-fancybox="travel"><img class="fig-img" src="/assets/并发编程与高并发解决方案/4.jpg" style="width:100%;height:100%;" alt=""></a></div><div style="clear:both;"></div>
<div class="figure center" style="width:100%;"><a class="fancybox" href="/assets/并发编程与高并发解决方案/5.jpg" title="" data-caption="" data-fancybox="travel"><img class="fig-img" src="/assets/并发编程与高并发解决方案/5.jpg" style="width:100%;height:100%;" alt=""></a></div><div style="clear:both;"></div>
<div class="figure center" style="width:100%;"><a class="fancybox" href="/assets/并发编程与高并发解决方案/6.jpg" title="" data-caption="" data-fancybox="travel"><img class="fig-img" src="/assets/并发编程与高并发解决方案/6.jpg" style="width:100%;height:100%;" alt=""></a></div><div style="clear:both;"></div>
<h3 id="CPU多级缓存"><a href="#CPU多级缓存" class="headerlink" title="CPU多级缓存"></a>CPU多级缓存</h3><div class="figure center" style="width:100%;"><a class="fancybox" href="/assets/并发编程与高并发解决方案/7.jpg" title="" data-caption="" data-fancybox="travel"><img class="fig-img" src="/assets/并发编程与高并发解决方案/7.jpg" style="width:100%;height:100%;" alt=""></a></div><div style="clear:both;"></div>
<div class="figure center" style="width:100%;"><a class="fancybox" href="/assets/并发编程与高并发解决方案/8.jpg" title="" data-caption="" data-fancybox="travel"><img class="fig-img" src="/assets/并发编程与高并发解决方案/8.jpg" style="width:100%;height:100%;" alt=""></a></div><div style="clear:both;"></div>
<div class="figure center" style="width:100%;"><a class="fancybox" href="/assets/并发编程与高并发解决方案/9.jpg" title="" data-caption="" data-fancybox="travel"><img class="fig-img" src="/assets/并发编程与高并发解决方案/9.jpg" style="width:100%;height:100%;" alt=""></a></div><div style="clear:both;"></div>
<div class="figure center" style="width:100%;"><a class="fancybox" href="/assets/并发编程与高并发解决方案/10.jpg" title="" data-caption="" data-fancybox="travel"><img class="fig-img" src="/assets/并发编程与高并发解决方案/10.jpg" style="width:100%;height:100%;" alt=""></a></div><div style="clear:both;"></div>
<div class="figure center" style="width:100%;"><a class="fancybox" href="/assets/并发编程与高并发解决方案/11.jpg" title="" data-caption="" data-fancybox="travel"><img class="fig-img" src="/assets/并发编程与高并发解决方案/11.jpg" style="width:100%;height:100%;" alt=""></a></div><div style="clear:both;"></div>
<h3 id="JAVA内存模型"><a href="#JAVA内存模型" class="headerlink" title="JAVA内存模型"></a>JAVA内存模型</h3><div class="figure center" style="width:100%;"><a class="fancybox" href="/assets/并发编程与高并发解决方案/12.jpg" title="" data-caption="" data-fancybox="travel"><img class="fig-img" src="/assets/并发编程与高并发解决方案/12.jpg" style="width:100%;height:100%;" alt=""></a></div><div style="clear:both;"></div>
<div class="figure center" style="width:100%;"><a class="fancybox" href="/assets/并发编程与高并发解决方案/13.jpg" title="" data-caption="" data-fancybox="travel"><img class="fig-img" src="/assets/并发编程与高并发解决方案/13.jpg" style="width:100%;height:100%;" alt=""></a></div><div style="clear:both;"></div>
<div class="figure center" style="width:100%;"><a class="fancybox" href="/assets/并发编程与高并发解决方案/14.jpg" title="" data-caption="" data-fancybox="travel"><img class="fig-img" src="/assets/并发编程与高并发解决方案/14.jpg" style="width:100%;height:100%;" alt=""></a></div><div style="clear:both;"></div>
<div class="figure center" style="width:100%;"><a class="fancybox" href="/assets/并发编程与高并发解决方案/15.jpg" title="" data-caption="" data-fancybox="travel"><img class="fig-img" src="/assets/并发编程与高并发解决方案/15.jpg" style="width:100%;height:100%;" alt=""></a></div><div style="clear:both;"></div>
<div class="figure center" style="width:100%;"><a class="fancybox" href="/assets/并发编程与高并发解决方案/16.jpg" title="" data-caption="" data-fancybox="travel"><img class="fig-img" src="/assets/并发编程与高并发解决方案/16.jpg" style="width:100%;height:100%;" alt=""></a></div><div style="clear:both;"></div>
<div class="figure center" style="width:100%;"><a class="fancybox" href="/assets/并发编程与高并发解决方案/17.jpg" title="" data-caption="" data-fancybox="travel"><img class="fig-img" src="/assets/并发编程与高并发解决方案/17.jpg" style="width:100%;height:100%;" alt=""></a></div><div style="clear:both;"></div>
<div class="figure center" style="width:100%;"><a class="fancybox" href="/assets/并发编程与高并发解决方案/18.jpg" title="" data-caption="" data-fancybox="travel"><img class="fig-img" src="/assets/并发编程与高并发解决方案/18.jpg" style="width:100%;height:100%;" alt=""></a></div><div style="clear:both;"></div>
<div class="figure center" style="width:100%;"><a class="fancybox" href="/assets/并发编程与高并发解决方案/19.jpg" title="" data-caption="" data-fancybox="travel"><img class="fig-img" src="/assets/并发编程与高并发解决方案/19.jpg" style="width:100%;height:100%;" alt=""></a></div><div style="clear:both;"></div>
<div class="figure center" style="width:100%;"><a class="fancybox" href="/assets/并发编程与高并发解决方案/20.jpg" title="" data-caption="" data-fancybox="travel"><img class="fig-img" src="/assets/并发编程与高并发解决方案/20.jpg" style="width:100%;height:100%;" alt=""></a></div><div style="clear:both;"></div>
<div class="figure center" style="width:100%;"><a class="fancybox" href="/assets/并发编程与高并发解决方案/21.jpg" title="" data-caption="" data-fancybox="travel"><img class="fig-img" src="/assets/并发编程与高并发解决方案/21.jpg" style="width:100%;height:100%;" alt=""></a></div><div style="clear:both;"></div>
<div class="figure center" style="width:100%;"><a class="fancybox" href="/assets/并发编程与高并发解决方案/22.jpg" title="" data-caption="" data-fancybox="travel"><img class="fig-img" src="/assets/并发编程与高并发解决方案/22.jpg" style="width:100%;height:100%;" alt=""></a></div><div style="clear:both;"></div>
<div class="figure center" style="width:100%;"><a class="fancybox" href="/assets/并发编程与高并发解决方案/23.jpg" title="" data-caption="" data-fancybox="travel"><img class="fig-img" src="/assets/并发编程与高并发解决方案/23.jpg" style="width:100%;height:100%;" alt=""></a></div><div style="clear:both;"></div>
<h3 id="并发的优势与风险"><a href="#并发的优势与风险" class="headerlink" title="并发的优势与风险"></a>并发的优势与风险</h3><div class="figure center" style="width:100%;"><a class="fancybox" href="/assets/并发编程与高并发解决方案/24.jpg" title="" data-caption="" data-fancybox="travel"><img class="fig-img" src="/assets/并发编程与高并发解决方案/24.jpg" style="width:100%;height:100%;" alt=""></a></div><div style="clear:both;"></div>
<h3 id="线程安全性"><a href="#线程安全性" class="headerlink" title="线程安全性"></a>线程安全性</h3><div class="figure center" style="width:100%;"><a class="fancybox" href="/assets/并发编程与高并发解决方案/25.jpg" title="" data-caption="" data-fancybox="travel"><img class="fig-img" src="/assets/并发编程与高并发解决方案/25.jpg" style="width:100%;height:100%;" alt=""></a></div><div style="clear:both;"></div>
<div class="figure center" style="width:100%;"><a class="fancybox" href="/assets/并发编程与高并发解决方案/26.jpg" title="" data-caption="" data-fancybox="travel"><img class="fig-img" src="/assets/并发编程与高并发解决方案/26.jpg" style="width:100%;height:100%;" alt=""></a></div><div style="clear:both;"></div>
<h4 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h4><div class="figure center" style="width:100%;"><a class="fancybox" href="/assets/并发编程与高并发解决方案/27.jpg" title="" data-caption="" data-fancybox="travel"><img class="fig-img" src="/assets/并发编程与高并发解决方案/27.jpg" style="width:100%;height:100%;" alt=""></a></div><div style="clear:both;"></div>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">import lombok.extern.slf4j.Slf4j;</span><br><span class="line"></span><br><span class="line">import java.util.concurrent.CountDownLatch;</span><br><span class="line">import java.util.concurrent.ExecutorService;</span><br><span class="line">import java.util.concurrent.Executors;</span><br><span class="line">import java.util.concurrent.Semaphore;</span><br><span class="line">import java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line">import java.util.concurrent.atomic.AtomicLong;</span><br><span class="line">import java.util.concurrent.atomic.LongAdder;</span><br><span class="line"></span><br><span class="line">@Slf4j</span><br><span class="line">@ThreadSafe</span><br><span class="line">public class AtomicExample1 &#123;</span><br><span class="line"></span><br><span class="line">    // 请求总数</span><br><span class="line">    public static int clientTotal = 5000;</span><br><span class="line"></span><br><span class="line">    // 同时并发执行的线程数</span><br><span class="line">    public static int threadTotal = 200;</span><br><span class="line"></span><br><span class="line">    public static AtomicInteger count = new AtomicInteger(0);</span><br><span class="line">    // public static AtomicLong count = new AtomicLong(0);</span><br><span class="line">    // public static LongAdder count = new LongAdder();</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">        final Semaphore semaphore = new Semaphore(threadTotal);</span><br><span class="line">        final CountDownLatch countDownLatch = new CountDownLatch(clientTotal);</span><br><span class="line">        for (int i = 0; i &lt; clientTotal ; i++) &#123;</span><br><span class="line">            executorService.execute(() -&gt; &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    semaphore.acquire();</span><br><span class="line">                    add();</span><br><span class="line">                    semaphore.release();</span><br><span class="line">                &#125; catch (Exception e) &#123;</span><br><span class="line">                    log.error(&quot;exception&quot;, e);</span><br><span class="line">                &#125;</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        countDownLatch.await();</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">        log.info(&quot;count:&#123;&#125;&quot;, count.get());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static void add() &#123;</span><br><span class="line">        count.incrementAndGet();</span><br><span class="line">        // count.getAndIncrement();</span><br><span class="line">        // count.increment();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">import lombok.extern.slf4j.Slf4j;</span><br><span class="line"></span><br><span class="line">import java.util.concurrent.CountDownLatch;</span><br><span class="line">import java.util.concurrent.ExecutorService;</span><br><span class="line">import java.util.concurrent.Executors;</span><br><span class="line">import java.util.concurrent.Semaphore;</span><br><span class="line">import java.util.concurrent.atomic.AtomicReference;</span><br><span class="line">import java.util.concurrent.atomic.LongAdder;</span><br><span class="line"></span><br><span class="line">@Slf4j</span><br><span class="line">@ThreadSafe</span><br><span class="line">public class AtomicExample4 &#123;</span><br><span class="line"></span><br><span class="line">    private static AtomicReference&lt;Integer&gt; count = new AtomicReference&lt;&gt;(0);</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        count.compareAndSet(0, 2); // 2</span><br><span class="line">        count.compareAndSet(0, 1); // no</span><br><span class="line">        count.compareAndSet(1, 3); // no</span><br><span class="line">        count.compareAndSet(2, 4); // 4</span><br><span class="line">        count.compareAndSet(3, 5); // no</span><br><span class="line">        log.info(&quot;count:&#123;&#125;&quot;, count.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;</span><br><span class="line"></span><br><span class="line">import lombok.Getter;</span><br><span class="line">import lombok.extern.slf4j.Slf4j;</span><br><span class="line"></span><br><span class="line">@Slf4j</span><br><span class="line">public class AtomicExample5 &#123;</span><br><span class="line"></span><br><span class="line">    private static AtomicIntegerFieldUpdater&lt;AtomicExample5&gt; updater =</span><br><span class="line">            AtomicIntegerFieldUpdater.newUpdater(AtomicExample5.class, &quot;count&quot;);</span><br><span class="line"></span><br><span class="line">    @Getter</span><br><span class="line">    public volatile int count = 100;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        AtomicExample5 example5 = new AtomicExample5();</span><br><span class="line"></span><br><span class="line">        if (updater.compareAndSet(example5, 100, 120)) &#123;</span><br><span class="line">            log.info(&quot;update success 1, &#123;&#125;&quot;, example5.getCount());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (updater.compareAndSet(example5, 100, 120)) &#123;</span><br><span class="line">            log.info(&quot;update success 2, &#123;&#125;&quot;, example5.getCount());</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            log.info(&quot;update failed, &#123;&#125;&quot;, example5.getCount());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">23:15:33.084 [main] INFO com.mmall.concurrency.example.atomic.AtomicExample5 - update success 1, 120</span><br><span class="line">23:15:33.089 [main] INFO com.mmall.concurrency.example.atomic.AtomicExample5 - update failed, 120</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">import lombok.extern.slf4j.Slf4j;</span><br><span class="line"></span><br><span class="line">import java.util.concurrent.CountDownLatch;</span><br><span class="line">import java.util.concurrent.ExecutorService;</span><br><span class="line">import java.util.concurrent.Executors;</span><br><span class="line">import java.util.concurrent.Semaphore;</span><br><span class="line">import java.util.concurrent.atomic.AtomicBoolean;</span><br><span class="line"></span><br><span class="line">@Slf4j</span><br><span class="line">@ThreadSafe</span><br><span class="line">public class AtomicExample6 &#123;</span><br><span class="line"></span><br><span class="line">    private static AtomicBoolean isHappened = new AtomicBoolean(false);</span><br><span class="line"></span><br><span class="line">    // 请求总数</span><br><span class="line">    public static int clientTotal = 5000;</span><br><span class="line"></span><br><span class="line">    // 同时并发执行的线程数</span><br><span class="line">    public static int threadTotal = 200;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">        final Semaphore semaphore = new Semaphore(threadTotal);</span><br><span class="line">        final CountDownLatch countDownLatch = new CountDownLatch(clientTotal);</span><br><span class="line">        for (int i = 0; i &lt; clientTotal ; i++) &#123;</span><br><span class="line">            executorService.execute(() -&gt; &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    semaphore.acquire();</span><br><span class="line">                    test();</span><br><span class="line">                    semaphore.release();</span><br><span class="line">                &#125; catch (Exception e) &#123;</span><br><span class="line">                    log.error(&quot;exception&quot;, e);</span><br><span class="line">                &#125;</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        countDownLatch.await();</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">        log.info(&quot;isHappened:&#123;&#125;&quot;, isHappened.get());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static void test() &#123;</span><br><span class="line">        if (isHappened.compareAndSet(false, true)) &#123;</span><br><span class="line">            log.info(&quot;execute&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">23:19:09.823 [pool-1-thread-1] INFO com.mmall.concurrency.example.atomic.AtomicExample6 - execute</span><br><span class="line">23:19:09.840 [main] INFO com.mmall.concurrency.example.atomic.AtomicExample6 - isHappened:true</span><br></pre></td></tr></table></figure></p>
<div class="figure center" style="width:100%;"><a class="fancybox" href="/assets/并发编程与高并发解决方案/28.jpg" title="" data-caption="" data-fancybox="travel"><img class="fig-img" src="/assets/并发编程与高并发解决方案/28.jpg" style="width:100%;height:100%;" alt=""></a></div><div style="clear:both;"></div>
<div class="figure center" style="width:100%;"><a class="fancybox" href="/assets/并发编程与高并发解决方案/29.jpg" title="" data-caption="" data-fancybox="travel"><img class="fig-img" src="/assets/并发编程与高并发解决方案/29.jpg" style="width:100%;height:100%;" alt=""></a></div><div style="clear:both;"></div>
<div class="figure center" style="width:100%;"><a class="fancybox" href="/assets/并发编程与高并发解决方案/30.jpg" title="" data-caption="" data-fancybox="travel"><img class="fig-img" src="/assets/并发编程与高并发解决方案/30.jpg" style="width:100%;height:100%;" alt=""></a></div><div style="clear:both;"></div>
<h4 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h4><div class="figure center" style="width:100%;"><a class="fancybox" href="/assets/并发编程与高并发解决方案/31.jpg" title="" data-caption="" data-fancybox="travel"><img class="fig-img" src="/assets/并发编程与高并发解决方案/31.jpg" style="width:100%;height:100%;" alt=""></a></div><div style="clear:both;"></div>
<div class="figure center" style="width:100%;"><a class="fancybox" href="/assets/并发编程与高并发解决方案/32.jpg" title="" data-caption="" data-fancybox="travel"><img class="fig-img" src="/assets/并发编程与高并发解决方案/32.jpg" style="width:100%;height:100%;" alt=""></a></div><div style="clear:both;"></div>
<div class="figure center" style="width:100%;"><a class="fancybox" href="/assets/并发编程与高并发解决方案/33.jpg" title="" data-caption="" data-fancybox="travel"><img class="fig-img" src="/assets/并发编程与高并发解决方案/33.jpg" style="width:100%;height:100%;" alt=""></a></div><div style="clear:both;"></div>
<div class="figure center" style="width:100%;"><a class="fancybox" href="/assets/并发编程与高并发解决方案/34.jpg" title="" data-caption="" data-fancybox="travel"><img class="fig-img" src="/assets/并发编程与高并发解决方案/34.jpg" style="width:100%;height:100%;" alt=""></a></div><div style="clear:both;"></div>
<div class="figure center" style="width:100%;"><a class="fancybox" href="/assets/并发编程与高并发解决方案/35.jpg" title="" data-caption="" data-fancybox="travel"><img class="fig-img" src="/assets/并发编程与高并发解决方案/35.jpg" style="width:100%;height:100%;" alt=""></a></div><div style="clear:both;"></div>
<div class="figure center" style="width:100%;"><a class="fancybox" href="/assets/并发编程与高并发解决方案/36.jpg" title="" data-caption="" data-fancybox="travel"><img class="fig-img" src="/assets/并发编程与高并发解决方案/36.jpg" style="width:100%;height:100%;" alt=""></a></div><div style="clear:both;"></div>
<h4 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h4><div class="figure center" style="width:100%;"><a class="fancybox" href="/assets/并发编程与高并发解决方案/38.jpg" title="" data-caption="" data-fancybox="travel"><img class="fig-img" src="/assets/并发编程与高并发解决方案/38.jpg" style="width:100%;height:100%;" alt=""></a></div><div style="clear:both;"></div>
<div class="figure center" style="width:100%;"><a class="fancybox" href="/assets/并发编程与高并发解决方案/39.jpg" title="" data-caption="" data-fancybox="travel"><img class="fig-img" src="/assets/并发编程与高并发解决方案/39.jpg" style="width:100%;height:100%;" alt=""></a></div><div style="clear:both;"></div>
<div class="figure center" style="width:100%;"><a class="fancybox" href="/assets/并发编程与高并发解决方案/40.jpg" title="" data-caption="" data-fancybox="travel"><img class="fig-img" src="/assets/并发编程与高并发解决方案/40.jpg" style="width:100%;height:100%;" alt=""></a></div><div style="clear:both;"></div>
<div class="figure center" style="width:100%;"><a class="fancybox" href="/assets/并发编程与高并发解决方案/41.jpg" title="" data-caption="" data-fancybox="travel"><img class="fig-img" src="/assets/并发编程与高并发解决方案/41.jpg" style="width:100%;height:100%;" alt=""></a></div><div style="clear:both;"></div>
<div class="figure center" style="width:100%;"><a class="fancybox" href="/assets/并发编程与高并发解决方案/42.jpg" title="" data-caption="" data-fancybox="travel"><img class="fig-img" src="/assets/并发编程与高并发解决方案/42.jpg" style="width:100%;height:100%;" alt=""></a></div><div style="clear:both;"></div>
<h3 id="安全发布对象"><a href="#安全发布对象" class="headerlink" title="安全发布对象"></a>安全发布对象</h3><div class="figure center" style="width:100%;"><a class="fancybox" href="/assets/并发编程与高并发解决方案/43.jpg" title="" data-caption="" data-fancybox="travel"><img class="fig-img" src="/assets/并发编程与高并发解决方案/43.jpg" style="width:100%;height:100%;" alt=""></a></div><div style="clear:both;"></div>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">import lombok.extern.slf4j.Slf4j;</span><br><span class="line"></span><br><span class="line">@Slf4j</span><br><span class="line">@NotThreadSafe</span><br><span class="line">@NotRecommend</span><br><span class="line">public class Escape &#123;</span><br><span class="line"></span><br><span class="line">    private int thisCanBeEscape = 0;</span><br><span class="line"></span><br><span class="line">    public Escape () &#123;</span><br><span class="line">        new InnerClass();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private class InnerClass &#123;</span><br><span class="line"></span><br><span class="line">        public InnerClass() &#123;</span><br><span class="line">            log.info(&quot;&#123;&#125;&quot;, Escape.this.thisCanBeEscape);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        new Escape();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">import lombok.extern.slf4j.Slf4j;</span><br><span class="line"></span><br><span class="line">import java.util.Arrays;</span><br><span class="line"></span><br><span class="line">@Slf4j</span><br><span class="line">@NotThreadSafe</span><br><span class="line">public class UnsafePublish &#123;</span><br><span class="line">    private String[] states = &#123;&quot;a&quot;, &quot;b&quot;, &quot;c&quot;&#125;;</span><br><span class="line"></span><br><span class="line">    public String[] getStates() &#123;</span><br><span class="line">        return states;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        UnsafePublish unsafePublish = new UnsafePublish();</span><br><span class="line">        log.info(&quot;&#123;&#125;&quot;, Arrays.toString(unsafePublish.getStates()));</span><br><span class="line"></span><br><span class="line">        unsafePublish.getStates()[0] = &quot;d&quot;;</span><br><span class="line">        log.info(&quot;&#123;&#125;&quot;, Arrays.toString(unsafePublish.getStates()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<div class="figure center" style="width:100%;"><a class="fancybox" href="/assets/并发编程与高并发解决方案/44.jpg" title="" data-caption="" data-fancybox="travel"><img class="fig-img" src="/assets/并发编程与高并发解决方案/44.jpg" style="width:100%;height:100%;" alt=""></a></div><div style="clear:both;"></div>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 懒汉模式</span><br><span class="line"> * 单例实例在第一次使用时进行创建</span><br><span class="line"> */</span><br><span class="line">@NotThreadSafe</span><br><span class="line">public class SingletonExample1 &#123;</span><br><span class="line">    // 私有构造函数</span><br><span class="line">    private SingletonExample1() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    // 单例对象</span><br><span class="line">    private static SingletonExample1 instance = null;</span><br><span class="line"></span><br><span class="line">    // 静态的工厂方法</span><br><span class="line">    public static SingletonExample1 getInstance() &#123;</span><br><span class="line">        if (instance == null) &#123;</span><br><span class="line">            instance = new SingletonExample1();</span><br><span class="line">        &#125;</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 饿汉模式</span><br><span class="line"> * 单例实例在类装载时进行创建</span><br><span class="line"> */</span><br><span class="line">@ThreadSafe</span><br><span class="line">public class SingletonExample2 &#123;</span><br><span class="line">    // 私有构造函数</span><br><span class="line">    private SingletonExample2() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    // 单例对象</span><br><span class="line">    private static SingletonExample2 instance = new SingletonExample2();</span><br><span class="line"></span><br><span class="line">    // 静态的工厂方法</span><br><span class="line">    public static SingletonExample2 getInstance() &#123;</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 懒汉模式</span><br><span class="line"> * 单例实例在第一次使用时进行创建</span><br><span class="line"> */</span><br><span class="line">@ThreadSafe</span><br><span class="line">@NotRecommend</span><br><span class="line">public class SingletonExample3 &#123;</span><br><span class="line">    // 私有构造函数</span><br><span class="line">    private SingletonExample3() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    // 单例对象</span><br><span class="line">    private static SingletonExample3 instance = null;</span><br><span class="line"></span><br><span class="line">    // 静态的工厂方法</span><br><span class="line">    public static synchronized SingletonExample3 getInstance() &#123;</span><br><span class="line">        if (instance == null) &#123;</span><br><span class="line">            instance = new SingletonExample3();</span><br><span class="line">        &#125;</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 懒汉模式 -》 双重同步锁单例模式</span><br><span class="line"> * 单例实例在第一次使用时进行创建</span><br><span class="line"> */</span><br><span class="line">@NotThreadSafe</span><br><span class="line">public class SingletonExample4 &#123;</span><br><span class="line">    // 私有构造函数</span><br><span class="line">    private SingletonExample4() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    // 1、memory = allocate() 分配对象的内存空间</span><br><span class="line">    // 2、ctorInstance() 初始化对象</span><br><span class="line">    // 3、instance = memory 设置instance指向刚分配的内存</span><br><span class="line"></span><br><span class="line">    // JVM和cpu优化，发生了指令重排</span><br><span class="line"></span><br><span class="line">    // 1、memory = allocate() 分配对象的内存空间</span><br><span class="line">    // 3、instance = memory 设置instance指向刚分配的内存</span><br><span class="line">    // 2、ctorInstance() 初始化对象</span><br><span class="line"></span><br><span class="line">    // 单例对象</span><br><span class="line">    private static SingletonExample4 instance = null;</span><br><span class="line"></span><br><span class="line">    // 静态的工厂方法</span><br><span class="line">    public static SingletonExample4 getInstance() &#123;</span><br><span class="line">        if (instance == null) &#123; // 双重检测机制        // B</span><br><span class="line">            synchronized (SingletonExample4.class) &#123; // 同步锁</span><br><span class="line">                if (instance == null) &#123;</span><br><span class="line">                    instance = new SingletonExample4(); // A - 3</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 懒汉模式 -》 双重同步锁单例模式</span><br><span class="line"> * 单例实例在第一次使用时进行创建</span><br><span class="line"> */</span><br><span class="line">@ThreadSafe</span><br><span class="line">public class SingletonExample5 &#123;</span><br><span class="line">    // 私有构造函数</span><br><span class="line">    private SingletonExample5() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    // 1、memory = allocate() 分配对象的内存空间</span><br><span class="line">    // 2、ctorInstance() 初始化对象</span><br><span class="line">    // 3、instance = memory 设置instance指向刚分配的内存</span><br><span class="line"></span><br><span class="line">    // 单例对象 volatile + 双重检测机制 -&gt; 禁止指令重排</span><br><span class="line">    private volatile static SingletonExample5 instance = null;</span><br><span class="line"></span><br><span class="line">    // 静态的工厂方法</span><br><span class="line">    public static SingletonExample5 getInstance() &#123;</span><br><span class="line">        if (instance == null) &#123; // 双重检测机制        // B</span><br><span class="line">            synchronized (SingletonExample5.class) &#123; // 同步锁</span><br><span class="line">                if (instance == null) &#123;</span><br><span class="line">                    instance = new SingletonExample5(); // A - 3</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 饿汉模式</span><br><span class="line"> * 单例实例在类装载时进行创建</span><br><span class="line"> */</span><br><span class="line">@ThreadSafe</span><br><span class="line">public class SingletonExample6 &#123;</span><br><span class="line">    // 私有构造函数</span><br><span class="line">    private SingletonExample6() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    // 单例对象</span><br><span class="line">    private static SingletonExample6 instance = null;</span><br><span class="line"></span><br><span class="line">    static &#123;</span><br><span class="line">        instance = new SingletonExample6();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 静态的工厂方法</span><br><span class="line">    public static SingletonExample6 getInstance() &#123;</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        System.out.println(getInstance().hashCode());</span><br><span class="line">        System.out.println(getInstance().hashCode());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 枚举模式：最安全</span><br><span class="line"> */</span><br><span class="line">@ThreadSafe</span><br><span class="line">@Recommend</span><br><span class="line">public class SingletonExample7 &#123;</span><br><span class="line"></span><br><span class="line">    // 私有构造函数</span><br><span class="line">    private SingletonExample7() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    public static SingletonExample7 getInstance() &#123;</span><br><span class="line">        return Singleton.INSTANCE.getInstance();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private enum Singleton &#123;</span><br><span class="line">        INSTANCE;</span><br><span class="line"></span><br><span class="line">        private SingletonExample7 singleton;</span><br><span class="line"></span><br><span class="line">        // JVM保证这个方法绝对只调用一次</span><br><span class="line">        Singleton() &#123;</span><br><span class="line">            singleton = new SingletonExample7();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public SingletonExample7 getInstance() &#123;</span><br><span class="line">            return singleton;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="不可变对象"><a href="#不可变对象" class="headerlink" title="不可变对象"></a>不可变对象</h3><div class="figure center" style="width:100%;"><a class="fancybox" href="/assets/并发编程与高并发解决方案/45.jpg" title="" data-caption="" data-fancybox="travel"><img class="fig-img" src="/assets/并发编程与高并发解决方案/45.jpg" style="width:100%;height:100%;" alt=""></a></div><div style="clear:both;"></div>
<div class="figure center" style="width:100%;"><a class="fancybox" href="/assets/并发编程与高并发解决方案/47.jpg" title="" data-caption="" data-fancybox="travel"><img class="fig-img" src="/assets/并发编程与高并发解决方案/47.jpg" style="width:100%;height:100%;" alt=""></a></div><div style="clear:both;"></div>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">import com.google.common.collect.Maps;</span><br><span class="line">import lombok.extern.slf4j.Slf4j;</span><br><span class="line"></span><br><span class="line">import java.util.Map;</span><br><span class="line"></span><br><span class="line">@Slf4j</span><br><span class="line">@NotThreadSafe</span><br><span class="line">public class ImmutableExample1 &#123;</span><br><span class="line"></span><br><span class="line">    private final static Integer a = 1;</span><br><span class="line">    private final static String b = &quot;2&quot;;</span><br><span class="line">    private final static Map&lt;Integer, Integer&gt; map = Maps.newHashMap();</span><br><span class="line"></span><br><span class="line">    static &#123;</span><br><span class="line">        map.put(1, 2);</span><br><span class="line">        map.put(3, 4);</span><br><span class="line">        map.put(5, 6);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">//        a = 2;</span><br><span class="line">//        b = &quot;3&quot;;</span><br><span class="line">//        map = Maps.newHashMap();</span><br><span class="line">        map.put(1, 3);</span><br><span class="line">        log.info(&quot;&#123;&#125;&quot;, map.get(1));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void test(final int a) &#123;</span><br><span class="line">//        a = 1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<div class="figure center" style="width:100%;"><a class="fancybox" href="/assets/并发编程与高并发解决方案/48.jpg" title="" data-caption="" data-fancybox="travel"><img class="fig-img" src="/assets/并发编程与高并发解决方案/48.jpg" style="width:100%;height:100%;" alt=""></a></div><div style="clear:both;"></div>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">import com.google.common.collect.Maps;</span><br><span class="line">import lombok.extern.slf4j.Slf4j;</span><br><span class="line"></span><br><span class="line">import java.util.Collections;</span><br><span class="line">import java.util.Map;</span><br><span class="line"></span><br><span class="line">@Slf4j</span><br><span class="line">@ThreadSafe</span><br><span class="line">public class ImmutableExample2 &#123;</span><br><span class="line"></span><br><span class="line">    private static Map&lt;Integer, Integer&gt; map = Maps.newHashMap();</span><br><span class="line"></span><br><span class="line">    static &#123;</span><br><span class="line">        map.put(1, 2);</span><br><span class="line">        map.put(3, 4);</span><br><span class="line">        map.put(5, 6);</span><br><span class="line">        map = Collections.unmodifiableMap(map);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        map.put(1, 3);</span><br><span class="line">        log.info(&quot;&#123;&#125;&quot;, map.get(1));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread &quot;main&quot; java.lang.UnsupportedOperationException</span><br><span class="line">	at java.util.Collections$UnmodifiableMap.put(Collections.java:1457)</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">import com.google.common.collect.ImmutableList;</span><br><span class="line">import com.google.common.collect.ImmutableMap;</span><br><span class="line">import com.google.common.collect.ImmutableSet;</span><br><span class="line"></span><br><span class="line">@ThreadSafe</span><br><span class="line">public class ImmutableExample3 &#123;</span><br><span class="line"></span><br><span class="line">    private final static ImmutableList&lt;Integer&gt; list = ImmutableList.of(1, 2, 3);</span><br><span class="line">    private final static ImmutableSet set = ImmutableSet.copyOf(list);</span><br><span class="line">    private final static ImmutableMap&lt;Integer, Integer&gt; map = ImmutableMap.of(1, 2, 3, 4);</span><br><span class="line">    private final static ImmutableMap&lt;Integer, Integer&gt; map2 = ImmutableMap.&lt;Integer, Integer&gt;builder()</span><br><span class="line">            .put(1, 2).put(3, 4).put(5, 6).build();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        System.out.println(map2.get(3));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="线程封闭"><a href="#线程封闭" class="headerlink" title="线程封闭"></a>线程封闭</h3><div class="figure center" style="width:100%;"><a class="fancybox" href="/assets/并发编程与高并发解决方案/49.jpg" title="" data-caption="" data-fancybox="travel"><img class="fig-img" src="/assets/并发编程与高并发解决方案/49.jpg" style="width:100%;height:100%;" alt=""></a></div><div style="clear:both;"></div>
<h3 id="线程不安全类与写法"><a href="#线程不安全类与写法" class="headerlink" title="线程不安全类与写法"></a>线程不安全类与写法</h3><div class="figure center" style="width:100%;"><a class="fancybox" href="/assets/并发编程与高并发解决方案/51.jpg" title="" data-caption="" data-fancybox="travel"><img class="fig-img" src="/assets/并发编程与高并发解决方案/51.jpg" style="width:100%;height:100%;" alt=""></a></div><div style="clear:both;"></div>
<p>JodaTime:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">import com.mmall.concurrency.annoations.ThreadSafe;</span><br><span class="line">import lombok.extern.slf4j.Slf4j;</span><br><span class="line">import org.joda.time.DateTime;</span><br><span class="line">import org.joda.time.format.DateTimeFormat;</span><br><span class="line">import org.joda.time.format.DateTimeFormatter;</span><br><span class="line"></span><br><span class="line">import java.util.concurrent.CountDownLatch;</span><br><span class="line">import java.util.concurrent.ExecutorService;</span><br><span class="line">import java.util.concurrent.Executors;</span><br><span class="line">import java.util.concurrent.Semaphore;</span><br><span class="line"></span><br><span class="line">@Slf4j</span><br><span class="line">@ThreadSafe</span><br><span class="line">public class DateFormatExample3 &#123;</span><br><span class="line">    // 请求总数</span><br><span class="line">    public static int clientTotal = 5000;</span><br><span class="line">    // 同时并发执行的线程数</span><br><span class="line">    public static int threadTotal = 200;</span><br><span class="line"></span><br><span class="line">    private static DateTimeFormatter dateTimeFormatter = DateTimeFormat.forPattern(&quot;yyyyMMdd&quot;);</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">        final Semaphore semaphore = new Semaphore(threadTotal);</span><br><span class="line">        final CountDownLatch countDownLatch = new CountDownLatch(clientTotal);</span><br><span class="line">        for (int i = 0; i &lt; clientTotal; i++) &#123;</span><br><span class="line">            final int count = i;</span><br><span class="line">            executorService.execute(() -&gt; &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    semaphore.acquire();</span><br><span class="line">                    update(count);</span><br><span class="line">                    semaphore.release();</span><br><span class="line">                &#125; catch (Exception e) &#123;</span><br><span class="line">                    log.error(&quot;exception&quot;, e);</span><br><span class="line">                &#125;</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        countDownLatch.await();</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static void update(int i) &#123;</span><br><span class="line">        log.info(&quot;&#123;&#125;, &#123;&#125;&quot;, i, DateTime.parse(&quot;20180208&quot;, dateTimeFormatter).toDate());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="同步容器"><a href="#同步容器" class="headerlink" title="同步容器"></a>同步容器</h3><div class="figure center" style="width:100%;"><a class="fancybox" href="/assets/并发编程与高并发解决方案/52.jpg" title="" data-caption="" data-fancybox="travel"><img class="fig-img" src="/assets/并发编程与高并发解决方案/52.jpg" style="width:100%;height:100%;" alt=""></a></div><div style="clear:both;"></div>
<p>Vector不是线程安全的情况:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Vector;</span><br><span class="line"></span><br><span class="line">@NotThreadSafe</span><br><span class="line">public class VectorExample2 &#123;</span><br><span class="line"></span><br><span class="line">    private static Vector&lt;Integer&gt; vector = new Vector&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        while (true) &#123;</span><br><span class="line"></span><br><span class="line">            for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">                vector.add(i);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Thread thread1 = new Thread() &#123;</span><br><span class="line">                public void run() &#123;</span><br><span class="line">                    for (int i = 0; i &lt; vector.size(); i++) &#123;</span><br><span class="line">                        vector.remove(i);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            Thread thread2 = new Thread() &#123;</span><br><span class="line">                public void run() &#123;</span><br><span class="line">                    for (int i = 0; i &lt; vector.size(); i++) &#123;</span><br><span class="line">                        vector.get(i);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            thread1.start();</span><br><span class="line">            thread2.start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>ConcurrentModificationException:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Iterator;</span><br><span class="line">import java.util.Vector;</span><br><span class="line"></span><br><span class="line">public class VectorExample3 &#123;</span><br><span class="line">    // java.util.ConcurrentModificationException</span><br><span class="line">    private static void test1(Vector&lt;Integer&gt; v1) &#123; // foreach</span><br><span class="line">        for(Integer i : v1) &#123;</span><br><span class="line">            if (i.equals(3)) &#123;</span><br><span class="line">                v1.remove(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // java.util.ConcurrentModificationException</span><br><span class="line">    private static void test2(Vector&lt;Integer&gt; v1) &#123; // iterator</span><br><span class="line">        Iterator&lt;Integer&gt; iterator = v1.iterator();</span><br><span class="line">        while (iterator.hasNext()) &#123;</span><br><span class="line">            Integer i = iterator.next();</span><br><span class="line">            if (i.equals(3)) &#123;</span><br><span class="line">                v1.remove(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // success</span><br><span class="line">    private static void test3(Vector&lt;Integer&gt; v1) &#123; // for</span><br><span class="line">        for (int i = 0; i &lt; v1.size(); i++) &#123;</span><br><span class="line">            if (v1.get(i).equals(3)) &#123;</span><br><span class="line">                v1.remove(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        Vector&lt;Integer&gt; vector = new Vector&lt;&gt;();</span><br><span class="line">        vector.add(1);</span><br><span class="line">        vector.add(2);</span><br><span class="line">        vector.add(3);</span><br><span class="line">        test1(vector);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Collections.synchronizedXXX<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">import com.google.common.collect.Lists;</span><br><span class="line">import com.google.common.collect.Sets;</span><br><span class="line">import com.mmall.concurrency.annoations.ThreadSafe;</span><br><span class="line">import lombok.extern.slf4j.Slf4j;</span><br><span class="line"></span><br><span class="line">import java.util.Collections;</span><br><span class="line">import java.util.List;</span><br><span class="line">import java.util.Vector;</span><br><span class="line">import java.util.Set;</span><br><span class="line">import java.util.concurrent.CountDownLatch;</span><br><span class="line">import java.util.concurrent.ExecutorService;</span><br><span class="line">import java.util.concurrent.Executors;</span><br><span class="line">import java.util.concurrent.Semaphore;</span><br><span class="line"></span><br><span class="line">@Slf4j</span><br><span class="line">@ThreadSafe</span><br><span class="line">public class CollectionsExample1 &#123;</span><br><span class="line"></span><br><span class="line">    // 请求总数</span><br><span class="line">    public static int clientTotal = 5000;</span><br><span class="line"></span><br><span class="line">    // 同时并发执行的线程数</span><br><span class="line">    public static int threadTotal = 200;</span><br><span class="line"></span><br><span class="line">    private static List&lt;Integer&gt; list = Collections.synchronizedList(Lists.newArrayList());</span><br><span class="line">    // private static Set&lt;Integer&gt; set = Collections.synchronizedSet(Sets.newHashSet());</span><br><span class="line">    // private static Map&lt;Integer, Integer&gt; map = Collections.synchronizedMap(new HashMap&lt;&gt;());</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">        final Semaphore semaphore = new Semaphore(threadTotal);</span><br><span class="line">        final CountDownLatch countDownLatch = new CountDownLatch(clientTotal);</span><br><span class="line">        for (int i = 0; i &lt; clientTotal; i++) &#123;</span><br><span class="line">            final int count = i;</span><br><span class="line">            executorService.execute(() -&gt; &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    semaphore.acquire();</span><br><span class="line">                    update(count);</span><br><span class="line">                    semaphore.release();</span><br><span class="line">                &#125; catch (Exception e) &#123;</span><br><span class="line">                    log.error(&quot;exception&quot;, e);</span><br><span class="line">                &#125;</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        countDownLatch.await();</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">        log.info(&quot;size:&#123;&#125;&quot;, list.size());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static void update(int i) &#123;</span><br><span class="line">        list.add(i);</span><br><span class="line">        // set.add(i);</span><br><span class="line">        // map.put(i, i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<div class="figure center" style="width:100%;"><a class="fancybox" href="/assets/并发编程与高并发解决方案/53.jpg" title="" data-caption="" data-fancybox="travel"><img class="fig-img" src="/assets/并发编程与高并发解决方案/53.jpg" style="width:100%;height:100%;" alt=""></a></div><div style="clear:both;"></div>
<h3 id="安全共享策略"><a href="#安全共享策略" class="headerlink" title="安全共享策略"></a>安全共享策略</h3><div class="figure center" style="width:100%;"><a class="fancybox" href="/assets/并发编程与高并发解决方案/55.jpg" title="" data-caption="" data-fancybox="travel"><img class="fig-img" src="/assets/并发编程与高并发解决方案/55.jpg" style="width:100%;height:100%;" alt=""></a></div><div style="clear:both;"></div>
<div class="figure center" style="width:100%;"><a class="fancybox" href="/assets/并发编程与高并发解决方案/57.jpg" title="" data-caption="" data-fancybox="travel"><img class="fig-img" src="/assets/并发编程与高并发解决方案/57.jpg" style="width:100%;height:100%;" alt=""></a></div><div style="clear:both;"></div>
<h3 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h3><div class="figure center" style="width:100%;"><a class="fancybox" href="/assets/并发编程与高并发解决方案/58.jpg" title="" data-caption="" data-fancybox="travel"><img class="fig-img" src="/assets/并发编程与高并发解决方案/58.jpg" style="width:100%;height:100%;" alt=""></a></div><div style="clear:both;"></div>
<div class="figure center" style="width:100%;"><a class="fancybox" href="/assets/并发编程与高并发解决方案/59.jpg" title="" data-caption="" data-fancybox="travel"><img class="fig-img" src="/assets/并发编程与高并发解决方案/59.jpg" style="width:100%;height:100%;" alt=""></a></div><div style="clear:both;"></div>
<div class="figure center" style="width:100%;"><a class="fancybox" href="/assets/并发编程与高并发解决方案/60.jpg" title="" data-caption="" data-fancybox="travel"><img class="fig-img" src="/assets/并发编程与高并发解决方案/60.jpg" style="width:100%;height:100%;" alt=""></a></div><div style="clear:both;"></div>
<p>Sync queue 同步队列（底层是双向链表）<br>Condition queue 单向链表（不是必须的，需要用到的时候才会使用）</p>
<h4 id="aqs实现的具体大致思路"><a href="#aqs实现的具体大致思路" class="headerlink" title="aqs实现的具体大致思路:"></a>aqs实现的具体大致思路:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">aqs内部维护了一个clh队列来管理锁，线程会首先尝试获取锁，如果失败，就将当前线程以及等待信息包成一个node节点，加入到之前介绍的同步队列</span><br><span class="line">，接着会不断循环尝试获取锁，条件是，当前节点为head的直接后继才会尝试，如果失败，就会阻塞自己，直到自己被唤醒，而当持有锁的线程释放锁的时候，会</span><br><span class="line">唤醒队列中的后继线程，基于这些基础的设计和思路，jdk提供了很多基于aqs的子类</span><br></pre></td></tr></table></figure>
<div class="figure center" style="width:100%;"><a class="fancybox" href="/assets/并发编程与高并发解决方案/61.jpg" title="" data-caption="" data-fancybox="travel"><img class="fig-img" src="/assets/并发编程与高并发解决方案/61.jpg" style="width:100%;height:100%;" alt=""></a></div><div style="clear:both;"></div>
<div class="figure center" style="width:100%;"><a class="fancybox" href="/assets/并发编程与高并发解决方案/62.jpg" title="" data-caption="" data-fancybox="travel"><img class="fig-img" src="/assets/并发编程与高并发解决方案/62.jpg" style="width:100%;height:100%;" alt=""></a></div><div style="clear:both;"></div>
<div class="figure center" style="width:100%;"><a class="fancybox" href="/assets/并发编程与高并发解决方案/63.jpg" title="" data-caption="" data-fancybox="travel"><img class="fig-img" src="/assets/并发编程与高并发解决方案/63.jpg" style="width:100%;height:100%;" alt=""></a></div><div style="clear:both;"></div>
<h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景:"></a>使用场景:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">程序执行需要等待某个条件完成后才能继续执行后续的操作，典型的应用比如：并行计算</span><br><span class="line">当某个处理的运算量很大时，可以将该运算任务拆分成多个子任务，等待所有的子任务都完成后，</span><br><span class="line">父任务再拿到所有子任务的运算结果进行汇总</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">import lombok.extern.slf4j.Slf4j;</span><br><span class="line"></span><br><span class="line">import java.util.concurrent.CountDownLatch;</span><br><span class="line">import java.util.concurrent.ExecutorService;</span><br><span class="line">import java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line">@Slf4j</span><br><span class="line">public class CountDownLatchExample1 &#123;</span><br><span class="line"></span><br><span class="line">    private final static int threadCount = 200;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">        ExecutorService exec = Executors.newCachedThreadPool();</span><br><span class="line"></span><br><span class="line">        final CountDownLatch countDownLatch = new CountDownLatch(threadCount);</span><br><span class="line"></span><br><span class="line">        for (int i = 0; i &lt; threadCount; i++) &#123;</span><br><span class="line">            final int threadNum = i;</span><br><span class="line">            exec.execute(() -&gt; &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    test(threadNum);</span><br><span class="line">                &#125; catch (Exception e) &#123;</span><br><span class="line">                    log.error(&quot;exception&quot;, e);</span><br><span class="line">                &#125; finally &#123;</span><br><span class="line">                    countDownLatch.countDown();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        countDownLatch.await();</span><br><span class="line">        log.info(&quot;finish&quot;);</span><br><span class="line">        exec.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static void test(int threadNum) throws Exception &#123;</span><br><span class="line">        Thread.sleep(100);</span><br><span class="line">        log.info(&quot;&#123;&#125;&quot;, threadNum);</span><br><span class="line">        Thread.sleep(100);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">15:14:51.589 [pool-1-thread-10] INFO com.mmall.concurrency.example.aqs.CountDownLatchExample1 - 9</span><br><span class="line">15:14:51.589 [pool-1-thread-6] INFO com.mmall.concurrency.example.aqs.CountDownLatchExample1 - 5</span><br><span class="line">15:14:51.589 [pool-1-thread-3] INFO com.mmall.concurrency.example.aqs.CountDownLatchExample1 - 2</span><br><span class="line">15:14:51.589 [pool-1-thread-7] INFO com.mmall.concurrency.example.aqs.CountDownLatchExample1 - 6</span><br><span class="line">15:14:51.589 [pool-1-thread-1] INFO com.mmall.concurrency.example.aqs.CountDownLatchExample1 - 0</span><br><span class="line">15:14:51.589 [pool-1-thread-5] INFO com.mmall.concurrency.example.aqs.CountDownLatchExample1 - 4</span><br><span class="line">15:14:51.589 [pool-1-thread-9] INFO com.mmall.concurrency.example.aqs.CountDownLatchExample1 - 8</span><br><span class="line">15:14:51.589 [pool-1-thread-4] INFO com.mmall.concurrency.example.aqs.CountDownLatchExample1 - 3</span><br><span class="line">15:14:51.589 [pool-1-thread-2] INFO com.mmall.concurrency.example.aqs.CountDownLatchExample1 - 1</span><br><span class="line">15:14:51.589 [pool-1-thread-8] INFO com.mmall.concurrency.example.aqs.CountDownLatchExample1 - 7</span><br><span class="line">15:14:51.696 [main] INFO com.mmall.concurrency.example.aqs.CountDownLatchExample1 - finish</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">import java.util.concurrent.CountDownLatch;</span><br><span class="line">import java.util.concurrent.ExecutorService;</span><br><span class="line">import java.util.concurrent.Executors;</span><br><span class="line">import java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line">import lombok.extern.slf4j.Slf4j;</span><br><span class="line"></span><br><span class="line">@Slf4j</span><br><span class="line">public class CountDownLatchExample2 &#123;</span><br><span class="line"></span><br><span class="line">    private final static int threadCount = 10;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">        ExecutorService exec = Executors.newCachedThreadPool();</span><br><span class="line"></span><br><span class="line">        final CountDownLatch countDownLatch = new CountDownLatch(threadCount);</span><br><span class="line"></span><br><span class="line">        for (int i = 0; i &lt; threadCount; i++) &#123;</span><br><span class="line">            final int threadNum = i;</span><br><span class="line">            exec.execute(() -&gt; &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    test(threadNum);</span><br><span class="line">                &#125; catch (Exception e) &#123;</span><br><span class="line">                    log.error(&quot;exception&quot;, e);</span><br><span class="line">                &#125; finally &#123;</span><br><span class="line">                    countDownLatch.countDown();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        countDownLatch.await(10, TimeUnit.MILLISECONDS);</span><br><span class="line">        log.info(&quot;finish&quot;);</span><br><span class="line">        exec.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static void test(int threadNum) throws Exception &#123;</span><br><span class="line">        Thread.sleep(100);</span><br><span class="line">        log.info(&quot;&#123;&#125;&quot;, threadNum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">15:17:50.556 [main] INFO com.mmall.concurrency.example.aqs.CountDownLatchExample2 - finish</span><br><span class="line">15:17:50.644 [pool-1-thread-1] INFO com.mmall.concurrency.example.aqs.CountDownLatchExample2 - 0</span><br><span class="line">15:17:50.644 [pool-1-thread-4] INFO com.mmall.concurrency.example.aqs.CountDownLatchExample2 - 3</span><br><span class="line">15:17:50.644 [pool-1-thread-3] INFO com.mmall.concurrency.example.aqs.CountDownLatchExample2 - 2</span><br><span class="line">15:17:50.644 [pool-1-thread-7] INFO com.mmall.concurrency.example.aqs.CountDownLatchExample2 - 6</span><br><span class="line">15:17:50.644 [pool-1-thread-8] INFO com.mmall.concurrency.example.aqs.CountDownLatchExample2 - 7</span><br><span class="line">15:17:50.644 [pool-1-thread-2] INFO com.mmall.concurrency.example.aqs.CountDownLatchExample2 - 1</span><br><span class="line">15:17:50.645 [pool-1-thread-10] INFO com.mmall.concurrency.example.aqs.CountDownLatchExample2 - 9</span><br><span class="line">15:17:50.644 [pool-1-thread-9] INFO com.mmall.concurrency.example.aqs.CountDownLatchExample2 - 8</span><br><span class="line">15:17:50.644 [pool-1-thread-6] INFO com.mmall.concurrency.example.aqs.CountDownLatchExample2 - 5</span><br><span class="line">15:17:50.644 [pool-1-thread-5] INFO com.mmall.concurrency.example.aqs.CountDownLatchExample2 - 4</span><br></pre></td></tr></table></figure></p>
<div class="figure center" style="width:100%;"><a class="fancybox" href="/assets/并发编程与高并发解决方案/64.jpg" title="" data-caption="" data-fancybox="travel"><img class="fig-img" src="/assets/并发编程与高并发解决方案/64.jpg" style="width:100%;height:100%;" alt=""></a></div><div style="clear:both;"></div>
<h4 id="使用场景-1"><a href="#使用场景-1" class="headerlink" title="使用场景:"></a>使用场景:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">仅能提供有限的访问资源，比如：我们项目中的数据库，数据库的最大连接数只有20，而我们的上层应用的并发数会远远大于20，如果同时对数据库进行操作，</span><br><span class="line">就可能会出现因为无法获取数据库连接数导致异常，这时候就可以通过信号量来做并发访问控制，当信号量semaphore把并发数控制到1时，就跟单线程运行很相似，</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">import lombok.extern.slf4j.Slf4j;</span><br><span class="line"></span><br><span class="line">import java.util.concurrent.CountDownLatch;</span><br><span class="line">import java.util.concurrent.ExecutorService;</span><br><span class="line">import java.util.concurrent.Executors;</span><br><span class="line">import java.util.concurrent.Semaphore;</span><br><span class="line"></span><br><span class="line">@Slf4j</span><br><span class="line">public class SemaphoreExample1 &#123;</span><br><span class="line"></span><br><span class="line">    private final static int threadCount = 10;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">        ExecutorService exec = Executors.newCachedThreadPool();</span><br><span class="line"></span><br><span class="line">        final Semaphore semaphore = new Semaphore(3);</span><br><span class="line"></span><br><span class="line">        for (int i = 0; i &lt; threadCount; i++) &#123;</span><br><span class="line">            final int threadNum = i;</span><br><span class="line">            exec.execute(() -&gt; &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    semaphore.acquire(); // 获取一个许可</span><br><span class="line">                    test(threadNum);</span><br><span class="line">                    semaphore.release(); // 释放一个许可</span><br><span class="line">                &#125; catch (Exception e) &#123;</span><br><span class="line">                    log.error(&quot;exception&quot;, e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        exec.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static void test(int threadNum) throws Exception &#123;</span><br><span class="line">        log.info(&quot;&#123;&#125;&quot;, threadNum);</span><br><span class="line">        Thread.sleep(1000);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果: 大概每隔1s打印3行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">12:14:18.188 [pool-1-thread-2] INFO com.mmall.concurrency.example.aqs.SemaphoreExample1 - 1</span><br><span class="line">12:14:18.188 [pool-1-thread-1] INFO com.mmall.concurrency.example.aqs.SemaphoreExample1 - 0</span><br><span class="line">12:14:18.188 [pool-1-thread-3] INFO com.mmall.concurrency.example.aqs.SemaphoreExample1 - 2</span><br><span class="line">12:14:19.194 [pool-1-thread-4] INFO com.mmall.concurrency.example.aqs.SemaphoreExample1 - 3</span><br><span class="line">12:14:19.194 [pool-1-thread-5] INFO com.mmall.concurrency.example.aqs.SemaphoreExample1 - 4</span><br><span class="line">12:14:19.194 [pool-1-thread-6] INFO com.mmall.concurrency.example.aqs.SemaphoreExample1 - 5</span><br><span class="line">12:14:20.195 [pool-1-thread-8] INFO com.mmall.concurrency.example.aqs.SemaphoreExample1 - 7</span><br><span class="line">12:14:20.195 [pool-1-thread-9] INFO com.mmall.concurrency.example.aqs.SemaphoreExample1 - 8</span><br><span class="line">12:14:20.195 [pool-1-thread-7] INFO com.mmall.concurrency.example.aqs.SemaphoreExample1 - 6</span><br><span class="line">12:14:21.196 [pool-1-thread-10] INFO com.mmall.concurrency.example.aqs.SemaphoreExample1 - 9</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">import java.util.concurrent.ExecutorService;</span><br><span class="line">import java.util.concurrent.Executors;</span><br><span class="line">import java.util.concurrent.Semaphore;</span><br><span class="line"></span><br><span class="line">import lombok.extern.slf4j.Slf4j;</span><br><span class="line"></span><br><span class="line">@Slf4j</span><br><span class="line">public class SemaphoreExample2 &#123;</span><br><span class="line"></span><br><span class="line">    private final static int threadCount = 10;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">        ExecutorService exec = Executors.newCachedThreadPool();</span><br><span class="line"></span><br><span class="line">        final Semaphore semaphore = new Semaphore(3);</span><br><span class="line"></span><br><span class="line">        for (int i = 0; i &lt; threadCount; i++) &#123;</span><br><span class="line">            final int threadNum = i;</span><br><span class="line">            exec.execute(() -&gt; &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    semaphore.acquire(3); // 获取多个许可</span><br><span class="line">                    test(threadNum);</span><br><span class="line">                    semaphore.release(3); // 释放多个许可</span><br><span class="line">                &#125; catch (Exception e) &#123;</span><br><span class="line">                    log.error(&quot;exception&quot;, e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        exec.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static void test(int threadNum) throws Exception &#123;</span><br><span class="line">        log.info(&quot;&#123;&#125;&quot;, threadNum);</span><br><span class="line">        Thread.sleep(1000);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果: 大概每隔1s打印1行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">12:17:05.304 [pool-1-thread-1] INFO com.mmall.concurrency.example.aqs.SemaphoreExample2 - 0</span><br><span class="line">12:17:06.310 [pool-1-thread-2] INFO com.mmall.concurrency.example.aqs.SemaphoreExample2 - 1</span><br><span class="line">12:17:07.310 [pool-1-thread-3] INFO com.mmall.concurrency.example.aqs.SemaphoreExample2 - 2</span><br><span class="line">12:17:08.310 [pool-1-thread-4] INFO com.mmall.concurrency.example.aqs.SemaphoreExample2 - 3</span><br><span class="line">12:17:09.311 [pool-1-thread-5] INFO com.mmall.concurrency.example.aqs.SemaphoreExample2 - 4</span><br><span class="line">12:17:10.312 [pool-1-thread-6] INFO com.mmall.concurrency.example.aqs.SemaphoreExample2 - 5</span><br><span class="line">12:17:11.312 [pool-1-thread-7] INFO com.mmall.concurrency.example.aqs.SemaphoreExample2 - 6</span><br><span class="line">12:17:12.313 [pool-1-thread-8] INFO com.mmall.concurrency.example.aqs.SemaphoreExample2 - 7</span><br><span class="line">12:17:13.314 [pool-1-thread-9] INFO com.mmall.concurrency.example.aqs.SemaphoreExample2 - 8</span><br><span class="line">12:17:14.314 [pool-1-thread-10] INFO com.mmall.concurrency.example.aqs.SemaphoreExample2 - 9</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">import lombok.extern.slf4j.Slf4j;</span><br><span class="line"></span><br><span class="line">import java.util.concurrent.ExecutorService;</span><br><span class="line">import java.util.concurrent.Executors;</span><br><span class="line">import java.util.concurrent.Semaphore;</span><br><span class="line">import java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line">@Slf4j</span><br><span class="line">public class SemaphoreExample3 &#123;</span><br><span class="line"></span><br><span class="line">    private final static int threadCount = 20;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">        ExecutorService exec = Executors.newCachedThreadPool();</span><br><span class="line"></span><br><span class="line">        final Semaphore semaphore = new Semaphore(3);</span><br><span class="line"></span><br><span class="line">        for (int i = 0; i &lt; threadCount; i++) &#123;</span><br><span class="line">            final int threadNum = i;</span><br><span class="line">            exec.execute(() -&gt; &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    if (semaphore.tryAcquire()) &#123; // 尝试获取一个许可</span><br><span class="line">                        test(threadNum);</span><br><span class="line">                        semaphore.release(); // 释放一个许可</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; catch (Exception e) &#123;</span><br><span class="line">                    log.error(&quot;exception&quot;, e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        exec.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static void test(int threadNum) throws Exception &#123;</span><br><span class="line">        log.info(&quot;&#123;&#125;&quot;, threadNum);</span><br><span class="line">        Thread.sleep(1000);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">12:19:05.556 [pool-1-thread-3] INFO com.mmall.concurrency.example.aqs.SemaphoreExample3 - 2</span><br><span class="line">12:19:05.556 [pool-1-thread-1] INFO com.mmall.concurrency.example.aqs.SemaphoreExample3 - 0</span><br><span class="line">12:19:05.556 [pool-1-thread-2] INFO com.mmall.concurrency.example.aqs.SemaphoreExample3 - 1</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">import java.util.concurrent.ExecutorService;</span><br><span class="line">import java.util.concurrent.Executors;</span><br><span class="line">import java.util.concurrent.Semaphore;</span><br><span class="line">import java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line">import lombok.extern.slf4j.Slf4j;</span><br><span class="line"></span><br><span class="line">@Slf4j</span><br><span class="line">public class SemaphoreExample4 &#123;</span><br><span class="line"></span><br><span class="line">    private final static int threadCount = 10;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">        ExecutorService exec = Executors.newCachedThreadPool();</span><br><span class="line"></span><br><span class="line">        final Semaphore semaphore = new Semaphore(3);</span><br><span class="line"></span><br><span class="line">        for (int i = 0; i &lt; threadCount; i++) &#123;</span><br><span class="line">            final int threadNum = i;</span><br><span class="line">            exec.execute(() -&gt; &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    if (semaphore.tryAcquire(5000, TimeUnit.MILLISECONDS)) &#123; // 尝试获取一个许可</span><br><span class="line">                        test(threadNum);</span><br><span class="line">                        semaphore.release(); // 释放一个许可</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; catch (Exception e) &#123;</span><br><span class="line">                    log.error(&quot;exception&quot;, e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        exec.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static void test(int threadNum) throws Exception &#123;</span><br><span class="line">        log.info(&quot;&#123;&#125;&quot;, threadNum);</span><br><span class="line">        Thread.sleep(1000);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果: 大概每隔1s打印3行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">12:22:58.289 [pool-1-thread-1] INFO com.mmall.concurrency.example.aqs.SemaphoreExample4 - 0</span><br><span class="line">12:22:58.289 [pool-1-thread-3] INFO com.mmall.concurrency.example.aqs.SemaphoreExample4 - 2</span><br><span class="line">12:22:58.289 [pool-1-thread-2] INFO com.mmall.concurrency.example.aqs.SemaphoreExample4 - 1</span><br><span class="line">12:22:59.294 [pool-1-thread-6] INFO com.mmall.concurrency.example.aqs.SemaphoreExample4 - 5</span><br><span class="line">12:22:59.294 [pool-1-thread-5] INFO com.mmall.concurrency.example.aqs.SemaphoreExample4 - 4</span><br><span class="line">12:22:59.294 [pool-1-thread-4] INFO com.mmall.concurrency.example.aqs.SemaphoreExample4 - 3</span><br><span class="line">12:23:00.294 [pool-1-thread-8] INFO com.mmall.concurrency.example.aqs.SemaphoreExample4 - 7</span><br><span class="line">12:23:00.294 [pool-1-thread-7] INFO com.mmall.concurrency.example.aqs.SemaphoreExample4 - 6</span><br><span class="line">12:23:00.294 [pool-1-thread-9] INFO com.mmall.concurrency.example.aqs.SemaphoreExample4 - 8</span><br><span class="line">12:23:01.294 [pool-1-thread-11] INFO com.mmall.concurrency.example.aqs.SemaphoreExample4 - 10</span><br><span class="line">12:23:01.294 [pool-1-thread-10] INFO com.mmall.concurrency.example.aqs.SemaphoreExample4 - 9</span><br><span class="line">12:23:01.294 [pool-1-thread-12] INFO com.mmall.concurrency.example.aqs.SemaphoreExample4 - 11</span><br><span class="line">12:23:02.295 [pool-1-thread-15] INFO com.mmall.concurrency.example.aqs.SemaphoreExample4 - 14</span><br><span class="line">12:23:02.295 [pool-1-thread-13] INFO com.mmall.concurrency.example.aqs.SemaphoreExample4 - 12</span><br><span class="line">12:23:02.295 [pool-1-thread-14] INFO com.mmall.concurrency.example.aqs.SemaphoreExample4 - 13</span><br></pre></td></tr></table></figure></p>
<div class="figure center" style="width:100%;"><a class="fancybox" href="/assets/并发编程与高并发解决方案/65.jpg" title="" data-caption="" data-fancybox="travel"><img class="fig-img" src="/assets/并发编程与高并发解决方案/65.jpg" style="width:100%;height:100%;" alt=""></a></div><div style="clear:both;"></div>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">import lombok.extern.slf4j.Slf4j;</span><br><span class="line"></span><br><span class="line">import java.util.concurrent.CyclicBarrier;</span><br><span class="line">import java.util.concurrent.ExecutorService;</span><br><span class="line">import java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line">@Slf4j</span><br><span class="line">public class CyclicBarrierExample1 &#123;</span><br><span class="line"></span><br><span class="line">    private static CyclicBarrier barrier = new CyclicBarrier(5);</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">        ExecutorService executor = Executors.newCachedThreadPool();</span><br><span class="line"></span><br><span class="line">        for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">            final int threadNum = i;</span><br><span class="line">            Thread.sleep(1000);</span><br><span class="line">            executor.execute(() -&gt; &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    race(threadNum);</span><br><span class="line">                &#125; catch (Exception e) &#123;</span><br><span class="line">                    log.error(&quot;exception&quot;, e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        executor.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static void race(int threadNum) throws Exception &#123;</span><br><span class="line">        Thread.sleep(1000);</span><br><span class="line">        log.info(&quot;&#123;&#125; is ready&quot;, threadNum);</span><br><span class="line">        barrier.await();</span><br><span class="line"></span><br><span class="line">/*        try &#123;</span><br><span class="line">            barrier.await(2000, TimeUnit.MILLISECONDS);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            log.warn(&quot;BarrierException&quot;, e);</span><br><span class="line">        &#125;*/</span><br><span class="line"></span><br><span class="line">        log.info(&quot;&#123;&#125; continue&quot;, threadNum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">23:57:27.925 [pool-1-thread-1] INFO com.mmall.concurrency.example.aqs.CyclicBarrierExample1 - 0 is ready</span><br><span class="line">23:57:28.916 [pool-1-thread-2] INFO com.mmall.concurrency.example.aqs.CyclicBarrierExample1 - 1 is ready</span><br><span class="line">23:57:29.917 [pool-1-thread-3] INFO com.mmall.concurrency.example.aqs.CyclicBarrierExample1 - 2 is ready</span><br><span class="line">23:57:30.917 [pool-1-thread-4] INFO com.mmall.concurrency.example.aqs.CyclicBarrierExample1 - 3 is ready</span><br><span class="line">23:57:31.918 [pool-1-thread-5] INFO com.mmall.concurrency.example.aqs.CyclicBarrierExample1 - 4 is ready</span><br><span class="line">23:57:31.918 [pool-1-thread-5] INFO com.mmall.concurrency.example.aqs.CyclicBarrierExample1 - 4 continue</span><br><span class="line">23:57:31.918 [pool-1-thread-1] INFO com.mmall.concurrency.example.aqs.CyclicBarrierExample1 - 0 continue</span><br><span class="line">23:57:31.918 [pool-1-thread-2] INFO com.mmall.concurrency.example.aqs.CyclicBarrierExample1 - 1 continue</span><br><span class="line">23:57:31.918 [pool-1-thread-3] INFO com.mmall.concurrency.example.aqs.CyclicBarrierExample1 - 2 continue</span><br><span class="line">23:57:31.918 [pool-1-thread-4] INFO com.mmall.concurrency.example.aqs.CyclicBarrierExample1 - 3 continue</span><br><span class="line">23:57:32.919 [pool-1-thread-6] INFO com.mmall.concurrency.example.aqs.CyclicBarrierExample1 - 5 is ready</span><br><span class="line">23:57:33.918 [pool-1-thread-4] INFO com.mmall.concurrency.example.aqs.CyclicBarrierExample1 - 6 is ready</span><br><span class="line">23:57:34.919 [pool-1-thread-1] INFO com.mmall.concurrency.example.aqs.CyclicBarrierExample1 - 7 is ready</span><br><span class="line">23:57:35.919 [pool-1-thread-2] INFO com.mmall.concurrency.example.aqs.CyclicBarrierExample1 - 8 is ready</span><br><span class="line">23:57:36.920 [pool-1-thread-3] INFO com.mmall.concurrency.example.aqs.CyclicBarrierExample1 - 9 is ready</span><br><span class="line">23:57:36.920 [pool-1-thread-3] INFO com.mmall.concurrency.example.aqs.CyclicBarrierExample1 - 9 continue</span><br><span class="line">23:57:36.920 [pool-1-thread-6] INFO com.mmall.concurrency.example.aqs.CyclicBarrierExample1 - 5 continue</span><br><span class="line">23:57:36.920 [pool-1-thread-4] INFO com.mmall.concurrency.example.aqs.CyclicBarrierExample1 - 6 continue</span><br><span class="line">23:57:36.920 [pool-1-thread-1] INFO com.mmall.concurrency.example.aqs.CyclicBarrierExample1 - 7 continue</span><br><span class="line">23:57:36.920 [pool-1-thread-2] INFO com.mmall.concurrency.example.aqs.CyclicBarrierExample1 - 8 continue</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">import lombok.extern.slf4j.Slf4j;</span><br><span class="line"></span><br><span class="line">import java.util.concurrent.CyclicBarrier;</span><br><span class="line">import java.util.concurrent.ExecutorService;</span><br><span class="line">import java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line">@Slf4j</span><br><span class="line">public class CyclicBarrierExample3 &#123;</span><br><span class="line"></span><br><span class="line">    private static CyclicBarrier barrier = new CyclicBarrier(5, () -&gt; &#123;</span><br><span class="line">        log.info(&quot;callback is running&quot;);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">        ExecutorService executor = Executors.newCachedThreadPool();</span><br><span class="line"></span><br><span class="line">        for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">            final int threadNum = i;</span><br><span class="line">            Thread.sleep(1000);</span><br><span class="line">            executor.execute(() -&gt; &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    race(threadNum);</span><br><span class="line">                &#125; catch (Exception e) &#123;</span><br><span class="line">                    log.error(&quot;exception&quot;, e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        executor.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static void race(int threadNum) throws Exception &#123;</span><br><span class="line">        Thread.sleep(1000);</span><br><span class="line">        log.info(&quot;&#123;&#125; is ready&quot;, threadNum);</span><br><span class="line">        barrier.await();</span><br><span class="line">        log.info(&quot;&#123;&#125; continue&quot;, threadNum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">00:00:48.622 [pool-1-thread-1] INFO com.mmall.concurrency.example.aqs.CyclicBarrierExample3 - 0 is ready</span><br><span class="line">00:00:49.618 [pool-1-thread-2] INFO com.mmall.concurrency.example.aqs.CyclicBarrierExample3 - 1 is ready</span><br><span class="line">00:00:50.618 [pool-1-thread-3] INFO com.mmall.concurrency.example.aqs.CyclicBarrierExample3 - 2 is ready</span><br><span class="line">00:00:51.618 [pool-1-thread-4] INFO com.mmall.concurrency.example.aqs.CyclicBarrierExample3 - 3 is ready</span><br><span class="line">00:00:52.617 [pool-1-thread-5] INFO com.mmall.concurrency.example.aqs.CyclicBarrierExample3 - 4 is ready</span><br><span class="line">00:00:52.617 [pool-1-thread-5] INFO com.mmall.concurrency.example.aqs.CyclicBarrierExample3 - callback is running</span><br><span class="line">00:00:52.617 [pool-1-thread-5] INFO com.mmall.concurrency.example.aqs.CyclicBarrierExample3 - 4 continue</span><br><span class="line">00:00:52.618 [pool-1-thread-2] INFO com.mmall.concurrency.example.aqs.CyclicBarrierExample3 - 1 continue</span><br><span class="line">00:00:52.618 [pool-1-thread-1] INFO com.mmall.concurrency.example.aqs.CyclicBarrierExample3 - 0 continue</span><br><span class="line">00:00:52.618 [pool-1-thread-3] INFO com.mmall.concurrency.example.aqs.CyclicBarrierExample3 - 2 continue</span><br><span class="line">00:00:52.618 [pool-1-thread-4] INFO com.mmall.concurrency.example.aqs.CyclicBarrierExample3 - 3 continue</span><br><span class="line">00:00:53.619 [pool-1-thread-6] INFO com.mmall.concurrency.example.aqs.CyclicBarrierExample3 - 5 is ready</span><br><span class="line">00:00:54.618 [pool-1-thread-4] INFO com.mmall.concurrency.example.aqs.CyclicBarrierExample3 - 6 is ready</span><br><span class="line">00:00:55.619 [pool-1-thread-3] INFO com.mmall.concurrency.example.aqs.CyclicBarrierExample3 - 7 is ready</span><br><span class="line">00:00:56.619 [pool-1-thread-2] INFO com.mmall.concurrency.example.aqs.CyclicBarrierExample3 - 8 is ready</span><br><span class="line">00:00:57.620 [pool-1-thread-1] INFO com.mmall.concurrency.example.aqs.CyclicBarrierExample3 - 9 is ready</span><br><span class="line">00:00:57.620 [pool-1-thread-1] INFO com.mmall.concurrency.example.aqs.CyclicBarrierExample3 - callback is running</span><br><span class="line">00:00:57.620 [pool-1-thread-1] INFO com.mmall.concurrency.example.aqs.CyclicBarrierExample3 - 9 continue</span><br><span class="line">00:00:57.620 [pool-1-thread-6] INFO com.mmall.concurrency.example.aqs.CyclicBarrierExample3 - 5 continue</span><br><span class="line">00:00:57.620 [pool-1-thread-4] INFO com.mmall.concurrency.example.aqs.CyclicBarrierExample3 - 6 continue</span><br><span class="line">00:00:57.620 [pool-1-thread-3] INFO com.mmall.concurrency.example.aqs.CyclicBarrierExample3 - 7 continue</span><br><span class="line">00:00:57.620 [pool-1-thread-2] INFO com.mmall.concurrency.example.aqs.CyclicBarrierExample3 - 8 continue</span><br></pre></td></tr></table></figure>
<div class="figure center" style="width:100%;"><a class="fancybox" href="/assets/并发编程与高并发解决方案/66.jpg" title="" data-caption="" data-fancybox="travel"><img class="fig-img" src="/assets/并发编程与高并发解决方案/66.jpg" style="width:100%;height:100%;" alt=""></a></div><div style="clear:both;"></div>
<div class="figure center" style="width:100%;"><a class="fancybox" href="/assets/并发编程与高并发解决方案/67.jpg" title="" data-caption="" data-fancybox="travel"><img class="fig-img" src="/assets/并发编程与高并发解决方案/67.jpg" style="width:100%;height:100%;" alt=""></a></div><div style="clear:both;"></div>
<p>synchronized:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">import lombok.extern.slf4j.Slf4j;</span><br><span class="line"></span><br><span class="line">import java.util.concurrent.CountDownLatch;</span><br><span class="line">import java.util.concurrent.ExecutorService;</span><br><span class="line">import java.util.concurrent.Executors;</span><br><span class="line">import java.util.concurrent.Semaphore;</span><br><span class="line"></span><br><span class="line">@Slf4j</span><br><span class="line">@ThreadSafe</span><br><span class="line">public class LockExample1 &#123;</span><br><span class="line">    // 请求总数</span><br><span class="line">    public static int clientTotal = 5000;</span><br><span class="line"></span><br><span class="line">    // 同时并发执行的线程数</span><br><span class="line">    public static int threadTotal = 200;</span><br><span class="line"></span><br><span class="line">    public static int count = 0;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">        final Semaphore semaphore = new Semaphore(threadTotal);</span><br><span class="line">        final CountDownLatch countDownLatch = new CountDownLatch(clientTotal);</span><br><span class="line">        for (int i = 0; i &lt; clientTotal ; i++) &#123;</span><br><span class="line">            executorService.execute(() -&gt; &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    semaphore.acquire();</span><br><span class="line">                    add();</span><br><span class="line">                    semaphore.release();</span><br><span class="line">                &#125; catch (Exception e) &#123;</span><br><span class="line">                    log.error(&quot;exception&quot;, e);</span><br><span class="line">                &#125;</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        countDownLatch.await();</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">        log.info(&quot;count:&#123;&#125;&quot;, count);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private synchronized static void add() &#123;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>ReentrantLock:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">import lombok.extern.slf4j.Slf4j;</span><br><span class="line"></span><br><span class="line">import java.util.concurrent.CountDownLatch;</span><br><span class="line">import java.util.concurrent.ExecutorService;</span><br><span class="line">import java.util.concurrent.Executors;</span><br><span class="line">import java.util.concurrent.Semaphore;</span><br><span class="line">import java.util.concurrent.locks.Lock;</span><br><span class="line">import java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line">@Slf4j</span><br><span class="line">@ThreadSafe</span><br><span class="line">public class LockExample2 &#123;</span><br><span class="line"></span><br><span class="line">    // 请求总数</span><br><span class="line">    public static int clientTotal = 5000;</span><br><span class="line"></span><br><span class="line">    // 同时并发执行的线程数</span><br><span class="line">    public static int threadTotal = 200;</span><br><span class="line"></span><br><span class="line">    public static int count = 0;</span><br><span class="line"></span><br><span class="line">    private final static Lock lock = new ReentrantLock();</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">        final Semaphore semaphore = new Semaphore(threadTotal);</span><br><span class="line">        final CountDownLatch countDownLatch = new CountDownLatch(clientTotal);</span><br><span class="line">        for (int i = 0; i &lt; clientTotal ; i++) &#123;</span><br><span class="line">            executorService.execute(() -&gt; &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    semaphore.acquire();</span><br><span class="line">                    add();</span><br><span class="line">                    semaphore.release();</span><br><span class="line">                &#125; catch (Exception e) &#123;</span><br><span class="line">                    log.error(&quot;exception&quot;, e);</span><br><span class="line">                &#125;</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        countDownLatch.await();</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">        log.info(&quot;count:&#123;&#125;&quot;, count);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static void add() &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        try &#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>ReentrantReadWriteLock:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">import lombok.extern.slf4j.Slf4j;</span><br><span class="line"></span><br><span class="line">import java.util.Map;</span><br><span class="line">import java.util.Set;</span><br><span class="line">import java.util.TreeMap;</span><br><span class="line">import java.util.concurrent.locks.Lock;</span><br><span class="line">import java.util.concurrent.locks.ReentrantReadWriteLock;</span><br><span class="line"></span><br><span class="line">@Slf4j</span><br><span class="line">public class LockExample3 &#123;</span><br><span class="line"></span><br><span class="line">    private final Map&lt;String, Data&gt; map = new TreeMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    private final ReentrantReadWriteLock lock = new ReentrantReadWriteLock();</span><br><span class="line"></span><br><span class="line">    private final Lock readLock = lock.readLock();</span><br><span class="line"></span><br><span class="line">    private final Lock writeLock = lock.writeLock();</span><br><span class="line"></span><br><span class="line">    public Data get(String key) &#123;</span><br><span class="line">        readLock.lock();</span><br><span class="line">        try &#123;</span><br><span class="line">            return map.get(key);</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            readLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Set&lt;String&gt; getAllKeys() &#123;</span><br><span class="line">        readLock.lock();</span><br><span class="line">        try &#123;</span><br><span class="line">            return map.keySet();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            readLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Data put(String key, Data value) &#123;</span><br><span class="line">        writeLock.lock();</span><br><span class="line">        try &#123;</span><br><span class="line">            return map.put(key, value);</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            readLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    class Data &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>StampedLock:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">import java.util.concurrent.locks.StampedLock;</span><br><span class="line"></span><br><span class="line">public class LockExample4 &#123;</span><br><span class="line"></span><br><span class="line">    class Point &#123;</span><br><span class="line">        private double x, y;</span><br><span class="line">        private final StampedLock sl = new StampedLock();</span><br><span class="line"></span><br><span class="line">        void move(double deltaX, double deltaY) &#123; // an exclusively locked method</span><br><span class="line">            long stamp = sl.writeLock();</span><br><span class="line">            try &#123;</span><br><span class="line">                x += deltaX;</span><br><span class="line">                y += deltaY;</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                sl.unlockWrite(stamp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //下面看看乐观读锁案例</span><br><span class="line">        double distanceFromOrigin() &#123; // A read-only method</span><br><span class="line">            long stamp = sl.tryOptimisticRead(); //获得一个乐观读锁</span><br><span class="line">            double currentX = x, currentY = y;  //将两个字段读入本地局部变量</span><br><span class="line">            if (!sl.validate(stamp)) &#123; //检查发出乐观读锁后同时是否有其他写锁发生？</span><br><span class="line">                stamp = sl.readLock();  //如果没有，我们再次获得一个读悲观锁</span><br><span class="line">                try &#123;</span><br><span class="line">                    currentX = x; // 将两个字段读入本地局部变量</span><br><span class="line">                    currentY = y; // 将两个字段读入本地局部变量</span><br><span class="line">                &#125; finally &#123;</span><br><span class="line">                    sl.unlockRead(stamp);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            return Math.sqrt(currentX * currentX + currentY * currentY);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //下面是悲观读锁案例</span><br><span class="line">        void moveIfAtOrigin(double newX, double newY) &#123; // upgrade</span><br><span class="line">            // Could instead start with optimistic, not read mode</span><br><span class="line">            long stamp = sl.readLock();</span><br><span class="line">            try &#123;</span><br><span class="line">                while (x == 0.0 &amp;&amp; y == 0.0) &#123; //循环，检查当前状态是否符合</span><br><span class="line">                    long ws = sl.tryConvertToWriteLock(stamp); //将读锁转为写锁</span><br><span class="line">                    if (ws != 0L) &#123; //这是确认转为写锁是否成功</span><br><span class="line">                        stamp = ws; //如果成功 替换票据</span><br><span class="line">                        x = newX; //进行状态改变</span><br><span class="line">                        y = newY;  //进行状态改变</span><br><span class="line">                        break;</span><br><span class="line">                    &#125; else &#123; //如果不能成功转换为写锁</span><br><span class="line">                        sl.unlockRead(stamp);  //我们显式释放读锁</span><br><span class="line">                        stamp = sl.writeLock();  //显式直接进行写锁 然后再通过循环再试</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                sl.unlock(stamp); //释放读锁或写锁</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">import lombok.extern.slf4j.Slf4j;</span><br><span class="line"></span><br><span class="line">import java.util.concurrent.CountDownLatch;</span><br><span class="line">import java.util.concurrent.ExecutorService;</span><br><span class="line">import java.util.concurrent.Executors;</span><br><span class="line">import java.util.concurrent.Semaphore;</span><br><span class="line">import java.util.concurrent.locks.StampedLock;</span><br><span class="line"></span><br><span class="line">@Slf4j</span><br><span class="line">@ThreadSafe</span><br><span class="line">public class LockExample5 &#123;</span><br><span class="line"></span><br><span class="line">    // 请求总数</span><br><span class="line">    public static int clientTotal = 5000;</span><br><span class="line"></span><br><span class="line">    // 同时并发执行的线程数</span><br><span class="line">    public static int threadTotal = 200;</span><br><span class="line"></span><br><span class="line">    public static int count = 0;</span><br><span class="line"></span><br><span class="line">    private final static StampedLock lock = new StampedLock();</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">        final Semaphore semaphore = new Semaphore(threadTotal);</span><br><span class="line">        final CountDownLatch countDownLatch = new CountDownLatch(clientTotal);</span><br><span class="line">        for (int i = 0; i &lt; clientTotal ; i++) &#123;</span><br><span class="line">            executorService.execute(() -&gt; &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    semaphore.acquire();</span><br><span class="line">                    add();</span><br><span class="line">                    semaphore.release();</span><br><span class="line">                &#125; catch (Exception e) &#123;</span><br><span class="line">                    log.error(&quot;exception&quot;, e);</span><br><span class="line">                &#125;</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        countDownLatch.await();</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">        log.info(&quot;count:&#123;&#125;&quot;, count);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static void add() &#123;</span><br><span class="line">        long stamp = lock.writeLock();</span><br><span class="line">        try &#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            lock.unlock(stamp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Condition:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">import lombok.extern.slf4j.Slf4j;</span><br><span class="line"></span><br><span class="line">import java.util.concurrent.locks.Condition;</span><br><span class="line">import java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line">@Slf4j</span><br><span class="line">public class LockExample6 &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ReentrantLock reentrantLock = new ReentrantLock();</span><br><span class="line">        Condition condition = reentrantLock.newCondition();</span><br><span class="line"></span><br><span class="line">        new Thread(() -&gt; &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                reentrantLock.lock();</span><br><span class="line">                log.info(&quot;wait signal&quot;); // 1</span><br><span class="line">                condition.await();</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            log.info(&quot;get signal&quot;); // 4</span><br><span class="line">            reentrantLock.unlock();</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        new Thread(() -&gt; &#123;</span><br><span class="line">            reentrantLock.lock();</span><br><span class="line">            log.info(&quot;get lock&quot;); // 2</span><br><span class="line">            try &#123;</span><br><span class="line">                Thread.sleep(3000);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            condition.signalAll();</span><br><span class="line">            log.info(&quot;send signal ~ &quot;); // 3</span><br><span class="line">            reentrantLock.unlock();</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Future:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">import lombok.extern.slf4j.Slf4j;</span><br><span class="line"></span><br><span class="line">import java.util.concurrent.Callable;</span><br><span class="line">import java.util.concurrent.ExecutorService;</span><br><span class="line">import java.util.concurrent.Executors;</span><br><span class="line">import java.util.concurrent.Future;</span><br><span class="line"></span><br><span class="line">@Slf4j</span><br><span class="line">public class FutureExample &#123;</span><br><span class="line"></span><br><span class="line">    static class MyCallable implements Callable&lt;String&gt; &#123;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public String call() throws Exception &#123;</span><br><span class="line">            log.info(&quot;do something in callable&quot;);</span><br><span class="line">            Thread.sleep(5000);</span><br><span class="line">            return &quot;Done&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">        Future&lt;String&gt; future = executorService.submit(new MyCallable());</span><br><span class="line">        log.info(&quot;do something in main&quot;);</span><br><span class="line">        Thread.sleep(1000);</span><br><span class="line">        String result = future.get();</span><br><span class="line">        log.info(&quot;result：&#123;&#125;&quot;, result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>FutureTask:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">import lombok.extern.slf4j.Slf4j;</span><br><span class="line"></span><br><span class="line">import java.util.concurrent.Callable;</span><br><span class="line">import java.util.concurrent.FutureTask;</span><br><span class="line"></span><br><span class="line">@Slf4j</span><br><span class="line">public class FutureTaskExample &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        FutureTask&lt;String&gt; futureTask = new FutureTask&lt;String&gt;(new Callable&lt;String&gt;() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public String call() throws Exception &#123;</span><br><span class="line">                log.info(&quot;do something in callable&quot;);</span><br><span class="line">                Thread.sleep(5000);</span><br><span class="line">                return &quot;Done&quot;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        new Thread(futureTask).start();</span><br><span class="line">        log.info(&quot;do something in main&quot;);</span><br><span class="line">        Thread.sleep(1000);</span><br><span class="line">        String result = futureTask.get();</span><br><span class="line">        log.info(&quot;result：&#123;&#125;&quot;, result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>结果:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">09:06:15.160 [main] INFO com.mmall.concurrency.example.aqs.FutureTaskExample - do something in main</span><br><span class="line">09:06:15.160 [Thread-0] INFO com.mmall.concurrency.example.aqs.FutureTaskExample - do something in callable</span><br><span class="line">09:06:20.164 [main] INFO com.mmall.concurrency.example.aqs.FutureTaskExample - result：Done</span><br></pre></td></tr></table></figure></p>
<h3 id="JUC组件拓展"><a href="#JUC组件拓展" class="headerlink" title="JUC组件拓展"></a>JUC组件拓展</h3><div class="figure center" style="width:100%;"><a class="fancybox" href="/assets/并发编程与高并发解决方案/68.jpg" title="" data-caption="" data-fancybox="travel"><img class="fig-img" src="/assets/并发编程与高并发解决方案/68.jpg" style="width:100%;height:100%;" alt=""></a></div><div style="clear:both;"></div>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">import lombok.extern.slf4j.Slf4j;</span><br><span class="line"></span><br><span class="line">import java.util.concurrent.ForkJoinPool;</span><br><span class="line">import java.util.concurrent.Future;</span><br><span class="line">import java.util.concurrent.RecursiveTask;</span><br><span class="line"></span><br><span class="line">@Slf4j</span><br><span class="line">public class ForkJoinTaskExample extends RecursiveTask&lt;Integer&gt; &#123;</span><br><span class="line"></span><br><span class="line">    public static final int threshold = 2;</span><br><span class="line">    private int start;</span><br><span class="line">    private int end;</span><br><span class="line"></span><br><span class="line">    public ForkJoinTaskExample(int start, int end) &#123;</span><br><span class="line">        this.start = start;</span><br><span class="line">        this.end = end;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected Integer compute() &#123;</span><br><span class="line">        int sum = 0;</span><br><span class="line"></span><br><span class="line">        //如果任务足够小就计算任务</span><br><span class="line">        boolean canCompute = (end - start) &lt;= threshold;</span><br><span class="line">        if (canCompute) &#123;</span><br><span class="line">            for (int i = start; i &lt;= end; i++) &#123;</span><br><span class="line">                sum += i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            // 如果任务大于阈值，就分裂成两个子任务计算</span><br><span class="line">            int middle = (start + end) / 2;</span><br><span class="line">            ForkJoinTaskExample leftTask = new ForkJoinTaskExample(start, middle);</span><br><span class="line">            ForkJoinTaskExample rightTask = new ForkJoinTaskExample(middle + 1, end);</span><br><span class="line"></span><br><span class="line">            // 执行子任务</span><br><span class="line">            leftTask.fork();</span><br><span class="line">            rightTask.fork();</span><br><span class="line"></span><br><span class="line">            // 等待任务执行结束合并其结果</span><br><span class="line">            int leftResult = leftTask.join();</span><br><span class="line">            int rightResult = rightTask.join();</span><br><span class="line"></span><br><span class="line">            // 合并子任务</span><br><span class="line">            sum = leftResult + rightResult;</span><br><span class="line">        &#125;</span><br><span class="line">        return sum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ForkJoinPool forkjoinPool = new ForkJoinPool();</span><br><span class="line"></span><br><span class="line">        //生成一个计算任务，计算1+2+3+4</span><br><span class="line">        ForkJoinTaskExample task = new ForkJoinTaskExample(1, 100);</span><br><span class="line"></span><br><span class="line">        //执行一个任务</span><br><span class="line">        Future&lt;Integer&gt; result = forkjoinPool.submit(task);</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            log.info(&quot;result:&#123;&#125;&quot;, result.get());</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            log.error(&quot;exception&quot;, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<div class="figure center" style="width:100%;"><a class="fancybox" href="/assets/并发编程与高并发解决方案/69.jpg" title="" data-caption="" data-fancybox="travel"><img class="fig-img" src="/assets/并发编程与高并发解决方案/69.jpg" style="width:100%;height:100%;" alt=""></a></div><div style="clear:both;"></div>
<div class="figure center" style="width:100%;"><a class="fancybox" href="/assets/并发编程与高并发解决方案/70.jpg" title="" data-caption="" data-fancybox="travel"><img class="fig-img" src="/assets/并发编程与高并发解决方案/70.jpg" style="width:100%;height:100%;" alt=""></a></div><div style="clear:both;"></div>
<div class="figure center" style="width:100%;"><a class="fancybox" href="/assets/并发编程与高并发解决方案/71.jpg" title="" data-caption="" data-fancybox="travel"><img class="fig-img" src="/assets/并发编程与高并发解决方案/71.jpg" style="width:100%;height:100%;" alt=""></a></div><div style="clear:both;"></div>
<div class="figure center" style="width:100%;"><a class="fancybox" href="/assets/并发编程与高并发解决方案/72.jpg" title="" data-caption="" data-fancybox="travel"><img class="fig-img" src="/assets/并发编程与高并发解决方案/72.jpg" style="width:100%;height:100%;" alt=""></a></div><div style="clear:both;"></div>
<h3 id="线程调度-线程池"><a href="#线程调度-线程池" class="headerlink" title="线程调度-线程池"></a>线程调度-线程池</h3><div class="figure center" style="width:100%;"><a class="fancybox" href="/assets/并发编程与高并发解决方案/73.jpg" title="" data-caption="" data-fancybox="travel"><img class="fig-img" src="/assets/并发编程与高并发解决方案/73.jpg" style="width:100%;height:100%;" alt=""></a></div><div style="clear:both;"></div>
<div class="figure center" style="width:100%;"><a class="fancybox" href="/assets/并发编程与高并发解决方案/74.jpg" title="" data-caption="" data-fancybox="travel"><img class="fig-img" src="/assets/并发编程与高并发解决方案/74.jpg" style="width:100%;height:100%;" alt=""></a></div><div style="clear:both;"></div>
<div class="figure center" style="width:100%;"><a class="fancybox" href="/assets/并发编程与高并发解决方案/75.jpg" title="" data-caption="" data-fancybox="travel"><img class="fig-img" src="/assets/并发编程与高并发解决方案/75.jpg" style="width:100%;height:100%;" alt=""></a></div><div style="clear:both;"></div>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">运行的线程数量  &lt;  corePoolSize                        直接创建新线程来处理任务即使线程池中的其他线程是空闲的</span><br><span class="line">corePoolSize  &lt;=  线程池的线程数量  &lt; maximumPoolSize  只有当workQueue满时才会创建新的线程处理任务</span><br><span class="line">corePoolSize   =  maximumPoolSize                     创建的线程池大小是固定的，这时如果有新任务提交，workQueue没满时，把请求放到workQueue里面，等待有空闲等待线程从里面取出任务进行处理</span><br><span class="line">运行的线程数量  &gt;  maximumPoolSize                     如果workQueue满了，通过指定策略来处理这个任务</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">提交一个新的任务到线程池以后，线程池会根据当前线程池中运行的线程数量来决定该任务的处理方式</span><br><span class="line">1.直接切换       SynchronousQueue</span><br><span class="line">2.使用无界队列   LnkedBlockingQueue 能创建的最大线程数就是corePoolSize</span><br><span class="line">3.使用有界队列   ArrayBlockQueue    将线程的最大线程数量设置为maximumPoolSize ，降低资源的消耗</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">降低系统资源的消耗（cpu使用率，操作系统资源的消耗）可以设置一个较大的队列容量，较小的线程池容量，降低线程处理任务的吞吐量</span><br><span class="line">提交的任务经常发生阻塞，调用设置线程最大线程数方法重新设置线程的容量，如果队列容量设置较小通常需要把线程池容量设置大一点，CPU的使用率会相对高一些</span><br></pre></td></tr></table></figure>
<div class="figure center" style="width:100%;"><a class="fancybox" href="/assets/并发编程与高并发解决方案/76.jpg" title="" data-caption="" data-fancybox="travel"><img class="fig-img" src="/assets/并发编程与高并发解决方案/76.jpg" style="width:100%;height:100%;" alt=""></a></div><div style="clear:both;"></div>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">AbortPolicy：直接抛出异常</span><br><span class="line">CallerRunsPolicy：用调用者使用的线程来执行任务</span><br><span class="line">DiscardOldestPolicy：丢弃掉阻塞队列中最靠前的任务，并执行当前任务</span><br><span class="line">DiscardPolicy：直接丢弃当前任务</span><br></pre></td></tr></table></figure>
<div class="figure center" style="width:100%;"><a class="fancybox" href="/assets/并发编程与高并发解决方案/77.jpg" title="" data-caption="" data-fancybox="travel"><img class="fig-img" src="/assets/并发编程与高并发解决方案/77.jpg" style="width:100%;height:100%;" alt=""></a></div><div style="clear:both;"></div>
<div class="figure center" style="width:100%;"><a class="fancybox" href="/assets/并发编程与高并发解决方案/78.jpg" title="" data-caption="" data-fancybox="travel"><img class="fig-img" src="/assets/并发编程与高并发解决方案/78.jpg" style="width:100%;height:100%;" alt=""></a></div><div style="clear:both;"></div>
<div class="figure center" style="width:100%;"><a class="fancybox" href="/assets/并发编程与高并发解决方案/79.jpg" title="" data-caption="" data-fancybox="travel"><img class="fig-img" src="/assets/并发编程与高并发解决方案/79.jpg" style="width:100%;height:100%;" alt=""></a></div><div style="clear:both;"></div>
<div class="figure center" style="width:100%;"><a class="fancybox" href="/assets/并发编程与高并发解决方案/80.jpg" title="" data-caption="" data-fancybox="travel"><img class="fig-img" src="/assets/并发编程与高并发解决方案/80.jpg" style="width:100%;height:100%;" alt=""></a></div><div style="clear:both;"></div>
<div class="figure center" style="width:100%;"><a class="fancybox" href="/assets/并发编程与高并发解决方案/81.jpg" title="" data-caption="" data-fancybox="travel"><img class="fig-img" src="/assets/并发编程与高并发解决方案/81.jpg" style="width:100%;height:100%;" alt=""></a></div><div style="clear:both;"></div>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">import lombok.extern.slf4j.Slf4j;</span><br><span class="line"></span><br><span class="line">import java.util.concurrent.ExecutorService;</span><br><span class="line">import java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line">@Slf4j</span><br><span class="line">public class ThreadPoolExample1 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">        // ExecutorService executorService = Executors.newFixedThreadPool(3);</span><br><span class="line">        // ExecutorService executorService = Executors.newSingleThreadExecutor();</span><br><span class="line"></span><br><span class="line">        for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">            final int index = i;</span><br><span class="line">            executorService.execute(new Runnable() &#123;</span><br><span class="line">                @Override</span><br><span class="line">                public void run() &#123;</span><br><span class="line">                    log.info(&quot;task:&#123;&#125;&quot;, index);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">import lombok.extern.slf4j.Slf4j;</span><br><span class="line"></span><br><span class="line">import java.util.Date;</span><br><span class="line">import java.util.Timer;</span><br><span class="line">import java.util.TimerTask;</span><br><span class="line">import java.util.concurrent.Executors;</span><br><span class="line">import java.util.concurrent.ScheduledExecutorService;</span><br><span class="line">import java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line">@Slf4j</span><br><span class="line">public class ThreadPoolExample4 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ScheduledExecutorService executorService = Executors.newScheduledThreadPool(1);</span><br><span class="line"></span><br><span class="line">//        executorService.schedule(new Runnable() &#123;</span><br><span class="line">//            @Override</span><br><span class="line">//            public void run() &#123;</span><br><span class="line">//                log.warn(&quot;schedule run&quot;);</span><br><span class="line">//            &#125;</span><br><span class="line">//        &#125;, 3, TimeUnit.SECONDS);</span><br><span class="line"></span><br><span class="line">        executorService.scheduleAtFixedRate(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                log.warn(&quot;schedule run&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, 1, 3, TimeUnit.SECONDS);</span><br><span class="line">//        executorService.shutdown();</span><br><span class="line"></span><br><span class="line">        Timer timer = new Timer();</span><br><span class="line">        timer.schedule(new TimerTask() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                log.warn(&quot;timer run&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, new Date(), 5 * 1000);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<div class="figure center" style="width:100%;"><a class="fancybox" href="/assets/并发编程与高并发解决方案/82.jpg" title="" data-caption="" data-fancybox="travel"><img class="fig-img" src="/assets/并发编程与高并发解决方案/82.jpg" style="width:100%;height:100%;" alt=""></a></div><div style="clear:both;"></div>
<h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><div class="figure center" style="width:100%;"><a class="fancybox" href="/assets/并发编程与高并发解决方案/83.jpg" title="" data-caption="" data-fancybox="travel"><img class="fig-img" src="/assets/并发编程与高并发解决方案/83.jpg" style="width:100%;height:100%;" alt=""></a></div><div style="clear:both;"></div>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">避免死锁</span><br><span class="line">1.按顺序加锁</span><br><span class="line">2.加锁时间（超过一定时间就放弃该锁的请求，并释放自己占有的锁）</span><br><span class="line">3.死锁检测（以上两种方式都无法解决）</span><br><span class="line"></span><br><span class="line">每当一个线程获取了锁，会在线程和锁的相关数据结构中记下来，除此之外，每当有线程请求锁，也需要记录在这个数据结构中，</span><br><span class="line">当一个线程请求锁失败的时候，这个线程可以遍历锁的关系图，看是否有死锁发生，并决定后续操作该怎么办，具体这个结构需要大家根据实际情况去设计一下，</span><br><span class="line">那么，当检测出死锁的时候，线程都可以做哪些是事情呢，一个可执行的做法是释放所有锁，回退，并且等待一定时间（随机）后，之后进行重试，</span><br><span class="line">这个和简单的加锁超时有些类似，不一样的是，只有死锁发生了才回退而不会因为加锁请求超时了，虽然有了回退和等待，但是，</span><br><span class="line">如果有大量线程又同时竞争同一批锁，他们还是有可能出现重复死锁，这时候有个更好的方案，给这些线程设置优先级，</span><br><span class="line">让一个或几个线程回退，剩下的线程就像reantran锁一样，继续保持他们，如果赋予这些线程的优先级是固定不变的，可以在死锁发生的时候设置随机的线程优先级</span><br></pre></td></tr></table></figure>
<h3 id="并发最佳实践"><a href="#并发最佳实践" class="headerlink" title="并发最佳实践"></a>并发最佳实践</h3><div class="figure center" style="width:100%;"><a class="fancybox" href="/assets/并发编程与高并发解决方案/84.jpg" title="" data-caption="" data-fancybox="travel"><img class="fig-img" src="/assets/并发编程与高并发解决方案/84.jpg" style="width:100%;height:100%;" alt=""></a></div><div style="clear:both;"></div>
<div class="figure center" style="width:100%;"><a class="fancybox" href="/assets/并发编程与高并发解决方案/85.jpg" title="" data-caption="" data-fancybox="travel"><img class="fig-img" src="/assets/并发编程与高并发解决方案/85.jpg" style="width:100%;height:100%;" alt=""></a></div><div style="clear:both;"></div>
<div class="figure center" style="width:100%;"><a class="fancybox" href="/assets/并发编程与高并发解决方案/86.jpg" title="" data-caption="" data-fancybox="travel"><img class="fig-img" src="/assets/并发编程与高并发解决方案/86.jpg" style="width:100%;height:100%;" alt=""></a></div><div style="clear:both;"></div>
<h3 id="spring与线程安全"><a href="#spring与线程安全" class="headerlink" title="spring与线程安全"></a>spring与线程安全</h3><div class="figure center" style="width:100%;"><a class="fancybox" href="/assets/并发编程与高并发解决方案/87.jpg" title="" data-caption="" data-fancybox="travel"><img class="fig-img" src="/assets/并发编程与高并发解决方案/87.jpg" style="width:100%;height:100%;" alt=""></a></div><div style="clear:both;"></div>
<h3 id="HashMap与ConcurrentHashMap解析"><a href="#HashMap与ConcurrentHashMap解析" class="headerlink" title="HashMap与ConcurrentHashMap解析"></a>HashMap与ConcurrentHashMap解析</h3><div class="figure center" style="width:100%;"><a class="fancybox" href="/assets/并发编程与高并发解决方案/88.jpg" title="" data-caption="" data-fancybox="travel"><img class="fig-img" src="/assets/并发编程与高并发解决方案/88.jpg" style="width:100%;height:100%;" alt=""></a></div><div style="clear:both;"></div>
<div class="figure center" style="width:100%;"><a class="fancybox" href="/assets/并发编程与高并发解决方案/89.jpg" title="" data-caption="" data-fancybox="travel"><img class="fig-img" src="/assets/并发编程与高并发解决方案/89.jpg" style="width:100%;height:100%;" alt=""></a></div><div style="clear:both;"></div>
<div class="figure center" style="width:100%;"><a class="fancybox" href="/assets/并发编程与高并发解决方案/90.jpg" title="" data-caption="" data-fancybox="travel"><img class="fig-img" src="/assets/并发编程与高并发解决方案/90.jpg" style="width:100%;height:100%;" alt=""></a></div><div style="clear:both;"></div>
<div class="figure center" style="width:100%;"><a class="fancybox" href="/assets/并发编程与高并发解决方案/91.jpg" title="" data-caption="" data-fancybox="travel"><img class="fig-img" src="/assets/并发编程与高并发解决方案/91.jpg" style="width:100%;height:100%;" alt=""></a></div><div style="clear:both;"></div>
<div class="figure center" style="width:100%;"><a class="fancybox" href="/assets/并发编程与高并发解决方案/92.jpg" title="" data-caption="" data-fancybox="travel"><img class="fig-img" src="/assets/并发编程与高并发解决方案/92.jpg" style="width:100%;height:100%;" alt=""></a></div><div style="clear:both;"></div>
<div class="figure center" style="width:100%;"><a class="fancybox" href="/assets/并发编程与高并发解决方案/93.jpg" title="" data-caption="" data-fancybox="travel"><img class="fig-img" src="/assets/并发编程与高并发解决方案/93.jpg" style="width:100%;height:100%;" alt=""></a></div><div style="clear:both;"></div>
<div class="figure center" style="width:100%;"><a class="fancybox" href="/assets/并发编程与高并发解决方案/94.jpg" title="" data-caption="" data-fancybox="travel"><img class="fig-img" src="/assets/并发编程与高并发解决方案/94.jpg" style="width:100%;height:100%;" alt=""></a></div><div style="clear:both;"></div>
<div class="figure center" style="width:100%;"><a class="fancybox" href="/assets/并发编程与高并发解决方案/95.jpg" title="" data-caption="" data-fancybox="travel"><img class="fig-img" src="/assets/并发编程与高并发解决方案/95.jpg" style="width:100%;height:100%;" alt=""></a></div><div style="clear:both;"></div>

                    
                        

                    
                    
                        <p>
                            <a href="/2019/08/25/并发编程与高并发解决方案/#post-footer" class="postShorten-excerpt_link link">
                                评论和共享
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a class="link-unstyled" href="/2019/07/10/docker安装Oracle 12c/">
                            docker安装Oracle 12c
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2019-07-10T16:35:48+08:00">
	
		    7月 10, 2019
    	
    </time>
    
</div>

            </div>
            
                <div class="postShorten-content">
                    <p>1.配置阿里的docker源<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cat /etc/docker/daemon.json</span><br><span class="line">&#123;</span><br><span class="line">&quot;registry-mirrors&quot;: [&quot;https://pee6w651.mirror.aliyuncs.com&quot;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>2.重启docker服务<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart docker</span><br></pre></td></tr></table></figure></p>
<p>3.拉取镜像<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull sath89/oracle-12c</span><br></pre></td></tr></table></figure></p>
<p>4.运行容器<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --name oracle -p 8080:8080 -p 1521:1521 -v $PWD/data:/mnt -e TZ=Asia/Shanghai sath89/oracle-12c</span><br></pre></td></tr></table></figure></p>
<p>5.进行容器<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it ef7e5bc1c20e /bin/bash (ef7e5bc1c20e自己容器的ID)</span><br></pre></td></tr></table></figure></p>
<p>6.相关操作<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#root用户切换到oracle用户</span><br><span class="line">su oracle</span><br><span class="line"></span><br><span class="line">#使用sysdba登陆</span><br><span class="line">/u01/app/oracle-product/12.1.0/xe/bin/sqlplus / as sysdba</span><br><span class="line"></span><br><span class="line">#create tablespace 表空间名称 datafile 表空间路劲 size 3000m;</span><br><span class="line">SQL&gt;create tablespace bspdb datafile &apos;/u01/app/oracle/oradata/xe/bspdb.dbf&apos; size 3000m;</span><br><span class="line"></span><br><span class="line">#create user 用户名 identified by 密码 default tablespace 用户默认使用哪一个表空间;</span><br><span class="line">SQL&gt;create user bspdb identified by 123456 default tablespace bspdb;</span><br><span class="line"></span><br><span class="line">#grant 角色1,角色2 to 用户名;</span><br><span class="line">SQL&gt;grant dba, connect to bspdb;</span><br></pre></td></tr></table></figure></p>
<p>参考：<br><a href="https://www.cnblogs.com/Dev0ps/p/10676930.html" target="_blank" rel="noopener">https://www.cnblogs.com/Dev0ps/p/10676930.html</a><br><a href="https://blog.csdn.net/Damionew/article/details/84566718" target="_blank" rel="noopener">https://blog.csdn.net/Damionew/article/details/84566718</a><br><a href="https://www.cnblogs.com/forturn/p/9371841.html" target="_blank" rel="noopener">https://www.cnblogs.com/forturn/p/9371841.html</a>  </p>

                    
                        

                    
                    
                        <p>
                            <a href="/2019/07/10/docker安装Oracle 12c/#post-footer" class="postShorten-excerpt_link link">
                                评论和共享
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a class="link-unstyled" href="/2019/05/24/解决SqlPlus前台程序出现中文乱码的问题/">
                            解决SqlPlus前台程序出现中文乱码的问题
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2019-05-24T17:22:11+08:00">
	
		    5月 24, 2019
    	
    </time>
    
</div>

            </div>
            
                <div class="postShorten-content">
                    <p>第一步：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">在sqlplus中执行 select userenv(&apos;language&apos;) from dual;查看当前数据库的字符集为：SIMPLIFIED CHINESE_CHINA.ZHS16GBK。</span><br><span class="line">我们只需要把客户端字符集和操作系统字符集都设置成这个就行了</span><br><span class="line">开始-运行-CMD：</span><br><span class="line">SET NLS_LANG=SIMPLIFIED CHINESE_CHINA.ZHS16GBK</span><br><span class="line">以上参数设置只是在当前会话生效</span><br></pre></td></tr></table></figure></p>
<p>第二步：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">在环境变量中查找一个名为“NLS_LANG”的环境变量，如果找不到，则新建一个，</span><br><span class="line">把变量值赋值为：“SIMPLIFIED CHINESE_CHINA.ZHS16GBK”</span><br></pre></td></tr></table></figure></p>
<p>参考：<br><a href="http://blog.itpub.net/26839123/viewspace-722870/" target="_blank" rel="noopener">http://blog.itpub.net/26839123/viewspace-722870/</a></p>

                    
                        

                    
                    
                        <p>
                            <a href="/2019/05/24/解决SqlPlus前台程序出现中文乱码的问题/#post-footer" class="postShorten-excerpt_link link">
                                评论和共享
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a class="link-unstyled" href="/2019/05/24/telegraf_volume/">
                            telegraf file plugin inputs
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2019-05-24T17:20:36+08:00">
	
		    5月 24, 2019
    	
    </time>
    
</div>

            </div>
            
                <div class="postShorten-content">
                    <h5 id="需要使用新增过功能的telegraf"><a href="#需要使用新增过功能的telegraf" class="headerlink" title="需要使用新增过功能的telegraf"></a>需要使用新增过功能的telegraf</h5><p>1.telegraf.conf<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">[global_tags]</span><br><span class="line"></span><br><span class="line">[agent]</span><br><span class="line">  interval = &quot;1h&quot;                #修改成实际的抓取间隔</span><br><span class="line">  round_interval = true</span><br><span class="line">  metric_batch_size = 1000</span><br><span class="line">  metric_buffer_limit = 10000</span><br><span class="line">  collection_jitter = &quot;0s&quot;</span><br><span class="line">  flush_interval = &quot;20s&quot;</span><br><span class="line">  flush_jitter = &quot;0s&quot;</span><br><span class="line">  precision = &quot;&quot;</span><br><span class="line">  debug = false</span><br><span class="line">  quiet = false</span><br><span class="line">  hostname = &quot;&quot;</span><br><span class="line">  omit_hostname = false</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">###############################################################################</span><br><span class="line">#                                  OUTPUTS                                    #</span><br><span class="line">###############################################################################</span><br><span class="line">[[outputs.influxdb]]</span><br><span class="line">  urls = [&quot;http://ip:8086&quot;]     #修改成实际的influxdb地址</span><br><span class="line">  database = &quot;volume_monitor&quot;</span><br><span class="line">  skip_database_creation = true</span><br><span class="line">  username = &quot;admin&quot;                        #有权限验证则修改用户名，否则删除该行配置</span><br><span class="line">  password = &quot;admin&quot;                        #有权限验证则修改密码，否则删除该行配置</span><br><span class="line">  namepass=[&quot;volume_*&quot;]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">###############################################################################</span><br><span class="line">#                                  INPUTS                                     #</span><br><span class="line">###############################################################################</span><br><span class="line">[[inputs.filecount]]</span><br><span class="line">  name_prefix=&quot;volume_&quot;</span><br><span class="line">  directories = [&quot;E:\\volume01&quot;]                    #实际抓取的文件目录</span><br><span class="line">  name = &quot;*&quot;</span><br><span class="line">  recursive = true</span><br><span class="line">  regular_only = true</span><br><span class="line">  size = 0</span><br><span class="line">  large_file_size = 4</span><br><span class="line">  mtime = &quot;0s&quot;</span><br></pre></td></tr></table></figure></p>
<p>2.启动<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">telegraf --config telegraf.conf --input-filter filecount --output-filter influxdb</span><br></pre></td></tr></table></figure></p>

                    
                        

                    
                    
                        <p>
                            <a href="/2019/05/24/telegraf_volume/#post-footer" class="postShorten-excerpt_link link">
                                评论和共享
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    <div class="pagination-bar">
    <ul class="pagination">
        
          <li class="pagination-prev">
            <a class="btn btn--default btn--small" href="/archives/page/5/">
              <i class="fa fa-angle-left text-base icon-mr"></i>
              <span>上一页</span>
            </a>
          </li>
        
        
          <li class="pagination-next">
            <a class="btn btn--default btn--small" href="/archives/page/7/">
              <span>下一页</span>
              <i class="fa fa-angle-right text-base icon-ml"></i>
            </a>
          </li>
        
        <li class="pagination-number">第 6 页 共 9 页</li>
    </ul>
</div>

</section>



                <footer id="footer" class="main-content-wrap">
    <span class="copyrights">
        Copyrights &copy; 2020 Brotherc. All Rights Reserved.
    </span>
</footer>

            </div>
            
        </div>
        


    
        
    

<div id="about">
    <div id="about-card">
        <div id="about-btn-close">
            <i class="fa fa-times"></i>
        </div>
        
            <img id="about-card-picture" src="/assets/images/head.jpg" alt="作者的图片">
        
            <h4 id="about-card-name">Brotherc</h4>
        
            <div id="about-card-bio"><p>java development</p>
</div>
        
        
            <div id="about-card-job">
                <i class="fa fa-briefcase"></i>
                <br>
                <p>java</p>

            </div>
        
        
            <div id="about-card-location">
                <i class="fa fa-map-marker-alt"></i>
                <br>
                zhuhai
            </div>
        
    </div>
</div>

        
        
<div id="cover" style="background-image:url('/assets/images/cover.jpg');"></div>
        <!--SCRIPTS-->
<script src="/assets/js/script-dbd16rvloemmuxdzniplmnxxvwoz24eya9wol0b7vvmlokgqsjivmb8dnscy.min.js"></script>
<!--SCRIPTS END-->



    </body>
</html>
