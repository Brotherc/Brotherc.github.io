
<!DOCTYPE html>
<html lang="zh-cn">
    
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="generator" content="Brotherc">
    <title>多线程3 - Brotherc</title>
    <meta name="author" content="Brotherc">
    
    
    
    <script type="application/ld+json">{"@context":"http://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"Brotherc","sameAs":["https://github.com/Brotherc"],"image":"head.jpg"},"articleBody":"java并发包介绍12JDK5.0 以后的版本都引入了高级并发特性，大多数的特性在java.util.concurrent 包中，是专门用于多线程发编程的，充分利用了现代多处理器和多核心系统的功能以编写大规模并发应用程序。主要包含原子量、并发集合、同步器、可重入锁，并对线程池的构造提供了强力的支持。\n线程池1、Single Thread Executor : 只有一个线程的线程池，因此所有提交的任务是顺序执行，Executors.newSingleThreadExecutor()\n2、Cached Thread Pool : 线程池里有很多线程需要同时执行，老的可用线程将被新的任务触发重新执行，如果线程超过60秒内没执行，那么将被终止并从池中删除，Executors.newCachedThreadPool()\n3、Fixed Thread Pool : 拥有固定线程数的线程池，如果没有任务执行，那么线程会一直等待，Executors.newFixedThreadPool(4)在构造函数中的参数4是线程池的大小，你可以随意设置，也可以和cpu的数量保持一致，获取cpu的数量int cpuNums = Runtime.getRuntime().availableProcessors();\n4、Scheduled Thread Pool : 用来调度即将执行的任务的线程池，Executors.newScheduledThreadPool()\n5、Single Thread Scheduled Pool : 只有一个线程，用来调度执行将来的任务，Executors.newSingleThreadScheduledExecutor()\n123456789101112131415161718192021222324import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;import java.util.concurrent.ScheduledExecutorService;/** * 列出并发包中的各种线程池 * */public class ExecutorDemo &#123;\tpublic static void main(String[] args) &#123;\t\tExecutorService newSingleThreadExecutor = Executors.newSingleThreadExecutor();\t\tExecutorService newCachedThreadPool = Executors.newCachedThreadPool();\t\tint cpuNums = Runtime.getRuntime().availableProcessors();\t\tSystem.out.println(cpuNums);\t\tExecutorService newFixedThreadPool = Executors.newFixedThreadPool(cpuNums);\t\tScheduledExecutorService newScheduledThreadPool = Executors.newScheduledThreadPool(8);\t\tScheduledExecutorService newSingleThreadScheduledExecutor = Executors.newSingleThreadScheduledExecutor();\t&#125;&#125;\n提交 Runnable ，任务完成后 Future 对象返回 null12345678910111213141516171819202122232425262728import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;public class ThreadPoolWithRunable &#123;\t/**\t * 通过线程池执行线程\t * @param args\t */\tpublic static void main(String[] args) &#123;\t\t//创建一个线程池\t\tExecutorService pool = Executors.newCachedThreadPool();\t\tfor(int i = 1; i &lt; 5; i++)&#123;\t\t\tpool.execute(new Runnable() &#123;\t\t\t\t@Override\t\t\t\tpublic void run() &#123;\t\t\t\t\tSystem.out.println(&quot;thread name: &quot; + Thread.currentThread().getName());\t\t\t\t\ttry &#123;\t\t\t\t\t\tThread.sleep(1000);\t\t\t\t\t&#125; catch (InterruptedException e) &#123;\t\t\t\t\t\te.printStackTrace();\t\t\t\t\t&#125;\t\t\t\t&#125;\t\t\t&#125;);\t\t&#125;\t\tpool.shutdown();\t&#125;&#125;\n提交 Callable，该方法返回一个 Future 实例表示任务的状态12345678910111213141516171819202122232425262728293031323334import java.util.ArrayList;import java.util.List;import java.util.concurrent.Callable;import java.util.concurrent.ExecutionException;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;import java.util.concurrent.Future;/** * callable 跟runnable的区别： * runnable的run方法不会有任何返回结果，所以主线程无法获得任务线程的返回值 * * callable的call方法可以返回结果，但是主线程在获取时是被阻塞，需要等待任务线程返回才能拿到结果 * */public class ThreadPoolWithcallable &#123;\tpublic static void main(String[] args) throws InterruptedException, ExecutionException &#123;\t\tExecutorService pool = Executors.newFixedThreadPool(4);\t\tfor(int i = 0; i &lt; 10; i++)&#123;\t\t\tFuture&lt;String&gt; submit = pool.submit(new Callable&lt;String&gt;()&#123;\t\t\t\t@Override\t\t\t\tpublic String call() throws Exception &#123;\t\t\t\t\t//System.out.println(&quot;a&quot;);\t\t\t\t\tThread.sleep(5000);\t\t\t\t\treturn &quot;b--&quot;+Thread.currentThread().getName();\t\t\t\t&#125;\t\t\t   &#125;);\t\t\t//从Future中get结果，这个方法是会被阻塞的，一直要等到线程任务返回结果\t\t\tSystem.out.println(submit.get());\t\t&#125;\t\t\tpool.shutdown();\t&#125;&#125;\n1234567891011121314151617181920212223242526272829import java.util.Random;import java.util.concurrent.Callable;public class TaskCallable implements Callable&lt;String&gt;&#123;\tprivate int s;\tRandom r = new Random();\tpublic TaskCallable(int s)&#123;\t\tthis.s = s;\t&#125;\t@Override\tpublic String call() throws Exception &#123;\t\tString name = Thread.currentThread().getName();\t\tlong currentTimeMillis = System.currentTimeMillis();\t\tSystem.out.println(name+&quot; 启动时间：&quot; + currentTimeMillis/1000);\t\tint rint = r.nextInt(3);\t\ttry &#123;\t\t\tThread.sleep(rint*1000);\t\t&#125; catch (InterruptedException e) &#123;\t\t\te.printStackTrace();\t\t&#125;\t\tSystem.out.println(name + &quot; is working...&quot;+s);\t\treturn s+&quot;&quot;;\t&#125;&#125;\n12345678910111213141516171819202122232425262728import java.util.Random;public class TaskRunnable implements Runnable&#123;\tprivate int s;\tpublic TaskRunnable(int s)&#123;\t\tthis.s = s;\t&#125;\tRandom r = new Random();\t@Override\tpublic void run() &#123;\t\tString name = Thread.currentThread().getName();\t\tlong currentTimeMillis = System.currentTimeMillis();\t\tSystem.out.println(name+&quot; 启动时间：&quot; + currentTimeMillis/1000);\t\tint rint = r.nextInt(3);\t\ttry &#123;\t\t\tThread.sleep(rint*1000);\t\t&#125; catch (InterruptedException e) &#123;\t\t\te.printStackTrace();\t\t&#125;\t\tSystem.out.println(name + &quot; is working...&quot;+s);\t&#125;&#125;\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647import java.util.ArrayList;import java.util.HashMap;import java.util.Random;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;import java.util.concurrent.Future;import java.util.concurrent.ScheduledExecutorService;import java.util.concurrent.TimeUnit;public class TestPool &#123;\tpublic static void main(String[] args) throws Exception &#123;\t\tFuture&lt;?&gt; submit = null;\t\tRandom random = new Random();\t\t//创建固定数量线程池//\t\tExecutorService exec = Executors.newFixedThreadPool(4);\t\t//创建调度线程池\t\tScheduledExecutorService exec = Executors.newScheduledThreadPool(4);\t\t//用来记录各线程的返回结果\t\tArrayList&lt;Future&lt;?&gt;&gt; results = new ArrayList&lt;Future&lt;?&gt;&gt;();\t\tfor (int i = 0; i &lt; 10; i++) &#123;\t\t\t//fixedPool提交线程，runnable无返回值，callable有返回值\t\t\t/*submit = exec.submit(new TaskRunnable(i));*/\t\t\t/*submit = exec.submit(new TaskCallable(i));*/\t\t\t//对于schedulerPool来说，调用submit提交任务时，跟普通pool效果一致\t\t\t/*submit = exec.submit(new TaskCallable(i));*/\t\t\t//对于schedulerPool来说，调用schedule提交任务时，则可按延迟，按间隔时长来调度线程的运行\t\t\tsubmit = exec.schedule(new TaskCallable(i), random.nextInt(10), TimeUnit.SECONDS);\t\t\t//存储线程执行结果\t\t\tresults.add(submit);\t\t&#125;\t\t//打印结果\t\tfor(Future f: results)&#123;\t\t\tboolean done = f.isDone();\t\t\tSystem.out.println(done?&quot;已完成&quot;:&quot;未完成&quot;);  //从结果的打印顺序可以看到，即使未完成，也会阻塞等待\t\t\tSystem.out.println(&quot;线程返回future结果： &quot; + f.get());\t\t&#125;\t\texec.shutdown();\t&#125;&#125;\n同步容器类同步类容器都是线程安全的,但在某些场景下可能需要加锁来保护复合操作,复合类操作如选代(反复访问元素,遍历完容器中所有的元素)、跳转(根据指定的顺序找到当前元素的下一个元素)、以及条件运算,这些复合操作在多线程并发地修改容器时,可能会表现出意外的行为,最经典的便是ConcurrengModificationException,原因是当容器迭代的过程中,被井发的修改了内容,这是由于早期达代器设计的时候并没有考虑并发修改的问题。同步类容器:如古老的Vector, Hash Table.这些容器的同步功能其实是在JDK的Collections.synchronized**等工厂方法去创建实现的,其底层的机制无非就是用传统的synchronized关键字对每个公用的方法都进行同步,使得每次只能有一个线程访问容器的状态,这很明显不满足我们今天互联网时代高并发的需求,在保证线程安全的同时,他必续要有足够好的性能\n并发类容器jak5.0以后提供了多种并发类容器来替代同步类容器从而改善性能.同步类容器的状态都是串行化的,他们虽然实现了线程安全,但是严重降低了并发性,在多线程环境时,严重降低了应用程序的吞吐量。并发类容器是专门针对并发设计的,使用ConcurrentHashMap来代替给子散列的传统的HashTable,而且在ConcurrentHashMap中,添加了一些常见复合操作的支持,以及使用了CopyOnWriteArrayList代替Voctor,并发的CopyonWriteArraySet,以及并发的Queue, ConcurrentLinkedQueue和LinkedBlockingQueue,前者是高性能的队列,后者是以阻塞形式的队列,具体实现Queue还有很多,例如ArrayBlockingQueue.PriorityBlockingQueue. Synchronous Queue等\nConcurrntMap:ConcurrentMap接口下有俩个重要的实现ConcurrentHashapConcurentSkipListMap (支持并发排序功能,弥补ConcurrentHashMap)ConcurrentHashMap内部使用段(Segmen)未表示这些不同的部分,每个段其实就是一个小的Hash Table,它们有自己的锁.只要多个修改操作发生在不同的段上,它们就可以并发进行,把一个整体分成了16个段(Segment).也就是最高支持16个线程的并发修改操作,这也是在多线程场景时减小锁的粒度从面降低锁竞争的一种方案。并且代码中大多共享变量使用volatile关键字声明,目的是第一时间获取修改的内容,性能非常好.\nCopy-On-Write容器:Copy-on-Write简称cow,是种用于程序设计中的优化策略。JDK里的CoW容器有两种: CopyOnWriteArrayList和CopyOnWriteArraySet,Cow容器非常有用,可以在非常多的并发场景中使用到什么是CopyOnWrite容器?CopyOnWrite容器即写时复制的容器,通俗的理解是当我们往一个容器添加元素的时候,不直接往当前容器添加,而是先将当前容器进行Copy,复制出一个新的容器,然后新的容器里添加元素,添加完元素之后,再将原容器的引用指向新的容器。这样放的好处是我们可以对CopyOnWrite容器进行并发的读,而不需要加锁,因为当前容器不会添加任何元素,所以CopyOnWrite容器也是一种读写分离的思想,读和写不同的容器。\n并发Queue在并发队列上JDK提供了两套实现,一个是以ConcurrentLinkedQueue为代表的高性能队列,一个是以BlockingQueue接口为代表的阻塞队列,无论哪种都维承自Queue\nConcurrentLinkedQueue:ConcurrentLinkedQueue:是一个适用于高并发场景下的队列,通过无锁的方式,实现了高并发状态下的高性能,通常ConcurrentLinkedQueue性能好于BlockingQueue.它是一个基于链接节点的无界线程安全队列,该队列的元素遵循先进先出的原则,头是最先加入的,尾是最近加入的,该队列不允许null元素。ConcurrentLinkedQueue重要方法:add()和 ofter()都是加入元素的方法(在ConcurrentLinkedaueue中,这两个方法没有任何区别)pol()和peek()都是取头元素节点,区别在于前者会删除元素,后者不会.\nClockingQueue接口:ArrayBlockingQueue:基于数组的阻塞队列实现,在ArrayBlockingQueue内部,维护了一个定长数组,以便缓存队列中的数据对象,其内部没实现读写分离,也就意味着生产和消费不能完全并行,长度是需要定义的,可以指定先进先出或者先进后出,也叫有界队列,在很多场合非常适合使用.LinkedBlockingQueue:基于链表的阻塞队列,同ArrayBlockingQueue类似,其内部也维持着一个数据缓冲队列(该队列由一个链表构成) , LinkedBlockingQueue之所以能够高效的处理并发数据,是因为其内部实现采用分离锁(读写分离两个锁) ,从而实现生产者和消费者操作的完全并行运行。他是一个无界队列。SynchronousQueue :一种没有缓冲的队列,生产者产生的数据直接会被消费者获取并消费。PriorityBlockingQueue:基于优先级的阻塞队列(优先级的判断通过构造函数传入的Compator对象来决定,也就是说传入队列的对象必须实现Comparable接口) ,在实现PriorityBlockingQueue时,内部控制线程同步的锁采用的是公平锁,他也是一个无界的队列。DelayQueue:带有延迟时间的Queue,其中的元素只有当其指定的延迟时间到了,才能够从队列中获取到该元素. Delayqueue中的元素必须实现Delayed接口, Delayqueue是一个没有大小限制的队列,应用场景很多,比如对缓存超时的数据进行移除、任务超时处理、空闲连接的关闭等等.\n生产消费模型应用:客户端服务器端数据传输，可能我们没有使用什么消息中间件，通过直连的手段，比如tcp, netty等。客服端与服务器直连进行数据传输，我们发现使用netty一般都会与队列结合使用，可能有一个客户端每秒发送10条数据到服务器端，但是处理的速度与生产的步伐不一致，服务器每秒只能消费1条。如果我们用netty,在业务高峰期，把这10条数据直接放到队列中，但是要有限制，使用有界队列，防止服务器内存溢出，非高峰期，用一些无界队列。或者有些在不同时间段使用不同类型队列。\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081import java.util.concurrent.SynchronousQueue;public class UseQueue &#123;\tpublic static void main(String[] args) throws Exception &#123;\t\t//高性能无阻塞无界队列：ConcurrentLinkedQueue\t\t/**\t\tConcurrentLinkedQueue&lt;String&gt; q = new ConcurrentLinkedQueue&lt;String&gt;();\t\tq.offer(&quot;a&quot;);\t\tq.offer(&quot;b&quot;);\t\tq.offer(&quot;c&quot;);\t\tq.offer(&quot;d&quot;);\t\tq.add(&quot;e&quot;);\t\tSystem.out.println(q.poll());\t//a 从头部取出元素，并从队列里删除\t\tSystem.out.println(q.size());\t//4\t\tSystem.out.println(q.peek());\t//b\t\tSystem.out.println(q.size());\t//4\t\t*/\t\t/**\t\tArrayBlockingQueue&lt;String&gt; array = new ArrayBlockingQueue&lt;String&gt;(5);\t\tarray.put(&quot;a&quot;);\t\tarray.put(&quot;b&quot;);\t\tarray.add(&quot;c&quot;);\t\tarray.add(&quot;d&quot;);\t\tarray.add(&quot;e&quot;);\t\tarray.add(&quot;f&quot;);\t\t//System.out.println(array.offer(&quot;a&quot;, 3, TimeUnit.SECONDS));\t\t*/\t\t/**\t\t//阻塞队列\t\tLinkedBlockingQueue&lt;String&gt; q = new LinkedBlockingQueue&lt;String&gt;();\t\tq.offer(&quot;a&quot;);\t\tq.offer(&quot;b&quot;);\t\tq.offer(&quot;c&quot;);\t\tq.offer(&quot;d&quot;);\t\tq.offer(&quot;e&quot;);\t\tq.add(&quot;f&quot;);\t\t//System.out.println(q.size());//\t\tfor (Iterator iterator = q.iterator(); iterator.hasNext();) &#123;//\t\t\tString string = (String) iterator.next();//\t\t\tSystem.out.println(string);//\t\t&#125;\t\tList&lt;String&gt; list = new ArrayList&lt;String&gt;();\t\tSystem.out.println(q.drainTo(list, 3));\t\tSystem.out.println(list.size());\t\tfor (String string : list) &#123;\t\t\tSystem.out.println(string);\t\t&#125;\t\t*/\t\tfinal SynchronousQueue&lt;String&gt; q = new SynchronousQueue&lt;String&gt;();\t\tThread t1 = new Thread(new Runnable() &#123;\t\t\t@Override\t\t\tpublic void run() &#123;\t\t\t\ttry &#123;\t\t\t\t\tSystem.out.println(q.take());\t\t\t\t&#125; catch (InterruptedException e) &#123;\t\t\t\t\te.printStackTrace();\t\t\t\t&#125;\t\t\t&#125;\t\t&#125;);\t\tt1.start();\t\tThread t2 = new Thread(new Runnable() &#123;\t\t\t@Override\t\t\tpublic void run() &#123;\t\t\t\tq.add(&quot;asdasd&quot;);\t\t\t&#125;\t\t&#125;);\t\tt2.start();\t&#125;&#125;\nPriorityBlockingQueue:123456789101112131415161718192021222324252627public class Task implements Comparable&lt;Task&gt;&#123;\tprivate int id ;\tprivate String name;\tpublic int getId() &#123;\t\treturn id;\t&#125;\tpublic void setId(int id) &#123;\t\tthis.id = id;\t&#125;\tpublic String getName() &#123;\t\treturn name;\t&#125;\tpublic void setName(String name) &#123;\t\tthis.name = name;\t&#125;\t@Override\tpublic int compareTo(Task task) &#123;\t\treturn this.id &gt; task.id ? 1 : (this.id &lt; task.id ? -1 : 0);\t&#125;\tpublic String toString()&#123;\t\treturn this.id + &quot;,&quot; + this.name;\t&#125;&#125;\n123456789101112131415161718192021222324252627282930313233import java.util.concurrent.PriorityBlockingQueue;public class UsePriorityBlockingQueue &#123;\tpublic static void main(String[] args) throws Exception&#123;\t\tPriorityBlockingQueue&lt;Task&gt; q = new PriorityBlockingQueue&lt;Task&gt;();\t\tTask t1 = new Task();\t\tt1.setId(3);\t\tt1.setName(&quot;id为3&quot;);\t\tTask t2 = new Task();\t\tt2.setId(4);\t\tt2.setName(&quot;id为4&quot;);\t\tTask t3 = new Task();\t\tt3.setId(1);\t\tt3.setName(&quot;id为1&quot;);\t\t//return this.id &gt; task.id ? 1 : 0;\t\tq.add(t1);\t//3\t\tq.add(t2);\t//4\t\tq.add(t3);  //1\t\t// 1 3 4\t\tSystem.out.println(&quot;容器：&quot; + q);\t\tSystem.out.println(q.take().getId());\t\tSystem.out.println(&quot;容器：&quot; + q);//\t\tSystem.out.println(q.take().getId());//\t\tSystem.out.println(q.take().getId());\t&#125;\ntake的时候才排序，放的时候不排序123容器：[1,id为1, 4,id为4, 3,id为3]1容器：[3,id为3, 4,id为4]\nDelayQueue:123456789101112131415161718192021222324252627282930313233343536373839404142434445import java.util.concurrent.Delayed;import java.util.concurrent.TimeUnit;public class Wangmin implements Delayed &#123;    private String name;    //身份证    private String id;    //截止时间    private long endTime;    //定义时间工具类    private TimeUnit timeUnit = TimeUnit.SECONDS;    public Wangmin(String name,String id,long endTime)&#123;        this.name=name;        this.id=id;        this.endTime = endTime;    &#125;    public String getName()&#123;        return this.name;    &#125;    public String getId()&#123;        return this.id;    &#125;    /**     * 用来判断是否到了截止时间     */    @Override    public long getDelay(TimeUnit unit) &#123;        //return unit.convert(endTime, TimeUnit.MILLISECONDS) - unit.convert(System.currentTimeMillis(), TimeUnit.MILLISECONDS);    \treturn endTime - System.currentTimeMillis();    &#125;    /**     * 相互批较排序用     */    @Override    public int compareTo(Delayed delayed) &#123;    \tWangmin w = (Wangmin)delayed;        return this.getDelay(this.timeUnit) - w.getDelay(this.timeUnit) &gt; 0 ? 1:0;    &#125;&#125;\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647import java.util.concurrent.DelayQueue;public class WangBa implements Runnable &#123;    private DelayQueue&lt;Wangmin&gt; queue = new DelayQueue&lt;Wangmin&gt;();    public boolean yinye =true;    public void shangji(String name,String id,int money)&#123;        Wangmin man = new Wangmin(name, id, 1000 * money + System.currentTimeMillis());        System.out.println(&quot;网名&quot;+man.getName()+&quot; 身份证&quot;+man.getId()+&quot;交钱&quot;+money+&quot;块,开始上机...&quot;);        this.queue.add(man);    &#125;    public void xiaji(Wangmin man)&#123;        System.out.println(&quot;网名&quot;+man.getName()+&quot; 身份证&quot;+man.getId()+&quot;时间到下机...&quot;);    &#125;    @Override    public void run() &#123;        while(yinye)&#123;            try &#123;                Wangmin man = queue.take();                xiaji(man);            &#125; catch (InterruptedException e) &#123;                e.printStackTrace();            &#125;        &#125;    &#125;    public static void main(String args[])&#123;        try&#123;            System.out.println(&quot;网吧开始营业&quot;);            WangBa siyu = new WangBa();            Thread shangwang = new Thread(siyu);            shangwang.start();            siyu.shangji(&quot;路人甲&quot;, &quot;123&quot;, 1);            siyu.shangji(&quot;路人乙&quot;, &quot;234&quot;, 10);            siyu.shangji(&quot;路人丙&quot;, &quot;345&quot;, 5);        &#125;        catch(Exception e)&#123;            e.printStackTrace();        &#125;    &#125;&#125;\n1234567网吧开始营业网名路人甲 身份证123交钱1块,开始上机...网名路人乙 身份证234交钱10块,开始上机...网名路人丙 身份证345交钱5块,开始上机...网名路人甲 身份证123时间到下机...网名路人丙 身份证345时间到下机...网名路人乙 身份证234时间到下机...\n1234567891011121314151617181920212223242526BlockingQueue也是java.util.concurrent下的主要用来控制线程同步的工具。主要的方法是：put、take一对阻塞存取；add、poll一对非阻塞存取。\t插入:\t\t1)add(anObject):把anObject加到BlockingQueue里,即如果BlockingQueue可以容纳,则返回true,否则抛出        2)offer(anObject):表示如果可能的话,将anObject加到BlockingQueue里,即如果BlockingQueue可以容纳,则返回true,否则返回false.        3)put(anObject):把anObject加到BlockingQueue里,如果BlockQueue没有空间,则调用此方法的线程被阻断直到BlockingQueue里面有空间再继续.\t读取：        4)poll(time):取走BlockingQueue里排在首位的对象,若不能立即取出,则可以等time参数规定的时间,取不到时返回null        5)take():取走BlockingQueue里排在首位的对象,若BlockingQueue为空,阻断进入等待状态直到Blocking有新的对象被加入为止\t其他int remainingCapacity();返回队列剩余的容量，在队列插入和获取的时候，不要瞎搞，数\t据可能不准boolean remove(Object o); 从队列移除元素，如果存在，即移除一个或者更多，队列改\t变了返回truepublic boolean contains(Object o); 查看队列是否存在这个元素，存在返回trueint drainTo(Collection&lt;? super E&gt; c); 移除此队列中所有可用的元素，并将它们添加到给定collection中int drainTo(Collection&lt;? super E&gt; c, int maxElements); 和上面方法的区别在于，制定了移动的数量BlockingQueue有四个具体的实现类,常用的两种实现类为：1、ArrayBlockingQueue：一个由数组支持的有界阻塞队列，规定大小的BlockingQueue,其构造函数必须带一个int参数来指明其大小.其所含的对象是以FIFO(先入先出)顺序排序的。2、LinkedBlockingQueue：大小不定的BlockingQueue,若其构造函数带一个规定大小的参数,生成的BlockingQueue有大小限制,若不带大小参数,所生成的BlockingQueue的大小由Integer.MAX_VALUE来决定.其所含的对象是以FIFO(先入先出)顺序排序的。\tLinkedBlockingQueue 可以指定容量，也可以不指定，不指定的话，默认最大是Integer.MAX_VALUE,其中主要用到put和take方法，put方法在队列满的时候会阻塞直到有队列成员被消费，take方法在队列空的时候会阻塞，直到有队列成员被放进来。LinkedBlockingQueue和ArrayBlockingQueue区别：LinkedBlockingQueue和ArrayBlockingQueue比较起来,它们背后所用的数据结构不一样,导致LinkedBlockingQueue的数据吞吐量要大于ArrayBlockingQueue,但在线程数量很大时其性能的可预见性低于ArrayBlockingQueue.\njava并发编程的一些总结1.不应用线程池的缺点有些开发者图省事，遇到需要多线程处理的地方，直接new Thread(…).start()，对于一般场景是没问题的，但如果是在并发请求很高的情况下，就会有些隐患：新建线程的开销。线程虽然比进程要轻量许多，但对于JVM来说，新建一个线程的代价还是挺大的，决不同于新建一个对象资源消耗量。没有一个池来限制线程的数量，会导致线程的数量直接取决于应用的并发量，这样有潜在的线程数据巨大的可能，那么资源消耗量将是巨大的稳定性。当线程数量超过系统资源所能承受的程度，稳定性就会成问题2.制定执行策略在每个需要多线程处理的地方，不管并发量有多大，需要考虑线程的执行策略任务以什么顺序执行可以有多少个任何并发执行可以有多少个任务进入等待执行队列系统过载的时候，应该放弃哪些任务？如何通知到应用程序？一个任务的执行前后应该做什么处理3.线程池的类型不管是通过Executors创建线程池，还是通过Spring来管理，都得清楚知道有哪几种线程池：FixedThreadPool：定长线程池，提交任务时创建线程，直到池的最大容量，如果有线程非预期结束，会补充新线程CachedThreadPool：可变线程池，它犹如一个弹簧，如果没有任务需求时，它回收空闲线程，如果需求增加，则按需增加线程，不对池的大小做限制SingleThreadExecutor：单线程。处理不过来的任务会进入FIFO队列等待执行SecheduledThreadPool：周期性线程池。支持执行周期性线程任务其实，这些不同类型的线程池都是通过构建一个ThreadPoolExecutor来完成的，所不同的是corePoolSize,maximumPoolSize,keepAliveTime,unit,workQueue,threadFactory这么几个参数。具体可以参见JDK DOC。4.线程池饱和策略由以上线程池类型可知，除了CachedThreadPool其他线程池都有饱和的可能，当饱和以后就需要相应的策略处理请求线程的任务，ThreadPoolExecutor采取的方式通过队列来存储这些任务，当然会根据池类型不同选择不同的队列，比如FixedThreadPool和SingleThreadExecutor默认采用的是无限长度的LinkedBlockingQueue。但从系统可控性讲，最好的做法是使用定长的ArrayBlockingQueue或有限的LinkedBlockingQueue，并且当达到上限时通过ThreadPoolExecutor.setRejectedExecutionHandler方法设置一个拒绝任务的策略，JDK提供了AbortPolicy、CallerRunsPolicy、DiscardPolicy、DiscardOldestPolicy几种策略，具体差异可见JDK DOC5.线程无依赖性多线程任务设计上尽量使得各任务是独立无依赖的，所谓依赖性可两个方面：线程之间的依赖性。如果线程有依赖可能会造成死锁或饥饿调用者与线程的依赖性。调用者得监视线程的完成情况，影响可并发量当然，在有些业务里确实需要一定的依赖性，比如调用者需要得到线程完成后结果，传统的Thread是不便完成的，因为run方法无返回值，只能通过一些共享的变量来传递结果，但在Executor框架里可以通过Future和Callable实现需要有返回值的任务，当然线程的异步性导致需要有相应机制来保证调用者能等待任务完成。\n多线程的设计模式并行设计模式属于设计优化的一部分,它是对一些常用的多线程结构的总结和抽象与串行程序相比,并行程序的结构通常更为复杂。因此合理的使用并行模式在多线程开发中更具有意义,在这里主要介绍Future, Master-Worker和生产者-消费者模型。\nFuture模式Future模式有点类似于商品订单。比如在网购时,当看重某一件商品事,就可以提交订 ,当订单处理完成后,在家里等待商品送货上门即可。或者说更形象的我们发送Ajax请求的时候,页面是异步的进行后台处理,用户无须一直等待请求的结果,可以继续浏览或操作其他内容。\nData:123public interface Data &#123;\tString getRequest();&#125;\nRealData:123456789101112131415161718192021public class RealData implements Data&#123;\tprivate String result ;\tpublic RealData (String queryStr)&#123;\t\tSystem.out.println(&quot;根据&quot; + queryStr + &quot;进行查询，这是一个很耗时的操作..&quot;);\t\ttry &#123;\t\t\tThread.sleep(5000);\t\t&#125; catch (InterruptedException e) &#123;\t\t\te.printStackTrace();\t\t&#125;\t\tSystem.out.println(&quot;操作完毕，获取结果&quot;);\t\tresult = &quot;查询结果&quot;;\t&#125;\t@Override\tpublic String getRequest() &#123;\t\treturn result;\t&#125;&#125;\nFutureData:12345678910111213141516171819202122232425262728293031public class FutureData implements Data&#123;\tprivate RealData realData ;\tprivate boolean isReady = false;\tpublic synchronized void setRealData(RealData realData) &#123;\t\t//如果已经装载完毕了，就直接返回\t\tif(isReady)&#123;\t\t\treturn;\t\t&#125;\t\t//如果没装载，进行装载真实对象\t\tthis.realData = realData;\t\tisReady = true;\t\t//进行通知\t\tnotify();\t&#125;\t@Override\tpublic synchronized String getRequest() &#123;\t\t//如果没装载好 程序就一直处于阻塞状态\t\twhile(!isReady)&#123;\t\t\ttry &#123;\t\t\t\twait();\t\t\t&#125; catch (InterruptedException e) &#123;\t\t\t\te.printStackTrace();\t\t\t&#125;\t\t&#125;\t\t//装载好直接获取数据即可\t\treturn this.realData.getRequest();\t&#125;&#125;\nFutureClient:123456789101112131415161718public class FutureClient &#123;\tpublic Data request(final String queryStr)&#123;\t\t//1 我想要一个代理对象（Data接口的实现类）先返回给发送请求的客户端，告诉他请求已经接收到，可以做其他的事情\t\tfinal FutureData futureData = new FutureData();\t\t//2 启动一个新的线程，去加载真实的数据，传递给这个代理对象\t\tnew Thread(new Runnable() &#123;\t\t\t@Override\t\t\tpublic void run() &#123;\t\t\t\t//3 这个新的线程可以去慢慢的加载真实对象，然后传递给代理对象\t\t\t\tRealData realData = new RealData(queryStr);\t\t\t\tfutureData.setRealData(realData);\t\t\t&#125;\t\t&#125;).start();\t\treturn futureData;\t&#125;&#125;\nMain:1234567891011121314public class Main &#123;\tpublic static void main(String[] args) throws InterruptedException &#123;\t\tFutureClient fc = new FutureClient();\t\tData data = fc.request(&quot;请求参数&quot;);\t\tSystem.out.println(&quot;请求发送成功!&quot;);\t\tSystem.out.println(&quot;做其他的事情...&quot;);\t\tString result = data.getRequest();\t\tSystem.out.println(result);\t&#125;&#125;\nMaster-Worker模式Master-Worker模式是常用的并行计算模式。它的核心思想是系统由两类进程协作工作: Master进程和Worker进程。Master负责接收和分配任务,Worker负责处理子任务。当各个Worker子进程处理完成后,会将结果返回给Master, 由Master做归纳和总结。其好处是能将一个大任务分解成若干个小任务,并行执行,从而提高系统的吞吐量。Task:123456789101112131415161718public class Task &#123;\tprivate int id;\tprivate int price ;\tpublic int getId() &#123;\t\treturn id;\t&#125;\tpublic void setId(int id) &#123;\t\tthis.id = id;\t&#125;\tpublic int getPrice() &#123;\t\treturn price;\t&#125;\tpublic void setPrice(int price) &#123;\t\tthis.price = price;\t&#125;&#125;\nMaster:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758import java.util.HashMap;import java.util.Map;import java.util.concurrent.ConcurrentHashMap;import java.util.concurrent.ConcurrentLinkedQueue;public class Master &#123;\t//1 有一个盛放任务的容器\tprivate ConcurrentLinkedQueue&lt;Task&gt; workQueue = new ConcurrentLinkedQueue&lt;Task&gt;();\t//2 需要有一个盛放worker的集合\tprivate HashMap&lt;String, Thread&gt; workers = new HashMap&lt;String, Thread&gt;();\t//3 需要有一个盛放每一个worker执行任务的结果集合\tprivate ConcurrentHashMap&lt;String, Object&gt; resultMap = new ConcurrentHashMap&lt;String, Object&gt;();\t//4 构造方法\tpublic Master(Worker worker , int workerCount)&#123;\t\tworker.setWorkQueue(this.workQueue);\t\tworker.setResultMap(this.resultMap);\t\tfor(int i = 0; i &lt; workerCount; i ++)&#123;\t\t\tthis.workers.put(Integer.toString(i), new Thread(worker));\t\t&#125;\t&#125;\t//5 需要一个提交任务的方法\tpublic void submit(Task task)&#123;\t\tthis.workQueue.add(task);\t&#125;\t//6 需要有一个执行的方法，启动所有的worker方法去执行任务\tpublic void execute()&#123;\t\tfor(Map.Entry&lt;String, Thread&gt; me : workers.entrySet())&#123;\t\t\tme.getValue().start();\t\t&#125;\t&#125;\t//7 判断是否运行结束的方法\tpublic boolean isComplete() &#123;\t\tfor(Map.Entry&lt;String, Thread&gt; me : workers.entrySet())&#123;\t\t\tif(me.getValue().getState() != Thread.State.TERMINATED)&#123;\t\t\t\treturn false;\t\t\t&#125;\t\t&#125;\t\treturn true;\t&#125;\t//8 计算结果方法\tpublic int getResult() &#123;\t\tint priceResult = 0;\t\tfor(Map.Entry&lt;String, Object&gt; me : resultMap.entrySet())&#123;\t\t\tpriceResult += (Integer)me.getValue();\t\t&#125;\t\treturn priceResult;\t&#125;&#125;\nWorker:1234567891011121314151617181920212223242526272829303132333435363738import java.util.concurrent.ConcurrentHashMap;import java.util.concurrent.ConcurrentLinkedQueue;public class Worker implements Runnable &#123;\tprivate ConcurrentLinkedQueue&lt;Task&gt; workQueue;\tprivate ConcurrentHashMap&lt;String, Object&gt; resultMap;\tpublic void setWorkQueue(ConcurrentLinkedQueue&lt;Task&gt; workQueue) &#123;\t\tthis.workQueue = workQueue;\t&#125;\tpublic void setResultMap(ConcurrentHashMap&lt;String, Object&gt; resultMap) &#123;\t\tthis.resultMap = resultMap;\t&#125;\t@Override\tpublic void run() &#123;\t\twhile(true)&#123;\t\t\tTask input = this.workQueue.poll();\t\t\tif(input == null) break;\t\t\tObject output = handle(input);\t\t\tthis.resultMap.put(Integer.toString(input.getId()), output);\t\t&#125;\t&#125;\tprivate Object handle(Task input) &#123;\t\tObject output = null;\t\ttry &#123;\t\t\t//处理任务的耗时。。 比如说进行操作数据库。。。\t\t\tThread.sleep(500);\t\t\toutput = input.getPrice();\t\t&#125; catch (InterruptedException e) &#123;\t\t\te.printStackTrace();\t\t&#125;\t\treturn output;\t&#125;&#125;\nMain:12345678910111213141516171819202122232425262728import java.util.Random;public class Main &#123;\tpublic static void main(String[] args) &#123;\t\tMaster master = new Master(new Worker(), 20);\t\tRandom r = new Random();\t\tfor(int i = 1; i &lt;= 100; i++)&#123;\t\t\tTask t = new Task();\t\t\tt.setId(i);\t\t\tt.setPrice(r.nextInt(1000));\t\t\tmaster.submit(t);\t\t&#125;\t\tmaster.execute();\t\tlong start = System.currentTimeMillis();\t\twhile(true)&#123;\t\t\tif(master.isComplete())&#123;\t\t\t\tlong end = System.currentTimeMillis() - start;\t\t\t\tint priceResult = master.getResult();\t\t\t\tSystem.out.println(&quot;最终结果：&quot; + priceResult + &quot;, 执行时间：&quot; + end);\t\t\t\tbreak;\t\t\t&#125;\t\t&#125;\t&#125;&#125;\n生产者-消费者生产者和消费者也是一个非常经典的多线程模式,我们在实际开发中应用非常广泛的思想理念。在生产-消费模式中:通常由两类线程,即若干个生产者的线程和若干个消费者的线程。生产者线程负责提交用户请求,消费者线程则负责具体处理生产者提交的任务,在生产者和消费者之间通过共享内存缓存区进行通信。Data:1234567891011121314151617181920212223242526272829303132public final class Data &#123;\tprivate String id;\tprivate String name;\tpublic Data(String id, String name)&#123;\t\tthis.id = id;\t\tthis.name = name;\t&#125;\tpublic String getId() &#123;\t\treturn id;\t&#125;\tpublic void setId(String id) &#123;\t\tthis.id = id;\t&#125;\tpublic String getName() &#123;\t\treturn name;\t&#125;\tpublic void setName(String name) &#123;\t\tthis.name = name;\t&#125;\t@Override\tpublic String toString()&#123;\t\treturn &quot;&#123;id: &quot; + id + &quot;, name: &quot; + name + &quot;&#125;&quot;;\t&#125;&#125;\nProvider:12345678910111213141516171819202122232425262728293031323334353637383940414243444546import java.util.Random;import java.util.concurrent.BlockingQueue;import java.util.concurrent.TimeUnit;import java.util.concurrent.atomic.AtomicInteger;public class Provider implements Runnable&#123;\t//共享缓存区\tprivate BlockingQueue&lt;Data&gt; queue;\t//多线程间是否启动变量，有强制从主内存中刷新的功能。即时返回线程的状态\tprivate volatile boolean isRunning = true;\t//id生成器\tprivate static AtomicInteger count = new AtomicInteger();\t//随机对象\tprivate static Random r = new Random();\tpublic Provider(BlockingQueue queue)&#123;\t\tthis.queue = queue;\t&#125;\t@Override\tpublic void run() &#123;\t\twhile(isRunning)&#123;\t\t\ttry &#123;\t\t\t\t//随机休眠0 - 1000 毫秒 表示获取数据(产生数据的耗时)\t\t\t\tThread.sleep(r.nextInt(1000));\t\t\t\t//获取的数据进行累计...\t\t\t\tint id = count.incrementAndGet();\t\t\t\t//比如通过一个getData方法获取了\t\t\t\tData data = new Data(Integer.toString(id), &quot;数据&quot; + id);\t\t\t\tSystem.out.println(&quot;当前线程:&quot; + Thread.currentThread().getName() + &quot;, 获取了数据，id为:&quot; + id + &quot;, 进行装载到公共缓冲区中...&quot;);\t\t\t\tif(!this.queue.offer(data, 2, TimeUnit.SECONDS))&#123;\t\t\t\t\tSystem.out.println(&quot;提交缓冲区数据失败....&quot;);\t\t\t\t\t//do something... 比如重新提交\t\t\t\t&#125;\t\t\t&#125; catch (InterruptedException e) &#123;\t\t\t\te.printStackTrace();\t\t\t&#125;\t\t&#125;\t&#125;\tpublic void stop()&#123;\t\tthis.isRunning = false;\t&#125;&#125;\nConsumer:1234567891011121314151617181920212223242526public class Consumer implements Runnable&#123;\tprivate BlockingQueue&lt;Data&gt; queue;\tpublic Consumer(BlockingQueue queue)&#123;\t\tthis.queue = queue;\t&#125;\t//随机对象\tprivate static Random r = new Random();\t@Override\tpublic void run() &#123;\t\twhile(true)&#123;\t\t\ttry &#123;\t\t\t\t//获取数据\t\t\t\tData data = this.queue.take();\t\t\t\t//进行数据处理。休眠0 - 1000毫秒模拟耗时\t\t\t\tThread.sleep(r.nextInt(1000));\t\t\t\tSystem.out.println(&quot;当前消费线程：&quot; + Thread.currentThread().getName() + &quot;， 消费成功，消费数据为id: &quot; + data.getId());\t\t\t&#125; catch (InterruptedException e) &#123;\t\t\t\te.printStackTrace();\t\t\t&#125;\t\t&#125;\t&#125;&#125;\nMain:12345678910111213141516171819202122232425262728293031323334353637383940414243444546import java.util.concurrent.BlockingQueue;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;import java.util.concurrent.LinkedBlockingQueue;public class Main &#123;\tpublic static void main(String[] args) throws Exception &#123;\t\t//内存缓冲区\t\tBlockingQueue&lt;Data&gt; queue = new LinkedBlockingQueue&lt;Data&gt;(10);\t\t//生产者\t\tProvider p1 = new Provider(queue);\t\tProvider p2 = new Provider(queue);\t\tProvider p3 = new Provider(queue);\t\t//消费者\t\tConsumer c1 = new Consumer(queue);\t\tConsumer c2 = new Consumer(queue);\t\tConsumer c3 = new Consumer(queue);\t\t//创建线程池运行,这是一个缓存的线程池，可以创建无穷大的线程，没有任务的时候不创建线程。空闲线程存活时间为60s（默认值）\t\tExecutorService cachePool = Executors.newCachedThreadPool();\t\tcachePool.execute(p1);\t\tcachePool.execute(p2);\t\tcachePool.execute(p3);\t\tcachePool.execute(c1);\t\tcachePool.execute(c2);\t\tcachePool.execute(c3);\t\ttry &#123;\t\t\tThread.sleep(3000);\t\t&#125; catch (InterruptedException e) &#123;\t\t\te.printStackTrace();\t\t&#125;\t\tp1.stop();\t\tp2.stop();\t\tp3.stop();\t\ttry &#123;\t\t\tThread.sleep(2000);\t\t&#125; catch (InterruptedException e) &#123;\t\t\te.printStackTrace();\t\t&#125;//\t\tcachePool.shutdown();//\t\tcachePool.shutdownNow();\t&#125;&#125;\nExecutor框架为了更好的控制多线程, JDK提供了一套线程框架Executor,帮助开发人员有效地进行线程控制。它们都在java.util.concurrent包中,是JDK并发包的核心。其中有一个比较重要的类: Executors,他扮演这线程工厂的角色,我们通过Executors可以创建特定功能的线程池。Executors创建线程池方法:newFixedThreadPool)方法,该方法返回一个固定数量的线程池,该方法的线程数始终不变,当有一个任务提交时,若线程池中空闲,则立即执行,若没有,则会被暂缓在一个任务队列中等待有空闲的线程去执行。newSingleThreadExecutor()方法,创建一个线程的线程池,若空闲则执行,若没有空闲线程则暂缓在任务列队中。newCachedThreadPool)方法,返回一个可根据实际情况调整线程个数的线程池,不限制最大线程数量,若有任务,则创建线程,若无任务则不创建线程。如果没有任务则线程在60s后自动回收(空闲时间60s) .newScheduled ThreadPool)方法,该方法返回一个SchededExecutorService对象,但该线程池可以指定线程的数量\n自定义线程池若Executors工厂类无法满足我们的需求,可以自己去创建自定义的线程池,其实Executors工广类里面的创建线程方法其内部实现均是用了ThreadPoolExecutor这个类,这个类可以自定义线程。构造方法如下:public ThreadPoolExecutor(int corePoolSize,                  int maximumPoolSize，                  long keepAliveTime,                  TimeUnit unit,                  BlockingQueue workQueue,                  ThreadFactory ThreadFactory,                  RejectedExecutionHandler handler) {…}\n比如：maximumPoolSize=2，maximumPoolSize=10，ArrayBlockingqueue=10当一次性来了30个任务，放到这个线程池里，肯定会有一堆任务被拒绝，首先，corePoolSize有2个，还有28个任务待处理，我们可以根据上限maximumPoolSize再去提高8个线程去处理，还剩20个，再往队列里扔10个，最后还剩10个，这10个就会去走RejectedExecutionHandler任务过多的时候会导致内存溢出，队列会逐渐变大。\n自定义线程池使用详细这个构造方法对于队列是什么类型的比较关键:在使用有界队列时: 若有新的任务需要执行,如果线程池实际线程数小于corePoolSize,则优先创建线程,若大于corePoolsize,则会将任务加入队列，若队列已满，则在总线程数不大于maximumPoolSize的前提下创建新的线程，若线程数大于maximumPoolsize,则执行拒绝策略。或其他自定义方式。无界的任务队列时: LinkedBlockingQueue,与有界队列相比,除非系统资源耗尽,否则无界的任务队列不存在任务入队失败的情况。当有新在务到来,系统的线程数小于corePoolsize时,则新建线程执行任务,当达到orePoolSize后,就不会继续增加。若后续仍有新的在务加入,而有没有闲的线程资源，则任务直接进入队列等待。若任务创建和处理的速度差异很大,无界队列会保持快速增长,直到耗尽系统内存。JDK拒绝策略:AbortPolicy:直接抛出异常组织系统正常工作CallerRunsPolicy:只要线程池未关闭,该策略直接在调用者线程中,运行当前被丢弃的任务。DiscardoldestPolicy:丢弃最老的一个请求,尝试再次提交当前任务。DiscardPolicy:丢弃无法处理的任务,不给予任何处理。如果需要自定义拒绝策略可以实现RejectedExecutionHandler接口。\n","dateCreated":"2019-09-07T10:23:08+08:00","dateModified":"2019-09-07T10:19:36+08:00","datePublished":"2019-09-07T10:23:08+08:00","description":"","headline":"多线程3","image":[],"mainEntityOfPage":{"@type":"WebPage","@id":"http://yoursite.com/2019/09/07/多线程3/"},"publisher":{"@type":"Organization","name":"Brotherc","sameAs":["https://github.com/Brotherc"],"image":"head.jpg","logo":{"@type":"ImageObject","url":"head.jpg"}},"url":"http://yoursite.com/2019/09/07/多线程3/","keywords":"java基础"}</script>
    <meta name="description" content="java并发包介绍12JDK5.0 以后的版本都引入了高级并发特性，大多数的特性在java.util.concurrent 包中，是专门用于多线程发编程的，充分利用了现代多处理器和多核心系统的功能以编写大规模并发应用程序。主要包含原子量、并发集合、同步器、可重入锁，并对线程池的构造提供了强力的支持。 线程池1、Single Thread Executor : 只有一个线程的线程池，因此所有提交的任">
<meta name="keywords" content="java基础">
<meta property="og:type" content="blog">
<meta property="og:title" content="多线程3">
<meta property="og:url" content="http://yoursite.com/2019/09/07/多线程3/index.html">
<meta property="og:site_name" content="Brotherc">
<meta property="og:description" content="java并发包介绍12JDK5.0 以后的版本都引入了高级并发特性，大多数的特性在java.util.concurrent 包中，是专门用于多线程发编程的，充分利用了现代多处理器和多核心系统的功能以编写大规模并发应用程序。主要包含原子量、并发集合、同步器、可重入锁，并对线程池的构造提供了强力的支持。 线程池1、Single Thread Executor : 只有一个线程的线程池，因此所有提交的任">
<meta property="og:locale" content="zh-cn">
<meta property="og:image" content="http://yoursite.com/2019/09/07/多线程3/queue.png">
<meta property="og:image" content="http://yoursite.com/2019/09/07/多线程3/Future模式.png">
<meta property="og:image" content="http://yoursite.com/2019/09/07/多线程3/master-worker.png">
<meta property="og:image" content="http://yoursite.com/2019/09/07/多线程3/master-worker2.png">
<meta property="og:updated_time" content="2019-09-07T02:19:36.164Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="多线程3">
<meta name="twitter:description" content="java并发包介绍12JDK5.0 以后的版本都引入了高级并发特性，大多数的特性在java.util.concurrent 包中，是专门用于多线程发编程的，充分利用了现代多处理器和多核心系统的功能以编写大规模并发应用程序。主要包含原子量、并发集合、同步器、可重入锁，并对线程池的构造提供了强力的支持。 线程池1、Single Thread Executor : 只有一个线程的线程池，因此所有提交的任">
<meta name="twitter:image" content="http://yoursite.com/2019/09/07/多线程3/queue.png">
    
    
        
    
    
        <meta property="og:image" content="http://yoursite.com/assets/images/head.jpg"/>
    
    
    
    
    <!--STYLES-->
    <link rel="stylesheet" href="/assets/css/style-c4ozcsklz4kht2pebhp44xorvyverh23toayhn7i6ubrpyedak24hv1v0hyd.min.css">
    <!--STYLES END-->
    

    
</head>

    <body>
        <div id="blog">
            <!-- Define author's picture -->


    
        
            
        
    

<header id="header" data-behavior="4">
    <i id="btn-open-sidebar" class="fa fa-lg fa-bars"></i>
    <div class="header-title">
        <a class="header-title-link" href="/ ">Brotherc</a>
    </div>
    
        
            <a class="header-right-picture " href="#about">
        
        
            <img class="header-picture" src="/assets/images/head.jpg" alt="作者的图片">
        
        </a>
    
</header>

            <!-- Define author's picture -->



        
    

<nav id="sidebar" data-behavior="4">
    <div class="sidebar-container">
        
            <div class="sidebar-profile">
                <a href="/#about">
                    <img class="sidebar-profile-picture" src="/assets/images/head.jpg" alt="作者的图片">
                </a>
                <h4 class="sidebar-profile-name">Brotherc</h4>
                
                    <h5 class="sidebar-profile-bio"><p>java development</p>
</h5>
                
            </div>
        
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a class="sidebar-button-link " href="/ " title="首页">
                    
                        <i class="sidebar-button-icon fa fa-home" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">首页</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a class="sidebar-button-link " href="/all-categories" title="分类">
                    
                        <i class="sidebar-button-icon fa fa-bookmark" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">分类</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a class="sidebar-button-link " href="/all-tags" title="标签">
                    
                        <i class="sidebar-button-icon fa fa-tags" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">标签</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a class="sidebar-button-link open-algolia-search" href="/all-archives" title="归档">
                    
                        <i class="sidebar-button-icon fa fa-archive" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">归档</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a class="sidebar-button-link " href="#about" title="关于">
                    
                        <i class="sidebar-button-icon fa fa-question" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">关于</span>
                    </a>
            </li>
            
        </ul>
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a class="sidebar-button-link " href="https://github.com/Brotherc" target="_blank" rel="noopener" title="GitHub">
                    
                        <i class="sidebar-button-icon fab fa-github" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">GitHub</span>
                    </a>
            </li>
            
        </ul>
        
    </div>
</nav>

            
            <div id="main" data-behavior="4"
                 class="
                        hasCoverMetaIn
                        ">
                
<article class="post">
    
    
        <div class="post-header main-content-wrap text-left">
    
        <h1 class="post-title">
            多线程3
        </h1>
    
    
        <div class="post-meta">
    <time datetime="2019-09-07T10:23:08+08:00">
	
		    9月 07, 2019
    	
    </time>
    
</div>

    
</div>

    
    <div class="post-content markdown">
        <div class="main-content-wrap">
            <h3 id="java并发包介绍"><a href="#java并发包介绍" class="headerlink" title="java并发包介绍"></a>java并发包介绍</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">JDK5.0 以后的版本都引入了高级并发特性，大多数的特性在java.util.concurrent 包中，是专门用于多线程发编程的，充分利用了现代多处理器和多核心系统的功能以编写大规模并发应用程序。</span><br><span class="line">主要包含原子量、并发集合、同步器、可重入锁，并对线程池的构造提供了强力的支持。</span><br></pre></td></tr></table></figure>
<h4 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h4><p>1、Single Thread Executor : 只有一个线程的线程池，因此所有提交的任务是顺序执行，<br>Executors.newSingleThreadExecutor()</p>
<p>2、Cached Thread Pool : 线程池里有很多线程需要同时执行，老的可用线程将被新的任务触发重新执行，如果线程超过60秒内没执行，那么将被终止并从池中删除，<br>Executors.newCachedThreadPool()</p>
<p>3、Fixed Thread Pool : 拥有固定线程数的线程池，如果没有任务执行，那么线程会一直等待，<br>Executors.newFixedThreadPool(4)<br>在构造函数中的参数4是线程池的大小，你可以随意设置，也可以和cpu的数量保持一致，获取cpu的数量int cpuNums = Runtime.getRuntime().availableProcessors();</p>
<p>4、Scheduled Thread Pool : 用来调度即将执行的任务的线程池，<br>Executors.newScheduledThreadPool()</p>
<p>5、Single Thread Scheduled Pool : 只有一个线程，用来调度执行将来的任务，<br>Executors.newSingleThreadScheduledExecutor()</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">import java.util.concurrent.ExecutorService;</span><br><span class="line">import java.util.concurrent.Executors;</span><br><span class="line">import java.util.concurrent.ScheduledExecutorService;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 列出并发包中的各种线程池</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">public class ExecutorDemo &#123;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		ExecutorService newSingleThreadExecutor = Executors.newSingleThreadExecutor();</span><br><span class="line">		ExecutorService newCachedThreadPool = Executors.newCachedThreadPool();</span><br><span class="line"></span><br><span class="line">		int cpuNums = Runtime.getRuntime().availableProcessors();</span><br><span class="line">		System.out.println(cpuNums);</span><br><span class="line">		ExecutorService newFixedThreadPool = Executors.newFixedThreadPool(cpuNums);</span><br><span class="line">		ScheduledExecutorService newScheduledThreadPool = Executors.newScheduledThreadPool(8);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		ScheduledExecutorService newSingleThreadScheduledExecutor = Executors.newSingleThreadScheduledExecutor();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>提交 Runnable ，任务完成后 Future 对象返回 null<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">import java.util.concurrent.ExecutorService;</span><br><span class="line">import java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line">public class ThreadPoolWithRunable &#123;</span><br><span class="line">	/**</span><br><span class="line">	 * 通过线程池执行线程</span><br><span class="line">	 * @param args</span><br><span class="line">	 */</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		//创建一个线程池</span><br><span class="line">		ExecutorService pool = Executors.newCachedThreadPool();</span><br><span class="line">		for(int i = 1; i &lt; 5; i++)&#123;</span><br><span class="line">			pool.execute(new Runnable() &#123;</span><br><span class="line">				@Override</span><br><span class="line">				public void run() &#123;</span><br><span class="line">					System.out.println(&quot;thread name: &quot; + Thread.currentThread().getName());</span><br><span class="line">					try &#123;</span><br><span class="line">						Thread.sleep(1000);</span><br><span class="line">					&#125; catch (InterruptedException e) &#123;</span><br><span class="line">						e.printStackTrace();</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;);</span><br><span class="line">		&#125;</span><br><span class="line">		pool.shutdown();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>提交 Callable，该方法返回一个 Future 实例表示任务的状态<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.List;</span><br><span class="line">import java.util.concurrent.Callable;</span><br><span class="line">import java.util.concurrent.ExecutionException;</span><br><span class="line">import java.util.concurrent.ExecutorService;</span><br><span class="line">import java.util.concurrent.Executors;</span><br><span class="line">import java.util.concurrent.Future;</span><br><span class="line">/**</span><br><span class="line"> * callable 跟runnable的区别：</span><br><span class="line"> * runnable的run方法不会有任何返回结果，所以主线程无法获得任务线程的返回值</span><br><span class="line"> *</span><br><span class="line"> * callable的call方法可以返回结果，但是主线程在获取时是被阻塞，需要等待任务线程返回才能拿到结果</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class ThreadPoolWithcallable &#123;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) throws InterruptedException, ExecutionException &#123;</span><br><span class="line">		ExecutorService pool = Executors.newFixedThreadPool(4);</span><br><span class="line"></span><br><span class="line">		for(int i = 0; i &lt; 10; i++)&#123;</span><br><span class="line">			Future&lt;String&gt; submit = pool.submit(new Callable&lt;String&gt;()&#123;</span><br><span class="line">				@Override</span><br><span class="line">				public String call() throws Exception &#123;</span><br><span class="line">					//System.out.println(&quot;a&quot;);</span><br><span class="line">					Thread.sleep(5000);</span><br><span class="line">					return &quot;b--&quot;+Thread.currentThread().getName();</span><br><span class="line">				&#125;</span><br><span class="line">			   &#125;);</span><br><span class="line">			//从Future中get结果，这个方法是会被阻塞的，一直要等到线程任务返回结果</span><br><span class="line">			System.out.println(submit.get());</span><br><span class="line">		&#125;</span><br><span class="line">			pool.shutdown();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Random;</span><br><span class="line">import java.util.concurrent.Callable;</span><br><span class="line"></span><br><span class="line">public class TaskCallable implements Callable&lt;String&gt;&#123;</span><br><span class="line"></span><br><span class="line">	private int s;</span><br><span class="line">	Random r = new Random();</span><br><span class="line">	public TaskCallable(int s)&#123;</span><br><span class="line">		this.s = s;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public String call() throws Exception &#123;</span><br><span class="line">		String name = Thread.currentThread().getName();</span><br><span class="line">		long currentTimeMillis = System.currentTimeMillis();</span><br><span class="line">		System.out.println(name+&quot; 启动时间：&quot; + currentTimeMillis/1000);</span><br><span class="line"></span><br><span class="line">		int rint = r.nextInt(3);</span><br><span class="line">		try &#123;</span><br><span class="line">			Thread.sleep(rint*1000);</span><br><span class="line">		&#125; catch (InterruptedException e) &#123;</span><br><span class="line"></span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(name + &quot; is working...&quot;+s);</span><br><span class="line">		return s+&quot;&quot;;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Random;</span><br><span class="line"></span><br><span class="line">public class TaskRunnable implements Runnable&#123;</span><br><span class="line">	private int s;</span><br><span class="line"></span><br><span class="line">	public TaskRunnable(int s)&#123;</span><br><span class="line">		this.s = s;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	Random r = new Random();</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public void run() &#123;</span><br><span class="line">		String name = Thread.currentThread().getName();</span><br><span class="line">		long currentTimeMillis = System.currentTimeMillis();</span><br><span class="line">		System.out.println(name+&quot; 启动时间：&quot; + currentTimeMillis/1000);</span><br><span class="line"></span><br><span class="line">		int rint = r.nextInt(3);</span><br><span class="line">		try &#123;</span><br><span class="line">			Thread.sleep(rint*1000);</span><br><span class="line">		&#125; catch (InterruptedException e) &#123;</span><br><span class="line"></span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(name + &quot; is working...&quot;+s);</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.HashMap;</span><br><span class="line">import java.util.Random;</span><br><span class="line">import java.util.concurrent.ExecutorService;</span><br><span class="line">import java.util.concurrent.Executors;</span><br><span class="line">import java.util.concurrent.Future;</span><br><span class="line">import java.util.concurrent.ScheduledExecutorService;</span><br><span class="line">import java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line">public class TestPool &#123;</span><br><span class="line">	public static void main(String[] args) throws Exception &#123;</span><br><span class="line">		Future&lt;?&gt; submit = null;</span><br><span class="line">		Random random = new Random();</span><br><span class="line"></span><br><span class="line">		//创建固定数量线程池</span><br><span class="line">//		ExecutorService exec = Executors.newFixedThreadPool(4);</span><br><span class="line"></span><br><span class="line">		//创建调度线程池</span><br><span class="line">		ScheduledExecutorService exec = Executors.newScheduledThreadPool(4);</span><br><span class="line"></span><br><span class="line">		//用来记录各线程的返回结果</span><br><span class="line">		ArrayList&lt;Future&lt;?&gt;&gt; results = new ArrayList&lt;Future&lt;?&gt;&gt;();</span><br><span class="line"></span><br><span class="line">		for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">			//fixedPool提交线程，runnable无返回值，callable有返回值</span><br><span class="line">			/*submit = exec.submit(new TaskRunnable(i));*/</span><br><span class="line">			/*submit = exec.submit(new TaskCallable(i));*/</span><br><span class="line"></span><br><span class="line">			//对于schedulerPool来说，调用submit提交任务时，跟普通pool效果一致</span><br><span class="line">			/*submit = exec.submit(new TaskCallable(i));*/</span><br><span class="line">			//对于schedulerPool来说，调用schedule提交任务时，则可按延迟，按间隔时长来调度线程的运行</span><br><span class="line">			submit = exec.schedule(new TaskCallable(i), random.nextInt(10), TimeUnit.SECONDS);</span><br><span class="line">			//存储线程执行结果</span><br><span class="line">			results.add(submit);</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		//打印结果</span><br><span class="line">		for(Future f: results)&#123;</span><br><span class="line">			boolean done = f.isDone();</span><br><span class="line">			System.out.println(done?&quot;已完成&quot;:&quot;未完成&quot;);  //从结果的打印顺序可以看到，即使未完成，也会阻塞等待</span><br><span class="line">			System.out.println(&quot;线程返回future结果： &quot; + f.get());</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		exec.shutdown();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="同步容器类"><a href="#同步容器类" class="headerlink" title="同步容器类"></a>同步容器类</h4><p>同步类容器都是线程安全的,但在某些场景下可能需要加锁来保护复合操作,复合类操作如选代(反复访问元素,遍历完容器中所有的元素)、跳转(根据指定的顺序找到当前元素的下一个元素)、以及条件运算,这些复合操作在多线程并发地修改容器时,可能会表现出意外的行为,最经典的便是ConcurrengModificationException,原因是当容器迭代的过程中,被井发的修改了内容,<br>这是由于早期达代器设计的时候并没有考虑并发修改的问题。<br>同步类容器:如古老的Vector, Hash Table.这些容器的同步功能其实是在JDK的Collections.synchronized**等工厂方法去创建实现的,其底层的机制无非就是用传统的synchronized关键字对每个公用的方法都进行同步,使得每次只能有一个线程访问容器的状态,这很明显不满足我们今天互联网时代高并发的需求,在保证线程安全的同时,他必续要有足够好的性能</p>
<h4 id="并发类容器"><a href="#并发类容器" class="headerlink" title="并发类容器"></a>并发类容器</h4><p>jak5.0以后提供了多种并发类容器来替代同步类容器从而改善性能.同步类容器的状态都是串行化的,他们虽然实现了线程安全,但是严重降低了并发性,在多线程环境时,严重降低了应用程序的吞吐量。<br>并发类容器是专门针对并发设计的,使用ConcurrentHashMap来代替给子散列的传统的HashTable,而且在ConcurrentHashMap中,添加了一些常见复合操作的支持,以及使用了CopyOnWriteArrayList代替Voctor,并发的CopyonWriteArraySet,以及并发的Queue, ConcurrentLinkedQueue和LinkedBlockingQueue,前者是高性能的队列,后者是以阻塞形式的队列,具体实现Queue还有很多,例如ArrayBlockingQueue.<br>PriorityBlockingQueue. Synchronous Queue等</p>
<p>ConcurrntMap:<br>ConcurrentMap接口下有俩个重要的实现<br>ConcurrentHashap<br>ConcurentSkipListMap (支持并发排序功能,弥补ConcurrentHashMap)<br>ConcurrentHashMap内部使用段(Segmen)未表示这些不同的部分,每个段其实就是一个小的Hash Table,它们有自己的锁.只要多个修改操作发生在不同的段上,它们就可以并发进行,把一个整体分成了16个段(Segment).<br>也就是最高支持16个线程的并发修改操作,这也是在多线程场景时减小锁的粒度从面降低锁竞争的一种方案。并且代码中大多共享变量使用volatile关键字声明,目的是第一时间获取修改的内容,性能非常好.</p>
<p>Copy-On-Write容器:<br>Copy-on-Write简称cow,是种用于程序设计中的优化策略。<br>JDK里的CoW容器有两种: CopyOnWriteArrayList和CopyOnWriteArraySet,Cow容器非常有用,可以在非常多的并发场景中使用到<br>什么是CopyOnWrite容器?<br>CopyOnWrite容器即写时复制的容器,通俗的理解是当我们往一个容器添加元素的时候,不直接往当前容器添加,而是先将当前容器进行Copy,复制出一个新的容器,然后新的容器里添加元素,添加完元素之后,再将原容器的引用指向新的容器。这样放的好处是我们可以对CopyOnWrite容器进行并发的读,而不需要加锁,因为当前容器不会添加任何元素,所以CopyOnWrite容器也是一种读写分离的思想,读和写不同<br>的容器。</p>
<h4 id="并发Queue"><a href="#并发Queue" class="headerlink" title="并发Queue"></a>并发Queue</h4><p>在并发队列上JDK提供了两套实现,一个是以ConcurrentLinkedQueue为代表的高性能队列,一个是以BlockingQueue接口为代表的阻塞队列,无论哪种都维承自Queue<br><img src="queue.png" alt="queue"></p>
<p>ConcurrentLinkedQueue:<br>ConcurrentLinkedQueue:是一个适用于高并发场景下的队列,通过无锁的方式,实现了高并发状态下的高性能,通常ConcurrentLinkedQueue性能好于BlockingQueue.它是一个基于链接节点的无界线程安全队列,该队列的元素遵循先进先出的原则,头是最先加入的,尾是最近加入的,该队列不允许null元素。<br>ConcurrentLinkedQueue重要方法:<br>add()和 ofter()都是加入元素的方法(在ConcurrentLinkedaueue中,这两个方法没有任何区别)<br>pol()和peek()都是取头元素节点,区别在于前者会删除元素,后者不会.</p>
<p>ClockingQueue接口:<br>ArrayBlockingQueue:基于数组的阻塞队列实现,在ArrayBlockingQueue内部,维护了一个定长数组,以便缓存队列中的数据对象,其内部没实现读写分离,也就意味着生产和消费不能完全并行,长度是需要定义的,可以指定先进先出或者先进后出,也叫有界队列,在很多场合非常适合使用.<br>LinkedBlockingQueue:基于链表的阻塞队列,同ArrayBlockingQueue类似,其内部也维持着一个数据缓冲队列(该队列由一个链表构成) , LinkedBlockingQueue之所以能够高效的处理并发数据,是因为其内部实现采用分离锁(读写分离两个锁) ,从而实现生产者和消费者操作的完全并行运行。他是一个无界队列。<br>SynchronousQueue :一种没有缓冲的队列,生产者产生的数据直接会被消费者获取并消费。<br>PriorityBlockingQueue:基于优先级的阻塞队列(优先级的判断通过构造函数传入的Compator对象来决定,也就是说传入队列的对象必须实现Comparable接口) ,在实现PriorityBlockingQueue时,内部控制线程同步的锁采用的是公平锁,他也是一个无界的队列。<br>DelayQueue:带有延迟时间的Queue,其中的元素只有当其指定的延迟时间到了,才能够从队列中获取到该元素. Delayqueue中的元素必须实现Delayed接口, Delayqueue是一个没有大小限制的队列,应用场景很多,比如对缓存超时的数据进行移除、任务超时处理、空闲连接的关闭等等.</p>
<p>生产消费模型应用:<br>客户端服务器端数据传输，可能我们没有使用什么消息中间件，通过直连的手段，比如tcp, netty等。<br>客服端与服务器直连进行数据传输，我们发现使用netty一般都会与队列结合使用，可能有一个客户端每秒发送10条数据到服务器端，但是处理的速度与生产的步伐不一致，服务器每秒只能消费1条。<br>如果我们用netty,在业务高峰期，把这10条数据直接放到队列中，但是要有限制，使用有界队列，防止服务器内存溢出，非高峰期，用一些无界队列。或者有些在不同时间段使用不同类型队列。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line">import java.util.concurrent.SynchronousQueue;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class UseQueue &#123;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">		//高性能无阻塞无界队列：ConcurrentLinkedQueue</span><br><span class="line">		/**</span><br><span class="line">		ConcurrentLinkedQueue&lt;String&gt; q = new ConcurrentLinkedQueue&lt;String&gt;();</span><br><span class="line">		q.offer(&quot;a&quot;);</span><br><span class="line">		q.offer(&quot;b&quot;);</span><br><span class="line">		q.offer(&quot;c&quot;);</span><br><span class="line">		q.offer(&quot;d&quot;);</span><br><span class="line">		q.add(&quot;e&quot;);</span><br><span class="line"></span><br><span class="line">		System.out.println(q.poll());	//a 从头部取出元素，并从队列里删除</span><br><span class="line">		System.out.println(q.size());	//4</span><br><span class="line">		System.out.println(q.peek());	//b</span><br><span class="line">		System.out.println(q.size());	//4</span><br><span class="line">		*/</span><br><span class="line"></span><br><span class="line">		/**</span><br><span class="line">		ArrayBlockingQueue&lt;String&gt; array = new ArrayBlockingQueue&lt;String&gt;(5);</span><br><span class="line">		array.put(&quot;a&quot;);</span><br><span class="line">		array.put(&quot;b&quot;);</span><br><span class="line">		array.add(&quot;c&quot;);</span><br><span class="line">		array.add(&quot;d&quot;);</span><br><span class="line">		array.add(&quot;e&quot;);</span><br><span class="line">		array.add(&quot;f&quot;);</span><br><span class="line">		//System.out.println(array.offer(&quot;a&quot;, 3, TimeUnit.SECONDS));</span><br><span class="line">		*/</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		/**</span><br><span class="line">		//阻塞队列</span><br><span class="line">		LinkedBlockingQueue&lt;String&gt; q = new LinkedBlockingQueue&lt;String&gt;();</span><br><span class="line">		q.offer(&quot;a&quot;);</span><br><span class="line">		q.offer(&quot;b&quot;);</span><br><span class="line">		q.offer(&quot;c&quot;);</span><br><span class="line">		q.offer(&quot;d&quot;);</span><br><span class="line">		q.offer(&quot;e&quot;);</span><br><span class="line">		q.add(&quot;f&quot;);</span><br><span class="line">		//System.out.println(q.size());</span><br><span class="line"></span><br><span class="line">//		for (Iterator iterator = q.iterator(); iterator.hasNext();) &#123;</span><br><span class="line">//			String string = (String) iterator.next();</span><br><span class="line">//			System.out.println(string);</span><br><span class="line">//		&#125;</span><br><span class="line"></span><br><span class="line">		List&lt;String&gt; list = new ArrayList&lt;String&gt;();</span><br><span class="line">		System.out.println(q.drainTo(list, 3));</span><br><span class="line">		System.out.println(list.size());</span><br><span class="line">		for (String string : list) &#123;</span><br><span class="line">			System.out.println(string);</span><br><span class="line">		&#125;</span><br><span class="line">		*/</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		final SynchronousQueue&lt;String&gt; q = new SynchronousQueue&lt;String&gt;();</span><br><span class="line">		Thread t1 = new Thread(new Runnable() &#123;</span><br><span class="line">			@Override</span><br><span class="line">			public void run() &#123;</span><br><span class="line">				try &#123;</span><br><span class="line">					System.out.println(q.take());</span><br><span class="line">				&#125; catch (InterruptedException e) &#123;</span><br><span class="line">					e.printStackTrace();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line">		t1.start();</span><br><span class="line">		Thread t2 = new Thread(new Runnable() &#123;</span><br><span class="line"></span><br><span class="line">			@Override</span><br><span class="line">			public void run() &#123;</span><br><span class="line">				q.add(&quot;asdasd&quot;);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line">		t2.start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>PriorityBlockingQueue:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public class Task implements Comparable&lt;Task&gt;&#123;</span><br><span class="line"></span><br><span class="line">	private int id ;</span><br><span class="line">	private String name;</span><br><span class="line">	public int getId() &#123;</span><br><span class="line">		return id;</span><br><span class="line">	&#125;</span><br><span class="line">	public void setId(int id) &#123;</span><br><span class="line">		this.id = id;</span><br><span class="line">	&#125;</span><br><span class="line">	public String getName() &#123;</span><br><span class="line">		return name;</span><br><span class="line">	&#125;</span><br><span class="line">	public void setName(String name) &#123;</span><br><span class="line">		this.name = name;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public int compareTo(Task task) &#123;</span><br><span class="line">		return this.id &gt; task.id ? 1 : (this.id &lt; task.id ? -1 : 0);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public String toString()&#123;</span><br><span class="line">		return this.id + &quot;,&quot; + this.name;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">import java.util.concurrent.PriorityBlockingQueue;</span><br><span class="line"></span><br><span class="line">public class UsePriorityBlockingQueue &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) throws Exception&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		PriorityBlockingQueue&lt;Task&gt; q = new PriorityBlockingQueue&lt;Task&gt;();</span><br><span class="line"></span><br><span class="line">		Task t1 = new Task();</span><br><span class="line">		t1.setId(3);</span><br><span class="line">		t1.setName(&quot;id为3&quot;);</span><br><span class="line">		Task t2 = new Task();</span><br><span class="line">		t2.setId(4);</span><br><span class="line">		t2.setName(&quot;id为4&quot;);</span><br><span class="line">		Task t3 = new Task();</span><br><span class="line">		t3.setId(1);</span><br><span class="line">		t3.setName(&quot;id为1&quot;);</span><br><span class="line"></span><br><span class="line">		//return this.id &gt; task.id ? 1 : 0;</span><br><span class="line">		q.add(t1);	//3</span><br><span class="line">		q.add(t2);	//4</span><br><span class="line">		q.add(t3);  //1</span><br><span class="line"></span><br><span class="line">		// 1 3 4</span><br><span class="line">		System.out.println(&quot;容器：&quot; + q);</span><br><span class="line">		System.out.println(q.take().getId());</span><br><span class="line">		System.out.println(&quot;容器：&quot; + q);</span><br><span class="line">//		System.out.println(q.take().getId());</span><br><span class="line">//		System.out.println(q.take().getId());</span><br><span class="line"></span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>take的时候才排序，放的时候不排序<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">容器：[1,id为1, 4,id为4, 3,id为3]</span><br><span class="line">1</span><br><span class="line">容器：[3,id为3, 4,id为4]</span><br></pre></td></tr></table></figure></p>
<p>DelayQueue:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">import java.util.concurrent.Delayed;</span><br><span class="line">import java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line">public class Wangmin implements Delayed &#123;</span><br><span class="line"></span><br><span class="line">    private String name;</span><br><span class="line">    //身份证</span><br><span class="line">    private String id;</span><br><span class="line">    //截止时间</span><br><span class="line">    private long endTime;</span><br><span class="line">    //定义时间工具类</span><br><span class="line">    private TimeUnit timeUnit = TimeUnit.SECONDS;</span><br><span class="line"></span><br><span class="line">    public Wangmin(String name,String id,long endTime)&#123;</span><br><span class="line">        this.name=name;</span><br><span class="line">        this.id=id;</span><br><span class="line">        this.endTime = endTime;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getName()&#123;</span><br><span class="line">        return this.name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getId()&#123;</span><br><span class="line">        return this.id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 用来判断是否到了截止时间</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    public long getDelay(TimeUnit unit) &#123;</span><br><span class="line">        //return unit.convert(endTime, TimeUnit.MILLISECONDS) - unit.convert(System.currentTimeMillis(), TimeUnit.MILLISECONDS);</span><br><span class="line">    	return endTime - System.currentTimeMillis();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 相互批较排序用</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    public int compareTo(Delayed delayed) &#123;</span><br><span class="line">    	Wangmin w = (Wangmin)delayed;</span><br><span class="line">        return this.getDelay(this.timeUnit) - w.getDelay(this.timeUnit) &gt; 0 ? 1:0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">import java.util.concurrent.DelayQueue;</span><br><span class="line"></span><br><span class="line">public class WangBa implements Runnable &#123;</span><br><span class="line"></span><br><span class="line">    private DelayQueue&lt;Wangmin&gt; queue = new DelayQueue&lt;Wangmin&gt;();</span><br><span class="line"></span><br><span class="line">    public boolean yinye =true;</span><br><span class="line"></span><br><span class="line">    public void shangji(String name,String id,int money)&#123;</span><br><span class="line">        Wangmin man = new Wangmin(name, id, 1000 * money + System.currentTimeMillis());</span><br><span class="line">        System.out.println(&quot;网名&quot;+man.getName()+&quot; 身份证&quot;+man.getId()+&quot;交钱&quot;+money+&quot;块,开始上机...&quot;);</span><br><span class="line">        this.queue.add(man);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void xiaji(Wangmin man)&#123;</span><br><span class="line">        System.out.println(&quot;网名&quot;+man.getName()+&quot; 身份证&quot;+man.getId()+&quot;时间到下机...&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        while(yinye)&#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                Wangmin man = queue.take();</span><br><span class="line">                xiaji(man);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String args[])&#123;</span><br><span class="line">        try&#123;</span><br><span class="line">            System.out.println(&quot;网吧开始营业&quot;);</span><br><span class="line">            WangBa siyu = new WangBa();</span><br><span class="line">            Thread shangwang = new Thread(siyu);</span><br><span class="line">            shangwang.start();</span><br><span class="line"></span><br><span class="line">            siyu.shangji(&quot;路人甲&quot;, &quot;123&quot;, 1);</span><br><span class="line">            siyu.shangji(&quot;路人乙&quot;, &quot;234&quot;, 10);</span><br><span class="line">            siyu.shangji(&quot;路人丙&quot;, &quot;345&quot;, 5);</span><br><span class="line">        &#125;</span><br><span class="line">        catch(Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">网吧开始营业</span><br><span class="line">网名路人甲 身份证123交钱1块,开始上机...</span><br><span class="line">网名路人乙 身份证234交钱10块,开始上机...</span><br><span class="line">网名路人丙 身份证345交钱5块,开始上机...</span><br><span class="line">网名路人甲 身份证123时间到下机...</span><br><span class="line">网名路人丙 身份证345时间到下机...</span><br><span class="line">网名路人乙 身份证234时间到下机...</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">BlockingQueue也是java.util.concurrent下的主要用来控制线程同步的工具。</span><br><span class="line">主要的方法是：put、take一对阻塞存取；add、poll一对非阻塞存取。</span><br><span class="line">	插入:</span><br><span class="line">		1)add(anObject):把anObject加到BlockingQueue里,即如果BlockingQueue可以容纳,则返回true,否则抛出</span><br><span class="line">        2)offer(anObject):表示如果可能的话,将anObject加到BlockingQueue里,即如果BlockingQueue可以容纳,则返回true,否则返回false.</span><br><span class="line">        3)put(anObject):把anObject加到BlockingQueue里,如果BlockQueue没有空间,则调用此方法的线程被阻断直到BlockingQueue里面有空间再继续.</span><br><span class="line">	读取：</span><br><span class="line">        4)poll(time):取走BlockingQueue里排在首位的对象,若不能立即取出,则可以等time参数规定的时间,取不到时返回null</span><br><span class="line">        5)take():取走BlockingQueue里排在首位的对象,若BlockingQueue为空,阻断进入等待状态直到Blocking有新的对象被加入为止</span><br><span class="line">	其他</span><br><span class="line">int remainingCapacity();返回队列剩余的容量，在队列插入和获取的时候，不要瞎搞，数	据可能不准</span><br><span class="line">boolean remove(Object o); 从队列移除元素，如果存在，即移除一个或者更多，队列改	变了返回true</span><br><span class="line">public boolean contains(Object o); 查看队列是否存在这个元素，存在返回true</span><br><span class="line">int drainTo(Collection&lt;? super E&gt; c); 移除此队列中所有可用的元素，并将它们添加到给定collection中</span><br><span class="line">int drainTo(Collection&lt;? super E&gt; c, int maxElements); 和上面方法的区别在于，制定了移动的数量</span><br><span class="line"></span><br><span class="line">BlockingQueue有四个具体的实现类,常用的两种实现类为：</span><br><span class="line"></span><br><span class="line">1、ArrayBlockingQueue：一个由数组支持的有界阻塞队列，规定大小的BlockingQueue,其构造函数必须带一个int参数来指明其大小.其所含的对象是以FIFO(先入先出)顺序排序的。</span><br><span class="line"></span><br><span class="line">2、LinkedBlockingQueue：大小不定的BlockingQueue,若其构造函数带一个规定大小的参数,生成的BlockingQueue有大小限制,若不带大小参数,所生成的BlockingQueue的大小由Integer.MAX_VALUE来决定.其所含的对象是以FIFO(先入先出)顺序排序的。</span><br><span class="line">	LinkedBlockingQueue 可以指定容量，也可以不指定，不指定的话，默认最大是Integer.MAX_VALUE,其中主要用到put和take方法，put方法在队列满的时候会阻塞直到有队列成员被消费，take方法在队列空的时候会阻塞，直到有队列成员被放进来。</span><br><span class="line"></span><br><span class="line">LinkedBlockingQueue和ArrayBlockingQueue区别：</span><br><span class="line"></span><br><span class="line">LinkedBlockingQueue和ArrayBlockingQueue比较起来,它们背后所用的数据结构不一样,导致LinkedBlockingQueue的数据吞吐量要大于ArrayBlockingQueue,但在线程数量很大时其性能的可预见性低于ArrayBlockingQueue.</span><br></pre></td></tr></table></figure>
<h3 id="java并发编程的一些总结"><a href="#java并发编程的一些总结" class="headerlink" title="java并发编程的一些总结"></a>java并发编程的一些总结</h3><p>1.不应用线程池的缺点<br>有些开发者图省事，遇到需要多线程处理的地方，直接new Thread(…).start()，对于一般场景是没问题的，但如果是在并发请求很高的情况下，就会有些隐患：<br>新建线程的开销。线程虽然比进程要轻量许多，但对于JVM来说，新建一个线程的代价还是挺大的，决不同于新建一个对象<br>资源消耗量。没有一个池来限制线程的数量，会导致线程的数量直接取决于应用的并发量，这样有潜在的线程数据巨大的可能，那么资源消耗量将是巨大的<br>稳定性。当线程数量超过系统资源所能承受的程度，稳定性就会成问题<br>2.制定执行策略<br>在每个需要多线程处理的地方，不管并发量有多大，需要考虑线程的执行策略<br>任务以什么顺序执行<br>可以有多少个任何并发执行<br>可以有多少个任务进入等待执行队列<br>系统过载的时候，应该放弃哪些任务？如何通知到应用程序？<br>一个任务的执行前后应该做什么处理<br>3.线程池的类型<br>不管是通过Executors创建线程池，还是通过Spring来管理，都得清楚知道有哪几种线程池：<br>FixedThreadPool：定长线程池，提交任务时创建线程，直到池的最大容量，如果有线程非预期结束，会补充新线程<br>CachedThreadPool：可变线程池，它犹如一个弹簧，如果没有任务需求时，它回收空闲线程，如果需求增加，则按需增加线程，不对池的大小做限制<br>SingleThreadExecutor：单线程。处理不过来的任务会进入FIFO队列等待执行<br>SecheduledThreadPool：周期性线程池。支持执行周期性线程任务<br>其实，这些不同类型的线程池都是通过构建一个ThreadPoolExecutor来完成的，所不同的是corePoolSize,maximumPoolSize,keepAliveTime,unit,workQueue,threadFactory这么几个参数。具体可以参见JDK DOC。<br>4.线程池饱和策略<br>由以上线程池类型可知，除了CachedThreadPool其他线程池都有饱和的可能，当饱和以后就需要相应的策略处理请求线程的任务，ThreadPoolExecutor采取的方式通过队列来存储这些任务，当然会根据池类型不同选择不同的队列，比如FixedThreadPool和SingleThreadExecutor默认采用的是无限长度的LinkedBlockingQueue。但从系统可控性讲，最好的做法是使用定长的ArrayBlockingQueue或有限的LinkedBlockingQueue，并且当达到上限时通过ThreadPoolExecutor.setRejectedExecutionHandler方法设置一个拒绝任务的策略，JDK提供了AbortPolicy、CallerRunsPolicy、DiscardPolicy、DiscardOldestPolicy几种策略，具体差异可见JDK DOC<br>5.线程无依赖性<br>多线程任务设计上尽量使得各任务是独立无依赖的，所谓依赖性可两个方面：<br>线程之间的依赖性。如果线程有依赖可能会造成死锁或饥饿<br>调用者与线程的依赖性。调用者得监视线程的完成情况，影响可并发量<br>当然，在有些业务里确实需要一定的依赖性，比如调用者需要得到线程完成后结果，传统的Thread是不便完成的，因为run方法无返回值，只能通过一些共享的变量来传递结果，但在Executor框架里可以通过Future和Callable实现需要有返回值的任务，当然线程的异步性导致需要有相应机制来保证调用者能等待任务完成。</p>
<h3 id="多线程的设计模式"><a href="#多线程的设计模式" class="headerlink" title="多线程的设计模式"></a>多线程的设计模式</h3><p>并行设计模式属于设计优化的一部分,它是对一些常用的多线程结构的总结和抽象与串行程序相比,并行程序的结构通常更为复杂。因此合理的使用并行模式在多线程开发中更具有意义,在这里主要介绍Future, Master-Worker和生产者-消费者模型。</p>
<h4 id="Future模式"><a href="#Future模式" class="headerlink" title="Future模式"></a>Future模式</h4><p>Future模式有点类似于商品订单。比如在网购时,当看重某一件商品事,就可以提交订 ,当订单处理完成后,在家里等待商品送货上门即可。或者说更形象的我们发送Ajax请求的时候,页面是异步的进行后台处理,用户无须一直等待请求的结果,可以继续浏览或操作其他内容。<br><img src="Future模式.png" alt="Future模式"></p>
<p>Data:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface Data &#123;</span><br><span class="line">	String getRequest();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>RealData:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class RealData implements Data&#123;</span><br><span class="line"></span><br><span class="line">	private String result ;</span><br><span class="line"></span><br><span class="line">	public RealData (String queryStr)&#123;</span><br><span class="line">		System.out.println(&quot;根据&quot; + queryStr + &quot;进行查询，这是一个很耗时的操作..&quot;);</span><br><span class="line">		try &#123;</span><br><span class="line">			Thread.sleep(5000);</span><br><span class="line">		&#125; catch (InterruptedException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(&quot;操作完毕，获取结果&quot;);</span><br><span class="line">		result = &quot;查询结果&quot;;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public String getRequest() &#123;</span><br><span class="line">		return result;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>FutureData:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">public class FutureData implements Data&#123;</span><br><span class="line"></span><br><span class="line">	private RealData realData ;</span><br><span class="line">	private boolean isReady = false;</span><br><span class="line"></span><br><span class="line">	public synchronized void setRealData(RealData realData) &#123;</span><br><span class="line">		//如果已经装载完毕了，就直接返回</span><br><span class="line">		if(isReady)&#123;</span><br><span class="line">			return;</span><br><span class="line">		&#125;</span><br><span class="line">		//如果没装载，进行装载真实对象</span><br><span class="line">		this.realData = realData;</span><br><span class="line">		isReady = true;</span><br><span class="line">		//进行通知</span><br><span class="line">		notify();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public synchronized String getRequest() &#123;</span><br><span class="line">		//如果没装载好 程序就一直处于阻塞状态</span><br><span class="line">		while(!isReady)&#123;</span><br><span class="line">			try &#123;</span><br><span class="line">				wait();</span><br><span class="line">			&#125; catch (InterruptedException e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		//装载好直接获取数据即可</span><br><span class="line">		return this.realData.getRequest();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>FutureClient:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class FutureClient &#123;</span><br><span class="line"></span><br><span class="line">	public Data request(final String queryStr)&#123;</span><br><span class="line">		//1 我想要一个代理对象（Data接口的实现类）先返回给发送请求的客户端，告诉他请求已经接收到，可以做其他的事情</span><br><span class="line">		final FutureData futureData = new FutureData();</span><br><span class="line">		//2 启动一个新的线程，去加载真实的数据，传递给这个代理对象</span><br><span class="line">		new Thread(new Runnable() &#123;</span><br><span class="line">			@Override</span><br><span class="line">			public void run() &#123;</span><br><span class="line">				//3 这个新的线程可以去慢慢的加载真实对象，然后传递给代理对象</span><br><span class="line">				RealData realData = new RealData(queryStr);</span><br><span class="line">				futureData.setRealData(realData);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;).start();</span><br><span class="line"></span><br><span class="line">		return futureData;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Main:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class Main &#123;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">		FutureClient fc = new FutureClient();</span><br><span class="line">		Data data = fc.request(&quot;请求参数&quot;);</span><br><span class="line">		System.out.println(&quot;请求发送成功!&quot;);</span><br><span class="line">		System.out.println(&quot;做其他的事情...&quot;);</span><br><span class="line"></span><br><span class="line">		String result = data.getRequest();</span><br><span class="line">		System.out.println(result);</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="Master-Worker模式"><a href="#Master-Worker模式" class="headerlink" title="Master-Worker模式"></a>Master-Worker模式</h4><p>Master-Worker模式是常用的并行计算模式。<br>它的核心思想是系统由两类进程协作工作: Master进程和Worker进程。Master负责接收和分配任务,Worker负责处理子任务。当各个Worker子进程处理完成后,会将结果返回给Master, 由Master做归纳和总结。<br>其好处是能将一个大任务分解成若干个小任务,并行执行,从而提高系统的吞吐量。<br><img src="master-worker.png" alt="master-worker"><br><img src="master-worker2.png" alt="master-worker2"><br>Task:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class Task &#123;</span><br><span class="line"></span><br><span class="line">	private int id;</span><br><span class="line">	private int price ;</span><br><span class="line">	public int getId() &#123;</span><br><span class="line">		return id;</span><br><span class="line">	&#125;</span><br><span class="line">	public void setId(int id) &#123;</span><br><span class="line">		this.id = id;</span><br><span class="line">	&#125;</span><br><span class="line">	public int getPrice() &#123;</span><br><span class="line">		return price;</span><br><span class="line">	&#125;</span><br><span class="line">	public void setPrice(int price) &#123;</span><br><span class="line">		this.price = price;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Master:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">import java.util.HashMap;</span><br><span class="line">import java.util.Map;</span><br><span class="line">import java.util.concurrent.ConcurrentHashMap;</span><br><span class="line">import java.util.concurrent.ConcurrentLinkedQueue;</span><br><span class="line"></span><br><span class="line">public class Master &#123;</span><br><span class="line"></span><br><span class="line">	//1 有一个盛放任务的容器</span><br><span class="line">	private ConcurrentLinkedQueue&lt;Task&gt; workQueue = new ConcurrentLinkedQueue&lt;Task&gt;();</span><br><span class="line"></span><br><span class="line">	//2 需要有一个盛放worker的集合</span><br><span class="line">	private HashMap&lt;String, Thread&gt; workers = new HashMap&lt;String, Thread&gt;();</span><br><span class="line"></span><br><span class="line">	//3 需要有一个盛放每一个worker执行任务的结果集合</span><br><span class="line">	private ConcurrentHashMap&lt;String, Object&gt; resultMap = new ConcurrentHashMap&lt;String, Object&gt;();</span><br><span class="line"></span><br><span class="line">	//4 构造方法</span><br><span class="line">	public Master(Worker worker , int workerCount)&#123;</span><br><span class="line">		worker.setWorkQueue(this.workQueue);</span><br><span class="line">		worker.setResultMap(this.resultMap);</span><br><span class="line"></span><br><span class="line">		for(int i = 0; i &lt; workerCount; i ++)&#123;</span><br><span class="line">			this.workers.put(Integer.toString(i), new Thread(worker));</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	//5 需要一个提交任务的方法</span><br><span class="line">	public void submit(Task task)&#123;</span><br><span class="line">		this.workQueue.add(task);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	//6 需要有一个执行的方法，启动所有的worker方法去执行任务</span><br><span class="line">	public void execute()&#123;</span><br><span class="line">		for(Map.Entry&lt;String, Thread&gt; me : workers.entrySet())&#123;</span><br><span class="line">			me.getValue().start();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	//7 判断是否运行结束的方法</span><br><span class="line">	public boolean isComplete() &#123;</span><br><span class="line">		for(Map.Entry&lt;String, Thread&gt; me : workers.entrySet())&#123;</span><br><span class="line">			if(me.getValue().getState() != Thread.State.TERMINATED)&#123;</span><br><span class="line">				return false;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		return true;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	//8 计算结果方法</span><br><span class="line">	public int getResult() &#123;</span><br><span class="line">		int priceResult = 0;</span><br><span class="line">		for(Map.Entry&lt;String, Object&gt; me : resultMap.entrySet())&#123;</span><br><span class="line">			priceResult += (Integer)me.getValue();</span><br><span class="line">		&#125;</span><br><span class="line">		return priceResult;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Worker:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">import java.util.concurrent.ConcurrentHashMap;</span><br><span class="line">import java.util.concurrent.ConcurrentLinkedQueue;</span><br><span class="line"></span><br><span class="line">public class Worker implements Runnable &#123;</span><br><span class="line"></span><br><span class="line">	private ConcurrentLinkedQueue&lt;Task&gt; workQueue;</span><br><span class="line">	private ConcurrentHashMap&lt;String, Object&gt; resultMap;</span><br><span class="line"></span><br><span class="line">	public void setWorkQueue(ConcurrentLinkedQueue&lt;Task&gt; workQueue) &#123;</span><br><span class="line">		this.workQueue = workQueue;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public void setResultMap(ConcurrentHashMap&lt;String, Object&gt; resultMap) &#123;</span><br><span class="line">		this.resultMap = resultMap;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public void run() &#123;</span><br><span class="line">		while(true)&#123;</span><br><span class="line">			Task input = this.workQueue.poll();</span><br><span class="line">			if(input == null) break;</span><br><span class="line">			Object output = handle(input);</span><br><span class="line">			this.resultMap.put(Integer.toString(input.getId()), output);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	private Object handle(Task input) &#123;</span><br><span class="line">		Object output = null;</span><br><span class="line">		try &#123;</span><br><span class="line">			//处理任务的耗时。。 比如说进行操作数据库。。。</span><br><span class="line">			Thread.sleep(500);</span><br><span class="line">			output = input.getPrice();</span><br><span class="line">		&#125; catch (InterruptedException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">		return output;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Main:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Random;</span><br><span class="line"></span><br><span class="line">public class Main &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">		Master master = new Master(new Worker(), 20);</span><br><span class="line"></span><br><span class="line">		Random r = new Random();</span><br><span class="line">		for(int i = 1; i &lt;= 100; i++)&#123;</span><br><span class="line">			Task t = new Task();</span><br><span class="line">			t.setId(i);</span><br><span class="line">			t.setPrice(r.nextInt(1000));</span><br><span class="line">			master.submit(t);</span><br><span class="line">		&#125;</span><br><span class="line">		master.execute();</span><br><span class="line">		long start = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">		while(true)&#123;</span><br><span class="line">			if(master.isComplete())&#123;</span><br><span class="line">				long end = System.currentTimeMillis() - start;</span><br><span class="line">				int priceResult = master.getResult();</span><br><span class="line">				System.out.println(&quot;最终结果：&quot; + priceResult + &quot;, 执行时间：&quot; + end);</span><br><span class="line">				break;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="生产者-消费者"><a href="#生产者-消费者" class="headerlink" title="生产者-消费者"></a>生产者-消费者</h4><p>生产者和消费者也是一个非常经典的多线程模式,我们在实际开发中应用非常广泛的思想理念。在生产-消费模式中:通常由两类线程,即若干个生产者的线程和若干个消费者的线程。生产者线程负责提交用户请求,消费者线程则负责具体处理生产者提交的任务,在生产者和消费者之间通过共享内存缓存区进行通信。<br>Data:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">public final class Data &#123;</span><br><span class="line"></span><br><span class="line">	private String id;</span><br><span class="line">	private String name;</span><br><span class="line"></span><br><span class="line">	public Data(String id, String name)&#123;</span><br><span class="line">		this.id = id;</span><br><span class="line">		this.name = name;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public String getId() &#123;</span><br><span class="line">		return id;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public void setId(String id) &#123;</span><br><span class="line">		this.id = id;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public String getName() &#123;</span><br><span class="line">		return name;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public void setName(String name) &#123;</span><br><span class="line">		this.name = name;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public String toString()&#123;</span><br><span class="line">		return &quot;&#123;id: &quot; + id + &quot;, name: &quot; + name + &quot;&#125;&quot;;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Provider:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Random;</span><br><span class="line">import java.util.concurrent.BlockingQueue;</span><br><span class="line">import java.util.concurrent.TimeUnit;</span><br><span class="line">import java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"></span><br><span class="line">public class Provider implements Runnable&#123;</span><br><span class="line"></span><br><span class="line">	//共享缓存区</span><br><span class="line">	private BlockingQueue&lt;Data&gt; queue;</span><br><span class="line">	//多线程间是否启动变量，有强制从主内存中刷新的功能。即时返回线程的状态</span><br><span class="line">	private volatile boolean isRunning = true;</span><br><span class="line">	//id生成器</span><br><span class="line">	private static AtomicInteger count = new AtomicInteger();</span><br><span class="line">	//随机对象</span><br><span class="line">	private static Random r = new Random();</span><br><span class="line"></span><br><span class="line">	public Provider(BlockingQueue queue)&#123;</span><br><span class="line">		this.queue = queue;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public void run() &#123;</span><br><span class="line">		while(isRunning)&#123;</span><br><span class="line">			try &#123;</span><br><span class="line">				//随机休眠0 - 1000 毫秒 表示获取数据(产生数据的耗时)</span><br><span class="line">				Thread.sleep(r.nextInt(1000));</span><br><span class="line">				//获取的数据进行累计...</span><br><span class="line">				int id = count.incrementAndGet();</span><br><span class="line">				//比如通过一个getData方法获取了</span><br><span class="line">				Data data = new Data(Integer.toString(id), &quot;数据&quot; + id);</span><br><span class="line">				System.out.println(&quot;当前线程:&quot; + Thread.currentThread().getName() + &quot;, 获取了数据，id为:&quot; + id + &quot;, 进行装载到公共缓冲区中...&quot;);</span><br><span class="line">				if(!this.queue.offer(data, 2, TimeUnit.SECONDS))&#123;</span><br><span class="line">					System.out.println(&quot;提交缓冲区数据失败....&quot;);</span><br><span class="line">					//do something... 比如重新提交</span><br><span class="line">				&#125;</span><br><span class="line">			&#125; catch (InterruptedException e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public void stop()&#123;</span><br><span class="line">		this.isRunning = false;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Consumer:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public class Consumer implements Runnable&#123;</span><br><span class="line"></span><br><span class="line">	private BlockingQueue&lt;Data&gt; queue;</span><br><span class="line"></span><br><span class="line">	public Consumer(BlockingQueue queue)&#123;</span><br><span class="line">		this.queue = queue;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	//随机对象</span><br><span class="line">	private static Random r = new Random();</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public void run() &#123;</span><br><span class="line">		while(true)&#123;</span><br><span class="line">			try &#123;</span><br><span class="line">				//获取数据</span><br><span class="line">				Data data = this.queue.take();</span><br><span class="line">				//进行数据处理。休眠0 - 1000毫秒模拟耗时</span><br><span class="line">				Thread.sleep(r.nextInt(1000));</span><br><span class="line">				System.out.println(&quot;当前消费线程：&quot; + Thread.currentThread().getName() + &quot;， 消费成功，消费数据为id: &quot; + data.getId());</span><br><span class="line">			&#125; catch (InterruptedException e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Main:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">import java.util.concurrent.BlockingQueue;</span><br><span class="line">import java.util.concurrent.ExecutorService;</span><br><span class="line">import java.util.concurrent.Executors;</span><br><span class="line">import java.util.concurrent.LinkedBlockingQueue;</span><br><span class="line"></span><br><span class="line">public class Main &#123;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) throws Exception &#123;</span><br><span class="line">		//内存缓冲区</span><br><span class="line">		BlockingQueue&lt;Data&gt; queue = new LinkedBlockingQueue&lt;Data&gt;(10);</span><br><span class="line">		//生产者</span><br><span class="line">		Provider p1 = new Provider(queue);</span><br><span class="line"></span><br><span class="line">		Provider p2 = new Provider(queue);</span><br><span class="line">		Provider p3 = new Provider(queue);</span><br><span class="line">		//消费者</span><br><span class="line">		Consumer c1 = new Consumer(queue);</span><br><span class="line">		Consumer c2 = new Consumer(queue);</span><br><span class="line">		Consumer c3 = new Consumer(queue);</span><br><span class="line">		//创建线程池运行,这是一个缓存的线程池，可以创建无穷大的线程，没有任务的时候不创建线程。空闲线程存活时间为60s（默认值）</span><br><span class="line"></span><br><span class="line">		ExecutorService cachePool = Executors.newCachedThreadPool();</span><br><span class="line">		cachePool.execute(p1);</span><br><span class="line">		cachePool.execute(p2);</span><br><span class="line">		cachePool.execute(p3);</span><br><span class="line">		cachePool.execute(c1);</span><br><span class="line">		cachePool.execute(c2);</span><br><span class="line">		cachePool.execute(c3);</span><br><span class="line"></span><br><span class="line">		try &#123;</span><br><span class="line">			Thread.sleep(3000);</span><br><span class="line">		&#125; catch (InterruptedException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">		p1.stop();</span><br><span class="line">		p2.stop();</span><br><span class="line">		p3.stop();</span><br><span class="line">		try &#123;</span><br><span class="line">			Thread.sleep(2000);</span><br><span class="line">		&#125; catch (InterruptedException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">//		cachePool.shutdown();</span><br><span class="line">//		cachePool.shutdownNow();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="Executor框架"><a href="#Executor框架" class="headerlink" title="Executor框架"></a>Executor框架</h4><p>为了更好的控制多线程, JDK提供了一套线程框架Executor,帮助开发人员有效地进行线程控制。它们都在java.util.concurrent包中,是JDK并发包的核心。其中有一个比较重要的类: Executors,他扮演这线程工厂的角色,我们通过Executors可以创建特定功能的线程池。<br>Executors创建线程池方法:<br>newFixedThreadPool)方法,该方法返回一个固定数量的线程池,该方法的线程数始终不变,当有一个任务提交时,若线程池中空闲,则立即执行,若没有,则会被暂缓在一个任务队列中等待有空闲的线程去执行。<br>newSingleThreadExecutor()方法,创建一个线程的线程池,若空闲则执行,若没有空闲线程则暂缓在任务列队中。<br>newCachedThreadPool)方法,返回一个可根据实际情况调整线程个数的线程池,不限制最大线程数量,若有任务,则创建线程,若无任务则不创建线程。如果没有任务则线程在60s后自动回收(空闲时间60s) .<br>newScheduled ThreadPool)方法,该方法返回一个SchededExecutorService对象,但该线程池可以指定线程的数量</p>
<h4 id="自定义线程池"><a href="#自定义线程池" class="headerlink" title="自定义线程池"></a>自定义线程池</h4><p>若Executors工厂类无法满足我们的需求,可以自己去创建自定义的线程池,其实Executors工广类里面的创建线程方法其内部实现均是用了ThreadPoolExecutor这个类,这个类可以自定义线程。构造方法如下:<br>public ThreadPoolExecutor(int corePoolSize,<br>                  int maximumPoolSize，<br>                  long keepAliveTime,<br>                  TimeUnit unit,<br>                  BlockingQueue<runnable> workQueue,<br>                  ThreadFactory ThreadFactory,<br>                  RejectedExecutionHandler handler) {…}</runnable></p>
<p>比如：maximumPoolSize=2，maximumPoolSize=10，ArrayBlockingqueue=10<br>当一次性来了30个任务，放到这个线程池里，肯定会有一堆任务被拒绝，首先，corePoolSize有2个，还有28个任务待处理，我们可以根据上限maximumPoolSize再去提高8个线程去处理，还剩20个，再往队列里扔10个，最后还剩10个，这10个就会去走RejectedExecutionHandler<br>任务过多的时候会导致内存溢出，队列会逐渐变大。</p>
<h4 id="自定义线程池使用详细"><a href="#自定义线程池使用详细" class="headerlink" title="自定义线程池使用详细"></a>自定义线程池使用详细</h4><p>这个构造方法对于队列是什么类型的比较关键:<br>在使用有界队列时: 若有新的任务需要执行,如果线程池实际线程数小于corePoolSize,则优先创建线程,若大于corePoolsize,则会将任务加入队列，若队列已满，<br>则在总线程数不大于maximumPoolSize的前提下创建新的线程，若线程数大于maximumPoolsize,则执行拒绝策略。或其他自定义方式。<br>无界的任务队列时: LinkedBlockingQueue,与有界队列相比,除非系统资源耗尽,否则无界的任务队列<br>不存在任务入队失败的情况。当有新在务到来,系统的线程数小于corePoolsize时,则新建线程执行任务,当达到orePoolSize后,就不会继续增加。若后续仍有新的在务加入,而有没有<br>闲的线程资源，则任务直接进入队列等待。若任务创建和处理的速度差异很大,无界队列会保持快速增长,直到耗尽系统内存。<br>JDK拒绝策略:<br>AbortPolicy:直接抛出异常组织系统正常工作<br>CallerRunsPolicy:只要线程池未关闭,该策略直接在调用者线程中,运行当前被丢弃的任务。<br>DiscardoldestPolicy:丢弃最老的一个请求,尝试再次提交当前任务。<br>DiscardPolicy:丢弃无法处理的任务,不给予任何处理。<br>如果需要自定义拒绝策略可以实现RejectedExecutionHandler接口。</p>

            

        </div>
    </div>
    <div id="post-footer" class="post-footer main-content-wrap">
        
            <div class="post-footer-tags">
                <span class="text-color-light text-small">标签</span><br>
                
    <a class="tag tag--primary tag--small t-link" href="/tags/java基础/">java基础</a>

            </div>
        
        
            <div class="post-actions-wrap">
    <nav>
        <ul class="post-actions post-action-nav">
            <li class="post-action">
                
                    
                    <a class="post-action-btn btn btn--default tooltip--top" href="/2019/09/07/集合/" data-tooltip="集合" aria-label="上一篇: 集合">
                
                    <i class="fa fa-angle-left" aria-hidden="true"></i>
                    <span class="hide-xs hide-sm text-small icon-ml">上一篇</span>
                </a>
            </li>
            <li class="post-action">
                
                    
                    <a class="post-action-btn btn btn--default tooltip--top" href="/2019/09/07/多线程2/" data-tooltip="多线程2" aria-label="下一篇: 多线程2">
                
                    <span class="hide-xs hide-sm text-small icon-mr">下一篇</span>
                    <i class="fa fa-angle-right" aria-hidden="true"></i>
                </a>
            </li>
        </ul>
    </nav>
    <ul class="post-actions post-action-share">
        <li class="post-action hide-lg hide-md hide-sm">
            <a class="post-action-btn btn btn--default btn-open-shareoptions" href="#btn-open-shareoptions" aria-label="Diesen Beitrag teilen">
                <i class="fa fa-share-alt" aria-hidden="true"></i>
            </a>
        </li>
        
            
            
            <li class="post-action hide-xs">
                <a class="post-action-btn btn btn--default" target="new" href="https://www.facebook.com/sharer/sharer.php?u=http://yoursite.com/2019/09/07/多线程3/" title="分享到 Facebook">
                    <i class="fab fa-facebook" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a class="post-action-btn btn btn--default" target="new" href="https://twitter.com/intent/tweet?text=http://yoursite.com/2019/09/07/多线程3/" title="分享到 Twitter">
                    <i class="fab fa-twitter" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a class="post-action-btn btn btn--default" target="new" href="https://plus.google.com/share?url=http://yoursite.com/2019/09/07/多线程3/" title="分享到 Google+">
                    <i class="fab fa-google-plus" aria-hidden="true"></i>
                </a>
            </li>
        
        
            
        
        <li class="post-action">
            
                <a class="post-action-btn btn btn--default" href="#" aria-label="Nach oben">
            
                <i class="fa fa-list" aria-hidden="true"></i>
            </a>
        </li>
    </ul>
</div>


        
        
            
        
    </div>
</article>



                <footer id="footer" class="main-content-wrap">
    <span class="copyrights">
        Copyrights &copy; 2020 Brotherc. All Rights Reserved.
    </span>
</footer>

            </div>
            
                <div id="bottom-bar" class="post-bottom-bar" data-behavior="4">
                    <div class="post-actions-wrap">
    <nav>
        <ul class="post-actions post-action-nav">
            <li class="post-action">
                
                    
                    <a class="post-action-btn btn btn--default tooltip--top" href="/2019/09/07/集合/" data-tooltip="集合" aria-label="上一篇: 集合">
                
                    <i class="fa fa-angle-left" aria-hidden="true"></i>
                    <span class="hide-xs hide-sm text-small icon-ml">上一篇</span>
                </a>
            </li>
            <li class="post-action">
                
                    
                    <a class="post-action-btn btn btn--default tooltip--top" href="/2019/09/07/多线程2/" data-tooltip="多线程2" aria-label="下一篇: 多线程2">
                
                    <span class="hide-xs hide-sm text-small icon-mr">下一篇</span>
                    <i class="fa fa-angle-right" aria-hidden="true"></i>
                </a>
            </li>
        </ul>
    </nav>
    <ul class="post-actions post-action-share">
        <li class="post-action hide-lg hide-md hide-sm">
            <a class="post-action-btn btn btn--default btn-open-shareoptions" href="#btn-open-shareoptions" aria-label="Diesen Beitrag teilen">
                <i class="fa fa-share-alt" aria-hidden="true"></i>
            </a>
        </li>
        
            
            
            <li class="post-action hide-xs">
                <a class="post-action-btn btn btn--default" target="new" href="https://www.facebook.com/sharer/sharer.php?u=http://yoursite.com/2019/09/07/多线程3/" title="分享到 Facebook">
                    <i class="fab fa-facebook" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a class="post-action-btn btn btn--default" target="new" href="https://twitter.com/intent/tweet?text=http://yoursite.com/2019/09/07/多线程3/" title="分享到 Twitter">
                    <i class="fab fa-twitter" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a class="post-action-btn btn btn--default" target="new" href="https://plus.google.com/share?url=http://yoursite.com/2019/09/07/多线程3/" title="分享到 Google+">
                    <i class="fab fa-google-plus" aria-hidden="true"></i>
                </a>
            </li>
        
        
            
        
        <li class="post-action">
            
                <a class="post-action-btn btn btn--default" href="#" aria-label="Nach oben">
            
                <i class="fa fa-list" aria-hidden="true"></i>
            </a>
        </li>
    </ul>
</div>


                </div>
                
    <div id="share-options-bar" class="share-options-bar" data-behavior="4">
        <i id="btn-close-shareoptions" class="fa fa-times"></i>
        <ul class="share-options">
            
                
                
                <li class="share-option">
                    <a class="share-option-btn" target="new" href="https://www.facebook.com/sharer/sharer.php?u=http://yoursite.com/2019/09/07/多线程3/">
                        <i class="fab fa-facebook" aria-hidden="true"></i><span>分享到 Facebook</span>
                    </a>
                </li>
            
                
                
                <li class="share-option">
                    <a class="share-option-btn" target="new" href="https://twitter.com/intent/tweet?text=http://yoursite.com/2019/09/07/多线程3/">
                        <i class="fab fa-twitter" aria-hidden="true"></i><span>分享到 Twitter</span>
                    </a>
                </li>
            
                
                
                <li class="share-option">
                    <a class="share-option-btn" target="new" href="https://plus.google.com/share?url=http://yoursite.com/2019/09/07/多线程3/">
                        <i class="fab fa-google-plus" aria-hidden="true"></i><span>分享到 Google+</span>
                    </a>
                </li>
            
        </ul>
    </div>


            
        </div>
        


    
        
    

<div id="about">
    <div id="about-card">
        <div id="about-btn-close">
            <i class="fa fa-times"></i>
        </div>
        
            <img id="about-card-picture" src="/assets/images/head.jpg" alt="作者的图片">
        
            <h4 id="about-card-name">Brotherc</h4>
        
            <div id="about-card-bio"><p>java development</p>
</div>
        
        
            <div id="about-card-job">
                <i class="fa fa-briefcase"></i>
                <br>
                <p>java</p>

            </div>
        
        
            <div id="about-card-location">
                <i class="fa fa-map-marker-alt"></i>
                <br>
                zhuhai
            </div>
        
    </div>
</div>

        
        
<div id="cover" style="background-image:url('/assets/images/cover.jpg');"></div>
        <!--SCRIPTS-->
<script src="/assets/js/script-dbd16rvloemmuxdzniplmnxxvwoz24eya9wol0b7vvmlokgqsjivmb8dnscy.min.js"></script>
<!--SCRIPTS END-->

    



    </body>
</html>
