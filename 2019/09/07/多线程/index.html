
<!DOCTYPE html>
<html lang="zh-cn">
    
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="generator" content="Brotherc">
    <title>多线程1 - Brotherc</title>
    <meta name="author" content="Brotherc">
    
    
    
    <script type="application/ld+json">{"@context":"http://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"Brotherc","sameAs":["https://github.com/Brotherc"],"image":"head.jpg"},"articleBody":"java多线程基本知识进程介绍123不管是我们开发的应用程序，还是我们运行的其他的应用程序，都需要先把程序安装在本地的硬盘上。然后找到这个程序的启动文件，启动程序的时候，其实是电脑把当前的这个程序加载到内存中，在内存中需要给当前的程序分配一段独立的运行空间。这片空间就专门负责当前这个程序的运行。不同的应用程序运行的过程中都需要在内存中分配自己独立的运行空间，彼此之间不会相互的影响。我们把每个独立应用程序在内存的独立空间称为当前应用程序运行的一个进程。进程：它是内存中的一段独立的空间，可以负责当前应用程序的运行。当前这个进程负责调度当前程序中的所有运行细节。\n线程介绍1234启动的QQ聊天软件，需要和多个人进行聊天。这时多个人之间是不能相互影响，但是它们都位于当前QQ这个软件运行时所分配的内容的独立空间中。\t在一个进程中，每个独立的功能都需要独立的去运行，这时又需要把当前这个进程划分成多个运行区域，每个独立的小区域（小单元）称为一个线程。线程：它是位于进程中，负责当前进程中的某个具备独立运行资格的空间。进程是负责整个程序的运行，而线程是程序中具体的某个独立功能的运行。一个进程中至少应该有一个线程。\n多线程介绍1234现在的操作系统基本都是多用户，多任务的操作系统。每个任务就是一个进程。而在这个进程中就会有线程。真正可以完成程序运行和功能的实现靠的是进程中的线程。多线程：在一个进程中，我们同时开启多个线程，让多个线程同时去完成某些任务（功能）。多线程的目的：提高程序的运行效率。\n多线程运行的原理1234cpu在线程中做时间片的切换。其实真正电脑中的程序的运行不是同时在运行的。CPU负责程序的运行，而CPU在运行程序的过程中某个时刻点上，它其实只能运行一个程序。而不是多个程序。而CPU它可以在多个程序之间进行高速的切换。而切换频率和速度太快，导致人的肉看看不到。每个程序就是进程， 而每个进程中会有多个线程，而CPU是在这些线程之间进行切换。了解了CPU对一个任务的执行过程，我们就必须知道，多线程可以提高程序的运行效率，但不能无限制的开线程。\n12345678多进程的意义?\t提高CPU的使用率多线程的意义?\t提高应用程序的使用率Java程序的运行原理及JVM的启动是多线程的吗?\t\tA:Java命令去启动JVM，JVM会启动一个进程，该进程会启动一个主线程。\t\tB:JVM的启动是多线程的，因为它最低有两个线程启动了，主线程和垃圾回收线程。\n实现线程的两种方式1、继承Thread的原理123456789101112131415161718192021222324252627282930313233343536import java.util.Random;public class MyThreadWithExtends extends Thread &#123;\tString flag;\tpublic MyThreadWithExtends(String flag)&#123;\t\tthis.flag = flag;\t&#125;\t@Override\tpublic void run() &#123;\t\tString tname = Thread.currentThread().getName();\t\tSystem.out.println(tname+&quot;线程的run方法被调用……&quot;);\t\tRandom random = new Random();\t\tfor(int i=0;i&lt;20;i++)&#123;\t\t\ttry &#123;\t\t\t\tThread.sleep(random.nextInt(10)*100);\t\t\t\tSystem.out.println(tname+ &quot;....&quot;+ flag);\t\t\t&#125; catch (InterruptedException e) &#123;\t\t\t\te.printStackTrace();\t\t\t&#125;\t\t&#125;\t&#125;\tpublic static void main(String[] args) &#123;\t\tThread thread1 = new MyThreadWithExtends(&quot;a&quot;);\t\tThread thread2 = new MyThreadWithExtends(&quot;b&quot;);\t\tthread1.start();\t\tthread2.start();\t\t/**\t\t * 如果是调用thread的run方法，则只是一个普通的方法调用，不会开启新的线程\t\t *///\t\tthread1.run();//\t\tthread2.run();\t&#125;&#125;\n2、声明实现 Runnable 接口的类1234567891011121314151617181920212223242526272829303132public class MyThreadWithImpliment implements Runnable &#123;\tint x;\tpublic MyThreadWithImpliment(int x) &#123;\t\tthis.x = x;\t&#125;\t@Override\tpublic void run() &#123;\t\tString name = Thread.currentThread().getName();\t\tSystem.out.println(&quot;线程&quot; + name + &quot;的run方法被调用……&quot;);\t\tfor (int i = 0; i &lt; 10; i++) &#123;\t\t\tSystem.out.println(x);\t\t\ttry &#123;\t\t\t\tThread.sleep(100);\t\t\t&#125; catch (InterruptedException e) &#123;\t\t\t\te.printStackTrace();\t\t\t&#125;\t\t&#125;\t&#125;\tpublic static void main(String[] args) &#123;\t\tThread thread1 = new Thread(new MyThreadWithImpliment(1), &quot;thread-1&quot;);\t\tThread thread2 = new Thread(new MyThreadWithImpliment(2), &quot;thread-2&quot;);\t\t thread1.start();\t\t thread2.start();\t\t// 注意调用run和调用start的区别,直接调用run，则都运行在main线程中//\t\tthread1.run();//\t\tthread2.run();\t&#125;&#125;\nsynchronized12345678910111213141516171819202122232425262728293031public class MySynchronized &#123;\tpublic static void main(String[] args) &#123;\t\tfinal MySynchronized mySynchronized = new MySynchronized();\t\tfinal MySynchronized mySynchronized2 = new MySynchronized();\t\tnew Thread(&quot;thread1&quot;) &#123;\t\t\tpublic void run() &#123;\t\t\t\tsynchronized (mySynchronized) &#123;\t\t\t\ttry &#123;\t\t\t\t\tSystem.out.println(this.getName()+&quot; start&quot;);\t\t\t\t\tint i =1/0;   //如果发生异常，jvm会将锁释放\t\t\t\t\tThread.sleep(5000);\t\t\t\t\tSystem.out.println(this.getName()+&quot;醒了&quot;);\t\t\t\t\tSystem.out.println(this.getName()+&quot; end&quot;);\t\t\t\t&#125; catch (InterruptedException e) &#123;\t\t\t\t\te.printStackTrace();\t\t\t\t&#125;\t\t\t\t&#125;\t\t\t&#125;\t\t&#125;.start();\t\tnew Thread(&quot;thread2&quot;) &#123;\t\t\tpublic void run() &#123;\t\t\t\tsynchronized (mySynchronized) &#123;         //争抢同一把锁时，线程1没释放之前，线程2只能等待//\t\t\t\t\tsynchronized (mySynchronized2) &#123;    //如果不是一把锁，可以看到两句话同时打印\t\t\t\t\tSystem.out.println(this.getName()+&quot; start&quot;);\t\t\t\t\tSystem.out.println(this.getName()+&quot; end&quot;);\t\t\t\t&#125;\t\t\t&#125;\t\t&#125;.start();\t&#125;&#125;\n线程的调度和优先级问题12345678A:线程的调度\ta:分时调度\tb:抢占式调度 (Java采用的是该调度方式)B:获取和设置线程优先级public final int getPriority():返回线程对象的优先级public final void setPriority(int newPriority)：更改线程的优先级。\ta:默认是5\tb:范围是1-10\n线程的控制(常见方法)1234567891011121314151617public final String getName():获取线程的名称。public final void setName(String name):设置线程的名称public static Thread currentThread():返回当前正在执行的线程对象Thread.currentThread().getName()A:休眠线程\tpublic static void sleep(long millis)  在run方法中调用Thread.sleep()B:加入线程\t public final void join():等待该线程终止。C:礼让线程\tpublic static void yield():暂停当前正在执行的线程对象，并执行其他线程。在run方法中调用Thread.yield()D:后台线程\tpublic final void setDaemon(boolean on):将该线程标记为守护线程或用户线程。当正在运行的线程都是守护线程时，Java虚拟机退出。该方法必须在启动线程前调用。E:终止线程(掌握)public final void stop():让线程停止，太暴力，过时了，但是还可以使用。public void interrupt():中断线程。 把线程的状态终止，并抛出一个InterruptedException。\n线程组123456789101112把多个线程组合到一起。它可以对一批线程进行分类管理，Java允许程序直接对线程组进行控制。线程默认情况下属于main线程组线程类里面的方法：public final ThreadGroup getThreadGroup()\t\t  Thread(ThreadGroup group, Runnable target, String name)线程组里面的方法：public final String getName()线程组的构造方法：ThreadGroup(String name)\t\t  ThreadGroup tg = new ThreadGroup(&quot;这是一个新的组&quot;);//通过组名称设置后台线程，表示该组的线程都是后台线程tg.setDaemon(true);\n线程安全1234567891011121314151617181920212223242526272829303132333435363738import java.util.concurrent.atomic.AtomicInteger;/** * 线程安全概念：当多个线程访问某一个类（对象或方法）时，这个对象始终都能表现出正确的行为，那么这个类（对象或方法）就是线程安全的。 * synchronized：可以在任意对象及方法上加锁，而加锁的这段代码称为&quot;互斥区&quot;或&quot;临界区&quot; * */public class MyThread extends Thread&#123;\tprivate int count = 5 ;\t//synchronized加锁\tpublic void run()&#123;\t\tcount--;\t\tSystem.out.println(this.currentThread().getName() + &quot; count = &quot;+ count);\t&#125;\tpublic static void main(String[] args) &#123;\t\t/**\t\t * 分析：当多个线程访问myThread的run方法时，以排队的方式进行处理（这里排对是按照CPU分配的先后顺序而定的），\t\t * \t\t一个线程想要执行synchronized修饰的方法里的代码：\t\t * \t\t1 尝试获得锁\t\t * \t\t2 如果拿到锁，执行synchronized代码体内容；拿不到锁，这个线程就会不断的尝试获得这把锁，直到拿到为止，\t\t * \t\t   而且是多个线程同时去竞争这把锁。（也就是会有锁竞争的问题）\t\t */\t\tMyThread myThread = new MyThread();\t\tThread t1 = new Thread(myThread,&quot;t1&quot;);\t\tThread t2 = new Thread(myThread,&quot;t2&quot;);\t\tThread t3 = new Thread(myThread,&quot;t3&quot;);\t\tThread t4 = new Thread(myThread,&quot;t4&quot;);\t\tThread t5 = new Thread(myThread,&quot;t5&quot;);\t\tt1.start();\t\tt2.start();\t\tt3.start();\t\tt4.start();\t\tt5.start();\t&#125;&#125;\n12345t1 count = 2t5 count = 0t4 count = 1t3 count = 2t2 count = 2\n多个线程多个锁多个线程多个锁，多个线程，每个线程都可以拿到自己指定的锁，分别获得锁之后，执行synchronized方法体的内容。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657/** * 关键字synchronized取得的锁都是对象锁，而不是把一段代码（方法）当做锁， * 所以代码中哪个线程先执行synchronized关键字的方法，哪个线程就持有该方法所属对象的锁（Lock）， * 两个对象，线程获得的就是两个不同的锁，他们互不影响。 * * 在静态方法上加synchronized关键字，表示锁定.class类，类一级别的锁（独占.class类）。 * */public class MultiThread &#123;\tprivate int num = 0;\t/** static */\tpublic synchronized void printNum(String tag)&#123;\t\ttry &#123;\t\t\tif(tag.equals(&quot;a&quot;))&#123;\t\t\t\tnum = 100;\t\t\t\tSystem.out.println(&quot;tag a, set num over!&quot;);\t\t\t\tThread.sleep(1000);\t\t\t&#125; else &#123;\t\t\t\tnum = 200;\t\t\t\tSystem.out.println(&quot;tag b, set num over!&quot;);\t\t\t&#125;\t\t\tSystem.out.println(&quot;tag &quot; + tag + &quot;, num = &quot; + num);\t\t&#125; catch (InterruptedException e) &#123;\t\t\te.printStackTrace();\t\t&#125;\t&#125;\t//注意观察run方法输出顺序\tpublic static void main(String[] args) &#123;\t\t//俩个不同的对象\t\tfinal MultiThread m1 = new MultiThread();\t\tfinal MultiThread m2 = new MultiThread();\t\tThread t1 = new Thread(new Runnable() &#123;\t\t\t@Override\t\t\tpublic void run() &#123;\t\t\t\tm1.printNum(&quot;a&quot;);\t\t\t&#125;\t\t&#125;);\t\tThread t2 = new Thread(new Runnable() &#123;\t\t\t@Override\t\t\tpublic void run() &#123;\t\t\t\tm2.printNum(&quot;b&quot;);\t\t\t&#125;\t\t&#125;);\t\tt1.start();\t\tt2.start();\t&#125;&#125;\n1234tag a, set num over!tag b, set num over!tag b, num = 200tag a, num = 100\n对象锁的同步和异步同步：synchronized同步的概念就是共享，我们要牢牢记住“共享”这两个字，如果不是共享的资源，就没有必要进行同步。异步：asynchronized异步的概念就是独立，相互之间不受任何制约。就好像我们学习http的时候，在页面发起的ajax请求，我们还可以继续浏览或操作页面的内容，二者之间没有任何关系。同步的目的就是为了线程安全，其实对于线程安全来说，需要猫满足两个特性。原子性（同步）可见性123456789101112131415161718192021222324252627282930313233343536373839404142434445/** * 对象锁的同步和异步问题 * */public class MyObject &#123;\tpublic synchronized void method1()&#123;\t\ttry &#123;\t\t\tSystem.out.println(Thread.currentThread().getName());\t\t\tThread.sleep(4000);\t\t&#125; catch (InterruptedException e) &#123;\t\t\te.printStackTrace();\t\t&#125;\t&#125;\t/** synchronized */\tpublic void method2()&#123;\t\t\tSystem.out.println(Thread.currentThread().getName());\t&#125;\tpublic static void main(String[] args) &#123;\t\tfinal MyObject mo = new MyObject();\t\t/**\t\t * 分析：\t\t * t1线程先持有object对象的Lock锁，t2线程可以以异步的方式调用对象中的非synchronized修饰的方法\t\t * t1线程先持有object对象的Lock锁，t2线程如果在这个时候调用对象中的同步（synchronized）方法则需等待，也就是同步\t\t */\t\tThread t1 = new Thread(new Runnable() &#123;\t\t\t@Override\t\t\tpublic void run() &#123;\t\t\t\tmo.method1();\t\t\t&#125;\t\t&#125;,&quot;t1&quot;);\t\tThread t2 = new Thread(new Runnable() &#123;\t\t\t@Override\t\t\tpublic void run() &#123;\t\t\t\tmo.method2();\t\t\t&#125;\t\t&#125;,&quot;t2&quot;);\t\tt1.start();\t\tt2.start();\t&#125;&#125;\n12t1t2 （立即打印）\n脏读对于对象的同步和异步的方法,我们在设计自己的程序的时候,一定要考虑问题的整体,不然就会出现数据不一致的错误,很经典的错误藏是讲读(dirtyread)123456789101112131415161718192021222324252627282930313233343536373839/** * 在我们对一个对象的方法加锁的时候,需要考虑业务的整体性,即为setValueigetvalue方法同时加链synchronized同步关键字, * 保证业务(service)的原子性,不然会出现业务错误(也从侧面保证业务的一致性) . */public class DirtyRead &#123;\tprivate String username = &quot;bjsxt&quot;;\tprivate String password = &quot;123&quot;;\tpublic synchronized void setValue(String username, String password)&#123;\t\tthis.username = username;\t\ttry &#123;\t\t\tThread.sleep(2000);\t\t&#125; catch (InterruptedException e) &#123;\t\t\te.printStackTrace();\t\t&#125;\t\tthis.password = password;\t\tSystem.out.println(&quot;setValue最终结果：username = &quot; + username + &quot; , password = &quot; + password);\t&#125;\tpublic void getValue()&#123;\t\tSystem.out.println(&quot;getValue方法得到：username = &quot; + this.username + &quot; , password = &quot; + this.password);\t&#125;\tpublic static void main(String[] args) throws Exception&#123;\t\tfinal DirtyRead dr = new DirtyRead();\t\tThread t1 = new Thread(new Runnable() &#123;\t\t\t@Override\t\t\tpublic void run() &#123;\t\t\t\tdr.setValue(&quot;z3&quot;, &quot;456&quot;);\t\t\t&#125;\t\t&#125;);\t\tt1.start();\t\tThread.sleep(1000);\t\tdr.getValue();\t&#125;&#125;\n12getValue方法得到：username = z3 , password = 123setValue最终结果：username = z3 , password = 456\nsynchronized锁重入:关键字synchronized拥有锁重入的功能,也就是在使用synchronized时,当一个线程得到了一个对象的锁后,再次请求此对象时是可以再次得到该对象的锁。12345678910111213141516171819202122232425262728/** * synchronized的重入 * */public class SyncDubbo1 &#123;\tpublic synchronized void method1()&#123;\t\tSystem.out.println(&quot;method1..&quot;);\t\tmethod2();\t&#125;\tpublic synchronized void method2()&#123;\t\tSystem.out.println(&quot;method2..&quot;);\t\tmethod3();\t&#125;\tpublic synchronized void method3()&#123;\t\tSystem.out.println(&quot;method3..&quot;);\t&#125;\tpublic static void main(String[] args) &#123;\t\tfinal SyncDubbo1 sd = new SyncDubbo1();\t\tThread t1 = new Thread(new Runnable() &#123;\t\t\t@Override\t\t\tpublic void run() &#123;\t\t\t\tsd.method1();\t\t\t&#125;\t\t&#125;);\t\tt1.start();\t&#125;&#125;\n1234567891011121314151617181920212223242526272829303132333435363738394041424344/** * synchronized的重入 * */public class SyncDubbo2 &#123;\tstatic class Main &#123;\t\tpublic int i = 10;\t\tpublic synchronized void operationSup()&#123;\t\t\ttry &#123;\t\t\t\ti--;\t\t\t\tSystem.out.println(&quot;Main print i = &quot; + i);\t\t\t\tThread.sleep(100);\t\t\t&#125; catch (InterruptedException e) &#123;\t\t\t\te.printStackTrace();\t\t\t&#125;\t\t&#125;\t&#125;\tstatic class Sub extends Main &#123;\t\tpublic synchronized void operationSub()&#123;\t\t\ttry &#123;\t\t\t\twhile(i &gt; 0) &#123;\t\t\t\t\ti--;\t\t\t\t\tSystem.out.println(&quot;Sub print i = &quot; + i);\t\t\t\t\tThread.sleep(100);\t\t\t\t\tthis.operationSup();\t\t\t\t&#125;\t\t\t&#125; catch (InterruptedException e) &#123;\t\t\t\te.printStackTrace();\t\t\t&#125;\t\t&#125;\t&#125;\tpublic static void main(String[] args) &#123;\t\tThread t1 = new Thread(new Runnable() &#123;\t\t\t@Override\t\t\tpublic void run() &#123;\t\t\t\tSub sub = new Sub();\t\t\t\tsub.operationSub();\t\t\t&#125;\t\t&#125;);\t\tt1.start();\t&#125;&#125;\n对于web应用程序,异常释放锁的情况,如果不及时处理,很可能对你的应用程序业务逻辑产生严重的错误,比如你现在执行一个队列任务,很多对象都去在等特第一个对象正确执行完毕再去释放锁,但是第一个对象由于异常的出现,导致业务逻辑没有正常执行完毕,就释放了锁,那么可把而知后续的对象执行的都是错误的逻钱.所以这一点一定要引起注意,在编写代码的时候,一定要考虑剧全.123456789101112131415161718192021222324252627282930313233/** * synchronized异常 * */public class SyncException &#123;\tprivate int i = 0;\tpublic synchronized void operation()&#123;\t\twhile(true)&#123;\t\t\ttry &#123;\t\t\t\ti++;\t\t\t\tThread.sleep(100);\t\t\t\tSystem.out.println(Thread.currentThread().getName() + &quot; , i = &quot; + i);\t\t\t\tif(i == 20)&#123;\t\t\t\t\t//Integer.parseInt(&quot;a&quot;);\t\t\t\t\tthrow new RuntimeException();\t\t\t\t&#125;\t\t\t&#125; catch (InterruptedException e) &#123;\t\t\t\te.printStackTrace();\t\t\t&#125;\t\t&#125;\t&#125;\tpublic static void main(String[] args) &#123;\t\tfinal SyncException se = new SyncException();\t\tThread t1 = new Thread(new Runnable() &#123;\t\t\t@Override\t\t\tpublic void run() &#123;\t\t\t\tse.operation();\t\t\t&#125;\t\t&#125;,&quot;t1&quot;);\t\tt1.start();\t&#125;&#125;\nsynchronized代码块使用syhchronized声明的方法在某些情况下是有弊端的,比如A线程调用同步的方法执行一个很长时间的任务,那么B找程就必须等待比较长的时间才能执行,这样的情况下可以使用synchronized代码块去优化代码执行时间,也就是通常所说的减小锁的粒度。12345678910111213141516171819202122232425262728293031323334353637383940414243/** * 使用synchronized代码块减小锁的粒度，提高性能 * */public class Optimize &#123;\tpublic void doLongTimeTask()&#123;\t\ttry &#123;\t\t\tSystem.out.println(&quot;当前线程开始：&quot; + Thread.currentThread().getName() +\t\t\t\t\t&quot;, 正在执行一个较长时间的业务操作，其内容不需要同步&quot;);\t\t\tThread.sleep(2000);\t\t\tsynchronized(this)&#123;\t\t\t\tSystem.out.println(&quot;当前线程：&quot; + Thread.currentThread().getName() +\t\t\t\t\t&quot;, 执行同步代码块，对其同步变量进行操作&quot;);\t\t\t\tThread.sleep(1000);\t\t\t&#125;\t\t\tSystem.out.println(&quot;当前线程结束：&quot; + Thread.currentThread().getName() +\t\t\t\t\t&quot;, 执行完毕&quot;);\t\t&#125; catch (InterruptedException e) &#123;\t\t\te.printStackTrace();\t\t&#125;\t&#125;\tpublic static void main(String[] args) &#123;\t\tfinal Optimize otz = new Optimize();\t\tThread t1 = new Thread(new Runnable() &#123;\t\t\t@Override\t\t\tpublic void run() &#123;\t\t\t\totz.doLongTimeTask();\t\t\t&#125;\t\t&#125;,&quot;t1&quot;);\t\tThread t2 = new Thread(new Runnable() &#123;\t\t\t@Override\t\t\tpublic void run() &#123;\t\t\t\totz.doLongTimeTask();\t\t\t&#125;\t\t&#125;,&quot;t2&quot;);\t\tt1.start();\t\tt2.start();\t&#125;&#125;\nsynchronized可以使用任意的Object进行加锁,用法比较灵活.1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465/** * 使用synchronized代码块加锁,比较灵活 * */public class ObjectLock &#123;\tpublic void method1()&#123;\t\tsynchronized (this) &#123;\t//对象锁\t\t\ttry &#123;\t\t\t\tSystem.out.println(&quot;do method1..&quot;);\t\t\t\tThread.sleep(2000);\t\t\t&#125; catch (InterruptedException e) &#123;\t\t\t\te.printStackTrace();\t\t\t&#125;\t\t&#125;\t&#125;\tpublic void method2()&#123;\t\t//类锁\t\tsynchronized (ObjectLock.class) &#123;\t\t\ttry &#123;\t\t\t\tSystem.out.println(&quot;do method2..&quot;);\t\t\t\tThread.sleep(2000);\t\t\t&#125; catch (InterruptedException e) &#123;\t\t\t\te.printStackTrace();\t\t\t&#125;\t\t&#125;\t&#125;\tprivate Object lock = new Object();\tpublic void method3()&#123;\t\t//任何对象锁\t\tsynchronized (lock) &#123;\t\t\ttry &#123;\t\t\t\tSystem.out.println(&quot;do method3..&quot;);\t\t\t\tThread.sleep(2000);\t\t\t&#125; catch (InterruptedException e) &#123;\t\t\t\te.printStackTrace();\t\t\t&#125;\t\t&#125;\t&#125;\tpublic static void main(String[] args) &#123;\t\tfinal ObjectLock objLock = new ObjectLock();\t\tThread t1 = new Thread(new Runnable() &#123;\t\t\t@Override\t\t\tpublic void run() &#123;\t\t\t\tobjLock.method1();\t\t\t&#125;\t\t&#125;);\t\tThread t2 = new Thread(new Runnable() &#123;\t\t\t@Override\t\t\tpublic void run() &#123;\t\t\t\tobjLock.method2();\t\t\t&#125;\t\t&#125;);\t\tThread t3 = new Thread(new Runnable() &#123;\t\t\t@Override\t\t\tpublic void run() &#123;\t\t\t\tobjLock.method3();\t\t\t&#125;\t\t&#125;);\t\tt1.start();\t\tt2.start();\t\tt3.start();\t&#125;&#125;\n另外特别注意一个问题,就是不要使用String的常量加锁,会出现死循环问题因为在JVM中具有String常量池(如果两个String具有相同的值，那么他们的地址是相同的，都保存在这个常量池中)。当以String作为锁的时候，如果值相同则，那么线程持有相同的锁。这样就造成了另外一个线程不能执行\n锁对象的改变问题,当使用一个对象进行加锁的时候,要注意对象本身发生改变的时候那么持有的镜就不同,如果对象本身不发生改变,那么依然是同步的,即使是对象的属性发生了改变。\n死锁问题12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061/** * 死锁问题，在设计程序时就应该避免双方相互持有对方的锁的情况 * */public class DeadLock implements Runnable&#123;\tprivate String tag;\tprivate static Object lock1 = new Object();\tprivate static Object lock2 = new Object();\tpublic void setTag(String tag)&#123;\t\tthis.tag = tag;\t&#125;\t@Override\tpublic void run() &#123;\t\tif(tag.equals(&quot;a&quot;))&#123;\t\t\tsynchronized (lock1) &#123;\t\t\t\ttry &#123;\t\t\t\t\tSystem.out.println(&quot;当前线程 : &quot;  + Thread.currentThread().getName() + &quot; 进入lock1执行&quot;);\t\t\t\t\tThread.sleep(2000);\t\t\t\t&#125; catch (InterruptedException e) &#123;\t\t\t\t\te.printStackTrace();\t\t\t\t&#125;\t\t\t\tsynchronized (lock2) &#123;\t\t\t\t\tSystem.out.println(&quot;当前线程 : &quot;  + Thread.currentThread().getName() + &quot; 进入lock2执行&quot;);\t\t\t\t&#125;\t\t\t&#125;\t\t&#125;\t\tif(tag.equals(&quot;b&quot;))&#123;\t\t\tsynchronized (lock2) &#123;\t\t\t\ttry &#123;\t\t\t\t\tSystem.out.println(&quot;当前线程 : &quot;  + Thread.currentThread().getName() + &quot; 进入lock2执行&quot;);\t\t\t\t\tThread.sleep(2000);\t\t\t\t&#125; catch (InterruptedException e) &#123;\t\t\t\t\te.printStackTrace();\t\t\t\t&#125;\t\t\t\tsynchronized (lock1) &#123;\t\t\t\t\tSystem.out.println(&quot;当前线程 : &quot;  + Thread.currentThread().getName() + &quot; 进入lock1执行&quot;);\t\t\t\t&#125;\t\t\t&#125;\t\t&#125;\t&#125;\tpublic static void main(String[] args) &#123;\t\tDeadLock d1 = new DeadLock();\t\td1.setTag(&quot;a&quot;);\t\tDeadLock d2 = new DeadLock();\t\td2.setTag(&quot;b&quot;);\t\tThread t1 = new Thread(d1, &quot;t1&quot;);\t\tThread t2 = new Thread(d2, &quot;t2&quot;);\t\tt1.start();\t\ttry &#123;\t\t\tThread.sleep(500);\t\t&#125; catch (InterruptedException e) &#123;\t\t\te.printStackTrace();\t\t&#125;\t\tt2.start();\t&#125;&#125;\nsynchronized的缺陷12345678910111213141516synchronized是java中的一个关键字，也就是说是Java语言内置的特性。如果一个代码块被synchronized修饰了，当一个线程获取了对应的锁，并执行该代码块时，其他线程便只能一直等待，等待获取锁的线程释放锁，而这里获取锁的线程释放锁只会有两种情况：1）获取锁的线程执行完了该代码块，然后线程释放对锁的占有；2）线程执行发生异常，此时JVM会让线程自动释放锁。例子1：　　如果这个获取锁的线程由于要等待IO或者其他原因（比如调用sleep方法）被阻塞了，但是又没有释放锁，其他线程便只能干巴巴地等待，试想一下，这多么影响程序执行效率。　　因此就需要有一种机制可以不让等待的线程一直无期限地等待下去（比如只等待一定的时间或者能够响应中断），通过Lock就可以办到。例子2：当有多个线程读写文件时，读操作和写操作会发生冲突现象，写操作和写操作会发生冲突现象，但是读操作和读操作不会发生冲突现象。　　但是采用synchronized关键字来实现同步的话，就会导致一个问题：如果多个线程都只是进行读操作，当一个线程在进行读操作时，其他线程只能等待无法进行读操作。因此就需要一种机制来使得多个线程都只是进行读操作时，线程之间不会发生冲突，通过Lock就可以办到。另外，通过Lock可以知道线程有没有成功获取到锁。这个是synchronized无法办到的。总的来说，也就是说Lock提供了比synchronized更多的功能。\nlocklock和synchronized的区别121）Lock不是Java语言内置的，synchronized是Java语言的关键字，因此是内置特性。Lock是一个类，通过这个类可以实现同步访问；2）Lock和synchronized有一点非常大的不同，采用synchronized不需要用户去手动释放锁，当synchronized方法或者synchronized代码块执行完之后，系统会自动让线程释放对锁的占用；而Lock则必须要用户去手动释放锁，如果没有主动释放锁，就有可能导致出现死锁现象。\nlock1234567public interface Lock &#123;    void lock();    void lockInterruptibly() throws InterruptedException;    boolean tryLock();    boolean tryLock(long time, TimeUnit unit) throws InterruptedException;    void unlock();&#125;\nLock接口中每个方法的使用：lock()、tryLock()、tryLock(long time, TimeUnit unit)、lockInterruptibly()是用来获取锁的。unLock()方法是用来释放锁的。四个获取锁方法的区别：lock()方法是平常使用得最多的一个方法，就是用来获取锁。如果锁已被其他线程获取，则进行等待。由于在前面讲到如果采用Lock，必须主动去释放锁，并且在发生异常时，不会自动释放锁。因此一般来说，使用Lock必须在try{}catch{}块中进行，并且将释放锁的操作放在finally块中进行，以保证锁一定被被释放，防止死锁的发生。tryLock()方法是有返回值的，它表示用来尝试获取锁，如果获取成功，则返回true，如果获取失败（即锁已被其他线程获取），则返回false，也就说这个方法无论如何都会立即返回。在拿不到锁时不会一直在那等待。tryLock(long time, TimeUnit unit)方法和tryLock()方法是类似的，只不过区别在于这个方法在拿不到锁时会等待一定的时间，在时间期限之内如果还拿不到锁，就返回false。如果如果一开始拿到锁或者在等待期间内拿到了锁，则返回true。lockInterruptibly()方法比较特殊，当通过这个方法去获取锁时，如果线程正在等待获取锁，则这个线程能够响应中断，即中断线程的等待状态。也就使说，当两个线程同时通过lock.lockInterruptibly()想获取某个锁时，假若此时线程A获取到了锁，而线程B只有在等待，那么对线程B调用threadB.interrupt()方法能够中断线程B的等待过程。注意，当一个线程获取了锁之后，是不会被interrupt()方法中断的。因此当通过lockInterruptibly()方法获取某个锁时，如果不能获取到，只有进行等待的情况下，是可以响应中断的。而用synchronized修饰的话，当一个线程处于等待某个锁的状态，是无法被中断的，只有一直等待下去。\nReentrantLock直接使用lock接口的话，我们需要实现很多方法，不太方便，ReentrantLock是唯一实现了Lock接口的类，并且ReentrantLock提供了更多的方法，ReentrantLock，意思是“可重入锁”。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748import java.util.ArrayList;import java.util.concurrent.locks.Lock;import java.util.concurrent.locks.ReentrantLock;public class MyLockTest &#123;\tprivate static ArrayList&lt;Integer&gt; arrayList = new ArrayList&lt;Integer&gt;();\tstatic Lock lock = new ReentrantLock(); // 注意这个地方\tpublic static &lt;E&gt; void main(String[] args) &#123;\t\tnew Thread() &#123;\t\t\tpublic void run() &#123;\t\t\t\tThread thread = Thread.currentThread();\t\t\t\tlock.lock();\t\t\t\ttry &#123;\t\t\t\t\tSystem.out.println(thread.getName() + &quot;得到了锁&quot;);\t\t\t\t\tfor (int i = 0; i &lt; 5; i++) &#123;\t\t\t\t\t\tarrayList.add(i);\t\t\t\t\t&#125;\t\t\t\t&#125; catch (Exception e) &#123;\t\t\t\t\t// TODO: handle exception\t\t\t\t&#125; finally &#123;\t\t\t\t\tSystem.out.println(thread.getName() + &quot;释放了锁&quot;);\t\t\t\t\tlock.unlock();\t\t\t\t&#125;\t\t\t&#125;;\t\t&#125;.start();\t\tnew Thread() &#123;\t\t\tpublic void run() &#123;\t\t\t\tThread thread = Thread.currentThread();\t\t\t\tlock.lock();\t\t\t\ttry &#123;\t\t\t\t\tSystem.out.println(thread.getName() + &quot;得到了锁&quot;);\t\t\t\t\tfor (int i = 0; i &lt; 5; i++) &#123;\t\t\t\t\t\tarrayList.add(i);\t\t\t\t\t&#125;\t\t\t\t&#125; catch (Exception e) &#123;\t\t\t\t\t// TODO: handle exception\t\t\t\t&#125; finally &#123;\t\t\t\t\tSystem.out.println(thread.getName() + &quot;释放了锁&quot;);\t\t\t\t\tlock.unlock();\t\t\t\t&#125;\t\t\t&#125;;\t\t&#125;.start();\t&#125;&#125;\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657import java.util.ArrayList;import java.util.concurrent.locks.Lock;import java.util.concurrent.locks.ReentrantLock;/** * 观察现象：一个线程获得锁后，另一个线程取不到锁，不会一直等待 * */public class MyTryLock &#123;\tprivate static ArrayList&lt;Integer&gt; arrayList = new ArrayList&lt;Integer&gt;();\tstatic Lock lock = new ReentrantLock(); // 注意这个地方\tpublic static void main(String[] args) &#123;\t\tnew Thread() &#123;\t\t\tpublic void run() &#123;\t\t\t\tThread thread = Thread.currentThread();\t\t\t\tboolean tryLock = lock.tryLock();\t\t\t\tSystem.out.println(thread.getName()+&quot; &quot;+tryLock);\t\t\t\tif (tryLock) &#123;\t\t\t\t\ttry &#123;\t\t\t\t\t\tSystem.out.println(thread.getName() + &quot;得到了锁&quot;);\t\t\t\t\t\tfor (int i = 0; i &lt; 5; i++) &#123;\t\t\t\t\t\t\tarrayList.add(i);\t\t\t\t\t\t&#125;\t\t\t\t\t&#125; catch (Exception e) &#123;\t\t\t\t\t\t// TODO: handle exception\t\t\t\t\t&#125; finally &#123;\t\t\t\t\t\tSystem.out.println(thread.getName() + &quot;释放了锁&quot;);\t\t\t\t\t\tlock.unlock();\t\t\t\t\t&#125;\t\t\t\t&#125;\t\t\t&#125;;\t\t&#125;.start();\t\tnew Thread() &#123;\t\t\tpublic void run() &#123;\t\t\t\tThread thread = Thread.currentThread();\t\t\t\tboolean tryLock = lock.tryLock();\t\t\t\tSystem.out.println(thread.getName()+&quot; &quot;+tryLock);\t\t\t\tif (tryLock) &#123;\t\t\t\t\ttry &#123;\t\t\t\t\t\tSystem.out.println(thread.getName() + &quot;得到了锁&quot;);\t\t\t\t\t\tfor (int i = 0; i &lt; 5; i++) &#123;\t\t\t\t\t\t\tarrayList.add(i);\t\t\t\t\t\t&#125;\t\t\t\t\t&#125; catch (Exception e) &#123;\t\t\t\t\t\t// TODO: handle exception\t\t\t\t\t&#125; finally &#123;\t\t\t\t\t\tSystem.out.println(thread.getName() + &quot;释放了锁&quot;);\t\t\t\t\t\tlock.unlock();\t\t\t\t\t&#125;\t\t\t\t&#125;\t\t\t&#125;;\t\t&#125;.start();\t&#125;&#125;\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859import java.util.concurrent.locks.Lock;import java.util.concurrent.locks.ReentrantLock;/** * 观察现象：如果thread-0得到了锁，阻塞。。。thread-1尝试获取锁，如果拿不到，则可以被中断等待 * */public class MyInterruptibly &#123;\t private Lock lock = new ReentrantLock();\t    public static void main(String[] args)  &#123;\t    \tMyInterruptibly test = new MyInterruptibly();\t        MyThread thread0 = new MyThread(test);\t        MyThread thread1 = new MyThread(test);\t        thread0.start();\t        thread1.start();\t        try &#123;\t            Thread.sleep(2000);\t        &#125; catch (InterruptedException e) &#123;\t            e.printStackTrace();\t        &#125;\t        thread1.interrupt();\t        System.out.println(&quot;=====================&quot;);\t    &#125;\t    public void insert(Thread thread) throws InterruptedException&#123;\t        lock.lockInterruptibly();   //注意，如果需要正确中断等待锁的线程，必须将获取锁放在外面，然后将InterruptedException抛出\t        try &#123;\t            System.out.println(thread.getName()+&quot;得到了锁&quot;);\t            long startTime = System.currentTimeMillis();\t            for(    ;     ;) &#123;\t                if(System.currentTimeMillis() - startTime &gt;= Integer.MAX_VALUE)\t                    break;\t                //插入数据\t            &#125;\t        &#125;\t        finally &#123;\t            System.out.println(Thread.currentThread().getName()+&quot;执行finally&quot;);\t            lock.unlock();\t            System.out.println(thread.getName()+&quot;释放了锁&quot;);\t        &#125;\t    &#125;\t&#125;\tclass MyThread extends Thread &#123;\t    private MyInterruptibly test = null;\t    public MyThread(MyInterruptibly test) &#123;\t        this.test = test;\t    &#125;\t    @Override\t    public void run() &#123;\t        try &#123;\t            test.insert(Thread.currentThread());\t        &#125; catch (Exception e) &#123;\t            System.out.println(Thread.currentThread().getName()+&quot;被中断&quot;);\t        &#125;\t    &#125;&#125;\nReadWriteLock123456789101112131415public interface ReadWriteLock &#123;    /**     * Returns the lock used for reading.     *     * @return the lock used for reading.     */    Lock readLock();    /**     * Returns the lock used for writing.     *     * @return the lock used for writing.     */    Lock writeLock();&#125;\n一个用来获取读锁，一个用来获取写锁。也就是说将文件的读写操作分开，分成2个锁来分配给线程，从而使得多个线程可以同时进行读操作。下面的ReentrantReadWriteLock实现了ReadWriteLock接口。123456789101112131415161718192021222324252627282930313233343536/** * 一个线程又要读又要写，用synchronize来实现的话，读写操作都只能锁住后一个线程一个线程地进行 * */public class MySynchronizedReadWrite &#123;    public static void main(String[] args)  &#123;        final MySynchronizedReadWrite test = new MySynchronizedReadWrite();        new Thread()&#123;            public void run() &#123;                test.get(Thread.currentThread());            &#125;;        &#125;.start();        new Thread()&#123;            public void run() &#123;                test.get(Thread.currentThread());            &#125;;        &#125;.start();    &#125;    public synchronized void get(Thread thread) &#123;        long start = System.currentTimeMillis();        int i=0;        while(System.currentTimeMillis() - start &lt;= 1) &#123;        \ti++;        \tif(i%4==0)&#123;            System.out.println(thread.getName()+&quot;正在进行写操作&quot;);        \t&#125;else &#123;        \t\tSystem.out.println(thread.getName()+&quot;正在进行读操作&quot;);\t\t\t&#125;        &#125;        System.out.println(thread.getName()+&quot;读写操作完毕&quot;);    &#125;&#125;\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667import java.util.concurrent.locks.ReentrantReadWriteLock;/** * 使用读写锁，可以实现读写分离锁定，读操作并发进行，写操作锁定单个线程 * * 如果有一个线程已经占用了读锁，则此时其他线程如果要申请写锁，则申请写锁的线程会一直等待释放读锁。 * 如果有一个线程已经占用了写锁，则此时其他线程如果申请写锁或者读锁，则申请的线程会一直等待释放写锁。 * */public class MyReentrantReadWriteLock &#123;\t private ReentrantReadWriteLock rwl = new ReentrantReadWriteLock();\t    public static void main(String[] args)  &#123;\t        final MyReentrantReadWriteLock test = new MyReentrantReadWriteLock();\t        new Thread()&#123;\t            public void run() &#123;\t                test.get(Thread.currentThread());\t                test.write(Thread.currentThread());\t            &#125;;\t        &#125;.start();\t        new Thread()&#123;\t            public void run() &#123;\t                test.get(Thread.currentThread());\t                test.write(Thread.currentThread());\t            &#125;;\t        &#125;.start();\t    &#125;\t    /**\t     * 读操作,用读锁来锁定\t     * @param thread\t     */\t    public void get(Thread thread) &#123;\t        rwl.readLock().lock();\t        try &#123;\t            long start = System.currentTimeMillis();\t            while(System.currentTimeMillis() - start &lt;= 1) &#123;\t                System.out.println(thread.getName()+&quot;正在进行读操作&quot;);\t            &#125;\t            System.out.println(thread.getName()+&quot;读操作完毕&quot;);\t        &#125; finally &#123;\t            rwl.readLock().unlock();\t        &#125;\t    &#125;\t    /**\t     * 写操作，用写锁来锁定\t     * @param thread\t     */\t    public void write(Thread thread) &#123;\t        rwl.writeLock().lock();;\t        try &#123;\t            long start = System.currentTimeMillis();\t            while(System.currentTimeMillis() - start &lt;= 1) &#123;\t                System.out.println(thread.getName()+&quot;正在进行写操作&quot;);\t            &#125;\t            System.out.println(thread.getName()+&quot;写操作完毕&quot;);\t        &#125; finally &#123;\t            rwl.writeLock().unlock();\t        &#125;\t    &#125;&#125;\n注意：不过要注意的是，如果有一个线程已经占用了读锁，则此时其他线程如果要申请写锁，则申请写锁的线程会一直等待释放读锁。如果有一个线程已经占用了写锁，则此时其他线程如果申请写锁或者读锁，则申请的线程会一直等待释放写锁。\nLock和synchronized的选择1234561）Lock是一个接口，而synchronized是Java中的关键字，synchronized是内置的语言实现；2）synchronized在发生异常时，会自动释放线程占有的锁，因此不会导致死锁现象发生；而Lock在发生异常时，如果没有主动通过unLock()去释放锁，则很可能造成死锁现象，因此使用Lock时需要在finally块中释放锁；3）Lock可以让等待锁的线程响应中断，而synchronized却不行，使用synchronized时，等待的线程会一直等待下去，不能够响应中断；4）通过Lock可以知道有没有成功获取锁，而synchronized却无法办到。5）Lock可以提高多个线程进行读操作的效率。在性能上来说，如果竞争资源不激烈，两者的性能是差不多的，而当竞争资源非常激烈时（即有大量线程同时竞争），此时Lock的性能要远远优于synchronized。所以说，在具体使用时要根据适当情况选择。\nvolatile关键字的概念volatile 概念: atile关键字的主要作用是使变量在多个线程同可见.在java中,每一个线程都会有一块工作内存区,其中存放着所有线程共享的主内存中的变量值的拷贝。当线程执行时,他在自己的工作内存区中操作这些变量,为了存取一个共享的变量,一个线程通常先获取镇定并去清除它的内存工作区,把这些共享变量从所有线程的共享内存区中正确的装入到他自己所在的工作内存区中,当线程解锁时保证该工作内存区中变量的值写回到共享内存中.一个线程可以执行的操作有使用(use) 、赋值(assign) 、装载(load)、存储(store) 、锁定(lock) 、解镇(unlock) .而主内存可以执行的操作有读(read)、写(wrte) 、锁定(lock)、解镇(unlock) ,每个操作都是原子的。volatile作用就是强制线程到主内存(共享内存)里去读取变量,而不去线程工作内存区里去读取,从而实现了多个线程间的变量可见。也就是满足线程安全的可见性。1234567891011121314151617181920212223public class RunThread extends Thread&#123;\tprivate volatile boolean isRunning = true;\tprivate void setRunning(boolean isRunning)&#123;\t\tthis.isRunning = isRunning;\t&#125;\tpublic void run()&#123;\t\tSystem.out.println(&quot;进入run方法..&quot;);\t\tint i = 0;\t\twhile(isRunning == true)&#123;\t\t\t//..\t\t&#125;\t\tSystem.out.println(&quot;线程停止&quot;);\t&#125;\tpublic static void main(String[] args) throws InterruptedException &#123;\t\tRunThread rt = new RunThread();\t\trt.start();\t\tThread.sleep(1000);\t\trt.setRunning(false);\t\tSystem.out.println(&quot;isRunning的值已经被设置了false&quot;);\t&#125;&#125;\n123进入run方法..isRunning的值已经被设置了false线程停止\n不加volatile12进入run方法..isRunning的值已经被设置了false\n\nvolatile关键字的非原子性volatile关键字虽然拥有多个线程之间的可见性,但是却不具备同步性(也就是原子性) ,可以算上是一个轻量级的synchronized,性能要比synchronized强很多,不会造成阻塞(在很多开源的架构里,比如netty的底层代码就大量使用volatile, 可见netty性能一定是非常不错的。)这里需要注意:一般volatile用于只针对于多个线程可见的变量操作,并不能代替synchronized的同步功能.123456789101112131415161718192021222324252627282930313233import java.util.concurrent.atomic.AtomicInteger;/** * volatile关键字不具备synchronized关键字的原子性（同步） * */public class VolatileNoAtomic extends Thread&#123;\tprivate static volatile int count;\t//private static AtomicInteger count = new AtomicInteger(0);\tprivate static void addCount()&#123;\t\tfor (int i = 0; i &lt; 1000; i++) &#123;\t\t\tcount++ ;\t\t\t// count.incrementAndGet();\t\t&#125;\t\tSystem.out.println(count);\t&#125;\tpublic void run()&#123;\t\taddCount();\t&#125;\tpublic static void main(String[] args) &#123;\t\tVolatileNoAtomic[] arr = new VolatileNoAtomic[100];\t\tfor (int i = 0; i &lt; 10; i++) &#123;\t\t\tarr[i] = new VolatileNoAtomic();\t\t&#125;\t\tfor (int i = 0; i &lt; 10; i++) &#123;\t\t\tarr[i].start();\t\t&#125;\t&#125;&#125;\n123456789101948394829481948531560396401740184019401\nAtomicInteger1234567891020002000341946725000600070009000800010000\nvolatie关键字只具有可见性,没有原子性,要实现原子性建议使用atomic类的系列对象,支持原子性操作(注童atomic类只保证本身方法原子性,并不保证多次操作的原子性)12345678910111213141516171819202122232425262728293031323334353637383940import java.util.ArrayList;import java.util.List;import java.util.concurrent.atomic.AtomicInteger;public class AtomicUse &#123;\tprivate static AtomicInteger count = new AtomicInteger(0);\t//多个addAndGet在一个方法内是非原子性的，需要加synchronized进行修饰，保证4个addAndGet整体原子性\t/**synchronized*/\tpublic synchronized int multiAdd()&#123;\t\t\ttry &#123;\t\t\t\tThread.sleep(100);\t\t\t&#125; catch (InterruptedException e) &#123;\t\t\t\te.printStackTrace();\t\t\t&#125;\t\t\tcount.addAndGet(1);\t\t\tcount.addAndGet(2);\t\t\tcount.addAndGet(3);\t\t\tcount.addAndGet(4); //+10\t\t\treturn count.get();\t&#125;\tpublic static void main(String[] args) &#123;\t\tfinal AtomicUse au = new AtomicUse();\t\tList&lt;Thread&gt; ts = new ArrayList&lt;Thread&gt;();\t\tfor (int i = 0; i &lt; 100; i++) &#123;\t\t\tts.add(new Thread(new Runnable() &#123;\t\t\t\t@Override\t\t\t\tpublic void run() &#123;\t\t\t\t\tSystem.out.println(au.multiAdd());\t\t\t\t&#125;\t\t\t&#125;));\t\t&#125;\t\tfor(Thread t : ts)&#123;\t\t\tt.start();\t\t&#125;\t&#125;&#125;\n","dateCreated":"2019-09-07T10:23:08+08:00","dateModified":"2019-09-07T10:19:28+08:00","datePublished":"2019-09-07T10:23:08+08:00","description":"","headline":"多线程1","image":[],"mainEntityOfPage":{"@type":"WebPage","@id":"http://yoursite.com/2019/09/07/多线程/"},"publisher":{"@type":"Organization","name":"Brotherc","sameAs":["https://github.com/Brotherc"],"image":"head.jpg","logo":{"@type":"ImageObject","url":"head.jpg"}},"url":"http://yoursite.com/2019/09/07/多线程/","keywords":"java基础"}</script>
    <meta name="description" content="java多线程基本知识进程介绍123不管是我们开发的应用程序，还是我们运行的其他的应用程序，都需要先把程序安装在本地的硬盘上。然后找到这个程序的启动文件，启动程序的时候，其实是电脑把当前的这个程序加载到内存中，在内存中需要给当前的程序分配一段独立的运行空间。这片空间就专门负责当前这个程序的运行。不同的应用程序运行的过程中都需要在内存中分配自己独立的运行空间，彼此之间不会相互的影响。我们把每个独立应">
<meta name="keywords" content="java基础">
<meta property="og:type" content="blog">
<meta property="og:title" content="多线程1">
<meta property="og:url" content="http://yoursite.com/2019/09/07/多线程/index.html">
<meta property="og:site_name" content="Brotherc">
<meta property="og:description" content="java多线程基本知识进程介绍123不管是我们开发的应用程序，还是我们运行的其他的应用程序，都需要先把程序安装在本地的硬盘上。然后找到这个程序的启动文件，启动程序的时候，其实是电脑把当前的这个程序加载到内存中，在内存中需要给当前的程序分配一段独立的运行空间。这片空间就专门负责当前这个程序的运行。不同的应用程序运行的过程中都需要在内存中分配自己独立的运行空间，彼此之间不会相互的影响。我们把每个独立应">
<meta property="og:locale" content="zh-cn">
<meta property="og:image" content="http://yoursite.com/2019/09/07/多线程/volatile关键字.jpg">
<meta property="og:updated_time" content="2019-09-07T02:19:28.240Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="多线程1">
<meta name="twitter:description" content="java多线程基本知识进程介绍123不管是我们开发的应用程序，还是我们运行的其他的应用程序，都需要先把程序安装在本地的硬盘上。然后找到这个程序的启动文件，启动程序的时候，其实是电脑把当前的这个程序加载到内存中，在内存中需要给当前的程序分配一段独立的运行空间。这片空间就专门负责当前这个程序的运行。不同的应用程序运行的过程中都需要在内存中分配自己独立的运行空间，彼此之间不会相互的影响。我们把每个独立应">
<meta name="twitter:image" content="http://yoursite.com/2019/09/07/多线程/volatile关键字.jpg">
    
    
        
    
    
        <meta property="og:image" content="http://yoursite.com/assets/images/head.jpg"/>
    
    
    
    
    <!--STYLES-->
    <link rel="stylesheet" href="/assets/css/style-c4ozcsklz4kht2pebhp44xorvyverh23toayhn7i6ubrpyedak24hv1v0hyd.min.css">
    <!--STYLES END-->
    

    
</head>

    <body>
        <div id="blog">
            <!-- Define author's picture -->


    
        
            
        
    

<header id="header" data-behavior="4">
    <i id="btn-open-sidebar" class="fa fa-lg fa-bars"></i>
    <div class="header-title">
        <a class="header-title-link" href="/ ">Brotherc</a>
    </div>
    
        
            <a class="header-right-picture " href="#about">
        
        
            <img class="header-picture" src="/assets/images/head.jpg" alt="作者的图片">
        
        </a>
    
</header>

            <!-- Define author's picture -->



        
    

<nav id="sidebar" data-behavior="4">
    <div class="sidebar-container">
        
            <div class="sidebar-profile">
                <a href="/#about">
                    <img class="sidebar-profile-picture" src="/assets/images/head.jpg" alt="作者的图片">
                </a>
                <h4 class="sidebar-profile-name">Brotherc</h4>
                
                    <h5 class="sidebar-profile-bio"><p>java development</p>
</h5>
                
            </div>
        
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a class="sidebar-button-link " href="/ " title="首页">
                    
                        <i class="sidebar-button-icon fa fa-home" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">首页</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a class="sidebar-button-link " href="/all-categories" title="分类">
                    
                        <i class="sidebar-button-icon fa fa-bookmark" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">分类</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a class="sidebar-button-link " href="/all-tags" title="标签">
                    
                        <i class="sidebar-button-icon fa fa-tags" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">标签</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a class="sidebar-button-link open-algolia-search" href="/all-archives" title="归档">
                    
                        <i class="sidebar-button-icon fa fa-archive" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">归档</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a class="sidebar-button-link " href="#about" title="关于">
                    
                        <i class="sidebar-button-icon fa fa-question" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">关于</span>
                    </a>
            </li>
            
        </ul>
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a class="sidebar-button-link " href="https://github.com/Brotherc" target="_blank" rel="noopener" title="GitHub">
                    
                        <i class="sidebar-button-icon fab fa-github" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">GitHub</span>
                    </a>
            </li>
            
        </ul>
        
    </div>
</nav>

            
            <div id="main" data-behavior="4"
                 class="
                        hasCoverMetaIn
                        ">
                
<article class="post">
    
    
        <div class="post-header main-content-wrap text-left">
    
        <h1 class="post-title">
            多线程1
        </h1>
    
    
        <div class="post-meta">
    <time datetime="2019-09-07T10:23:08+08:00">
	
		    9月 07, 2019
    	
    </time>
    
</div>

    
</div>

    
    <div class="post-content markdown">
        <div class="main-content-wrap">
            <h3 id="java多线程基本知识"><a href="#java多线程基本知识" class="headerlink" title="java多线程基本知识"></a>java多线程基本知识</h3><h4 id="进程介绍"><a href="#进程介绍" class="headerlink" title="进程介绍"></a>进程介绍</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">不管是我们开发的应用程序，还是我们运行的其他的应用程序，都需要先把程序安装在本地的硬盘上。然后找到这个程序的启动文件，启动程序的时候，其实是电脑把当前的这个程序加载到内存中，在内存中需要给当前的程序分配一段独立的运行空间。这片空间就专门负责当前这个程序的运行。</span><br><span class="line">不同的应用程序运行的过程中都需要在内存中分配自己独立的运行空间，彼此之间不会相互的影响。我们把每个独立应用程序在内存的独立空间称为当前应用程序运行的一个进程。</span><br><span class="line">进程：它是内存中的一段独立的空间，可以负责当前应用程序的运行。当前这个进程负责调度当前程序中的所有运行细节。</span><br></pre></td></tr></table></figure>
<h4 id="线程介绍"><a href="#线程介绍" class="headerlink" title="线程介绍"></a>线程介绍</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">启动的QQ聊天软件，需要和多个人进行聊天。这时多个人之间是不能相互影响，但是它们都位于当前QQ这个软件运行时所分配的内容的独立空间中。</span><br><span class="line">	在一个进程中，每个独立的功能都需要独立的去运行，这时又需要把当前这个进程划分成多个运行区域，每个独立的小区域（小单元）称为一个线程。</span><br><span class="line">线程：它是位于进程中，负责当前进程中的某个具备独立运行资格的空间。</span><br><span class="line">进程是负责整个程序的运行，而线程是程序中具体的某个独立功能的运行。一个进程中至少应该有一个线程。</span><br></pre></td></tr></table></figure>
<h4 id="多线程介绍"><a href="#多线程介绍" class="headerlink" title="多线程介绍"></a>多线程介绍</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">现在的操作系统基本都是多用户，多任务的操作系统。每个任务就是一个进程。而在这个进程中就会有线程。</span><br><span class="line">真正可以完成程序运行和功能的实现靠的是进程中的线程。</span><br><span class="line">多线程：在一个进程中，我们同时开启多个线程，让多个线程同时去完成某些任务（功能）。</span><br><span class="line">多线程的目的：提高程序的运行效率。</span><br></pre></td></tr></table></figure>
<h4 id="多线程运行的原理"><a href="#多线程运行的原理" class="headerlink" title="多线程运行的原理"></a>多线程运行的原理</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cpu在线程中做时间片的切换。</span><br><span class="line">其实真正电脑中的程序的运行不是同时在运行的。CPU负责程序的运行，而CPU在运行程序的过程中某个时刻点上，它其实只能运行一个程序。而不是多个程序。而CPU它可以在多个程序之间进行高速的切换。而切换频率和速度太快，导致人的肉看看不到。</span><br><span class="line">每个程序就是进程， 而每个进程中会有多个线程，而CPU是在这些线程之间进行切换。</span><br><span class="line">了解了CPU对一个任务的执行过程，我们就必须知道，多线程可以提高程序的运行效率，但不能无限制的开线程。</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">多进程的意义?</span><br><span class="line">	提高CPU的使用率</span><br><span class="line">多线程的意义?</span><br><span class="line">	提高应用程序的使用率</span><br><span class="line"></span><br><span class="line">Java程序的运行原理及JVM的启动是多线程的吗?</span><br><span class="line">		A:Java命令去启动JVM，JVM会启动一个进程，该进程会启动一个主线程。</span><br><span class="line">		B:JVM的启动是多线程的，因为它最低有两个线程启动了，主线程和垃圾回收线程。</span><br></pre></td></tr></table></figure>
<h4 id="实现线程的两种方式"><a href="#实现线程的两种方式" class="headerlink" title="实现线程的两种方式"></a>实现线程的两种方式</h4><p>1、继承Thread的原理<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Random;</span><br><span class="line"></span><br><span class="line">public class MyThreadWithExtends extends Thread &#123;</span><br><span class="line">	String flag;</span><br><span class="line"></span><br><span class="line">	public MyThreadWithExtends(String flag)&#123;</span><br><span class="line">		this.flag = flag;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public void run() &#123;</span><br><span class="line">		String tname = Thread.currentThread().getName();</span><br><span class="line">		System.out.println(tname+&quot;线程的run方法被调用……&quot;);</span><br><span class="line">		Random random = new Random();</span><br><span class="line">		for(int i=0;i&lt;20;i++)&#123;</span><br><span class="line">			try &#123;</span><br><span class="line">				Thread.sleep(random.nextInt(10)*100);</span><br><span class="line">				System.out.println(tname+ &quot;....&quot;+ flag);</span><br><span class="line">			&#125; catch (InterruptedException e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		Thread thread1 = new MyThreadWithExtends(&quot;a&quot;);</span><br><span class="line">		Thread thread2 = new MyThreadWithExtends(&quot;b&quot;);</span><br><span class="line">		thread1.start();</span><br><span class="line">		thread2.start();</span><br><span class="line">		/**</span><br><span class="line">		 * 如果是调用thread的run方法，则只是一个普通的方法调用，不会开启新的线程</span><br><span class="line">		 */</span><br><span class="line">//		thread1.run();</span><br><span class="line">//		thread2.run();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>2、声明实现 Runnable 接口的类<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">public class MyThreadWithImpliment implements Runnable &#123;</span><br><span class="line">	int x;</span><br><span class="line"></span><br><span class="line">	public MyThreadWithImpliment(int x) &#123;</span><br><span class="line">		this.x = x;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public void run() &#123;</span><br><span class="line">		String name = Thread.currentThread().getName();</span><br><span class="line">		System.out.println(&quot;线程&quot; + name + &quot;的run方法被调用……&quot;);</span><br><span class="line">		for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">			System.out.println(x);</span><br><span class="line">			try &#123;</span><br><span class="line">				Thread.sleep(100);</span><br><span class="line"></span><br><span class="line">			&#125; catch (InterruptedException e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		Thread thread1 = new Thread(new MyThreadWithImpliment(1), &quot;thread-1&quot;);</span><br><span class="line">		Thread thread2 = new Thread(new MyThreadWithImpliment(2), &quot;thread-2&quot;);</span><br><span class="line">		 thread1.start();</span><br><span class="line">		 thread2.start();</span><br><span class="line">		// 注意调用run和调用start的区别,直接调用run，则都运行在main线程中</span><br><span class="line">//		thread1.run();</span><br><span class="line">//		thread2.run();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">public class MySynchronized &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		final MySynchronized mySynchronized = new MySynchronized();</span><br><span class="line">		final MySynchronized mySynchronized2 = new MySynchronized();</span><br><span class="line">		new Thread(&quot;thread1&quot;) &#123;</span><br><span class="line">			public void run() &#123;</span><br><span class="line">				synchronized (mySynchronized) &#123;</span><br><span class="line">				try &#123;</span><br><span class="line">					System.out.println(this.getName()+&quot; start&quot;);</span><br><span class="line">					int i =1/0;   //如果发生异常，jvm会将锁释放</span><br><span class="line">					Thread.sleep(5000);</span><br><span class="line">					System.out.println(this.getName()+&quot;醒了&quot;);</span><br><span class="line">					System.out.println(this.getName()+&quot; end&quot;);</span><br><span class="line">				&#125; catch (InterruptedException e) &#123;</span><br><span class="line">					e.printStackTrace();</span><br><span class="line">				&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;.start();</span><br><span class="line">		new Thread(&quot;thread2&quot;) &#123;</span><br><span class="line">			public void run() &#123;</span><br><span class="line">				synchronized (mySynchronized) &#123;         //争抢同一把锁时，线程1没释放之前，线程2只能等待</span><br><span class="line">//					synchronized (mySynchronized2) &#123;    //如果不是一把锁，可以看到两句话同时打印</span><br><span class="line">					System.out.println(this.getName()+&quot; start&quot;);</span><br><span class="line">					System.out.println(this.getName()+&quot; end&quot;);</span><br><span class="line"></span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;.start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="线程的调度和优先级问题"><a href="#线程的调度和优先级问题" class="headerlink" title="线程的调度和优先级问题"></a>线程的调度和优先级问题</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">A:线程的调度</span><br><span class="line">	a:分时调度</span><br><span class="line">	b:抢占式调度 (Java采用的是该调度方式)</span><br><span class="line">B:获取和设置线程优先级</span><br><span class="line">public final int getPriority():返回线程对象的优先级</span><br><span class="line">public final void setPriority(int newPriority)：更改线程的优先级。</span><br><span class="line">	a:默认是5</span><br><span class="line">	b:范围是1-10</span><br></pre></td></tr></table></figure>
<h3 id="线程的控制-常见方法"><a href="#线程的控制-常见方法" class="headerlink" title="线程的控制(常见方法)"></a>线程的控制(常见方法)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public final String getName():获取线程的名称。</span><br><span class="line">public final void setName(String name):设置线程的名称</span><br><span class="line">public static Thread currentThread():返回当前正在执行的线程对象</span><br><span class="line">Thread.currentThread().getName()</span><br><span class="line"></span><br><span class="line">A:休眠线程</span><br><span class="line">	public static void sleep(long millis)  在run方法中调用Thread.sleep()</span><br><span class="line">B:加入线程</span><br><span class="line">	 public final void join():等待该线程终止。</span><br><span class="line">C:礼让线程</span><br><span class="line">	public static void yield():暂停当前正在执行的线程对象，并执行其他线程。在run方法中调用Thread.yield()</span><br><span class="line">D:后台线程</span><br><span class="line">	public final void setDaemon(boolean on):</span><br><span class="line">将该线程标记为守护线程或用户线程。当正在运行的线程都是守护线程时，Java虚拟机退出。该方法必须在启动线程前调用。</span><br><span class="line">E:终止线程(掌握)</span><br><span class="line">public final void stop():让线程停止，太暴力，过时了，但是还可以使用。</span><br><span class="line">public void interrupt():中断线程。 把线程的状态终止，并抛出一个InterruptedException。</span><br></pre></td></tr></table></figure>
<h3 id="线程组"><a href="#线程组" class="headerlink" title="线程组"></a>线程组</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">把多个线程组合到一起。</span><br><span class="line">它可以对一批线程进行分类管理，Java允许程序直接对线程组进行控制。</span><br><span class="line"></span><br><span class="line">线程默认情况下属于main线程组</span><br><span class="line">线程类里面的方法：public final ThreadGroup getThreadGroup()</span><br><span class="line">		  Thread(ThreadGroup group, Runnable target, String name)</span><br><span class="line">线程组里面的方法：public final String getName()</span><br><span class="line">线程组的构造方法：ThreadGroup(String name)</span><br><span class="line">		  ThreadGroup tg = new ThreadGroup(&quot;这是一个新的组&quot;);</span><br><span class="line"></span><br><span class="line">//通过组名称设置后台线程，表示该组的线程都是后台线程</span><br><span class="line">tg.setDaemon(true);</span><br></pre></td></tr></table></figure>
<h3 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">import java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 线程安全概念：当多个线程访问某一个类（对象或方法）时，这个对象始终都能表现出正确的行为，那么这个类（对象或方法）就是线程安全的。</span><br><span class="line"> * synchronized：可以在任意对象及方法上加锁，而加锁的这段代码称为&quot;互斥区&quot;或&quot;临界区&quot;</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class MyThread extends Thread&#123;</span><br><span class="line"></span><br><span class="line">	private int count = 5 ;</span><br><span class="line"></span><br><span class="line">	//synchronized加锁</span><br><span class="line">	public void run()&#123;</span><br><span class="line">		count--;</span><br><span class="line">		System.out.println(this.currentThread().getName() + &quot; count = &quot;+ count);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		/**</span><br><span class="line">		 * 分析：当多个线程访问myThread的run方法时，以排队的方式进行处理（这里排对是按照CPU分配的先后顺序而定的），</span><br><span class="line">		 * 		一个线程想要执行synchronized修饰的方法里的代码：</span><br><span class="line">		 * 		1 尝试获得锁</span><br><span class="line">		 * 		2 如果拿到锁，执行synchronized代码体内容；拿不到锁，这个线程就会不断的尝试获得这把锁，直到拿到为止，</span><br><span class="line">		 * 		   而且是多个线程同时去竞争这把锁。（也就是会有锁竞争的问题）</span><br><span class="line">		 */</span><br><span class="line">		MyThread myThread = new MyThread();</span><br><span class="line">		Thread t1 = new Thread(myThread,&quot;t1&quot;);</span><br><span class="line">		Thread t2 = new Thread(myThread,&quot;t2&quot;);</span><br><span class="line">		Thread t3 = new Thread(myThread,&quot;t3&quot;);</span><br><span class="line">		Thread t4 = new Thread(myThread,&quot;t4&quot;);</span><br><span class="line">		Thread t5 = new Thread(myThread,&quot;t5&quot;);</span><br><span class="line">		t1.start();</span><br><span class="line">		t2.start();</span><br><span class="line">		t3.start();</span><br><span class="line">		t4.start();</span><br><span class="line">		t5.start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">t1 count = 2</span><br><span class="line">t5 count = 0</span><br><span class="line">t4 count = 1</span><br><span class="line">t3 count = 2</span><br><span class="line">t2 count = 2</span><br></pre></td></tr></table></figure>
<h3 id="多个线程多个锁"><a href="#多个线程多个锁" class="headerlink" title="多个线程多个锁"></a>多个线程多个锁</h3><p>多个线程多个锁，多个线程，每个线程都可以拿到自己指定的锁，分别获得锁之后，执行synchronized方法体的内容。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 关键字synchronized取得的锁都是对象锁，而不是把一段代码（方法）当做锁，</span><br><span class="line"> * 所以代码中哪个线程先执行synchronized关键字的方法，哪个线程就持有该方法所属对象的锁（Lock），</span><br><span class="line"> * 两个对象，线程获得的就是两个不同的锁，他们互不影响。</span><br><span class="line"> *</span><br><span class="line"> * 在静态方法上加synchronized关键字，表示锁定.class类，类一级别的锁（独占.class类）。</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class MultiThread &#123;</span><br><span class="line"></span><br><span class="line">	private int num = 0;</span><br><span class="line"></span><br><span class="line">	/** static */</span><br><span class="line">	public synchronized void printNum(String tag)&#123;</span><br><span class="line">		try &#123;</span><br><span class="line"></span><br><span class="line">			if(tag.equals(&quot;a&quot;))&#123;</span><br><span class="line">				num = 100;</span><br><span class="line">				System.out.println(&quot;tag a, set num over!&quot;);</span><br><span class="line">				Thread.sleep(1000);</span><br><span class="line">			&#125; else &#123;</span><br><span class="line">				num = 200;</span><br><span class="line">				System.out.println(&quot;tag b, set num over!&quot;);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			System.out.println(&quot;tag &quot; + tag + &quot;, num = &quot; + num);</span><br><span class="line"></span><br><span class="line">		&#125; catch (InterruptedException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	//注意观察run方法输出顺序</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">		//俩个不同的对象</span><br><span class="line">		final MultiThread m1 = new MultiThread();</span><br><span class="line">		final MultiThread m2 = new MultiThread();</span><br><span class="line"></span><br><span class="line">		Thread t1 = new Thread(new Runnable() &#123;</span><br><span class="line">			@Override</span><br><span class="line">			public void run() &#123;</span><br><span class="line">				m1.printNum(&quot;a&quot;);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line"></span><br><span class="line">		Thread t2 = new Thread(new Runnable() &#123;</span><br><span class="line">			@Override</span><br><span class="line">			public void run() &#123;</span><br><span class="line">				m2.printNum(&quot;b&quot;);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line"></span><br><span class="line">		t1.start();</span><br><span class="line">		t2.start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">tag a, set num over!</span><br><span class="line">tag b, set num over!</span><br><span class="line">tag b, num = 200</span><br><span class="line">tag a, num = 100</span><br></pre></td></tr></table></figure>
<h3 id="对象锁的同步和异步"><a href="#对象锁的同步和异步" class="headerlink" title="对象锁的同步和异步"></a>对象锁的同步和异步</h3><p>同步：synchronized<br>同步的概念就是共享，我们要牢牢记住“共享”这两个字，如果不是共享的资源，就没有必要进行同步。<br>异步：asynchronized<br>异步的概念就是独立，相互之间不受任何制约。就好像我们学习http的时候，在页面发起的ajax请求，我们还可以继续浏览<br>或操作页面的内容，二者之间没有任何关系。<br>同步的目的就是为了线程安全，其实对于线程安全来说，需要猫满足两个特性。<br>原子性（同步）<br>可见性<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 对象锁的同步和异步问题</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class MyObject &#123;</span><br><span class="line">	public synchronized void method1()&#123;</span><br><span class="line">		try &#123;</span><br><span class="line">			System.out.println(Thread.currentThread().getName());</span><br><span class="line">			Thread.sleep(4000);</span><br><span class="line">		&#125; catch (InterruptedException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/** synchronized */</span><br><span class="line">	public void method2()&#123;</span><br><span class="line">			System.out.println(Thread.currentThread().getName());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		final MyObject mo = new MyObject();</span><br><span class="line"></span><br><span class="line">		/**</span><br><span class="line">		 * 分析：</span><br><span class="line">		 * t1线程先持有object对象的Lock锁，t2线程可以以异步的方式调用对象中的非synchronized修饰的方法</span><br><span class="line">		 * t1线程先持有object对象的Lock锁，t2线程如果在这个时候调用对象中的同步（synchronized）方法则需等待，也就是同步</span><br><span class="line">		 */</span><br><span class="line">		Thread t1 = new Thread(new Runnable() &#123;</span><br><span class="line">			@Override</span><br><span class="line">			public void run() &#123;</span><br><span class="line">				mo.method1();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;,&quot;t1&quot;);</span><br><span class="line"></span><br><span class="line">		Thread t2 = new Thread(new Runnable() &#123;</span><br><span class="line">			@Override</span><br><span class="line">			public void run() &#123;</span><br><span class="line">				mo.method2();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;,&quot;t2&quot;);</span><br><span class="line"></span><br><span class="line">		t1.start();</span><br><span class="line">		t2.start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">t1</span><br><span class="line">t2 （立即打印）</span><br></pre></td></tr></table></figure>
<h3 id="脏读"><a href="#脏读" class="headerlink" title="脏读"></a>脏读</h3><p>对于对象的同步和异步的方法,我们在设计自己的程序的时候,一定要考虑问题的整体,不然就会出现数据不一致的错误,很经典的错误藏是讲读(dirtyread)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 在我们对一个对象的方法加锁的时候,需要考虑业务的整体性,即为setValueigetvalue方法同时加链synchronized同步关键字,</span><br><span class="line"> * 保证业务(service)的原子性,不然会出现业务错误(也从侧面保证业务的一致性) .</span><br><span class="line"> */</span><br><span class="line">public class DirtyRead &#123;</span><br><span class="line">	private String username = &quot;bjsxt&quot;;</span><br><span class="line">	private String password = &quot;123&quot;;</span><br><span class="line"></span><br><span class="line">	public synchronized void setValue(String username, String password)&#123;</span><br><span class="line">		this.username = username;</span><br><span class="line"></span><br><span class="line">		try &#123;</span><br><span class="line">			Thread.sleep(2000);</span><br><span class="line">		&#125; catch (InterruptedException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		this.password = password;</span><br><span class="line">		System.out.println(&quot;setValue最终结果：username = &quot; + username + &quot; , password = &quot; + password);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public void getValue()&#123;</span><br><span class="line">		System.out.println(&quot;getValue方法得到：username = &quot; + this.username + &quot; , password = &quot; + this.password);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) throws Exception&#123;</span><br><span class="line">		final DirtyRead dr = new DirtyRead();</span><br><span class="line">		Thread t1 = new Thread(new Runnable() &#123;</span><br><span class="line">			@Override</span><br><span class="line">			public void run() &#123;</span><br><span class="line">				dr.setValue(&quot;z3&quot;, &quot;456&quot;);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line">		t1.start();</span><br><span class="line">		Thread.sleep(1000);</span><br><span class="line"></span><br><span class="line">		dr.getValue();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">getValue方法得到：username = z3 , password = 123</span><br><span class="line">setValue最终结果：username = z3 , password = 456</span><br></pre></td></tr></table></figure>
<h3 id="synchronized锁重入"><a href="#synchronized锁重入" class="headerlink" title="synchronized锁重入:"></a>synchronized锁重入:</h3><p>关键字synchronized拥有锁重入的功能,也就是在使用synchronized时,当一个线程得到了一个对象的锁后,<br>再次请求此对象时是可以再次得到该对象的锁。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * synchronized的重入</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class SyncDubbo1 &#123;</span><br><span class="line">	public synchronized void method1()&#123;</span><br><span class="line">		System.out.println(&quot;method1..&quot;);</span><br><span class="line">		method2();</span><br><span class="line">	&#125;</span><br><span class="line">	public synchronized void method2()&#123;</span><br><span class="line">		System.out.println(&quot;method2..&quot;);</span><br><span class="line">		method3();</span><br><span class="line">	&#125;</span><br><span class="line">	public synchronized void method3()&#123;</span><br><span class="line">		System.out.println(&quot;method3..&quot;);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		final SyncDubbo1 sd = new SyncDubbo1();</span><br><span class="line">		Thread t1 = new Thread(new Runnable() &#123;</span><br><span class="line">			@Override</span><br><span class="line">			public void run() &#123;</span><br><span class="line">				sd.method1();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line">		t1.start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * synchronized的重入</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class SyncDubbo2 &#123;</span><br><span class="line">	static class Main &#123;</span><br><span class="line">		public int i = 10;</span><br><span class="line">		public synchronized void operationSup()&#123;</span><br><span class="line">			try &#123;</span><br><span class="line">				i--;</span><br><span class="line">				System.out.println(&quot;Main print i = &quot; + i);</span><br><span class="line">				Thread.sleep(100);</span><br><span class="line">			&#125; catch (InterruptedException e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	static class Sub extends Main &#123;</span><br><span class="line">		public synchronized void operationSub()&#123;</span><br><span class="line">			try &#123;</span><br><span class="line">				while(i &gt; 0) &#123;</span><br><span class="line">					i--;</span><br><span class="line">					System.out.println(&quot;Sub print i = &quot; + i);</span><br><span class="line">					Thread.sleep(100);</span><br><span class="line">					this.operationSup();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125; catch (InterruptedException e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		Thread t1 = new Thread(new Runnable() &#123;</span><br><span class="line">			@Override</span><br><span class="line">			public void run() &#123;</span><br><span class="line">				Sub sub = new Sub();</span><br><span class="line">				sub.operationSub();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line">		t1.start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于web应用程序,异常释放锁的情况,如果不及时处理,很可能对你的应用程序业务逻辑产生严重的错误,<br>比如你现在执行一个队列任务,很多对象都去在等特第一个对象正确执行完毕再去释放锁,但是第一个对象由于异常的出现,<br>导致业务逻辑没有正常执行完毕,就释放了锁,那么可把而知后续的对象执行的都是错误的逻钱.<br>所以这一点一定要引起注意,在编写代码的时候,一定要考虑剧全.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * synchronized异常</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class SyncException &#123;</span><br><span class="line">	private int i = 0;</span><br><span class="line">	public synchronized void operation()&#123;</span><br><span class="line">		while(true)&#123;</span><br><span class="line">			try &#123;</span><br><span class="line">				i++;</span><br><span class="line">				Thread.sleep(100);</span><br><span class="line">				System.out.println(Thread.currentThread().getName() + &quot; , i = &quot; + i);</span><br><span class="line">				if(i == 20)&#123;</span><br><span class="line">					//Integer.parseInt(&quot;a&quot;);</span><br><span class="line">					throw new RuntimeException();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125; catch (InterruptedException e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		final SyncException se = new SyncException();</span><br><span class="line">		Thread t1 = new Thread(new Runnable() &#123;</span><br><span class="line">			@Override</span><br><span class="line">			public void run() &#123;</span><br><span class="line">				se.operation();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;,&quot;t1&quot;);</span><br><span class="line">		t1.start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="synchronized代码块"><a href="#synchronized代码块" class="headerlink" title="synchronized代码块"></a>synchronized代码块</h3><p>使用syhchronized声明的方法在某些情况下是有弊端的,比如A线程调用同步的方法执行一个很长时间的任务,<br>那么B找程就必须等待比较长的时间才能执行,这样的情况下可以使用synchronized代码块去优化代码执行时间,<br>也就是通常所说的减小锁的粒度。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 使用synchronized代码块减小锁的粒度，提高性能</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class Optimize &#123;</span><br><span class="line">	public void doLongTimeTask()&#123;</span><br><span class="line">		try &#123;</span><br><span class="line">			System.out.println(&quot;当前线程开始：&quot; + Thread.currentThread().getName() +</span><br><span class="line">					&quot;, 正在执行一个较长时间的业务操作，其内容不需要同步&quot;);</span><br><span class="line">			Thread.sleep(2000);</span><br><span class="line"></span><br><span class="line">			synchronized(this)&#123;</span><br><span class="line">				System.out.println(&quot;当前线程：&quot; + Thread.currentThread().getName() +</span><br><span class="line">					&quot;, 执行同步代码块，对其同步变量进行操作&quot;);</span><br><span class="line">				Thread.sleep(1000);</span><br><span class="line">			&#125;</span><br><span class="line">			System.out.println(&quot;当前线程结束：&quot; + Thread.currentThread().getName() +</span><br><span class="line">					&quot;, 执行完毕&quot;);</span><br><span class="line"></span><br><span class="line">		&#125; catch (InterruptedException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		final Optimize otz = new Optimize();</span><br><span class="line">		Thread t1 = new Thread(new Runnable() &#123;</span><br><span class="line">			@Override</span><br><span class="line">			public void run() &#123;</span><br><span class="line">				otz.doLongTimeTask();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;,&quot;t1&quot;);</span><br><span class="line">		Thread t2 = new Thread(new Runnable() &#123;</span><br><span class="line">			@Override</span><br><span class="line">			public void run() &#123;</span><br><span class="line">				otz.doLongTimeTask();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;,&quot;t2&quot;);</span><br><span class="line">		t1.start();</span><br><span class="line">		t2.start();</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>synchronized可以使用任意的Object进行加锁,用法比较灵活.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 使用synchronized代码块加锁,比较灵活</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class ObjectLock &#123;</span><br><span class="line">	public void method1()&#123;</span><br><span class="line">		synchronized (this) &#123;	//对象锁</span><br><span class="line">			try &#123;</span><br><span class="line">				System.out.println(&quot;do method1..&quot;);</span><br><span class="line">				Thread.sleep(2000);</span><br><span class="line">			&#125; catch (InterruptedException e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public void method2()&#123;		//类锁</span><br><span class="line">		synchronized (ObjectLock.class) &#123;</span><br><span class="line">			try &#123;</span><br><span class="line">				System.out.println(&quot;do method2..&quot;);</span><br><span class="line">				Thread.sleep(2000);</span><br><span class="line">			&#125; catch (InterruptedException e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	private Object lock = new Object();</span><br><span class="line">	public void method3()&#123;		//任何对象锁</span><br><span class="line">		synchronized (lock) &#123;</span><br><span class="line">			try &#123;</span><br><span class="line">				System.out.println(&quot;do method3..&quot;);</span><br><span class="line">				Thread.sleep(2000);</span><br><span class="line">			&#125; catch (InterruptedException e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		final ObjectLock objLock = new ObjectLock();</span><br><span class="line">		Thread t1 = new Thread(new Runnable() &#123;</span><br><span class="line">			@Override</span><br><span class="line">			public void run() &#123;</span><br><span class="line">				objLock.method1();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line">		Thread t2 = new Thread(new Runnable() &#123;</span><br><span class="line">			@Override</span><br><span class="line">			public void run() &#123;</span><br><span class="line">				objLock.method2();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line">		Thread t3 = new Thread(new Runnable() &#123;</span><br><span class="line">			@Override</span><br><span class="line">			public void run() &#123;</span><br><span class="line">				objLock.method3();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line"></span><br><span class="line">		t1.start();</span><br><span class="line">		t2.start();</span><br><span class="line">		t3.start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>另外特别注意一个问题,就是不要使用String的常量加锁,会出现死循环问题<br>因为在JVM中具有String常量池(如果两个String具有相同的值，那么他们的地址是相同的，都保存在这个常量池中)。<br>当以String作为锁的时候，如果值相同则，那么线程持有相同的锁。这样就造成了另外一个线程不能执行</p>
<p>锁对象的改变问题,当使用一个对象进行加锁的时候,<br>要注意对象本身发生改变的时候那么持有的镜就不同,如果对象本身不发生改变,那么依然是同步的,即使是对象的属性发生了改变。</p>
<p>死锁问题<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 死锁问题，在设计程序时就应该避免双方相互持有对方的锁的情况</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class DeadLock implements Runnable&#123;</span><br><span class="line">	private String tag;</span><br><span class="line">	private static Object lock1 = new Object();</span><br><span class="line">	private static Object lock2 = new Object();</span><br><span class="line"></span><br><span class="line">	public void setTag(String tag)&#123;</span><br><span class="line">		this.tag = tag;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public void run() &#123;</span><br><span class="line">		if(tag.equals(&quot;a&quot;))&#123;</span><br><span class="line">			synchronized (lock1) &#123;</span><br><span class="line">				try &#123;</span><br><span class="line">					System.out.println(&quot;当前线程 : &quot;  + Thread.currentThread().getName() + &quot; 进入lock1执行&quot;);</span><br><span class="line">					Thread.sleep(2000);</span><br><span class="line">				&#125; catch (InterruptedException e) &#123;</span><br><span class="line">					e.printStackTrace();</span><br><span class="line">				&#125;</span><br><span class="line">				synchronized (lock2) &#123;</span><br><span class="line">					System.out.println(&quot;当前线程 : &quot;  + Thread.currentThread().getName() + &quot; 进入lock2执行&quot;);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		if(tag.equals(&quot;b&quot;))&#123;</span><br><span class="line">			synchronized (lock2) &#123;</span><br><span class="line">				try &#123;</span><br><span class="line">					System.out.println(&quot;当前线程 : &quot;  + Thread.currentThread().getName() + &quot; 进入lock2执行&quot;);</span><br><span class="line">					Thread.sleep(2000);</span><br><span class="line">				&#125; catch (InterruptedException e) &#123;</span><br><span class="line">					e.printStackTrace();</span><br><span class="line">				&#125;</span><br><span class="line">				synchronized (lock1) &#123;</span><br><span class="line">					System.out.println(&quot;当前线程 : &quot;  + Thread.currentThread().getName() + &quot; 进入lock1执行&quot;);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		DeadLock d1 = new DeadLock();</span><br><span class="line">		d1.setTag(&quot;a&quot;);</span><br><span class="line">		DeadLock d2 = new DeadLock();</span><br><span class="line">		d2.setTag(&quot;b&quot;);</span><br><span class="line"></span><br><span class="line">		Thread t1 = new Thread(d1, &quot;t1&quot;);</span><br><span class="line">		Thread t2 = new Thread(d2, &quot;t2&quot;);</span><br><span class="line"></span><br><span class="line">		t1.start();</span><br><span class="line">		try &#123;</span><br><span class="line">			Thread.sleep(500);</span><br><span class="line">		&#125; catch (InterruptedException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">		t2.start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="synchronized的缺陷"><a href="#synchronized的缺陷" class="headerlink" title="synchronized的缺陷"></a>synchronized的缺陷</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">synchronized是java中的一个关键字，也就是说是Java语言内置的特性。</span><br><span class="line">如果一个代码块被synchronized修饰了，当一个线程获取了对应的锁，并执行该代码块时，其他线程便只能一直等待，等待获取锁的线程释放锁，而这里获取锁的线程释放锁只会有两种情况：</span><br><span class="line">1）获取锁的线程执行完了该代码块，然后线程释放对锁的占有；</span><br><span class="line">2）线程执行发生异常，此时JVM会让线程自动释放锁。</span><br><span class="line"></span><br><span class="line">例子1：</span><br><span class="line">　　如果这个获取锁的线程由于要等待IO或者其他原因（比如调用sleep方法）被阻塞了，但是又没有释放锁，其他线程便只能干巴巴地等待，试想一下，这多么影响程序执行效率。</span><br><span class="line">　　因此就需要有一种机制可以不让等待的线程一直无期限地等待下去（比如只等待一定的时间或者能够响应中断），通过Lock就可以办到。</span><br><span class="line">例子2：</span><br><span class="line">当有多个线程读写文件时，读操作和写操作会发生冲突现象，写操作和写操作会发生冲突现象，但是读操作和读操作不会发生冲突现象。</span><br><span class="line">　　但是采用synchronized关键字来实现同步的话，就会导致一个问题：</span><br><span class="line">如果多个线程都只是进行读操作，当一个线程在进行读操作时，其他线程只能等待无法进行读操作。</span><br><span class="line"></span><br><span class="line">因此就需要一种机制来使得多个线程都只是进行读操作时，线程之间不会发生冲突，通过Lock就可以办到。</span><br><span class="line">另外，通过Lock可以知道线程有没有成功获取到锁。这个是synchronized无法办到的。</span><br><span class="line">总的来说，也就是说Lock提供了比synchronized更多的功能。</span><br></pre></td></tr></table></figure>
<h3 id="lock"><a href="#lock" class="headerlink" title="lock"></a>lock</h3><h4 id="lock和synchronized的区别"><a href="#lock和synchronized的区别" class="headerlink" title="lock和synchronized的区别"></a>lock和synchronized的区别</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1）Lock不是Java语言内置的，synchronized是Java语言的关键字，因此是内置特性。Lock是一个类，通过这个类可以实现同步访问；</span><br><span class="line">2）Lock和synchronized有一点非常大的不同，采用synchronized不需要用户去手动释放锁，当synchronized方法或者synchronized代码块执行完之后，系统会自动让线程释放对锁的占用；而Lock则必须要用户去手动释放锁，如果没有主动释放锁，就有可能导致出现死锁现象。</span><br></pre></td></tr></table></figure>
<h4 id="lock-1"><a href="#lock-1" class="headerlink" title="lock"></a>lock</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public interface Lock &#123;</span><br><span class="line">    void lock();</span><br><span class="line">    void lockInterruptibly() throws InterruptedException;</span><br><span class="line">    boolean tryLock();</span><br><span class="line">    boolean tryLock(long time, TimeUnit unit) throws InterruptedException;</span><br><span class="line">    void unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Lock接口中每个方法的使用：<br>lock()、tryLock()、tryLock(long time, TimeUnit unit)、lockInterruptibly()是用来获取锁的。unLock()方法是用来释放锁的。<br>四个获取锁方法的区别：<br>lock()方法是平常使用得最多的一个方法，就是用来获取锁。如果锁已被其他线程获取，则进行等待。<br>由于在前面讲到如果采用Lock，必须主动去释放锁，并且在发生异常时，不会自动释放锁。因此一般来说，使用Lock必须在try{}catch{}块中进行，并且将释放锁的操作放在finally块中进行，以保证锁一定被被释放，防止死锁的发生。<br>tryLock()方法是有返回值的，它表示用来尝试获取锁，如果获取成功，则返回true，如果获取失败（即锁已被其他线程获取），则返回false，也就说这个方法无论如何都会立即返回。在拿不到锁时不会一直在那等待。<br>tryLock(long time, TimeUnit unit)方法和tryLock()方法是类似的，只不过区别在于这个方法在拿不到锁时会等待一定的时间，在时间期限之内如果还拿不到锁，就返回false。如果如果一开始拿到锁或者在等待期间内拿到了锁，则返回true。<br>lockInterruptibly()方法比较特殊，当通过这个方法去获取锁时，如果线程正在等待获取锁，则这个线程能够响应中断，即中断线程的等待状态。也就使说，当两个线程同时通过lock.lockInterruptibly()想获取某个锁时，假若此时线程A获取到了锁，而线程B只有在等待，那么对线程B调用threadB.interrupt()方法能够中断线程B的等待过程。<br>注意，当一个线程获取了锁之后，是不会被interrupt()方法中断的。<br>因此当通过lockInterruptibly()方法获取某个锁时，如果不能获取到，只有进行等待的情况下，是可以响应中断的。<br>而用synchronized修饰的话，当一个线程处于等待某个锁的状态，是无法被中断的，只有一直等待下去。</p>
<h4 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h4><p>直接使用lock接口的话，我们需要实现很多方法，不太方便，ReentrantLock是唯一实现了Lock接口的类，并且ReentrantLock提供了更多的方法，ReentrantLock，意思是“可重入锁”。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.concurrent.locks.Lock;</span><br><span class="line">import java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line">public class MyLockTest &#123;</span><br><span class="line">	private static ArrayList&lt;Integer&gt; arrayList = new ArrayList&lt;Integer&gt;();</span><br><span class="line">	static Lock lock = new ReentrantLock(); // 注意这个地方</span><br><span class="line">	public static &lt;E&gt; void main(String[] args) &#123;</span><br><span class="line">		new Thread() &#123;</span><br><span class="line">			public void run() &#123;</span><br><span class="line">				Thread thread = Thread.currentThread();</span><br><span class="line"></span><br><span class="line">				lock.lock();</span><br><span class="line">				try &#123;</span><br><span class="line">					System.out.println(thread.getName() + &quot;得到了锁&quot;);</span><br><span class="line">					for (int i = 0; i &lt; 5; i++) &#123;</span><br><span class="line">						arrayList.add(i);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125; catch (Exception e) &#123;</span><br><span class="line">					// TODO: handle exception</span><br><span class="line">				&#125; finally &#123;</span><br><span class="line">					System.out.println(thread.getName() + &quot;释放了锁&quot;);</span><br><span class="line">					lock.unlock();</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">			&#125;;</span><br><span class="line">		&#125;.start();</span><br><span class="line"></span><br><span class="line">		new Thread() &#123;</span><br><span class="line">			public void run() &#123;</span><br><span class="line">				Thread thread = Thread.currentThread();</span><br><span class="line">				lock.lock();</span><br><span class="line">				try &#123;</span><br><span class="line">					System.out.println(thread.getName() + &quot;得到了锁&quot;);</span><br><span class="line">					for (int i = 0; i &lt; 5; i++) &#123;</span><br><span class="line">						arrayList.add(i);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125; catch (Exception e) &#123;</span><br><span class="line">					// TODO: handle exception</span><br><span class="line">				&#125; finally &#123;</span><br><span class="line">					System.out.println(thread.getName() + &quot;释放了锁&quot;);</span><br><span class="line">					lock.unlock();</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">			&#125;;</span><br><span class="line">		&#125;.start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.concurrent.locks.Lock;</span><br><span class="line">import java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 观察现象：一个线程获得锁后，另一个线程取不到锁，不会一直等待</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class MyTryLock &#123;</span><br><span class="line">	private static ArrayList&lt;Integer&gt; arrayList = new ArrayList&lt;Integer&gt;();</span><br><span class="line">	static Lock lock = new ReentrantLock(); // 注意这个地方</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">		new Thread() &#123;</span><br><span class="line">			public void run() &#123;</span><br><span class="line">				Thread thread = Thread.currentThread();</span><br><span class="line">				boolean tryLock = lock.tryLock();</span><br><span class="line">				System.out.println(thread.getName()+&quot; &quot;+tryLock);</span><br><span class="line">				if (tryLock) &#123;</span><br><span class="line">					try &#123;</span><br><span class="line">						System.out.println(thread.getName() + &quot;得到了锁&quot;);</span><br><span class="line">						for (int i = 0; i &lt; 5; i++) &#123;</span><br><span class="line">							arrayList.add(i);</span><br><span class="line">						&#125;</span><br><span class="line">					&#125; catch (Exception e) &#123;</span><br><span class="line">						// TODO: handle exception</span><br><span class="line">					&#125; finally &#123;</span><br><span class="line">						System.out.println(thread.getName() + &quot;释放了锁&quot;);</span><br><span class="line">						lock.unlock();</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;;</span><br><span class="line">		&#125;.start();</span><br><span class="line"></span><br><span class="line">		new Thread() &#123;</span><br><span class="line">			public void run() &#123;</span><br><span class="line">				Thread thread = Thread.currentThread();</span><br><span class="line">				boolean tryLock = lock.tryLock();</span><br><span class="line">				System.out.println(thread.getName()+&quot; &quot;+tryLock);</span><br><span class="line">				if (tryLock) &#123;</span><br><span class="line">					try &#123;</span><br><span class="line">						System.out.println(thread.getName() + &quot;得到了锁&quot;);</span><br><span class="line">						for (int i = 0; i &lt; 5; i++) &#123;</span><br><span class="line">							arrayList.add(i);</span><br><span class="line">						&#125;</span><br><span class="line">					&#125; catch (Exception e) &#123;</span><br><span class="line">						// TODO: handle exception</span><br><span class="line">					&#125; finally &#123;</span><br><span class="line">						System.out.println(thread.getName() + &quot;释放了锁&quot;);</span><br><span class="line">						lock.unlock();</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">			&#125;;</span><br><span class="line">		&#125;.start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">import java.util.concurrent.locks.Lock;</span><br><span class="line">import java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 观察现象：如果thread-0得到了锁，阻塞。。。thread-1尝试获取锁，如果拿不到，则可以被中断等待</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class MyInterruptibly &#123;</span><br><span class="line">	 private Lock lock = new ReentrantLock();</span><br><span class="line">	    public static void main(String[] args)  &#123;</span><br><span class="line">	    	MyInterruptibly test = new MyInterruptibly();</span><br><span class="line">	        MyThread thread0 = new MyThread(test);</span><br><span class="line">	        MyThread thread1 = new MyThread(test);</span><br><span class="line">	        thread0.start();</span><br><span class="line">	        thread1.start();</span><br><span class="line"></span><br><span class="line">	        try &#123;</span><br><span class="line">	            Thread.sleep(2000);</span><br><span class="line">	        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">	            e.printStackTrace();</span><br><span class="line">	        &#125;</span><br><span class="line">	        thread1.interrupt();</span><br><span class="line">	        System.out.println(&quot;=====================&quot;);</span><br><span class="line">	    &#125;</span><br><span class="line"></span><br><span class="line">	    public void insert(Thread thread) throws InterruptedException&#123;</span><br><span class="line">	        lock.lockInterruptibly();   //注意，如果需要正确中断等待锁的线程，必须将获取锁放在外面，然后将InterruptedException抛出</span><br><span class="line">	        try &#123;</span><br><span class="line">	            System.out.println(thread.getName()+&quot;得到了锁&quot;);</span><br><span class="line">	            long startTime = System.currentTimeMillis();</span><br><span class="line">	            for(    ;     ;) &#123;</span><br><span class="line">	                if(System.currentTimeMillis() - startTime &gt;= Integer.MAX_VALUE)</span><br><span class="line">	                    break;</span><br><span class="line">	                //插入数据</span><br><span class="line">	            &#125;</span><br><span class="line">	        &#125;</span><br><span class="line">	        finally &#123;</span><br><span class="line">	            System.out.println(Thread.currentThread().getName()+&quot;执行finally&quot;);</span><br><span class="line">	            lock.unlock();</span><br><span class="line">	            System.out.println(thread.getName()+&quot;释放了锁&quot;);</span><br><span class="line">	        &#125;</span><br><span class="line">	    &#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	class MyThread extends Thread &#123;</span><br><span class="line">	    private MyInterruptibly test = null;</span><br><span class="line">	    public MyThread(MyInterruptibly test) &#123;</span><br><span class="line">	        this.test = test;</span><br><span class="line">	    &#125;</span><br><span class="line">	    @Override</span><br><span class="line">	    public void run() &#123;</span><br><span class="line"></span><br><span class="line">	        try &#123;</span><br><span class="line">	            test.insert(Thread.currentThread());</span><br><span class="line">	        &#125; catch (Exception e) &#123;</span><br><span class="line">	            System.out.println(Thread.currentThread().getName()+&quot;被中断&quot;);</span><br><span class="line">	        &#125;</span><br><span class="line">	    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="ReadWriteLock"><a href="#ReadWriteLock" class="headerlink" title="ReadWriteLock"></a>ReadWriteLock</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public interface ReadWriteLock &#123;</span><br><span class="line">    /**</span><br><span class="line">     * Returns the lock used for reading.</span><br><span class="line">     *</span><br><span class="line">     * @return the lock used for reading.</span><br><span class="line">     */</span><br><span class="line">    Lock readLock();</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Returns the lock used for writing.</span><br><span class="line">     *</span><br><span class="line">     * @return the lock used for writing.</span><br><span class="line">     */</span><br><span class="line">    Lock writeLock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一个用来获取读锁，一个用来获取写锁。也就是说将文件的读写操作分开，分成2个锁来分配给线程，从而使得多个线程可以同时进行读操作。下面的ReentrantReadWriteLock实现了ReadWriteLock接口。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 一个线程又要读又要写，用synchronize来实现的话，读写操作都只能锁住后一个线程一个线程地进行</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class MySynchronizedReadWrite &#123;</span><br><span class="line">    public static void main(String[] args)  &#123;</span><br><span class="line">        final MySynchronizedReadWrite test = new MySynchronizedReadWrite();</span><br><span class="line"></span><br><span class="line">        new Thread()&#123;</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                test.get(Thread.currentThread());</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;.start();</span><br><span class="line"></span><br><span class="line">        new Thread()&#123;</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                test.get(Thread.currentThread());</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;.start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public synchronized void get(Thread thread) &#123;</span><br><span class="line">        long start = System.currentTimeMillis();</span><br><span class="line">        int i=0;</span><br><span class="line">        while(System.currentTimeMillis() - start &lt;= 1) &#123;</span><br><span class="line">        	i++;</span><br><span class="line">        	if(i%4==0)&#123;</span><br><span class="line">            System.out.println(thread.getName()+&quot;正在进行写操作&quot;);</span><br><span class="line">        	&#125;else &#123;</span><br><span class="line">        		System.out.println(thread.getName()+&quot;正在进行读操作&quot;);</span><br><span class="line">			&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(thread.getName()+&quot;读写操作完毕&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">import java.util.concurrent.locks.ReentrantReadWriteLock;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 使用读写锁，可以实现读写分离锁定，读操作并发进行，写操作锁定单个线程</span><br><span class="line"> *</span><br><span class="line"> * 如果有一个线程已经占用了读锁，则此时其他线程如果要申请写锁，则申请写锁的线程会一直等待释放读锁。</span><br><span class="line"> * 如果有一个线程已经占用了写锁，则此时其他线程如果申请写锁或者读锁，则申请的线程会一直等待释放写锁。</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class MyReentrantReadWriteLock &#123;</span><br><span class="line">	 private ReentrantReadWriteLock rwl = new ReentrantReadWriteLock();</span><br><span class="line"></span><br><span class="line">	    public static void main(String[] args)  &#123;</span><br><span class="line">	        final MyReentrantReadWriteLock test = new MyReentrantReadWriteLock();</span><br><span class="line"></span><br><span class="line">	        new Thread()&#123;</span><br><span class="line">	            public void run() &#123;</span><br><span class="line">	                test.get(Thread.currentThread());</span><br><span class="line">	                test.write(Thread.currentThread());</span><br><span class="line">	            &#125;;</span><br><span class="line">	        &#125;.start();</span><br><span class="line"></span><br><span class="line">	        new Thread()&#123;</span><br><span class="line">	            public void run() &#123;</span><br><span class="line">	                test.get(Thread.currentThread());</span><br><span class="line">	                test.write(Thread.currentThread());</span><br><span class="line">	            &#125;;</span><br><span class="line">	        &#125;.start();</span><br><span class="line"></span><br><span class="line">	    &#125;</span><br><span class="line"></span><br><span class="line">	    /**</span><br><span class="line">	     * 读操作,用读锁来锁定</span><br><span class="line">	     * @param thread</span><br><span class="line">	     */</span><br><span class="line">	    public void get(Thread thread) &#123;</span><br><span class="line">	        rwl.readLock().lock();</span><br><span class="line">	        try &#123;</span><br><span class="line">	            long start = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">	            while(System.currentTimeMillis() - start &lt;= 1) &#123;</span><br><span class="line">	                System.out.println(thread.getName()+&quot;正在进行读操作&quot;);</span><br><span class="line">	            &#125;</span><br><span class="line">	            System.out.println(thread.getName()+&quot;读操作完毕&quot;);</span><br><span class="line">	        &#125; finally &#123;</span><br><span class="line">	            rwl.readLock().unlock();</span><br><span class="line">	        &#125;</span><br><span class="line">	    &#125;</span><br><span class="line"></span><br><span class="line">	    /**</span><br><span class="line">	     * 写操作，用写锁来锁定</span><br><span class="line">	     * @param thread</span><br><span class="line">	     */</span><br><span class="line">	    public void write(Thread thread) &#123;</span><br><span class="line">	        rwl.writeLock().lock();;</span><br><span class="line">	        try &#123;</span><br><span class="line">	            long start = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">	            while(System.currentTimeMillis() - start &lt;= 1) &#123;</span><br><span class="line">	                System.out.println(thread.getName()+&quot;正在进行写操作&quot;);</span><br><span class="line">	            &#125;</span><br><span class="line">	            System.out.println(thread.getName()+&quot;写操作完毕&quot;);</span><br><span class="line">	        &#125; finally &#123;</span><br><span class="line">	            rwl.writeLock().unlock();</span><br><span class="line">	        &#125;</span><br><span class="line">	    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意：<br>不过要注意的是，如果有一个线程已经占用了读锁，则此时其他线程如果要申请写锁，则申请写锁的线程会一直等待释放读锁。<br>如果有一个线程已经占用了写锁，则此时其他线程如果申请写锁或者读锁，则申请的线程会一直等待释放写锁。</p>
<h4 id="Lock和synchronized的选择"><a href="#Lock和synchronized的选择" class="headerlink" title="Lock和synchronized的选择"></a>Lock和synchronized的选择</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1）Lock是一个接口，而synchronized是Java中的关键字，synchronized是内置的语言实现；</span><br><span class="line">2）synchronized在发生异常时，会自动释放线程占有的锁，因此不会导致死锁现象发生；而Lock在发生异常时，如果没有主动通过unLock()去释放锁，则很可能造成死锁现象，因此使用Lock时需要在finally块中释放锁；</span><br><span class="line">3）Lock可以让等待锁的线程响应中断，而synchronized却不行，使用synchronized时，等待的线程会一直等待下去，不能够响应中断；</span><br><span class="line">4）通过Lock可以知道有没有成功获取锁，而synchronized却无法办到。</span><br><span class="line">5）Lock可以提高多个线程进行读操作的效率。</span><br><span class="line">在性能上来说，如果竞争资源不激烈，两者的性能是差不多的，而当竞争资源非常激烈时（即有大量线程同时竞争），此时Lock的性能要远远优于synchronized。所以说，在具体使用时要根据适当情况选择。</span><br></pre></td></tr></table></figure>
<h3 id="volatile关键字的概念"><a href="#volatile关键字的概念" class="headerlink" title="volatile关键字的概念"></a>volatile关键字的概念</h3><p>volatile 概念: atile关键字的主要作用是使变量在多个线程同可见.<br>在java中,每一个线程都会有一块工作内存区,其中存放着所有线程共享的主内存中的变量值的拷贝。当线程执行时,他在自己的工作内存区中操作这些变量,为了存取一个共享的变量,一个线程通常先获取镇定并去清除它的内存工作区,把这些共享变量从所有线程的共享内存区中正确的装入到他自己所在的工作内存区中,当线程解锁时保证该工作内存区中变量的值写回到共享内存中.<br>一个线程可以执行的操作有使用(use) 、赋值(assign) 、装载(load)、存储(store) 、锁定(lock) 、解镇(unlock) .<br>而主内存可以执行的操作有读(read)、写(wrte) 、锁定(lock)、解镇(unlock) ,每个操作都是原子的。<br>volatile作用就是强制线程到主内存(共享内存)里去读取变量,而不去线程工作内存区里去读取,从而实现了多个线程间的变量可见。也就是满足线程安全的可见性。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public class RunThread extends Thread&#123;</span><br><span class="line">	private volatile boolean isRunning = true;</span><br><span class="line">	private void setRunning(boolean isRunning)&#123;</span><br><span class="line">		this.isRunning = isRunning;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public void run()&#123;</span><br><span class="line">		System.out.println(&quot;进入run方法..&quot;);</span><br><span class="line">		int i = 0;</span><br><span class="line">		while(isRunning == true)&#123;</span><br><span class="line">			//..</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(&quot;线程停止&quot;);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">		RunThread rt = new RunThread();</span><br><span class="line">		rt.start();</span><br><span class="line">		Thread.sleep(1000);</span><br><span class="line">		rt.setRunning(false);</span><br><span class="line">		System.out.println(&quot;isRunning的值已经被设置了false&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">进入run方法..</span><br><span class="line">isRunning的值已经被设置了false</span><br><span class="line">线程停止</span><br></pre></td></tr></table></figure>
<p>不加volatile<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">进入run方法..</span><br><span class="line">isRunning的值已经被设置了false</span><br></pre></td></tr></table></figure></p>
<p><img src="volatile关键字.jpg" alt="1"></p>
<h3 id="volatile关键字的非原子性"><a href="#volatile关键字的非原子性" class="headerlink" title="volatile关键字的非原子性"></a>volatile关键字的非原子性</h3><p>volatile关键字虽然拥有多个线程之间的可见性,但是却不具备同步性(也就是原子性) ,可以算上是一个轻量级的synchronized,性能要比synchronized强很多,不会造成阻塞<br>(在很多开源的架构里,比如netty的底层代码就大量使用volatile, 可见netty性能一定是非常不错的。)<br>这里需要注意:一般volatile用于只针对于多个线程可见的变量操作,并不能代替synchronized的同步功能.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">import java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * volatile关键字不具备synchronized关键字的原子性（同步）</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class VolatileNoAtomic extends Thread&#123;</span><br><span class="line">	private static volatile int count;</span><br><span class="line">	//private static AtomicInteger count = new AtomicInteger(0);</span><br><span class="line">	private static void addCount()&#123;</span><br><span class="line">		for (int i = 0; i &lt; 1000; i++) &#123;</span><br><span class="line">			count++ ;</span><br><span class="line">			// count.incrementAndGet();</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(count);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public void run()&#123;</span><br><span class="line">		addCount();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">		VolatileNoAtomic[] arr = new VolatileNoAtomic[100];</span><br><span class="line">		for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">			arr[i] = new VolatileNoAtomic();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">			arr[i].start();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1948</span><br><span class="line">3948</span><br><span class="line">2948</span><br><span class="line">1948</span><br><span class="line">5315</span><br><span class="line">6039</span><br><span class="line">6401</span><br><span class="line">7401</span><br><span class="line">8401</span><br><span class="line">9401</span><br></pre></td></tr></table></figure>
<p>AtomicInteger<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">2000</span><br><span class="line">2000</span><br><span class="line">3419</span><br><span class="line">4672</span><br><span class="line">5000</span><br><span class="line">6000</span><br><span class="line">7000</span><br><span class="line">9000</span><br><span class="line">8000</span><br><span class="line">10000</span><br></pre></td></tr></table></figure></p>
<p>volatie关键字只具有可见性,没有原子性,要实现原子性建议使用atomic类的系列对象,<br>支持原子性操作(注童atomic类只保证本身方法原子性,并不保证多次操作的原子性)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.List;</span><br><span class="line">import java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"></span><br><span class="line">public class AtomicUse &#123;</span><br><span class="line">	private static AtomicInteger count = new AtomicInteger(0);</span><br><span class="line"></span><br><span class="line">	//多个addAndGet在一个方法内是非原子性的，需要加synchronized进行修饰，保证4个addAndGet整体原子性</span><br><span class="line">	/**synchronized*/</span><br><span class="line">	public synchronized int multiAdd()&#123;</span><br><span class="line">			try &#123;</span><br><span class="line">				Thread.sleep(100);</span><br><span class="line">			&#125; catch (InterruptedException e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">			count.addAndGet(1);</span><br><span class="line">			count.addAndGet(2);</span><br><span class="line">			count.addAndGet(3);</span><br><span class="line">			count.addAndGet(4); //+10</span><br><span class="line">			return count.get();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		final AtomicUse au = new AtomicUse();</span><br><span class="line"></span><br><span class="line">		List&lt;Thread&gt; ts = new ArrayList&lt;Thread&gt;();</span><br><span class="line">		for (int i = 0; i &lt; 100; i++) &#123;</span><br><span class="line">			ts.add(new Thread(new Runnable() &#123;</span><br><span class="line">				@Override</span><br><span class="line">				public void run() &#123;</span><br><span class="line">					System.out.println(au.multiAdd());</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;));</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		for(Thread t : ts)&#123;</span><br><span class="line">			t.start();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

            

        </div>
    </div>
    <div id="post-footer" class="post-footer main-content-wrap">
        
            <div class="post-footer-tags">
                <span class="text-color-light text-small">标签</span><br>
                
    <a class="tag tag--primary tag--small t-link" href="/tags/java基础/">java基础</a>

            </div>
        
        
            <div class="post-actions-wrap">
    <nav>
        <ul class="post-actions post-action-nav">
            <li class="post-action">
                
                    
                    <a class="post-action-btn btn btn--default tooltip--top" href="/2019/09/07/多线程2/" data-tooltip="多线程2" aria-label="上一篇: 多线程2">
                
                    <i class="fa fa-angle-left" aria-hidden="true"></i>
                    <span class="hide-xs hide-sm text-small icon-ml">上一篇</span>
                </a>
            </li>
            <li class="post-action">
                
                    
                    <a class="post-action-btn btn btn--default tooltip--top" href="/2019/09/07/常用类/" data-tooltip="常用类" aria-label="下一篇: 常用类">
                
                    <span class="hide-xs hide-sm text-small icon-mr">下一篇</span>
                    <i class="fa fa-angle-right" aria-hidden="true"></i>
                </a>
            </li>
        </ul>
    </nav>
    <ul class="post-actions post-action-share">
        <li class="post-action hide-lg hide-md hide-sm">
            <a class="post-action-btn btn btn--default btn-open-shareoptions" href="#btn-open-shareoptions" aria-label="Diesen Beitrag teilen">
                <i class="fa fa-share-alt" aria-hidden="true"></i>
            </a>
        </li>
        
            
            
            <li class="post-action hide-xs">
                <a class="post-action-btn btn btn--default" target="new" href="https://www.facebook.com/sharer/sharer.php?u=http://yoursite.com/2019/09/07/多线程/" title="分享到 Facebook">
                    <i class="fab fa-facebook" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a class="post-action-btn btn btn--default" target="new" href="https://twitter.com/intent/tweet?text=http://yoursite.com/2019/09/07/多线程/" title="分享到 Twitter">
                    <i class="fab fa-twitter" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a class="post-action-btn btn btn--default" target="new" href="https://plus.google.com/share?url=http://yoursite.com/2019/09/07/多线程/" title="分享到 Google+">
                    <i class="fab fa-google-plus" aria-hidden="true"></i>
                </a>
            </li>
        
        
            
        
        <li class="post-action">
            
                <a class="post-action-btn btn btn--default" href="#" aria-label="Nach oben">
            
                <i class="fa fa-list" aria-hidden="true"></i>
            </a>
        </li>
    </ul>
</div>


        
        
            
        
    </div>
</article>



                <footer id="footer" class="main-content-wrap">
    <span class="copyrights">
        Copyrights &copy; 2020 Brotherc. All Rights Reserved.
    </span>
</footer>

            </div>
            
                <div id="bottom-bar" class="post-bottom-bar" data-behavior="4">
                    <div class="post-actions-wrap">
    <nav>
        <ul class="post-actions post-action-nav">
            <li class="post-action">
                
                    
                    <a class="post-action-btn btn btn--default tooltip--top" href="/2019/09/07/多线程2/" data-tooltip="多线程2" aria-label="上一篇: 多线程2">
                
                    <i class="fa fa-angle-left" aria-hidden="true"></i>
                    <span class="hide-xs hide-sm text-small icon-ml">上一篇</span>
                </a>
            </li>
            <li class="post-action">
                
                    
                    <a class="post-action-btn btn btn--default tooltip--top" href="/2019/09/07/常用类/" data-tooltip="常用类" aria-label="下一篇: 常用类">
                
                    <span class="hide-xs hide-sm text-small icon-mr">下一篇</span>
                    <i class="fa fa-angle-right" aria-hidden="true"></i>
                </a>
            </li>
        </ul>
    </nav>
    <ul class="post-actions post-action-share">
        <li class="post-action hide-lg hide-md hide-sm">
            <a class="post-action-btn btn btn--default btn-open-shareoptions" href="#btn-open-shareoptions" aria-label="Diesen Beitrag teilen">
                <i class="fa fa-share-alt" aria-hidden="true"></i>
            </a>
        </li>
        
            
            
            <li class="post-action hide-xs">
                <a class="post-action-btn btn btn--default" target="new" href="https://www.facebook.com/sharer/sharer.php?u=http://yoursite.com/2019/09/07/多线程/" title="分享到 Facebook">
                    <i class="fab fa-facebook" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a class="post-action-btn btn btn--default" target="new" href="https://twitter.com/intent/tweet?text=http://yoursite.com/2019/09/07/多线程/" title="分享到 Twitter">
                    <i class="fab fa-twitter" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a class="post-action-btn btn btn--default" target="new" href="https://plus.google.com/share?url=http://yoursite.com/2019/09/07/多线程/" title="分享到 Google+">
                    <i class="fab fa-google-plus" aria-hidden="true"></i>
                </a>
            </li>
        
        
            
        
        <li class="post-action">
            
                <a class="post-action-btn btn btn--default" href="#" aria-label="Nach oben">
            
                <i class="fa fa-list" aria-hidden="true"></i>
            </a>
        </li>
    </ul>
</div>


                </div>
                
    <div id="share-options-bar" class="share-options-bar" data-behavior="4">
        <i id="btn-close-shareoptions" class="fa fa-times"></i>
        <ul class="share-options">
            
                
                
                <li class="share-option">
                    <a class="share-option-btn" target="new" href="https://www.facebook.com/sharer/sharer.php?u=http://yoursite.com/2019/09/07/多线程/">
                        <i class="fab fa-facebook" aria-hidden="true"></i><span>分享到 Facebook</span>
                    </a>
                </li>
            
                
                
                <li class="share-option">
                    <a class="share-option-btn" target="new" href="https://twitter.com/intent/tweet?text=http://yoursite.com/2019/09/07/多线程/">
                        <i class="fab fa-twitter" aria-hidden="true"></i><span>分享到 Twitter</span>
                    </a>
                </li>
            
                
                
                <li class="share-option">
                    <a class="share-option-btn" target="new" href="https://plus.google.com/share?url=http://yoursite.com/2019/09/07/多线程/">
                        <i class="fab fa-google-plus" aria-hidden="true"></i><span>分享到 Google+</span>
                    </a>
                </li>
            
        </ul>
    </div>


            
        </div>
        


    
        
    

<div id="about">
    <div id="about-card">
        <div id="about-btn-close">
            <i class="fa fa-times"></i>
        </div>
        
            <img id="about-card-picture" src="/assets/images/head.jpg" alt="作者的图片">
        
            <h4 id="about-card-name">Brotherc</h4>
        
            <div id="about-card-bio"><p>java development</p>
</div>
        
        
            <div id="about-card-job">
                <i class="fa fa-briefcase"></i>
                <br>
                <p>java</p>

            </div>
        
        
            <div id="about-card-location">
                <i class="fa fa-map-marker-alt"></i>
                <br>
                zhuhai
            </div>
        
    </div>
</div>

        
        
<div id="cover" style="background-image:url('/assets/images/cover.jpg');"></div>
        <!--SCRIPTS-->
<script src="/assets/js/script-dbd16rvloemmuxdzniplmnxxvwoz24eya9wol0b7vvmlokgqsjivmb8dnscy.min.js"></script>
<!--SCRIPTS END-->

    



    </body>
</html>
